%!TEX root = std.tex
\setcounter{chapter}{19}
\rSec0[utilities]{General utilities library}

\setcounter{section}{9}
\rSec1[memory]{Memory}
\setcounter{subsection}{1}
\rSec2[memory.syn]{Header \tcode{<\added{experimental/ranges/}memory>} synopsis}

{\color{remclr}
\begin{codeblock}
// 20.10.10 specialized algorithms:
template <class ForwardIterator>
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
template <class ForwardIterator>
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
template <class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
template <class InputIterator, class Size, class ForwardIterator>
  pair<InputIterator, ForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
template <class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T& x);
template <class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
template <class T>
  void destroy_at(T* location);
template <class ForwardIterator>
  void destroy(ForwardIterator first, ForwardIterator last);
template <class ForwardIterator, class Size>
  ForwardIterator destroy_n(ForwardIterator first, Size n);
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <class I>
concept @\xname{ReferenceTo}@ = // \expos
  InputIterator<I> &&
  is_lvalue_reference_v<reference_t<I>> &&
  Same<remove_cv_t<remove_reference_t<reference_t<I>>>, value_type_t<I>>;

template <class T>
concept @\xname{NoThrowForwardIterator}@ = // \expos
  ForwardIterator<T>;

template <class T>
concept @\xname{NoThrowForwardRange}@ = // \expos
  Range<T> && @\xname{NoThrowForwardIterator}@;

// \ref{specialized.algorithms} specialized algorithms:
template <@\xname{NoThrowForwardIterator}@ I, Sentinel<I> S>
requires
  DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_default_construct(I first, S last);

template <@\xname{NoThrowForwardRange}@ Rng>
requires
  DefaultConstructible<value_type_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> uninitialized_default_construct(Rng&& rng);

template <@\xname{NoThrowForwardIterator}@ I>
requires
  DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_default_construct_n(I first, difference_type_t<I> n);

template <@\xname{NoThrowForwardIterator}@ I, Sentinel<I> S>
requires
  DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_value_construct(I first, S last);

template <@\xname{NoThrowForwardRange}@ Rng>
requires
  DefaultConstructible<value_type_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> uninitialized_value_construct(Rng&& rng);

template <@\xname{NoThrowForwardIterator}@ I>
requires
  DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_value_construct_n(I first, difference_type_t<I> n);

template <InputIterator I, Sentinel<I> S, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, reference_t<I>> &&
  @\xname{ReferenceTo}@<O, value_type_t<O>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_copy(I first, S last, O result);

template <InputRange Rng, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, reference_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<O, value_type_t<O>>
tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)> uninitialized_copy(Rng&& rng, O result);

template <InputIterator I, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, reference_t<I>> &&
  @\xname{ReferenceTo}@<O, value_type_t<O>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_copy_n(I first, difference_type_t<I> n, O out);

template <InputIterator I, Sentinel<I> S, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, rvalue_reference_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<O>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_move(I first, S last, O result);

template <InputRange Rng, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, rvalue_reference_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<O>>
tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)> uninitialized_move(Rng&& rng, O result);

template <InputIterator I, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, rvalue_reference_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_move_n(I first, difference_type_t<I> n, O result);

template <@\xname{NoThrowForwardIterator}@ I, Sentinel<I> S, typename T>
requires
  Constructible<value_type_t<I>, const T&> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_fill(I first, S last, const T& x);

template <@\xname{NoThrowForwardRange}@ Rng, typename T>
requires
  Constructible<value_type_t<iterator_t<Rng>>, const T&> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> uninitialized_fill(Rng&& rng, const T& x);

template <@\xname{NoThrowForwardIterator}@ I, typename T>
requires
  Constructible<value_type_t<I>, const T&> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_fill_n(I first, const difference_type_t<I> n, const T& x);

template <Destructible T>
void destroy_at(T* location) noexcept;

template <Destructible T>
void destroy_at(T& location) noexcept;

template <InputIterator I, Sentinel<I> S>
requires
  Destructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I destroy(I first, S last) noexcept;

template <InputRange Rng>
requires
  Destructible<value_type_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;

template <InputIterator I>
requires
  Destructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I destroy_n(I first, difference_type_t<I> n) noexcept
\end{codeblock}
} %% \color{addclr}

\setcounter{subsection}{9}
\rSec2[specialized.algorithms]{Specialized algorithms}
\setcounter{Paras}{0}
\pnum
Throughout this sub-clause, the names of template parameters are used to express type requirements.
{\color{remclr}
\begin{itemize}
\item If an algorithm's template parameter is named InputIterator, the template argument shall satisfy the
requirements of an input iterator ~(\ref{input.iterators}).

\item If an algorithm's template parameter is named ForwardIterator, the template argument shall satisfy the
requirements of a forward iterator ~(\ref{forward.iterators}), and is required to have the property that no exceptions
are thrown from increment, assignment, comparison, or indirection through valid iterators.
\end{itemize}
} %% \color{remclr}

{\color{addclr}
\setcounter{subparagraph}{0}
\begin{itemize}
\item This section defines the expositional concepts, \tcode{\xname{NoThrowForwardIterator}} and \tcode{\xname{NoThrowForwardRange}},
which require all conforming types to have the property that no exceptions are thrown from increment, assignment, comparison, or
indirection through valid iterators.

\enternote
The distinction between \tcode{ForwardIterator} and \tcode{\xname{NoThrowForwardIterator}} is purely semantic. Similarly for
\tcode{ForwardRange} and \tcode{\xname{NoThrowForwardRange}}.
\exitnote
\end{itemize}
} %% \color{addclr}

Unless otherwise specified, if an exception is thrown in the following algorithms there are no effects.
\rSec3[uninitialized.construct.default]{\tcode{uninitialized_default_construct}}
{\color{remclr}
\begin{codeblock}
template <class ForwardIterator>
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
\end{codeblock}

\setcounter{Paras}{1}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n>0; (void)++first, --n)
          ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<ForwardIterator>::value_type;
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <@\xname{NoThrowForwardIterator}@ I, Sentinel<I> S>
requires
  DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_default_construct(I first, S last);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
    for (; first != last; ++first)
      ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
        @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@;
    @\added{return first;}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <@\xname{NoThrowForwardRange}@ Rng>
requires
  DefaultConstructible<value_type_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> uninitialized_default_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_default_construct(begin(rng), end(rng));
\end{codeblock}

\begin{codeblock}
template <@\xname{NoThrowForwardIterator}@ I>
requires DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_default_construct_n(I first, difference_type_t<I> n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return uninitialized_default_construct(make_counted_iterator(first, n),
      default_sentinel{}).base();
\end{codeblock}
} %% \color{addclr}

\rSec3[uninitialized.construct.value]{\tcode{uninitialized_value_construct}}
{\color{remclr}
\begin{codeblock}
template <class ForwardIterator>
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
\end{codeblock}
\setcounter{Paras}{1}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n>0; (void)++first, --n)
          ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<ForwardIterator>::value_type();
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <@\xname{NoThrowForwardIterator}@ I, Sentinel<I> S>
requires
  DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_value_construct(I first, S last);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
} %% \color{addclr}

\begin{codeblock}
    for (; first != last; ++first)
      ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
        @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@();
    @\added{return first;}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <@\xname{NoThrowForwardRange}@ Rng>
requires
  DefaultConstructible<value_type_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> uninitialized_value_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return uninitialized_value_construct(begin(rng), end(rng));
\end{codeblock}

\begin{codeblock}
template <@\xname{NoThrowForwardIterator}@ I>
requires
  DefaultConstructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_value_construct_n(I first, difference_type_t<I> n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return uninitialized_value_construct(make_counted_iterator(first, n), default_sentinel{}).base();
\end{codeblock}
} %% \color{addclr}

\rSec3[uninitialized.copy]{\tcode{uninitialized_copy}}
{\color{remclr}
\begin{codeblock}
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{codeblock}

\setcounter{Paras}{1}
\pnum
\returns \tcode{result}
\begin{codeblock}
template <class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
\end{codeblock}

\pnum
\effects As if by:
\begin{codeblock}
        for ( ; n > 0; ++result, (void) ++first, --n) {
          ::new (static_cast<void*>(addressof(*result)))
            typename iterator_traits<ForwardIterator>::value_type(*first);
        }
\end{codeblock}

\pnum
\returns \tcode{result}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <InputIterator I, Sentinel<I> S, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, reference_t<I>> &&
  @\xname{ReferenceTo}@<O, value_type_t<O>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_copy(I first, S last, O result);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
    for (; first != last; ++result, (void)++first)
      ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*result)))@\added{)}@
        @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(*first);
    @\added{return \{first, result\};}@
\end{codeblock}

{\color{addclr}
\requires \tcode{result} shall not be in the range \range{first}{last}.

\begin{codeblock}
template <InputRange Rng, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, reference_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<O, value_type_t<O>>
tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)> uninitialized_copy(Rng&& rng, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return uninitialized_copy(begin(rng), end(rng), result);
\end{codeblock}

\pnum
\requires \tcode{result} shall not be in the range \range{begin(rng)}{end(rng))}.

\begin{codeblock}
template <InputIterator I, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, reference_t<I>> &&
  @\xname{ReferenceTo}@<O, value_type_t<O>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_copy_n(I first, difference_type_t<I> n, O out);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    auto t = uninitialized_copy(make_counted_iterator(first, n), default_sentinel{}).base();
    return {t.in().base(), t.out()};
\end{codeblock}

\requires \tcode{result} shall not be in the range \range{first}{next(first, n)}.
} %% \color{addclr}

\rSec3[uninitialized.move]{\tcode{uninitialized_move}}
{\color{remclr}
\begin{codeblock}
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{codeblock}

\begin{codeblock}
template <class InputIterator, class Size, class ForwardIterator>
  pair<InputIterator, ForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
\end{codeblock}

\setcounter{Paras}{2}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n > 0; ++result, (void) ++first, --n)
          ::new (static_cast<void*>(addressof(*result)))
            typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
        return {first,result};
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <InputIterator I, Sentinel<I> S, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, rvalue_reference_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<O>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_move(I first, S last, O result);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
    for (; first != last; (void)++result, ++first)
      ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*result)))@\added{)}@
        @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(std::move(*first));
    return @\changed{result}{\{first, result\}}@;
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in the range \range{first}{last} are left in a valid but
unspecified state.

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \range{first}{last}.

\begin{codeblock}
template <InputRange Rng, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, rvalue_reference_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<O>>
tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
uninitialized_move(Rng&& rng, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return uninitialized_move(begin(rng), end(rng), result);
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in the range \range{begin(rng)}{end(rng)} are left in a valid, but
unspecified state.

\pnum
\requires \tcode{result} shall not be in the range \range{begin(rng)}{end(rng)}.

\begin{codeblock}
template <InputIterator I, @\xname{NoThrowForwardIterator}@ O>
requires
  Constructible<value_type_t<O>, rvalue_reference_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
tagged_pair<tag::in(I), tag::out(O)> uninitialized_move_n(I first, difference_type_t<I> n, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    auto t = uninitialized_move(make_counted_iterator(first, n),
                                default_sentinel{}, result).base();
    return {t.in().base(), t.out()};
\end{codeblock}

\pnum
} %% \color{addclr}
\remarks If an exception is thrown, some objects in the range \range{first}{std::next(first, n)}
are left in a valid\added{,} but unspecified state.

\pnum
\requires \tcode{result} shall not be in the range \range{first}{std::next(first, n)}.

\rSec3[uninitialized.fill]{\tcode{uninitialized_fill}}
{\color{remclr}
\begin{codeblock}
template <class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T& x);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
\end{codeblock}

\setcounter{Paras}{1}
\pnum
\effects As if by:
\begin{codeblock}
        for (; n--; ++first)
          ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<ForwardIterator>::value_type(x);
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <@\xname{NoThrowForwardIterator}@ I, Sentinel<I> S, typename T>
requires
  Constructible<value_type_t<I>, const T&> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>> I uninitialized_fill(I first, S last, const T& x);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects \added{Equivalent to:}
\begin{codeblock}
    for (; first != last; ++first)
      ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
        @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@(x);
    @\added{return first}@;
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <@\xname{NoThrowForwardRange}@ Rng, typename T>
requires
  Constructible<value_type_t<iterator_t<Rng>>, const T&> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> uninitialized_fill(Rng&& rng, const T& x)
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
    return uninitialized_fill(begin(rng), end(rng), x);
\end{codeblock}

\begin{codeblock}
template <@\xname{NoThrowForwardIterator}@ I, typename T>
requires
  Constructible<value_type_t<I>, const T&> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I uninitialized_fill_n(I first, const difference_type_t<I> n, const T& x);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return uninitialized_fill(make_counted_iterator(first, n), default_sentinel{}, x).base();
\end{codeblock}
} %% \color{addclr}

\rSec3[specialized.destroy]{\tcode{destroy}}
{\color{remclr}
\begin{codeblock}
template <class T>
  void destroy_at(T* location);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator>
  void destroy(ForwardIterator first, ForwardIterator last);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size>
  ForwardIterator destroy_n(ForwardIterator first, Size n);
\end{codeblock}

\setcounter{Paras}{2}
\pnum
\effects Equivalent to:
\begin{codeblock}
      for (; n > 0; (void)++first, --n)
          destroy_at(addressof(*first));
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <Destructible T>
void destroy_at(T* location) noexcept;
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
    location->~T();
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <Destructible T>
void destroy_at(T& location) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    location.~T();
\end{codeblock}

\begin{codeblock}
template <InputIterator I, Sentinel<I> S>
requires
  Destructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I destroy(I first, S last) noexcept;
\end{codeblock}
}

\pnum
\effects Equivalent to:
\begin{codeblock}
    for (; first != last; ++first)
      destroy_at(addressof(*first));
    @\added{return first;}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <InputRange Rng>
requires
  Destructible<value_type_t<iterator_t<Rng>>> &&
  @\xname{ReferenceTo}@<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>
safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return destroy(begin(rng), end(rng));
\end{codeblock}

\begin{codeblock}
template <InputIterator I>
requires
  Destructible<value_type_t<I>> &&
  @\xname{ReferenceTo}@<I, value_type_t<I>>
I destroy_n(I first, difference_type_t<I> n) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
    return destroy(make_counted_iterator(first, n), default_sentinel{}).base();
\end{codeblock}
} %% \color{addclr}