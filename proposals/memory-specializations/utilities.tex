%!TEX root = std.tex
\setcounter{chapter}{19}
\rSec0[utilities]{General utilities library}

\setcounter{section}{9}
\rSec1[memory]{Memory}
\setcounter{subsection}{1}
\rSec2[memory.syn]{Header \tcode{<\added{experimental/ranges/}memory>} synopsis}

{\color{remclr}
\begin{codeblock}
// 20.10.10 specialized algorithms:
template <class ForwardIterator>
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
template <class ForwardIterator>
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
template <class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
template <class InputIterator, class Size, class ForwardIterator>
  pair<InputIterator, ForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
template <class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T& x);
template <class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
template <class T>
  void destroy_at(T* location);
template <class ForwardIterator>
  void destroy(ForwardIterator first, ForwardIterator last);
template <class ForwardIterator, class Size>
  ForwardIterator destroy_n(ForwardIterator first, Size n);
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
// \ref{specialized.algorithms} specialized algorithms:
template <ForwardIterator I, Sentinel<I> S>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_default_construct(I first, S last);
template <ForwardRange Rng>
  requires DefaultConstructible<value_type_t<iterator_t<Rng>>>() &&
           __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
    safe_iterator_t<Rng>
    uninitialized_default_construct(Rng&& rng);
template <ForwardIterator I>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_default_construct_n(I first, difference_type_t<I> n);
template <ForwardIterator I, Sentinel<I> S>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_value_construct(I first, S last);
template <ForwardRange Rng>
  requires DefaultConstructible<value_type_t<iterator_t<Rng>>>() &&
           __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
    safe_iterator_t<Rng>
    uninitialized_value_construct(Rng&& rng);
template <ForwardIterator I>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_value_construct_n(I first, difference_type_t<I> n);
template <InputIterator I, Sentinel<I> S, ForwardIterator O>
  requires Constructible<value_type_t<O>, reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)>
    uninitialized_copy(I first, S last, O result);
template <InputRange Rng, ForwardIterator O>
  requires Constructible<value_type_t<O>, reference_t<iterator_t<Rng>>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
    uninitialized_copy(Rng&& rng, O result);
template <InputIterator I, ForwardIterator O>
  requires Constructible<value_type_t<O>, reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)>
    uninitialized_copy_n(I first, difference_type_t<I> n, O result);
template <InputIterator I, Sentinel<I> S, ForwardIterator O>
  requires Constructible<value_type_t<O>, rvalue_reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)> uninitialized_move(I first, S last, O result);
template <InputRange Rng, ForwardIterator O>
  requires Constructible<value_type_t<O>, rvalue_reference_t<iterator_t<Rng>>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
    uninitialized_move(Rng&& rng, O result);
template <InputIterator I, ForwardIterator O>
  requires Constructible<value_type_t<O>, rvalue_reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)>
    uninitialized_move_n(I first, difference_type_t<I> n, O result);
template <ForwardIterator I, Sentinel<I> S, class T>
  requires Constructible<value_type_t<I>, const T&>() &&
           __ReferenceTo<I, const T&>()
  I uninitialized_fill(I first, S last, const T& x);
template <ForwardRange Rng, class T>
  requrires Constructible<iterator_t<Rng>, const T&>() &&
            __ReferenceTo<iterator_t<Rng>, const T&>()
  safe_iterator_t<I>
  uninitialized_fill(Rng&& rng, const T& x);
template <ForwardIterator I, class T>
  requires Constructible<value_type_t<I>, const T&>() &&
           __ReferenceTo<I, const T&>()
  I uninitialized_fill_n(I first, difference_type_t<I> n, const T& x);
template <Destructible T>
  void destroy_at(T* location) noexcept;
template <InputIterator I, Sentinel<I> S>
  requires Destructible<value_type_t<I>>() &&
           __ReferenceTo<iterator_t<Rng, value_type_t<Rng>>>()
    I destroy(I first, S last) noexcept;
template <InputRange Rng>
  requires Destructible<value_type_t<Rng>>() &&
           __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
    safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;
template <InputIterator I>
  requires Destructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I destroy_n(I first, difference_type_t<I> n) noexcept;

template <class I, class T>
concept bool __ReferenceTo() { // exposition only
  return InputIterator<I>() &&
    is_lvalue_reference_v<reference_t<I>> &&
    Same<remove_cv_t<remove_reference_t<reference_t<I>>>, T>();
}
\end{codeblock}
} %% \color{addclr}

\setcounter{subsection}{9}
\rSec2[specialized.algorithms]{Specialized algorithms}
This section assumes the definition of a \tcode{NoThrowForwardIterator} concept, which shall be described in a sibling
proposal as an addition to \tcode{<experimental/ranges/iterator>}.

\rSec3[uninitialized.construct.default]{\tcode{uninitialized_default_construct}}
{\color{remclr}
\begin{codeblock}
template <class ForwardIterator>
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
\end{codeblock}

\setcounter{Paras}{1}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n>0; (void)++first, --n)
          ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<ForwardIterator>::value_type;
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <NoThrowForwardIterator I, Sentinel<I> S>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_default_construct(I first, S last);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@;
        @\added{return first;}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
  template <NoThrowForwardRange Rng>
    requires DefaultConstructible<value_type_t<iterator_t<Rng>>>() &&
             __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
  safe_iterator_t<Rng>
  uninitialized_default_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_default_construct(begin(rng), end(rng));
\end{codeblock}

\begin{codeblock}
template <NoThrowForwardIterator I>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_default_construct_n(I first, difference_type_t<I> n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_default_construct(make_counted_iterator(first, n),
                                               default_sentinel{}).base();
\end{codeblock}
} %% \color{addclr}

\rSec3[uninitialized.construct.value]{\tcode{uninitialized_value_construct}}
{\color{remclr}
\begin{codeblock}
template <class ForwardIterator>
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size>
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
\end{codeblock}
\setcounter{Paras}{1}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n>0; (void)++first, --n)
          ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<ForwardIterator>::value_type();
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <NoThrowForwardIterator I, Sentinel<I> S>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_value_construct(I first, S last);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
} %% \color{addclr}

\begin{codeblock}
        for (; first != last; ++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@();
        @\added{return first;}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <NoThrowForwardRange Rng>
  requires DefaultConstructible<value_type_t<iterator_t<Rng>>>() &&
           __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
    safe_iterator_t<Rng>
    uninitialized_value_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_value_construct(begin(rng), end(rng));
\end{codeblock}

\begin{codeblock}
template <NoThrowForwardIterator I>
  requires DefaultConstructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I uninitialized_value_construct_n(I first, difference_type_t<I> n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_value_construct(make_counted_iterator(first, n),
                                             default_sentinel{}).base();
\end{codeblock}
} %% \color{addclr}

\rSec3[uninitialized.copy]{\tcode{uninitialized_copy}}
{\color{remclr}
\begin{codeblock}
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{codeblock}

\setcounter{Paras}{1}
\pnum
\returns \tcode{result}
\begin{codeblock}
template <class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                       ForwardIterator result);
\end{codeblock}

\pnum
\effects As if by:
\begin{codeblock}
        for ( ; n > 0; ++result, (void) ++first, --n) {
          ::new (static_cast<void*>(addressof(*result)))
            typename iterator_traits<ForwardIterator>::value_type(*first);
        }
\end{codeblock}

\pnum
\returns \tcode{result}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <InputIterator I, Sentinel<I> S, NoThrowForwardIterator O>
  requires Constructible<value_type_t<O>, reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)>
    uninitialized_copy(I first, S last, O result);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
        for (; first != last; ++result, (void)++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*result)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(*first);
        @\added{return \{first, result\};}@
\end{codeblock}

{\color{addclr}
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.

\begin{codeblock}
template <InputRange Rng, NoThrowForwardIterator O>
  requires Constructible<value_type_t<O>, reference_t<iterator_t<Rng>>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
    uninitialized_copy(Rng&& rng, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_copy(begin(rng), end(rng), result);
\end{codeblock}

\pnum
\requires \tcode{result} shall not be in the range \tcode{[begin(rng), end(rng))}.

\begin{codeblock}
template <InputIterator I, NoThrowForwardIterator O>
  requires Constructible<value_type_t<O>, reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)>
    uninitialized_copy_n(I first, difference_type_t<I> n, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_copy(make_counted_iterator(first, n),
                                  default_sentinel{}).base();
\end{codeblock}

\requires \newtxt{\tcode{result} shall not be in the range \tcode{make_counted_iterator(first, n)}.}
} %% \color{addclr}

\rSec3[uninitialized.move]{\tcode{uninitialized_move}}
{\color{remclr}
\begin{codeblock}
template <class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{codeblock}

\begin{codeblock}
template <class InputIterator, class Size, class ForwardIterator>
  pair<InputIterator, ForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
\end{codeblock}

\setcounter{Paras}{2}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n > 0; ++result, (void) ++first, --n)
          ::new (static_cast<void*>(addressof(*result)))
            typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
        return {first,result};
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <InputIterator I, Sentinel<I> S, NoThrowForwardIterator O>
  requires Constructible<value_type_t<O>, rvalue_reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)> uninitialized_move(I first, S last, O result);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; (void)++result, ++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*result)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@(std::move(*first));
        return @\changed{result}{\{first, result\}}@;
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in the range \tcode{[first, last)} are left in a valid but
unspecified state.

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.

\begin{codeblock}
template <InputRange Rng, NoThrowForwardIterator O>
  requires Constructible<value_type_t<O>, rvalue_reference_t<iterator_t<Rng>>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
    uninitialized_move(Rng&& rng, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_move(begin(rng), end(rng), result);
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in the range\tcode{[begin(rng), end(rng))} are left in a valid, but
unspecified state.

\pnum
\requires \tcode{result} shall not be in the range \tcode{[begin(rng), end(rng))}.

\begin{codeblock}
template <InputIterator I, NoThrowForwardIterator O>
  requires Constructible<value_type_t<O>, rvalue_reference_t<I>>() &&
           __ReferenceTo<O, value_type_t<O>>()
    tagged_pair<tag::in(I), tag::out(O)>
    uninitialized_move_n(I first, difference_type_t<I> n, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_move(make_counted_iterator(first, n),
                                  default_sentinel{}, result).base();
\end{codeblock}

\pnum
} %% \color{addclr}
\remarks If an exception is thrown, some objects in the range
\begin{codeblock}
        @\changed{[first, std::next(first, n))}{[make_counted_iterator(first, n), default_sentinel{})}@
\end{codeblock}
are left in a valid\added{,} but unspecified state.

\pnum
\newtxt{\requires \tcode{result} shall not be in the range \tcode{make_counted_iterator(first, n)}.}

\rSec3[uninitialized.fill]{\tcode{uninitialized_fill}}
{\color{remclr}
\begin{codeblock}
template <class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                          const T& x);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
\end{codeblock}

\setcounter{Paras}{1}
\pnum
\effects As if by:
\begin{codeblock}
        for (; n--; ++first)
          ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<ForwardIterator>::value_type(x);
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <NoThrowForwardIterator I, Sentinel<I> S, class T>
  requires Constructible<value_type_t<I>, const T&>() &&
           __ReferenceTo<I, const T&>()
  I uninitialized_fill(I first, S last, const T& x);
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects \added{Equivalent to:}
\begin{codeblock}
        for (; first != last; ++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@(x);
        @\added{return first}@;
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <NoThrowForwardRange Rng, class T>
  requrires Constructible<iterator_t<Rng>, const T&>() &&
            __ReferenceTo<iterator_t<Rng>, const T&>()
  safe_iterator_t<I>
  uninitialized_fill(Rng&& rng, const T& x);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_fill(begin(rng), end(rng), x);
\end{codeblock}

\begin{codeblock}
template <NoThrowForwardIterator I, class T>
  requires Constructible<value_type_t<I>, const T&>() &&
           __ReferenceTo<I, const T&>()
  I uninitialized_fill_n(I first, difference_type_t<I> n, const T& x);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_fill(make_counted_iterator(first, n),
                                  default_sentinel{}, x).base();
\end{codeblock}
} %% \color{addclr}

\rSec3[specialized.destroy]{\tcode{destroy}}
{\color{remclr}
\begin{codeblock}
template <class T>
  void destroy_at(T* location);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator>
  void destroy(ForwardIterator first, ForwardIterator last);
\end{codeblock}

\begin{codeblock}
template <class ForwardIterator, class Size>
  ForwardIterator destroy_n(ForwardIterator first, Size n);
\end{codeblock}

\setcounter{Paras}{2}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n > 0; (void)++first, --n)
          destroy_at(addressof(*first));
        return first;
\end{codeblock}
} %% \color{remclr}

{\color{addclr}
\begin{codeblock}
template <Destructible T>
  void destroy_at(T* location) noexcept;
\end{codeblock}
} %% \color{addclr}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        location->~T();
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <InputIterator I, Sentinel<I> S>
  requires Destructible<value_type_t<I>>() &&
           __ReferenceTo<iterator_t<Rng, value_type_t<Rng>>>()
    I destroy(I first, S last) noexcept;
\end{codeblock}
}

\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          destroy_at(addressof(*first));
        @\added{return first;}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
template <InputRange Rng>
  requires Destructible<value_type_t<iterator_t<Rng>>>() &&
           __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
    safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return destroy(begin(rng), end(rng));
\end{codeblock}

\begin{codeblock}
template <InputIterator I>
  requires Destructible<value_type_t<I>>() &&
           __ReferenceTo<I, value_type_t<I>>()
    I destroy_n(I first, difference_type_t<I> n) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return destroy(make_counted_iterator(first, n), default_sentinel{});
\end{codeblock}
} %% \color{addclr}