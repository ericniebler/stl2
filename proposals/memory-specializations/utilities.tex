%!TEX root = std.tex
\setcounter{chapter}{19}
\rSec0[utilities]{General utilities library}

\setcounter{section}{6}
\rSec1[memory]{Memory}
\synopsis{Header \tcode{<\added{experimental/ranges/}memory>} synopsis}

\setcounter{subsection}{11}
\rSec2[specialized.algorithms]{Specialized algorithms}

\rSec3[uninitialized.construct.default]{uninitialized_default_construct}

{\color{addclr}
\begin{codeblock}
template <class I, class T>
concept bool __ReferenceTo() {
  return InputIterator<I>() &&
    is_lvalue_reference_v<reference_t<I>> &&
    Same<remove_cv_t<remove_reference_t<reference_t<I>>>, T>();
}
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class ForwardIterator}{ForwardIterator I, Sentinel<I> S}@>
    @\added{requires DefaultConstructible<value_type_t<I>{>}() \&\&}@
             @\added{__ReferenceTo<I, value_type_t<I>{>}()}@
    @\changed{void}{I}@ uninitialized_default_construct(@\changed{ForwardIterator}{I}@ first, @\changed{ForwardIterator}{S}@ last);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<I>}@;
        @\added{return first;}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
  template <ForwardRange Rng>
    requires DefaultConstructible<value_type_t<iterator_t<Rng>>>() &&
             __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
  safe_iterator_t<Rng> uninitialized_default_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_default_construct(begin(rng), end(rng));
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class OutputIterator}{ForwardIterator I}\removed{, class Size}@>
    @\added{requires DefaultConstructible<value_type_t<I>{>}() \&\&}@
             @\added{__ReferenceTo<I, value_type_t<I>{>}()}@
  @\changed{ForwardIterator}{I}@
    uninitialized_default_construct_n(@\changed{ForwardIterator}{I}@ first, @\changed{Size}{difference_type_t<I>}@ n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        @\removed{for (; n>0; (void)++first, --n)}@
          @\removed{::new (static_cast<void*>(addressof(*first)))}@
            @\removed{typename iterator_traits<ForwardIterator>::value_type}@
        return @\changed{first}{uninitialized_default_construct(make_counted_iterator(first, n),}@
                                                               @\added{default_sentinel\{\}).base()}@;
\end{codeblock}

\rSec3[uninitialized.construct.value]{uninitialized_value_construct}
\begin{codeblock}
  template <@\changed{class ForwardIterator}{ForwardIterator I, Sentinel<I> S}@>
    @\added{requires DefaultConstructible<value_type_t<I>{>}() \&\&}@
             @\added{__ReferenceTo<I, value_type_t<I>{>}()}@
    @\changed{void}{I}@ uninitialized_value_construct(@\changed{ForwardIterator}{I}@ first, @\changed{ForwardIterator}{S}@ last);
\end{codeblock}


\setcounter{Paras}{0}
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@();
        @\added{return first;}@
\end{codeblock}
{\color{addclr}
\begin{codeblock}
  template <ForwardRange Rng>
    requires DefaultConstructible<value_type_t<iterator_t<Rng>>> &&
             __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
  safe_iterator_t<Rng> uninitialized_value_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
      return uninitialized_value_construct(begin(rng), end(rng));
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class ForwardIterator}{ForwardIterator I}\removed{, class Size}@>
    @\added{requires DefaultConstructible<value_type_t<I>{>}() \&\&}@
            @\added{__ReferenceTo<I, value_type_t<I>{>}()}@
  @\changed{ForwardIterator}{I}@
    uninitialized_value_construct_n(@\changed{ForwardIterator}{I}@ first, @\changed{Size}{difference_type_t<I>}@ n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        @\removed{for (; n > 0; --n, (void)++first)}@
          @\removed{::new (static_cast<void*>(addressof(*first)))}@
            @\removed{typename iterator_traits<ForwardIterator>::value_type();}@
        return @\changed{first}{uninitialized_value_construct(make_counted_iterator(first, n),}@
                                                             @\added{default_sentinel\{\}).base()}@;
\end{codeblock}

\rSec3[uninitialized.copy]{uninitialized_copy}
\begin{codeblock}
  template <@\changed{class InputIterator}{InputIterator I, Sentinel<I> S, }@
            @\changed{class ForwardIterator}{ForwardIterator O}@>
    @\added{requires Constructible<value_type_t<O>, reference_t<I>{>}() \&\&}@
            @\added{__ReferenceTo<O, value_type_t<O>{>}()}@
  @\changed{ForwardIterator}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_copy(@\changed{InputIterator}{I}@ first, @\changed{InputIterator}{S}@ last, @\changed{ForwardIterator}{O}@ result);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
        for (; first != last; ++result, (void)++first)
          ::new @\added{(const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*result)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(*first);
        return {last, result};
\end{codeblock}

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.

\begin{codeblock}
  template <InputRange Rng, ForwardIterator O>
    requires Constructible<value_type_t<O>, reference_t<iterator_t<Rng>>>() &&
             __ReferenceTo<O, value_type_t<O>>()
  tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
    uninitialized_copy(Rng&& rng, O&& result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_copy(begin(rng), end(rng), result);
\end{codeblock}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[begin(rng), end(rng))}.
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class InputIterator}{InputIterator I}@,
            @\changed{class Size, class ForwardIterator}{ForwardIterator O}@>
    @\added{requires Constructible<value_type_t<O>, reference_t<I>{>}() \&\&}@
             @\added{__ReferenceTo<O, value_type_t<O>{>}() \&\&}@
  @\changed{ForwardIterator}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_copy_n(@\changed{InputIterator}{I}@ first, @\changed{Size}{difference_type_t<I>}@ n,
                         @\changed{ForwardIterator}{O}@ out)
\end{codeblock}

\pnum
\effects \changed{As if by}{Equivalent to:}
\begin{codeblock}
        @\removed{for (; n > 0; ++result, (void) ++first, --n)}@
          @\removed{::new(static_cast<void*>(addressof(result)))}@
            @\removed{typename iterator_traits<ForwardIterator>::value_type(*first);}@
        return @\changed{result}{uninitialized_copy(make_counted_iterator(first, n),}@
                                                   @\added{default_sentinel\{\}).base()}@;
\end{codeblock}

{\color{addclr}
\pnum
\requires \tcode{result} is not in the range \tcode{[first, next(first, n))}.
} %% \color{addclr}

\rSec3[uninitialized.move]{uninitialized_move}
\begin{codeblock}
  template <@\changed{class InputIterator}{InputIterator I}@,
            @\changed{class ForwardIterator}{Sentinel<I> S, OutputIterator O}@>
    @\added{requires Constructible<value_type_t<O>, rvalue_reference_t<I>{>}() \&\&}@
              @\added{__ReferenceTo<O, value_type_t<O>{>}()}@
  @\changed{InputIterator}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_move(@\changed{InputIterator}{I}@ first, @\changed{InputIterator}{S}@ last, @\changed{ForwardIterator}{O}@ result);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; (void)++result, ++first)
          ::new @\added{const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*result)))@\added{)}@
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(std::move(*first));
        return @\changed{last}{\{last, result\}}@;
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in \tcode{[first, last)} are left in a valid, but unspecified state.

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.

\begin{codeblock}
  template <InputRange Rng, OutputIterator O>
    requires Constructible<value_type_t<O>, rvalue_reference_t<iterator_t<Rng>>> &&
             __ReferenceTo<O, value_type_t<O>>()
  tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>>
    uninitialized_move(Rng&& rng, O result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_move(begin(rng), end(rng), result);
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in \tcode{[first, last)} are left in a valid, but unspecified state.

\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class InputIterator}{InputIterator I}@, @\changed{class Size, class ForwardIterator}{ForwardIterator O}@>
    @\added{requires Constructible<value_type_t<O>, rvalue_reference_t<I>{>}() \&\&}@
             @\added{__ReferenceTo<O, value_type_t<O>{>}()}@
  @\changed{pair<InputIterator, OutputIterator>}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_move_n(@\changed{InputIterator}{I}@ first, @\changed{Size}{difference_type_t<I>}@ n, @\changed{ForwardIterator}{O}@ out)
\end{codeblock}


\pnum
\effects Equivalent to:
\begin{codeblock}
        @\removed{for (; n > 0; ++result, (void) ++first, --n)}@
          @\removed{::new (static_cast<void*>(addressof(*result)))}@
            @\removed{typename iterator_traits<ForwardIterator>::value_type(std::move(*first));}@
        return @\changed{\{first,result\}}{uninitialized_value_construct(make_counted_iterator(first, n),}@
                                                                       @\added{default_sentinel\{\}).base()}@;
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in \tcode{[first, next(first, n))} are left in a valid, but unspecified state.

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, next(first, n))}.
} %%\color{addclr}

\rSec3[uninitialized.fill]{uninitialized_fill}
\begin{codeblock}
  template <@\changed{class}{CopyConstructible}@ @\changed{ForwardIterator}{T}@, @\changed{class}{OutputIterator<const T\&>}@ @\changed{T}{O},@
            @\added{Sentinel<O> S}@>
    @\added{requires __ReferenceTo<O, value_type_t<O>{>}()}@
    @\changed{void}{O}@ fill(@\changed{ForwardIterator}{O}@ first, @\changed{ForwardIterator}{S}@ last, const T& x);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
        for (; first != last; ++first)
           ::new @\added{const_cast<void*>}@(static_cast<@\added{const volatile }@void*>(addressof(*first)))@\added{)}@
              @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(x);
        return last;
\end{codeblock}
{\color{addclr}
\begin{codeblock}
  template <OutputRange Rng, Constructible T>
    requires __ReferenceTo<T, value_type_t<I>>()
  safe_iterator_t<Rng>
    uninitialized_fill(Rng&& rng, const T& x);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_fill(begin(rng), end(rng), x);
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class}{Constructible}@ @\changed{ForwardIterator}{T}@, @\changed{class Size, class}{OutputIterator<const T\&>}@ @\changed{T}{O}@>
    @\added{requires __ReferenceTo<T, value_type_t<T>{>}()}@
  @\changed{ForwardIterator}{O}@ uninitialized_fill_n(@\changed{ForwardIterator}{O}@ first, @\changed{Size}{difference_type_t<O>}@, const T& x);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
        @\removed{for (; n > 0; --n, ++first)}@
          @\removed{::new (static_cast<void*>(addressof(*first)))}@
            @\removed{typename iterator_traits<ForwardIterator>::value_type(x);}@
        @\added{uninitialized_value_construct(make_counted_iterator(first, n),}@
                                                 @\added{default_sentinel\{\}).base()}@;
\end{codeblock}

\rSec3[specialized.destroy]{destroy}

\begin{codeblock}
  template <@\changed{class}{Destructible}@ T>
    void destroy_at(T* location);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:

\begin{codeblock}
        location->~T();
\end{codeblock}

\begin{codeblock}
  template <@\changed{class ForwardIterator}{InputIterator I, Sentinel<I> S}@>
    @\added{requires Destructible<value_type_t<I>{>}() \&\&}@
             @\added{__ReferenceTo<I, value_type_t<I>{>}()}@
  I destroy(@\changed{ForwardIterator}{I}@ first, @\changed{ForwardIterator}{S}@ last) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          destroy_at(addressof(*first));
        return first;
\end{codeblock}

{\color{addclr}
\begin{codeblock}
  template <InputRange Rng>
    requires Destructible<value_type_t<iterator_t<Rng>>()
             __ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>>>()
  safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return destroy(begin(rng), end(rng));
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class ForwardIterator}{InputIterator I, class Size}@>
    @\added{requires Destructible<value_type_t<I>{>}() \&\&}@
             @\added{__ReferenceTo<I, value_type_t<I>{>}()}@
  @\changed{ForwardIterator}{I}@ destroy_n(@\changed{ForwardIterator}{I}@ first, @\changed{Size}{difference_type_t<I>}@ n) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        @\added{return destroy(make_counted_iterator(first, n), default_sentinel{}).base();}@
\end{codeblock}
