%!TEX root = std.tex
\setcounter{chapter}{19}
\rSec0[utilities]{General utilities library}

\setcounter{section}{6}
\rSec1[memory]{Memory}
\synopsis{Header \tcode{<\added{experimental/ranges/}memory>} synopsis}

\setcounter{subsection}{11}
\rSec2[specialized.algorithms]{Specialized algorithms}

\rSec3[uninitialized.construct.default]{uninitialized_default_construct}
\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges \{ inline namespace v\replacedtxt{1}{2} \{}@
\end{codeblock}

{\color{newclr}
\begin{codeblock}
template <class I, class T>
concept bool __ReferenceTo() {
  return InputIterator<I>() &&
    is_lvalue_reference_v<reference_t<I>> &&
    Same<remove_cv_t<remove_reference_t<reference_t<I>>>, T>();
}
\end{codeblock}
} %% \color{newclr}

\begin{codeblock}
  template <@\changed{class ForwardIterator}{OutputIterator O, Sentinel<O> S}@>
    @\added{requires DefaultConstructible<value_type_t<O>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>}}{__ReferenceTo<O, value_type_t<O>{>}()}@
    @\changed{void}{O}@ uninitialized_default_construct(@\changed{ForwardIterator}{O}@ first, @\changed{ForwardIterator}{S}@ last);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          ::new(static_cast<void*>(addressof(\newtxt{*}first)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@;
        @\added{return \replacedtxt{last}{first};}@
\end{codeblock}

{\color{addclr}
\begin{codeblock}
  template <OutputRange Rng>
    requires DefaultConstructible<value_type_t<iterator_t<Rng>>>\newtxt{()} &&
             @\replacedtxt{Same<value_type_t<iterator_t<O>>, reference_t<iterator_t<O>>}{__ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>{>}{>}()}@
  @\replacedtxt{O}{safe_iterator_t<Rng>}@ uninitialized_default_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return last uninitialized_default_construct(begin(rng), end(rng));
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class}{OutputIterator}@ @\changed{OutputIterator}{O}\removed{, class Size}@>
    @\added{requires DefaultConstructible<value_type_t<O>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>}}{__ReferenceTo<O, value_type_t<O>{>}()}@
  @\changed{ForwardIterator}{O}@
    uninitialized_default_construct_n(@\changed{ForwardIterator}{O}@ first, @\changed{Size}{difference_type_t<O>}@ n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n > 0; (void)++first, --n)
          ::new (static_cast<void*>(addressof(*first)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@;
        return first;
\end{codeblock}

\rSec3[uninitialized.construct.value]{uninitialized_value_construct}
\begin{codeblock}
  template <@\changed{class ForwardIterator}{OutputIterator O, Sentinel<O> S}@>
    @\added{requires Constructible<value_type_t<O>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>}}{__ReferenceTo<O, value_type_t<O>{>}()}@
    @\changed{void}{O}@ uninitialized_value_construct(@\changed{ForwardIterator}{O}@ first, @\changed{ForwardIterator}{S}@ last);
\end{codeblock}


\setcounter{Paras}{0}
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          ::new (static_cast<void*>(addressof(*first)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>()}@;
        @\added{return first;}@
\end{codeblock}
{\color{addclr}
\begin{codeblock}
  template <OutputRange Rng>
    requires Constructible<value_type_t<iterator_t<Rng>>> &&
             @\replacedtxt{Same<value_type_t<iterator_t<O>>, reference_t<iterator_t<O>>}{__ReferenceTo<iterator_t<Rng>, value_type_t<iterator_t<Rng>{>}{>}()}@
  @\replacedtxt{O}{safe_iterator_t<Rng>}@ uninitialized_value_construct(Rng&& rng);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
      return uninitialized_value_construct(begin(rng), end(rng));
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class}{OutputIterator}@ @\changed{OutputIterator}{O}\removed{, class Size}@>
    @\added{requires Constructible<value_type_t<O>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>}}{__ReferenceTo<O, value_type_t<O>{>}()}@
  @\changed{ForwardIterator}{O}@
    uninitialized_value_construct_n(@\changed{ForwardIterator}{O}@ first, @\changed{Size}{difference_type_t<O>}@ n);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n > 0; --n, (void)++first)
          ::new (static_cast<void*>(addressof(*first)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>()}@;
        @\added{return first;}@
\end{codeblock}

\rSec3[uninitialized.copy]{uninitialized_copy}
\begin{codeblock}
  template <@\changed{class}{InputIterator}@ @\changed{InputIterator}{I}@, @\added{Sentinel<I> S, }@
            @\changed{class ForwardIterator}{ForwardIterator O}@>
    @\added{requires }\added{Constructible<value_type_t<O>, reference_t<O>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>} \&\&}{__ReferenceTo<O, value_type_t<O>{>}()}@
             @\newtxt{CopyConstructible<value_type_t<O>{>}()}@
  @\changed{ForwardIterator}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_copy(@\changed{InputIterator}{I}@ first, @\changed{InputIterator}{S}@ last, @\changed{ForwardIterator}{O}@ result);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
        for (; first != last; ++first)
          ::new (static_cast<void*>(addressof(*first)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(*first);
        @\added{return \{last, result + (last - first)\}}@
\end{codeblock}

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.

\begin{codeblock}
  template <InputRange Rng, class O>
    requires ForwardIterator<O>() &&
             Constructible<value_type_t<O>, reference_t<iterator_t<Rng>>>() &&
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>} \&\&}{__ReferenceTo<O, value_type_t<O>{>}()}@
             @\oldtxt{CopyConstructible<value_type_t<O>{>}()}@
  tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
    uninitialized_copy(Rng&& rng, O&& result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_copy(begin(rng), end(rng), std::forward<O>(result));
\end{codeblock}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class}{InputIterator}@ @\changed{InputIterator}{I}@, @\changed{class Size, class ForwardIterator}{OutputIterator O}@>
    @\added{requires }\added{Constructible<value_type_t<O>, reference_t<I>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>}}{__ReferenceTo<O, value_type_t<O>{>}()}\added{ \&\&}@
             @\newtxt{CopyConstructible<value_type_t<O>{>}()}@
  @\changed{ForwardIterator}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_copy_n(@\changed{InputIterator}{I\&\&}@ first, @\changed{Size}{difference_type_t<I>}@ n,
                         @\changed{ForwardIterator}{O\&\&}@ out)
\end{codeblock}

\pnum
\effects \changed{As if by}{Equivalent to:}
\begin{codeblock}
        for (; n > 0; ++result, (void) ++first, --n)
          ::new(static_cast<void*>(addressof(result)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(*first);
        return @\changed{result}{\{first, result\}}@;
\end{codeblock}

{\color{addclr}
\pnum
\requires \tcode{result} is not in the range \tcode{[first, next(first, n))}.
} %% \color{addclr}

\rSec3[uninitialized.move]{uninitialized_move}
\begin{codeblock}
  template <@\changed{class}{InputIterator}@ @\changed{InputIterator}{I}@,
            @\changed{class}{Sentinel<I>}@ @\changed{ForwardIterator}{S, OutputIterator O}@>
    @\added{requires Constructible<value_type_t<O>, reference_t<I>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>} \&\&}{__ReferenceTo<O, value_type_t<O>{>}()}@
             @\newtxt{MoveConstructible<value_type_t<O>{>}()}@
  @\changed{InputIterator}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_move(@\changed{InputIteratror}{I}@ first, @\changed{InputIterator}{S}@ last, @\changed{ForwardIterator}{O}@ result);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; (void)++result, ++first)
          ::new (static_cast<void*>(addressof(*result)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(std::move(*first));
        return @\changed{last}{\{last, result + (last - first)\}}@;
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in \tcode{[first, last)} are left in a valid, but unspecified state.

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.

\begin{codeblock}
  template <InputRange Rng, OutputIterator O>
    requires Constructible<value_type_t<O>, reference_t<iterator_t<Rng>>> &&
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>> \&\&}{__ReferenceTo<O, value_type_t<O>{>}()}@
             @\newtxt{MoveConstructible<value_type_t<O>{>}()}@
  tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>>
    uninitialized_move(Rng&& rng, O&& result);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_move(begin(rng), end(rng), std::forward<O>(result));
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in \tcode{[first, last)} are left in a valid, but unspecified state.

\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, last)}.
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class}{InputIterator}@ @\changed{InputIterator}{I}@, @\changed{class Size, class ForwardIterator}{OutputIterator O}@>
    @\added{requires Constructible<value_type_t<O>, reference_t<I>{>}() \&\&}@
             @\replacedtxt{Same<value_type_t<O>\&, reference_t<O>{>}}{__ReferenceTo<O, value_type_t<O>{>}()}@
             @\newtxt{MoveConstructible<value_type_t<O>{>}()}@
  @\changed{pair<InputIterator, OutputIterator>}{tagged_pair<tag::in(I), tag::out(O)>}@
    uninitialized_move_n(@\changed{InputIterator}{I}@&& first, @\changed{Size}{difference_type_t<I>}@ n, @\changed{ForwardIterator}{O}@&& out)
\end{codeblock}


\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n > 0; ++result, (void) ++first, --n)
          ::new (static_cast<void*>(addressof(*result)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(std::move(*first));
        return {first,result};
\end{codeblock}

\pnum
\remarks If an exception is thrown, some objects in \tcode{[first, next(first, n))} are left in a valid, but unspecified state.

{\color{addclr}
\pnum
\requires \tcode{result} shall not be in the range \tcode{[first, next(first, n))}.
} %%\color{addclr}

\rSec3[uninitialized.fill]{uninitialized_fill}
\begin{codeblock}
  template <@\changed{class}{CopyConstructible}@ @\changed{ForwardIterator}{T}@, @\changed{class}{OutputIterator<const T\&>}@ @\changed{T}{O},@
            @\added{Sentinel<O> S}@>
    @\added{requires }\replacedtxt{Same<value_type_t<T>\&, reference_t<T>{>}}{__ReferenceTo<T, value_type_t<T>{>}()}@
    @\changed{void}{O}@ fill(@\changed{ForwardIterator}{O}@ first, @\changed{ForwardIterator}{S}@ last, const T& x);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
        for (; first != last; ++first)
           ::new (static_cast<void*>(addressof(*first)))
              @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(x);
        return last;
\end{codeblock}
{\color{addclr}
\begin{codeblock}
  template <CopyConstructible T, OutputRange<const T&> Rng>
    requires @\replacedtxt{Same<value_type_t<T>\&, reference_t<T>{>}}{__ReferenceTo<T, value_type_t<T>{>}()}@
  safe_iterator_t<Rng>
    \newtxt{uninitialized_}fill(Rng&& rng, const T& x);
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return uninitialized_fill(begin(rng), end(rng), x);
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class}{CopyConstructible}@ @\changed{ForwardIterator}{T}@, @\changed{class Size, class}{OutputIterator<const T\&>}@ @\changed{T}{O}@>
    @\added{requires }\replacedtxt{Same<value_type_t<T>\&, reference_t<T>{>}}{__ReferenceTo<T, value_type_t<T>{>}()}@
  @\changed{ForwardIterator}{O}@ fill_n(@\changed{ForwardIterator}{O}@ first, @\changed{Size}{difference_type_t<O>}@, const T& x);
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects \changed{As if by}{Equivalent to}:
\begin{codeblock}
        for (; n > 0; --n, ++first)
          ::new (static_cast<void*>(addressof(*first)))
            @\changed{typename iterator_traits<ForwardIterator>::value_type}{value_type_t<O>}@(x);
        @\added{return first;}@
\end{codeblock}

\rSec3[specialized.destroy]{destroy}

\begin{codeblock}
  template <@\changed{class}{ForwardIterator}@ @\changed{ForwardIterator}{I, Sentinel<I> S}@>
    @\added{requires Destructible<value_type_t<I>{>}()}@
  I destroy(@\changed{ForwardIterator}{I}@ first, @\changed{ForwardIterator}{S}@ last) noexcept;
\end{codeblock}

\setcounter{Paras}{0}
\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; first != last; ++first)
          destroy_at(addressof(*first));
        return first;
\end{codeblock}

{\color{addclr}
\begin{codeblock}
  template <ForwardRange Rng>
    requires Destructible<value_type_t<iterator_t<I>>()
  safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        return destroy(begin(rng), end(rng));
\end{codeblock}
} %% \color{addclr}

\begin{codeblock}
  template <@\changed{class}{ForwardIterator}@ @\changed{ForwardIterator}{I}\removed{, class Size}@>
    @\added{requires Destructible<value_type_t<I>{>}()}@
  @\changed{ForwardIterator}{I}@ destroy_n(@\changed{ForwardIterator}{I}@ first, @\changed{Size}{difference_type_t<I>}@ n) noexcept;
}@\added{\}\}\}}@
\end{codeblock}

\pnum
\effects Equivalent to:
\begin{codeblock}
        for (; n > 0; --n, ++first)
          destroy_at(addressof(*first));
        return first;
\end{codeblock}
