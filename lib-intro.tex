%!TEX root = std.tex
\setcounter{chapter}{16}
\rSec0[library]{Library introduction}

\setcounter{section}{5}
\setcounter{subsection}{1}
\setcounter{subsubsection}{2}

\rSec3[structure.requirements]{Requirements}

\pnum
\indextext{requirements}%
Requirements describe constraints that shall be met by a \Cpp program that extends the standard library.
Such extensions are generally one of the following:

\begin{itemize}
\item Template arguments
\item Derived classes
\item Containers, iterators, and algorithms that meet an interface convention
or satisfy a concept
\end{itemize}

\pnum
The string and iostream components use an explicit representation of operations
required of template arguments. They use a class template \tcode{char_traits} to
define these constraints.

\pnum
Interface convention requirements are stated as generally as possible. Instead
of stating ``class X has to define a member function \tcode{operator++()},'' the
interface requires ``for any object \tcode{x} of class \tcode{X}, \tcode{++x} is
defined.'' That is, whether the operator is a member is unspecified.

\pnum
Requirements are stated in terms of \added{concepts~(Concepts TS [dcl.spec.concept]).
Concepts are stated in terms of} well-defined expressions that define valid terms of
the types that satisfy the \changed{requirements}{concept}. For every set of
well-defined expression requirements there is a \changed{table}{named concept} that
specifies an initial set of the valid expressions and their semantics. Any generic
algorithm (Clause~\ref{algorithms}) that uses the well-defined expression requirements
is described in terms of the valid expressions for its formal type parameters. 

\pnum
Template argument requirements are sometimes referenced by name.
See~\cxxref{type.descriptions}.

\pnum
In some cases the semantic requirements are presented as \Cpp code.
Such code is intended as a
specification of equivalence of a construct to another construct, not
necessarily as the way the construct
must be implemented.\footnote{Although in some cases the code given is
unambiguously the optimum implementation.}

\begin{addedblock}
\pnum
Required operations of any concept defined in this document need not be
total functions; that is, some arguments to a required operation may
result in the required semantics failing to be satisfied. \enterexample
The required \tcode{<} operator of the \tcode{StrictTotallyOrdered}
concept~(\ref{concepts.lib.compare.stricttotallyordered}) does not meet the
semantic requirements of that concept when operating on NaNs.\exitexample
This does not affect whether a type satisfies the concept.

\pnum
A declaration may explicitly impose requirements through its associated
constraints (Concepts TS [temp.constr.decl]). When the associated constraints
refer to a concept~(Concepts TS [dcl.spec.concept]), additional semantic requirements are
imposed on the use of the declaration.

\pnum
If the semantic requirements of a declaration are not satisfied at the
point of use, the program is ill-formed, no diagnostic required.
\end{addedblock}

\setcounter{section}{5}
\setcounter{subsection}{2}
\setcounter{subsubsection}{1}
\setcounter{paragraph}{4}

\begin{addedblock}
\rSec4[customization.point.object]{Customization Point Objects}
\pnum
A \techterm{customization point object} is a function object~(\ref{function.objects}) with a
literal class type that interacts with user-defined types while
enforcing semantic requirements on that interaction.

\pnum
The type of a customization point object shall satisfy
\tcode{Semiregular}~(\ref{concepts.lib.object.semiregular}).

\pnum
All instances of a specific customization point object type shall
be equal.

\pnum
The type of a customization point object \tcode{T} shall satisfy
\tcode{Callable<const T, Args...>()}~(\ref{concepts.lib.callables.callable}) when the types of
\tcode{Args...} meet the requirements specified in that
customization point object's definition. Otherwise, \tcode{T}
shall not have a function call operator that participates in
overload resolution.

\pnum
Each customization point object type constrains its return type
to satisfy a particular concept.

\pnum
The library defines several named customization point objects.
In every translation unit where such a name is defined, it shall
refer to the same instance of the customization point object.

\pnum
\enternote Many of the customization point objects in the library
evaluate function call expressions with an unqualified name which
results in a call to a user-defined function found by argument
dependent name lookup~(\cxxref{basic.lookup.argdep}). To preclude
such an expression resulting in a call to unconstrained functions
with the same name in namespace \tcode{std}, customization point
objects specify that lookup for these expressions is performed in
a context that includes deleted overloads matching the signatures
of overloads defined in namespace \tcode{std}. When the deleted
overloads are viable, user-defined overloads must be more
specialized~(\cxxref{temp.func.order}) or more
constrained~(Concepts TS [temp.constr.order]) to be used by a
customization point object. \exitnote
\end{addedblock}
