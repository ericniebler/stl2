%!TEX root = std.tex

\setcounter{chapter}{23}
\rSec0[iterators]{Iterators library}

\rSec1[iterators.general]{General}

\pnum
This Clause describes components that \Cpp programs may use to perform
iterations over containers (Clause \cxxref{containers}),
streams~(\cxxref{iostream.format}),
\removed{and} stream buffers~(\cxxref{stream.buffers})
\added{, and ranges~(\ref{ranges})}.

\pnum
The following subclauses describe
iterator requirements, and
components for
iterator primitives,
predefined iterators,
and stream iterators,
as summarized in Table~\ref{tab:iterators.lib.summary}.

\begin{libsumtab}{Iterators library summary}{tab:iterators.lib.summary}
\ref{iterator.requirements} & Requirements        &                           \\ \rowsep
\ref{iterator.primitives} & Iterator primitives   &   \tcode{<\added{experimental/ranges\oldtxt{_v1}/}iterator>}      \\
\ref{iterators.predef} & Predefined iterators     &                           \\
\ref{iterators.stream} & Stream iterators         &                           \\
\added{\ref{ranges}} & \added{Ranges}             &                           \\
\end{libsumtab}

\rSec1[iterator.requirements]{Iterator requirements}

\rSec2[iterator.requirements.general]{In general}

\pnum
\indextext{requirements!iterator}%
Iterators are a generalization of pointers that allow a \Cpp program to work with different data structures
(\added{for example, }containers\added{ and ranges}) in a uniform manner.
To be able to construct template algorithms that work correctly and
efficiently on different types of data structures, the library formalizes not just the interfaces but also the
semantics and complexity assumptions of iterators.
All input iterators
\tcode{i}
support the expression
\tcode{*i},
resulting in a value of some object type
\tcode{T},
called the
\term{value type}
of the iterator.
All output iterators support the expression
\tcode{*i = o}
where
\tcode{o}
is a value of some type that is in the set of types that are
\term{writable}
to the particular iterator type of
\tcode{i}.
\removed{All iterators
\tcode{i}
for which the expression
\tcode{(*i).m}
is well-defined, support the expression
\tcode{i->m}
with the same semantics as
\tcode{(*i).m}.}
For every iterator type
\tcode{X}
\oldoldtxt{for which
equality is defined}, there is a corresponding signed integer type called the
\term{difference type}
of the iterator.

\pnum
Since iterators are an abstraction of pointers, their semantics \oldoldtxt{is}\newtxt{are}
a generalization of most of the semantics of pointers in \Cpp.
This ensures that every
function template
that takes iterators
works as well with regular pointers.
This International Standard defines
five\oldtxt{seven} categories of iterators, according to the operations
defined on them:
\oldtxt{\techterm{weak input iterators}, }
\techterm{input iterators},
\oldtxt{\techterm{weak output iterators}, }
\techterm{output iterators},
\techterm{forward iterators},
\techterm{bidirectional iterators}
and
\techterm{random access iterators},
as shown in Table~\ref{tab:iterators.relations}.

\begin{floattable}{Relations among iterator categories}{tab:iterators.relations}
{lllll}
\topline
\textbf{Random Access}          &   $\rightarrow$ \textbf{Bidirectional}    &
$\rightarrow$ \textbf{Forward}  &   $\rightarrow$ \textbf{Input}            & \oldtxt{   $\rightarrow$ \textbf{WeakInput}}           \\
                        &   &   &   $\rightarrow$ \textbf{Output}           & \oldtxt{   $\rightarrow$ \textbf{WeakOutput}}          \\
\end{floattable}

\begin{addedblock}
\pnum
The \oldtxt{seven}\newtxt{five} categories of iterators correspond to the iterator concepts
\oldtxt{\tcode{WeakInputIterator},}
\tcode{InputIterator},
\oldtxt{\tcode{WeakOutputIterator},}
\tcode{OutputIterator},
\tcode{ForwardIterator},
\tcode{BidirectionalIterator}, and
\tcode{RandomAccess\-Iterator}, respectively. The generic term \techterm{iterator} refers to
any type that satisfies \tcode{\oldtxt{Weak}Iterator}.
\end{addedblock}

\pnum
Forward\oldtxt{Input} iterators satisfy all the requirements of \oldtxt{weak }input
iterators and can be used whenever an\oldtxt{a weak} input iterator is specified;
\oldtxt{Forward iterators also satisfy all the requirements of
input iterators and can be used whenever an input iterator is specified;}
Bidirectional iterators also satisfy all the requirements of
forward iterators and can be used whenever a forward iterator is specified;
Random access iterators also satisfy all the requirements of bidirectional
iterators and can be used whenever a bidirectional iterator is specified.

\pnum
Iterators that further satisfy the requirements of \oldtxt{weak }output iterators are
called \defn{mutable iterator}{s}. Nonmutable iterators are referred to
as \defn{constant iterator}{s}.

\pnum
Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence.
These values are called
\term{past-the-end}
values.
Values of an iterator
\tcode{i}
for which the expression
\tcode{*i}
is defined are called
\term{dereferenceable}.
The library never assumes that past-the-end values are dereferenceable.
Iterators can also have singular values that are not associated with any
sequence.
\enterexample
After the declaration of an uninitialized pointer
\tcode{x}
(as with
\tcode{int* x;}),
\tcode{x}
must always be assumed to have a singular value of a pointer.
\exitexample
Results of most expressions are undefined for singular values;
the only exceptions are destroying an iterator that holds a singular value,
the assignment of a non-singular value to
an iterator that holds a singular value, and\removed{, for iterators that satisfy the
\tcode{DefaultConstructible} requirements,} using a value-initialized iterator
as the source of a copy or move operation. \enternote This guarantee is not
offered for default initialization, although the distinction only matters for types
with trivial default constructors such as pointers or aggregates holding pointers.
\exitnote
In these cases the singular
value is overwritten the same way as any other value.
Dereferenceable
values are always non-singular.

\begin{addedblock}
\pnum
A
\term{sentinel}
is an abstraction of a past-the-end iterator. \oldtxt{Sentinels
are \tcode{Regular} types that can be used to denote the end of
a range.} An iterator and a sentinel denoting a range
\newtxt{are comparable}\oldtxt{shall be \tcode{EqualityComparable}}.
A sentinel denotes an element when\newtxt{ it compares equal to}
an iterator \tcode{i}\oldtxt{ compares equal to the sentinel}, and
\tcode{i} points to that element. \newtxt{The types of a sentinel
and an iterator that denote a range must satisfy
\tcode{Sentinel}~(\ref{iterators.sentinel}).}
\end{addedblock}

\pnum
\oldoldtxt{An iterator }\oldtxt{or }\newnewtxt{A }\added{sentinel}
\tcode{\oldoldtxt{j}\newnewtxt{s}}
is called
\term{reachable}
from an iterator
\tcode{i}
if and only if there is a finite sequence of applications of
the expression
\tcode{++i}
that makes
\tcode{i == \oldoldtxt{j}\newnewtxt{s}}.
If
\tcode{\oldoldtxt{j}\newnewtxt{s}}
is reachable from
\tcode{i},
they \oldoldtxt{refer to elements of the same sequence}\newnewtxt{denote a range}.

\pnum
Most of the library's algorithmic templates that operate on data structures have interfaces that use ranges.
A
\term{range}
is \oldoldtxt{a pair of iterators }\oldtxt{or }\added{an iterator and a sentinel} that designate the beginning and end of the computation.
A range \oldoldtxt{\range{i}{i}}\newnewtxt{\range{i}{s}}
is an empty range\newnewtxt{ if \tcode{i == s}};
\oldoldtxt{in general, a range \range{i}{j}}\newnewtxt{otherwise, \range{i}{s}}
refers to the elements in the data structure starting with the element
pointed to by
\tcode{i}
and up to but not including the element pointed to\oldtxt{denoted} by
\newnewtxt{the first iterator} \tcode{j} \newnewtxt{such that \tcode{j == s}}.
Range \oldoldtxt{\range{i}{j}}\newnewtxt{\range{i}{s}}
is valid if and only if
\oldoldtxt{\tcode{j}}\newnewtxt{\tcode{s}}
is reachable from
\tcode{i}.
The result of the application of functions in the library to invalid ranges is
undefined.

\pnum
All the categories of iterators require only those functions that are realizable for a given category in
constant time (amortized).
\removed{Therefore, requirement tables for the iterators do not have a complexity column.}

\pnum
Destruction of an iterator may invalidate pointers and references
previously obtained from that iterator.

\pnum
An
\techterm{invalid}
iterator is an iterator that may be singular.\footnote{This definition applies to pointers, since pointers are iterators.
The effect of dereferencing an iterator that has been invalidated
is undefined.
}

\oldoldtxt{
\pnum
In the following sections,
\tcode{a}
and
\tcode{b}
denote values of type
\tcode{X} or \tcode{const X},
\tcode{difference_type} and \tcode{reference} refer to the
types \tcode{iterator_traits<X>::difference_type} and
\tcode{iterator_traits<X>::ref\-erence}, respectively,
\tcode{n}
denotes a value of
\tcode{difference_type},
\tcode{u},
\tcode{tmp},
and
\tcode{m}
denote identifiers,
\tcode{r}
denotes a value of
\tcode{X\&},
\tcode{t}
denotes a value of value type
\tcode{T},
\tcode{o}
denotes a value of some type that is writable to the output iterator.
\enternote For an iterator type \tcode{X} there must be an instantiation
of \tcode{iterator_traits<X>}~(\cxxref{iterator.traits}). \exitnote
}

\begin{addedblock}
\rSec2[iterators.readable]{Concept Readable}

\pnum
The \tcode{Readable} concept is satisfied by types that are readable by
applying \tcode{operator*} including pointers, smart pointers, and iterators.

\indexlibrary{\idxcode{Readable}}%
\begin{codeblock}
  template <class I>
  concept bool Readable() {
    return Semiregular<I>() &&
      requires (const I i) {
        typename @\oldtxt{ValueType}\newtxt{value_type_t}@<I>;
        { *i } -> const @\oldtxt{ValueType}\newtxt{value_type_t}@<I>&; // pre: i is dereferenceable
      };
  }
\end{codeblock}

\pnum
A \tcode{Readable} type has an associated value type that can be accessed with the
\tcode{\oldtxt{ValueType}}\tcode{\newtxt{value_type_t}} alias template.

\indexlibrary{\idxcode{value_type_t}}%
\begin{codeblock}
  template <class> struct value_type { };
  template <class T>
  struct value_type<T*>
    : enable_if<is_object<T>::value, remove_cv_t<T>> { };
  template <class I>
    requires is_array<I>::value
  struct value_type<I> : value_type<decay_t<I>> { };
  template <class I>
  struct value_type<I const> : value_type<decay_t<I>> { };
  @\oldtxt{template <class I>}@
  @\oldtxt{struct value_type<I volatile> : value_type<decay_t<I>{}> \{ \};}@
  @\oldtxt{template <class I>}@
  @\oldtxt{struct value_type<I const volatile> : value_type<decay_t<I>{}> \{ \};}@
  template <class T>
    requires requires { typename T::value_type; }
  struct value_type<T>
    : enable_if<is_object<typename T::value_type>::value, typename T::value_type> { };
  template <class T>
    requires requires { typename T::element_type; }
  struct value_type<T>
    : enable_if<is_object<typename T::element_type>::value, typename T::element_type> { };

  template <class T>
    using @\oldtxt{ValueType}\newtxt{value_type_t}@ = typename value_type<T>::type;
\end{codeblock}

\pnum
If a type \tcode{I} has an associated value type, then \tcode{value_type<I>::type} shall name the
value type. Otherwise, there shall be no nested type \tcode{type}.

\pnum
The \tcode{value_type} class template may be specialized on user-defined types.

\pnum
When instantiated with a type \tcode{I} \oldtxt{that has a nested type \tcode{value_type}}
\newtxt{such that \tcode{I::value_type} is valid and denotes a type},
\tcode{value_type<I>::type} names that type, unless it is not an object type~(\cxxref{basic.types}) in which case
\tcode{value_type<I>} shall have no nested type \tcode{type}. \enternote Some legacy output
iterators define a nested type named \tcode{value_type} that is an alias for \tcode{void}. These
types are not \tcode{Readable} and have no associated value types.\exitnote

\pnum
When instantiated with a type \tcode{I} \oldtxt{that has a nested type \tcode{element_type}}
\newtxt{such that \tcode{I::element_type} is valid and denotes a type},
\tcode{value_type<I>::type} names that type, unless it is not an object type~(\cxxref{basic.types}) in which case
\tcode{value_type<I>} shall have no nested type \tcode{type}. \enternote Smart pointers like
\tcode{shared_ptr<int>} are \tcode{Readable} and have an associated value type. But a smart pointer
like \tcode{shared_ptr<void>} is not \tcode{Readable} and has no associated value type.\exitnote

\rSec2[iterators.writable]{Concept Writable}

\pnum
The \tcode{\oldtxt{Move}Writable} concept describes the requirements for \oldtxt{moving}\newtxt{writing} a value into an iterator's
referenced object.

\indexlibrary{\idxcode{Writable}}%
\begin{codeblock}
  template <class Out, class T>
  concept bool @\oldtxt{Move}@Writable() {
    return Semiregular<Out>() &&
      requires(Out o, T@\newtxt{\&\&}@ v) {
        *o = std::@\oldtxt{move}\newtxt{forward<T>}@(v); // not required to be equality preserving
      };
  }
\end{codeblock}

\pnum
Let \tcode{t} be an \oldtxt{rvalue or a lvalue of type (possibly \tcode{const})}\newtxt{an expression such that \tcode{decltype(t)} is} \tcode{T}, and let \tcode{o}
be a dereferenceable object of type \tcode{Out}. Then \tcode{\oldtxt{Move}Writable<Out, T>()} is satisfied if and only if

\begin{itemize}
\item If \oldtxt{\tcode{Out} is }\tcode{Readable<Out>()\newtxt{ \&\& Same<value_type_t<Out>, decay_t<T>{>}()}}\newtxt{ is satisfied},
then\newtxt{ \tcode{*o}} after the assignment\oldtxt{ \tcode{*o = std::move(t)}, \tcode{*o}} is equal
to the value of \tcode{t} before the assignment.
\end{itemize}

\pnum
After\newtxt{ evaluating} the \newtxt{assignment }expression\oldtxt{ \tcode{*o = std::move(v)}}, \oldtxt{object }\tcode{o} is not required to be dereferenceable.

\pnum
\oldtxt{\tcode{v}'s state}\newtxt{If \tcode{v} is an xvalue~(\cxxref{basic.lval}), the resulting
state of the object it denotes} is unspecified. \enternote \oldtxt{\tcode{v}}\newtxt{The object} must still meet the
requirements of \oldtxt{the}\newtxt{any} library component that is using it. The operations listed
in those requirements must work as specified whether \oldtxt{\tcode{v}}\newtxt{the object} has been moved
from or not.\exitnote

\ednote{``If \tcode{t} is an xvalue'' suffices for now, but incorporating P0022's proxy
 iterators will require a characterization of the ``xvalue-ness'' of a proxy reference type.}

\pnum
\enternote
The only valid use of an \tcode{operator*} is on the left side of the assignment statement.
\textit{Assignment through the same value of the writable type happens only once.}
\exitnote

{\color{oldclr}
\rSec2[iterators.oldwritable]{(Was) Concept Writable}

\pnum
The \tcode{Writable} concept describes the requirements for copying a value into an iterator's
referenced object.

\begin{codeblock}
  template <class Out, class T>
  concept bool Writable() {
    return MoveWritable<Out, T>() &&
      requires (Out o, const T v) {
        *o = v; // not required to be equality preserving
      };
  }
\end{codeblock}

\pnum
Let \tcode{v} be an lvalue of type (possibly \tcode{const}) \tcode{T} or an rvalue
of type \tcode{const T}, and let \tcode{o} be a dereferenceable object of type
\tcode{Out}. Then \tcode{Writable<Out, T>()} is satisfied if and only if

\begin{itemize}
\item If \tcode{Out} is \tcode{Readable}, after the assignment \tcode{*o = v},
\tcode{*o} is equal to the value of \tcode{v}.
\end{itemize}
} %% color{oldclr}

\rSec2[iterators.weaklyincrementable]{Concept WeaklyIncrementable}

\pnum
The \tcode{WeaklyIncrementable} concept describes types that can be incremented with the pre-
and post-increment operators. The increment operations are not required to be equality-preserving,
nor is the type required to be \tcode{EqualityComparable}.

\indexlibrary{\idxcode{WeaklyIncrementable}}%
\begin{codeblock}
  template <class I>
  concept bool WeaklyIncrementable() {
    return Semiregular<I>() &&
      requires (I i) {
        typename @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
        requires SignedIntegral<@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>>();
        { ++i } -> Same<I&>; // not required to be equality preserving
        i++; // not required to be equality preserving
      };
  }
\end{codeblock}

\pnum
Let \tcode{i} be an object of type \tcode{I}. When both pre- and post-increment
are valid, \tcode{i} is said to be \techterm{incrementable}. Then
\tcode{WeaklyIncrementable<I>()} is satisfied if and only if

\begin{itemize}
\item \tcode{++i} is valid if and only if \tcode{i++} is valid.
\item If \tcode{i} is incrementable, then both \tcode{++i}
  and \tcode{i++} moves \tcode{i} to the next element.
\item If \tcode{i} is incrementable, then \tcode{\&++i == \&i}.
\end{itemize}

\ednote{Copied almost verbatim from the \tcode{InputIterator} description. This wording is removed
there:}

\pnum
\enternote For \tcode{WeaklyIncrementable} types, \tcode{a} equals \tcode{b} does not imply that \tcode{++a}
equals \tcode{++b}. (Equality does not guarantee the substitution property or referential
transparency.) Algorithms on weakly incrementable types should never attempt to pass
through the same incrementable value twice. They should be single pass algorithms. These algorithms
can be used with istreams as the source of the input data through the \tcode{istream_iterator} class
template.\exitnote

\rSec2[iterators.incrementable]{Concept Incrementable}

\pnum
The \tcode{Incrementable} concept describes types that can be incremented with the pre-
and post-increment operators. The increment operations are required to be equality-preserving,
and the type is required to be \tcode{EqualityComparable}. \enternote This requirement
supersedes the annotations on the increment expressions in the definition of
\tcode{WeaklyIncrementable}. \exitnote

\indexlibrary{\idxcode{Incrementable}}%
\begin{codeblock}
  template <class I>
  concept bool Incrementable() {
    return Regular<I>() &&
      WeaklyIncrementable<I>() &&
      requires(I i) {
        { i++ } -> Same<I>;
      };
  }
\end{codeblock}

\pnum
Let \tcode{a} and \tcode{b} be incrementable objects of type \tcode{I}.
Then \tcode{Incrementable<I>()} is satisfied
if and only if

\begin{itemize}
\item If \tcode{bool(a == b)} then \tcode{bool(a++ == b)}.
\item If \tcode{bool(a == b)} then \tcode{bool((a++, a) == ++b)}.
\end{itemize}

\ednote{Copied in part from the \tcode{ForwardIterator} description. This wording is removed
there.}

\pnum
\enternote The requirement that \tcode{a} equals \tcode{b} implies \tcode{++a} equals \tcode{++b}
(which is not true for weakly incrementable types) allows the use of multi-pass one-directional
algorithms with types that satisfy \tcode{Incrementable}.\exitnote

\end{addedblock}

\ednote{Section ``Iterator'' renamed to ``Concept Iterator'' below:}

\rSec2[iterators.iterator]{Concept Iterator}

\pnum
The \oldtxt{\tcode{Weak}}\tcode{Iterator} \changed{requirements}{concept} form\added{s}
the basis of the iterator concept taxonomy; every iterator satisfies the
\oldtxt{\tcode{Weak}}\tcode{Iterator} requirements. This
\changed{set of requirements}{concept} specifies operations for dereferencing and incrementing
an iterator. Most algorithms will require additional operations
\added{to compare iterators\newtxt{ with sentinels}~(\ref{iterators.sentinel}),} to
read~(\ref{iterators.input}) or write~(\ref{iterators.output}) values, or
to provide a richer set of iterator movements~(\ref{iterators.forward},
\ref{iterators.bidirectional}, \ref{iterators.random.access}).)

\ednote{Remove para 2 and Table 106.}

\begin{addedblock}
\indexlibrary{\idxcode{Iterator}}%
\begin{codeblock}
  template <class I>
  concept bool @\oldtxt{Weak}@Iterator() {
    return WeaklyIncrementable<I>() &&
      requires(I i) {
        { *i } -> auto&&; // pre: i is dereferenceable
      };
  }
\end{codeblock}

\pnum
\enternote The requirement that the result of dereferencing the iterator is deducible from
\tcode{auto\&\&} means that it cannot be \tcode{void}.\exitnote

\rSec2[iterators.sentinel]{Concept Sentinel}
\pnum
The \tcode{Sentinel} concept \oldtxt{defines requirements for a type that
is an abstraction of the past-the-end iterator. Its values can be
compared to an iterator for equality.}\newtxt{specifies the relationship
between an \tcode{Iterator} type and a \tcode{Semiregular} type whose values
denote a range.}

\indexlibrary{\idxcode{Sentinel}}%
\begin{itemdecl}
  template <class @\oldtxt{T}\newtxt{S}@, class I>
  concept bool Sentinel() {
    return @\newtxt{Semi}@regular<@\oldtxt{T}\newtxt{S}@>() &&
      Iterator<I>() &&
      @\newtxt{Weakly}@EqualityComparable<@\oldtxt{T}\newtxt{S}@, I>();
  }
\end{itemdecl}

{\color{newclr}
\begin{itemdescr}
\pnum
Let \tcode{s} and \tcode{i} be values of type \tcode{S} and
\tcode{I} such that \range{i}{s} denotes a range. Types
\tcode{S} and \tcode{I} satisfy \tcode{Sentinel<S, I>()}
if and only if:

\begin{itemize}
\item \tcode{i == s} is well-defined.

\item If \tcode{bool(i != s)} then \tcode{i} is dereferenceable and
      \range{++i}{s} denotes a range.
\end{itemize}
\end{itemdescr}

\pnum
The domain of \tcode{==} can change over time.
Given an iterator \tcode{i} and sentinel \tcode{s} such that \range{i}{s}
denotes a range and \tcode{i != s}, \range{i}{s} is not required to continue to
denote a range after incrementing any iterator equal to \tcode{i}. Consequently,
\tcode{i == s} is no longer required to be well-defined.
} %% color{newclr}

\rSec2[iterators.sizedsentinel]{Concept SizedSentinel}
\pnum
The \tcode{Sized\oldtxt{IteratorRange}\newtxt{Sentinel}} concept specifies\oldtxt{ the}
requirements on a\newtxt{n} \tcode{Iterator}\oldtxt{~(\ref{iterators.iterator})} and a \tcode{Sentinel}
that allow\oldtxt{s} the use of the \tcode{-} operator to compute the distance
between them in constant time.

{\color{oldclr}
\indexlibrary{\idxcode{SizedIteratorRange}}%
\begin{itemdecl}
  template <class I, class S>
  concept bool SizedIteratorRange() {
    return Sentinel<S, I>() &&
      requires (const I i, const S j) {
        { i - i } -> difference_type_t<I>;
        { j - j } -> difference_type_t<I>;
        { i - j } -> difference_type_t<I>;
        { j - i } -> difference_type_t<I>;
      };
  }
\end{itemdecl}

\pnum
Let \tcode{a} be a valid iterator of type \tcode{I} and \tcode{b} be
a valid sentinel of type \tcode{S}. Let \tcode{n} be the smallest value
of type \tcode{difference_type_t<I>} such that after \tcode{n}
applications of \tcode{++a}, then \tcode{bool(a == b)}.
Then \tcode{SizedIteratorRange<I, S>()} is satisfied if and only if:

\begin{itemize}
\item \tcode{(b - a) == n}.
\item \tcode{(a - b) == -n}.
\item \tcode{(a - a) == 0}.
\item \tcode{(b - b) == 0}.
\end{itemize}
} %% color{oldclr}

\indexlibrary{\idxcode{SizedSentinel}}%
{\color{newclr}
\begin{itemdecl}
  template <class S, class I>
  constexpr bool disable_sized_sentinel = false;

  template <class S, class I>
  concept bool SizedSentinel() {
    return Sentinel<S, I>() &&
      !disable_sized_sentinel<remove_cv_t<S>, remove_cv_t<I>> &&
      requires (const I i, const S s) {
        { s - i } -> Same<difference_type_t<I>>;
        { i - s } -> Same<difference_type_t<I>>;
      };
  }
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{i} be an iterator of type \tcode{I}, and \tcode{s}
a sentinel of type \tcode{S} such that \range{i}{s} denotes a range.
Let $N$ be the smallest number of applications of \tcode{++i}
necessary to make \tcode{bool(i == s)} be \tcode{true}.
\tcode{SizedSentinel<S, I>()} is satisfied if and only if:

\begin{itemize}
\item If $N$ is representable by \tcode{difference_type_t<I>},
      then \tcode{s - i} is well-defined and equals $N$.

\item If $-N$ is representable by \tcode{difference_type_t<I>},
      then \tcode{i - s} is well-defined and equals $-N$.
\end{itemize}
\end{itemdescr}

\pnum
The \tcode{disable_sized_sentinel<S, I>} predicate provides a mechanism to
enable use of sentinels and iterators with the library that meet the
syntactic requirements but do not in fact satisfy \tcode{SizedSentinel}.

\pnum
\enternote A program that instantiates a library template that requires
\tcode{SizedSentinel} with an iterator type \tcode{I} and sentinel type
\tcode{S} that meet the syntactic requirements of \tcode{SizedSentinel<S, I>()}
but do not satisfy \tcode{SizedSentinel} is ill-formed with no diagnostic required
unless \tcode{disable_sized_sentinel<S, I>} evaluates to
\tcode{true}~(\ref{structure.requirements}). \exitnote
} %% color{newclr}

\pnum
\enternote The \tcode{Sized\oldtxt{IteratorRange}\newtxt{Sentinel}}
concept is satisfied by pairs of
\tcode{RandomAccessIterator}s~(\ref{iterators.random.access}) and by
counted iterators and their sentinels~(\ref{counted.iterator}).\exitnote

\ednote{\oldtxt{This concept also gives us a way to demote the category of \tcode{move_iterator}s to Input
while retaining the ability of \tcode{move_iterator} pairs to communicate the range's size to
container constructors.}}

{\color{oldclr}
\rSec2[iterators.olditerator]{(Was) Concept Iterator}

\pnum
The \tcode{Iterator} concept refines \tcode{WeakIterator}~(\ref{iterators.iterator}) and adds
the requirement that the iterator is equality comparable.

\pnum
In the \tcode{Iterator} concept, the set of values over which
\tcode{==} is (required to be) defined can change over time.
Each algorithm places additional requirements on the domain of
\tcode{==} for the iterator values it uses.
These requirements can be inferred from the uses that algorithm
makes of \tcode{==} and \tcode{!=}.
\enterexample
the call \tcode{find(a, b, x)}
is defined only if the value of \tcode{a}
has the property \textit{p}
defined as follows:
\tcode{b} has property \textit{p}
and a value \tcode{i}
has property \textit{p}
if
\tcode{(*i==x)}
or if
\tcode{(*i!=x}
and
\tcode{++i}
has property
\textit{p}).
\exitexample

\begin{itemdecl}
  template <class I>
  concept bool Iterator() {
    return WeakIterator<I>() &&
      EqualityComparable<I>();
  }
\end{itemdecl}
} %% color{oldclr}
\end{addedblock}

\ednote{Section ``Input iterators'' renamed to ``Concept InputIterator'' below:}

\rSec2[iterators.input]{Concept InputIterator}

\ednote{Replace the entire content of the section with:}

\begin{addedblock}
\pnum
The \tcode{\oldtxt{Weak}InputIterator} concept is a refinement of
\tcode{\oldtxt{Weak}Iterator}~(\ref{iterators.iterator}). It
defines requirements for a type whose \oldtxt{referred to}\newtxt{referenced} values can be read (from the requirement for
\tcode{Readable}~(\ref{iterators.readable})) and which can be both pre- and post-incremented. However,
\oldtxt{weak }input iterators are not required to be comparable for equality.

\indexlibrary{\idxcode{InputIterator}}%
\begin{codeblock}
  template <class I>
  concept bool @\oldtxt{Weak}@InputIterator() {
    return @\oldtxt{Weak}@Iterator<I>() &&
      Readable<I>() &&
      requires(I i, const I ci) {
        typename @\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@<I>;
        requires DerivedFrom<@\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@<I>, @\oldtxt{weak_}@input_iterator_tag>();
        { i++ } -> Readable; // not required to be equality preserving
        requires Same<@\oldtxt{ValueType}\newtxt{value_type_t}@<I>, @\oldtxt{ValueType}\newtxt{value_type_t}@<decltype(i++)>>();
        { *ci } -> const @\oldtxt{ValueType}\newtxt{value_type_t}@<I>&;
      };
  }
\end{codeblock}
\end{addedblock}

{\color{oldclr}
\rSec2[iterators.oldinput]{(Was) Concept InputIterator}

\pnum
The \tcode{InputIterator} concept is a refinement of \tcode{Iterator}~(\ref{iterators.iterator}) and
\tcode{WeakInputIterator}~(\ref{iterators.input}).

\begin{codeblock}
  template <class I>
  concept bool InputIterator() {
    return WeakInputIterator<I>() &&
      DerivedFrom<IteratorCategory<I>, input_iterator_tag>() &&
      Iterator<I>();
  }
\end{codeblock}

\pnum
\enternote
Since \tcode{InputIterator} is only \tcode{WeaklyIncrementable},
\tcode{a == b}
does not imply
\tcode{++a == ++b}.
(Equality does not guarantee the substitution property or referential transparency.)
Algorithms on input iterators should never attempt to pass through the same iterator twice.
They should be
\term{single pass}
algorithms.
\tcode{value_type_t<I>} is not required
to be a \tcode{Copyable}
type~(\ref{concepts.lib.object.copyable}). These algorithms can be used with
istreams as the source of the input data through the \tcode{istream_iterator} class template.
\exitnote
} %% color{oldclr}

\ednote{Section ``Output iterators'' renamed to ``Concept \oldtxt{Weak}OutputIterator'' below:}

\rSec2[iterators.output]{Concept OutputIterator}

\ednote{Remove para 1 and Table 108}

\begin{addedblock}
\pnum
The \tcode{\oldtxt{Weak}OutputIterator} concept is a refinement of
\tcode{\oldtxt{Weak}Iterator}~(\ref{iterators.iterator}). It defines requirements for a type that
can be used to write values (from the requirement for
\tcode{Writable}~(\ref{iterators.writable})) and which can be both pre- and post-incremented.
However, \oldtxt{weak }output iterators are not required to
satisfy \tcode{EqualityComparable}.

\indexlibrary{\idxcode{OutputIterator}}%
\begin{codeblock}
  template <class I, class T>
  concept bool @\oldtxt{Weak}@OutputIterator() {
    return @\oldtxt{Weak}@Iterator<I>() && Writable<I, T>();
  }
\end{codeblock}
\end{addedblock}

\pnum
\enternote
\removed{The only valid use of an
\tcode{operator*}
is on the left side of the assignment statement.}
\textit{\removed{Assignment through the same value of the iterator happens only once.}}
Algorithms on output iterators should never attempt to pass through the same iterator twice.
They should be
\term{single pass}
algorithms.
\removed{Equality and inequality might not be defined.}
Algorithms that take \oldtxt{weak }output iterators can be used with ostreams as the destination
for placing data through the
\tcode{ostream_iterator}
class as well as with insert iterators and insert pointers.
\exitnote

\begin{addedblock}
{\color{oldclr}
\rSec2[iterators.oldoutput]{(Was) Concept OutputIterator}

\pnum
The \tcode{OutputIterator} concept is a refinement of \tcode{Iterator}~(\ref{iterators.iterator}) and
\tcode{WeakOutputIterator}~(\ref{iterators.output}).

\begin{codeblock}
  template <class I, class T>
  concept bool OutputIterator() {
    return WeakOutputIterator<I, T>() && Iterator<I>();
  }
\end{codeblock}

\pnum
\enternote Output iterators are used by single-pass
algorithms that write into a bounded range, like \tcode{generate}.
\exitnote
} %% color{oldclr}
\end{addedblock}

\rSec2[iterators.forward]{Concept ForwardIterator}

\begin{removedblock}
\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of a forward iterator if

\begin{itemize}
\item \tcode{X} satisfies the requirements of an input iterator~(\ref{iterators.input}),

\item X satisfies the \tcode{DefaultConstructible}
requirements~(\cxxref{utility.arg.requirements}),

\item if \tcode{X} is a mutable iterator, \tcode{reference} is a reference to \tcode{T};
if \tcode{X} is a const iterator, \tcode{reference} is a reference to \tcode{const T},

\item the expressions in Table~\cxxref{tab:iterator.forward.requirements}
are valid and have the indicated semantics, and

\item objects of type \tcode{X} offer the multi-pass guarantee, described below.
\end{itemize}
\end{removedblock}

\begin{addedblock}
\pnum
The \tcode{ForwardIterator} concept refines \tcode{InputIterator}~(\ref{iterators.input}),
\oldtxt{and adds}\newtxt{adding equality comparison and} the multi-pass guarantee, described below.

\indexlibrary{\idxcode{ForwardIterator}}%
\begin{codeblock}
  template <class I>
  concept bool ForwardIterator() {
    return InputIterator<I>() &&
      DerivedFrom<@\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@<I>, forward_iterator_tag>() &&
      Incrementable<I>()@\newtxt{ \&\&}@
      @\newtxt{Sentinel<I, I>()}@;
  }
\end{codeblock}
\end{addedblock}

\pnum
The domain of \tcode{==} for forward iterators is that of iterators over the same
underlying sequence. However, value-initialized iterators \added{of the same type}
may be compared and shall compare equal to other value-initialized iterators of the same type.
\enternote \changed{v}{V}alue\added{-}initialized iterators behave as if they refer past the end of
the same empty sequence\added{.} \exitnote

\pnum
Two dereferenceable iterators \tcode{a} and \tcode{b} of type \tcode{X} offer the
\defn{multi-pass guarantee} if:

\begin{itemize}
\item \tcode{a == b} implies \tcode{++a == ++b} and
\item \removed{\tcode{X} is a pointer type or t}\added{T}he expression
\tcode{\removed{(void)++X(a)}\added{([](X x)\{++x;\}(a)}, *a\added{)}} is equivalent to the expression \tcode{*a}.
\end{itemize}

\pnum
\enternote
The requirement that
\tcode{a == b}
implies
\tcode{++a == ++b}
(which is not true for \removed{input and output}\added{weaker} iterators)
and the removal of the restrictions on the number of\removed{ the} assignments through
a mutable iterator
(which applies to output iterators)
allow\removed{s} the use of multi-pass one-directional algorithms with forward iterators.
\exitnote

\ednote{Remove Table 109}

\pnum
\removed{If \tcode{a} and \tcode{b} are equal, then either \tcode{a} and \tcode{b}
are both dereferenceable
or else neither is dereferenceable.}

\pnum
\removed{If \tcode{a} and \tcode{b} are both dereferenceable, then \tcode{a == b}
if and only if \tcode{*a} and \tcode{*b} are bound to the same object.}

\rSec2[iterators.bidirectional]{Concept BidirectionalIterator}

\begin{removedblock}
\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of a bidirectional iterator if,
in addition to satisfying the requirements for forward iterators,
the following expressions are valid as shown in Table~\cxxref{tab:iterator.bidirectional.requirements}.
\end{removedblock}

\begin{addedblock}
\pnum
The \tcode{BidirectionalIterator} concept refines \tcode{ForwardIterator}~(\ref{iterators.forward}),
and adds the ability to move an iterator backward as well as forward.

\indexlibrary{\idxcode{BidirectionalIterator}}%
\begin{codeblock}
  template <class I>
  concept bool BidirectionalIterator() {
    return ForwardIterator<I>() &&
      DerivedFrom<@\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@<I>, bidirectional_iterator_tag>() &&
      requires (I i) {
        { @\dcr@i } -> Same<I&>;
        { i@\dcr@ } -> Same<I>;
      };
  }
\end{codeblock}
\end{addedblock}

\ednote{Remove table 110}

\begin{addedblock}
\pnum
A bidirectional iterator \tcode{r} is decrementable if and only if there exists some \tcode{s} such that
\tcode{++s == r}. The expressions \tcode{\dcr{}r} and \tcode{r\dcr{}} are only valid if \tcode{r} is
decrementable.

\pnum
Let \tcode{a} and \tcode{b} be decrementable objects of type \tcode{I}. Then
\tcode{BidirectionalIterator<I>()} is satisfied if and only if:

\begin{itemize}
\item \tcode{\&\dcr{}a == \&a}.
\item If \tcode{bool(a == b)}, then \tcode{bool(a\dcr{} == b)}.
\item If \tcode{bool(a == b)}, then \tcode{bool((a\dcr{}, a) == \dcr{}b)}.
\item If \tcode{a} is incrementable and \tcode{bool(a == b)}, then
      \tcode{bool(\dcr{}(++a) == b)}.
\item If \tcode{bool(a == b)}, then \tcode{bool(++(\dcr{}a) == b)}.
\end{itemize}
\end{addedblock}

\begin{removedblock}
\pnum
\enternote
Bidirectional iterators allow algorithms to move iterators backward as well as forward.
\exitnote
\end{removedblock}

\rSec2[iterators.random.access]{Concept RandomAccessIterator}

\begin{removedblock}
\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of a random access iterator if,
in addition to satisfying the requirements for bidirectional iterators,
the following expressions are valid as shown in Table~\cxxref{tab:iterator.random.access.requirements}.
\end{removedblock}

\begin{addedblock}
The \tcode{RandomAccessIterator} concept refines \tcode{BidirectionalIterator}~(\ref{iterators.bidirectional})
and adds support for constant-time advancement with \tcode{+=}, \tcode{+},  \tcode{-=}, and \tcode{-}, and the
computation of distance in constant time with \tcode{-}. Random access iterators also support array
notation via subscripting.

\indexlibrary{\idxcode{RandomAccessIterator}}%
\begin{codeblock}
  @\oldtxt{template <class I>}@
  @\oldtxt{concept bool \xname{MutableIterator} = // \expos}@
    @\oldtxt{Iterator<I>() \&\&}@
    @\oldtxt{requires(const I i) \{}@
      @\oldtxt{\{ *i \} -> auto\&;}@
      @\oldtxt{*i = *i;}@
    @\oldtxt{\};}@

  template <class I>
  concept bool RandomAccessIterator() {
    return BidirectionalIterator<I>() &&
      DerivedFrom<@\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@<I>, random_access_iterator_tag>() &&
      @\newtxt{Strict}@TotallyOrdered<I>() &&
      Sized@\oldtxt{IteratorRange}\newtxt{Sentinel}@<I, I>() &&
      requires (I i, const I j, const @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n) {
        { i += n } -> Same<I&>;
        { j + n } -> Same<I>;
        { n + j } -> Same<I>;
        { i -= n } -> Same<I&>;
        { j - n } -> Same<I>;
        { j[n] } -> @\oldtxt{const ValueType<I>\&}\newtxt{Same<reference_t<I>{}>}@;
      } @\oldtxt{\&\&}@
      @\oldtxt{(!\xname{MutableIterator}<I> ||}@
        @\oldtxt{requires(const I i, const DifferenceType<I> n) \{ i[n] = *i; *i = i[n]; \})}@;
  }
\end{codeblock}
\end{addedblock}

\ednote{Remove Table 111}

\begin{addedblock}
\pnum
Let \tcode{a} and \tcode{b} be valid iterators of type \tcode{I} such that \tcode{b} is reachable
from \tcode{a}. Let \tcode{n} be the smallest value of type
\tcode{\oldtxt{DifferenceType<I>}}\tcode{\newtxt{difference_type_t<I>}} such that after
\tcode{n} applications of \tcode{++a}, then \tcode{bool(a == b)}. Then
\tcode{RandomAccessIterator<I>()} is satisfied if and only if:

\begin{itemize}
\item \tcode{(a += n)} is equal to \tcode{b}.
\item \tcode{\&(a += n)} is equal to \tcode{\&a}.
\item \tcode{(a + n)} is equal to \tcode{(a += n)}.
\item For any two positive integers \tcode{x} and \tcode{y}, if \tcode{a + (x + y)} is valid, then
\tcode{a + (x + y)} is equal to \tcode{(a + x) + y}.
\item \tcode{a + 0} is equal to \tcode{a}.
\item If \tcode{(a + (n - 1))} is valid, then \tcode{a + n} is equal to \tcode{++(a + (n - 1))}.
\item \tcode{(b += -n)} is equal to \tcode{a}.
\item \tcode{(b -= n)} is equal to \tcode{a}.
\item \tcode{\&(b -= n)} is equal to \tcode{\&b}.
\item \tcode{(b - n)} is equal to \tcode{(b -= n)}.
\item If \tcode{b} is dereferenceable, then \tcode{a[n]} is valid and is equal to \tcode{*b}.
\end{itemize}

\rSec1[indirectcallables]{Indirect callable requirements}

\rSec2[indirectcallables.general]{In general}

\pnum
There are several concepts that group requirements of algorithms that take callable
objects~(\cxxref{func.require}) as arguments.

\ednote{Specifying the algorithms in terms of these indirect callable concepts would ease
the transition should we ever decide to support proxy iterators in the future. See the
Future Work appendix~(\ref{future.proxy}).}

{\color{oldclr}
\rSec2[indirectcallables.as_function_t]{as_function_t type}

\pnum
The \tcode{\oldtxt{FunctionType}}\tcode{as_function_t} is an alias used to turn a
callable type~(\cxxref{func.def}) into a function object type~(\ref{function.objects}).

\indexlibrary{\idxcode{function_t}}%
\begin{codeblock}
  // Exposition only
  template <class T>
    requires is_member_pointer<decay_t<T>>::value
  auto @\xname{as_function}@(T&& t) {
    return mem_fn(t);
  }
  template <class T>
  T @\xname{as_function}@(T&& t) {
    return std::forward<T>(t);
  }

  template <class T>
  using @\oldtxt{FunctionType}\newtxt{as_function_t}@ =
    decltype(@\xname{as_function}@(declval<T>()));
\end{codeblock}
} %% color{oldclr}

\rSec2[indirectcallables.indirectfunc]{Indirect callables}

\pnum
The indirect callable concepts are used to constrain those algorithms that accept
callable objects~(\cxxref{func.def}) as arguments.

\indexlibrary{\idxcode{indirect_result_of_t}}%
\indexlibrary{\idxcode{IndirectCallable}}%
\indexlibrary{\idxcode{IndirectRegularCallable}}%
\indexlibrary{\idxcode{IndirectCallablePredicate}}%
\indexlibrary{\idxcode{IndirectCallableRelation}}%
\indexlibrary{\idxcode{IndirectCallableStrictWeakOrder}}%
\begin{codeblock}
  template <class F, class... Is>
  concept bool IndirectCallable() {
    return (Readable<Is>() && ...) &&
      @\newtxt{Callable<F, value_type_t<Is>...>();}@
      @\oldtxt{Function<FunctionType<F>, ValueType<Is>...>();}@
  }

  template <class F, class... Is>
  concept bool IndirectRegularCallable() {
    return (Readable<Is>() && ...) &&
      @\newtxt{RegularCallable<F, value_type_t<Is>...>();}@
      @\oldtxt{RegularFunction<FunctionType<F>, ValueType<Is>...>();}@
  }

  template <class F, class... Is>
  concept bool IndirectCallablePredicate() {
    return (Readable<Is>() && ...) &&
      @\newtxt{Predicate<F, value_type_t<Is>...>();}@
      @\oldtxt{Predicate<FunctionType<F>, ValueType<Is>...>();}@
  }

  template <class F, class I1, class I2 = I1>
  concept bool IndirectCallableRelation() {
    return Readable<I1>() && Readable<I2>() &&
      @\newtxt{Relation<F, value_type_t<I1>, value_type_t<I2>{}>();}@
      @\oldtxt{Relation<FunctionType<F>, ValueType<I1>, ValueType<I2>{}>();}@
  }

  template <class F, class I1, class I2 = I1>
  concept bool IndirectCallableStrictWeakOrder() {
    return Readable<I1>() && Readable<I2>() &&
      @\newtxt{StrictWeakOrder<F, value_type_t<I1>, value_type_t<I2>{}>();}@
      @\oldtxt{StrictWeakOrder<FunctionType<F>, ValueType<I1>, ValueType<I2>{}>();}@
  }

  @\oldtxt{template <class F, class... Is>}@
  @\oldtxt{using IndirectCallableResultType =}@
    @\oldtxt{ResultType<FunctionType<F>, ValueType<Is>...>}@

  @\newtxt{template <class> struct indirect_result_of \{ \};}@
  @\newtxt{template <class F, class... Is>}@
    @\newtxt{requires IndirectCallable<remove_reference_t<F>, Is...>()}@
  @\newtxt{struct indirect_result_of<F(Is...)> :}@
    @\newtxt{result_of<F(value_type_t<Is>...)> \{ \};}@

  @\newtxt{template <class F>}@
  @\newtxt{using indirect_result_of_t = typename indirect_result_of<F>::type;}@
\end{codeblock}

\rSec2[projected]{Class template \tcode{projected}}

\pnum
The \tcode{\oldtxt{P}\newtxt{p}rojected} class template is intended for use when specifying the constraints of
algorithms that accept callable objects and projections. It bundles a \tcode{Readable} type
\tcode{I} and a function \tcode{Proj} into a new \tcode{Readable} type whose
\tcode{reference} type is the result of applying \tcode{Proj} to the
\tcode{\oldtxt{ReferenceType}}\tcode{\newtxt{reference_t}} of \tcode{I}.

\indexlibrary{\idxcode{projected}}%
\begin{codeblock}
  template <Readable I, IndirectRegularCallable<I> Proj>
    @\oldtxt{requires RegularFunction<FunctionType<Proj>, ValueType<I>{}>}@
    @\newtxt{requires RegularCallable<Proj, reference_t<I>{}>()}@
  struct @\oldtxt{P}\newtxt{p}@rojected {
    @\oldtxt{using value_type = decay_t<ResultType<FunctionType<Proj>, ValueType<I>{}>{}>;}@
    @\oldtxt{ResultType<FunctionType<Proj>, ReferenceType<I>{}> operator*() const;}@
    @\newtxt{using value_type = decay_t<indirect_result_of_t<Proj\&(I)>{}>;}@
    @\newtxt{result_of_t<Proj\&(reference_t<I>)> operator*() const;}@
  };

  template <WeaklyIncrementable I, class Proj>
  struct difference_type<@\oldtxt{P}\newtxt{p}@rojected<I, Proj>> {
    using type = @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
  };
\end{codeblock}

\pnum
\enternote \tcode{\oldtxt{P}\newtxt{p}rojected} is only used to ease constraints specification. Its
member function need not be defined.\exitnote

\rSec1[commonalgoreq]{Common algorithm requirements}

\rSec2[commonalgoreq.general]{In general}

\pnum
There are several additional iterator concepts that are commonly applied to families of algorithms.
These group together iterator requirements of algorithm families. \newtxt{There are three relational
concepts that specify how element values are transferred between \tcode{Readable} and \tcode{Writable} types:
\tcode{IndirectlyMovable}, \tcode{IndirectlyCopyable}, and \tcode{IndirectlySwappable}.} There are \oldtxt{four}\newtxt{three} relational concepts
for rearrangements: \tcode{Permutable}, \tcode{Mergeable},\oldtxt{ \tcode{MergeMovable},} and \tcode{Sortable}.
There is one relational concept for comparing values from different sequences: \tcode{IndirectlyComparable}.

{\color{newclr}
\pnum
\enternote The \tcode{equal_to<>} and \tcode{less<>}~(\ref{comparisons}) function types used in the
concepts below impose additional constraints on their arguments beyond those that appear explicitly in the
concepts' bodies. \tcode{equal_to<>} requires its arguments satisfy \tcode{EqualityComparable}~(\ref{concepts.lib.compare.equalitycomparable}),
and \tcode{less<>} requires its arguments satisfy \tcode{StrictTotallyOrdered}~(\ref{concepts.lib.compare.stricttotallyordered}).\exitnote
}

\rSec2[commonalgoreq.indirectlymovable]{Concept IndirectlyMovable}

\pnum
The \tcode{IndirectlyMovable} concept \oldtxt{describes}\newtxt{specifies} the\oldtxt{ move} relationship between a \tcode{Readable}
type and a \tcode{\oldtxt{Move}Writable} type\newtxt{ between which values may be moved}.

\indexlibrary{\idxcode{IndirectlyMovable}}%
\begin{codeblock}
  @\newtxt{template <class I>}@
  @\newtxt{using rvalue_reference_t =}@
    @\newtxt{decltype(std::move(declval<reference_t<I>{>}()));}@

  template <class I@\newtxt{n}@, class Out>
  concept bool IndirectlyMovable() {
    return Readable<I@\newtxt{n}@>() &&
      @\oldtxt{Move}@Writable<Out, @\oldtxt{ValueType<I>}\newtxt{rvalue_reference_t<In>}@>();
  }
\end{codeblock}

\ednote{This is a simple version of \tcode{rvalue_reference_t} to be replaced
with the formulation from P0022 when that proposal is integrated.}

{\color{oldclr} %% Redundant with Writable
\pnum
Let \tcode{i} be an object of type \tcode{I}, and let \tcode{o} be a
dereferenceable object of type \tcode{Out}. Then
\tcode{IndirectlyMovable<I, Out>()} is satisfied if and only if

\begin{itemize}
\item If \tcode{Out} is \tcode{Readable}, after the assignment
\tcode{*o = std::move(*i)}, \tcode{*o} is equal to
the value of \tcode{*i} before the assignment.
\end{itemize}
} %% color{oldclr}

{\color{newclr}
\pnum
The \tcode{IndirectlyMovableStorable} concept augments \tcode{IndirectlyMovable} with additional
requirements enabling the transfer to be performed through an intermediate object of the
\tcode{Readable} type's value type.

\indexlibrary{\idxcode{IndirectlyMovableStorable}}%
\begin{codeblock}
  template <class In, class Out>
  concept bool IndirectlyMovableStorable() {
    return IndirectlyMovable<In, Out>() &&
      Writable<Out, value_type_t<In>&&>() &&
      Movable<value_type_t<In>>() &&
      Constructible<value_type_t<In>, rvalue_reference_t<In>>() &&
      Assignable<value_type_t<In>&, rvalue_reference_t<In>>();
  }
\end{codeblock}
} %% color{newclr}

\rSec2[commonalgoreq.indirectlycopyable]{Concept IndirectlyCopyable}

\pnum
The \tcode{IndirectlyCopyable} concept \oldtxt{describes}\newtxt{specifies} the\oldtxt{ copy} relationship between a \tcode{Readable}
type and a \tcode{Writable} type\newtxt{ between which values may be transferred without necessarily moving}.

\indexlibrary{\idxcode{IndirectlyCopyable}}%
\begin{codeblock}
  template <class I@\newtxt{n}@, class Out>
  concept bool IndirectlyCopyable() {
    return IndirectlyMovable<I@\newtxt{n}@, Out>() &&
      Writable<Out, @\oldtxt{ValueType}\newtxt{reference_t}@<I@\newtxt{n}@>>();
  }
\end{codeblock}

{\color{oldclr} %% Redundant with Writable
\pnum
Let \tcode{i} be an object of type \tcode{I}, and let \tcode{o} be a
dereferenceable object of type \tcode{Out}. Then
\tcode{IndirectlyCopyable<I, Out>()} is satisfied if and only if

\begin{itemize}
\item If \tcode{Out} is \tcode{Readable}, after the assignment \tcode{*o = *i},
\tcode{*o} is equal to the value of \tcode{*i}.
\end{itemize}
} %% color{oldclr}

{\color{newclr}
\pnum
The \tcode{IndirectlyCopyableStorable} concept augments \tcode{IndirectlyCopyable} with additional
requirements enabling the transfer to be performed through an intermediate object of the
\tcode{Readable} type's value type. It also requires the capability to make copies of values.

\indexlibrary{\idxcode{IndirectlyCopyableStorable}}%
\begin{codeblock}
  template <class In, class Out>
  concept bool IndirectlyCopyableStorable() {
    return IndirectlyCopyable<In, Out>() &&
      IndirectlyMovableStorable<In, Out>() &&
      Writable<Out, const value_type_t<In>&>() &&
      Copyable<value_type_t<In>>() &&
      Constructible<value_type_t<In>, reference_t<In>>() &&
      Assignable<value_type_t<In>&, reference_t<In>>();
  }
\end{codeblock}
} %% color{newclr}

\rSec2[commonalgoreq.indirectlyswappable]{Concept IndirectlySwappable}

\pnum
The \tcode{IndirectlySwappable} concept describes a swappable relationship between the
reference types of two \tcode{Readable} types.

\indexlibrary{\idxcode{IndirectlySwappable}}%
\begin{codeblock}
  template <class I1, class I2 = I1>
  concept bool IndirectlySwappable() {
    return Readable<I1>() && Readable<I2>() &&
      Swappable<@\oldtxt{ReferenceType}\newtxt{reference_t}@<I1>, @\oldtxt{ReferenceType}\newtxt{reference_t}@<I2>>();
  }
\end{codeblock}

\rSec2[commonalgoreq.indirectlycomparable]{Concept IndirectlyComparable}

\pnum
The \tcode{IndirectlyComparable} concept specifies the common requirements of algorithms that
compare values from two different sequences.

\indexlibrary{\idxcode{IndirectlyComparable}}%
\begin{codeblock}
  template <class I1, class I2, class R = equal_to<>, class P1 = identity,
    class P2 = identity>
  concept bool IndirectlyComparable() {
    return IndirectCallableRelation<R, @\oldtxt{P}\newtxt{p}@rojected<I1, P1>, @\oldtxt{P}\newtxt{p}@rojected<I2, P2>>();
  }
\end{codeblock}

\rSec2[commonalgoreq.permutable]{Concept Permutable}

\pnum
The \tcode{Permutable} concept specifies the common requirements of algorithms that reorder
elements in place by moving or swapping them.

\indexlibrary{\idxcode{Permutable}}%
\begin{codeblock}
  template <class I>
  concept bool Permutable() {
    return ForwardIterator<I>() &&
      @\oldtxt{Movable<ValueType<I>{>}() \&\&}@
      IndirectlyMovable@\newtxt{Storable}@<I, I>()@\newtxt{ \&\&}@
      @\newtxt{IndirectlySwappable<I, I>()}@;
  }
\end{codeblock}

\rSec2[commonalgoreq.mergeable]{Concept Mergeable}

\pnum
The \tcode{Mergeable} concept specifies the requirements of
algorithms that merge sorted sequences into an output sequence by copying elements.

\indexlibrary{\idxcode{Mergeable}}%
\begin{codeblock}
  template <class I1, class I2, class Out,
      class R = less<>, class P1 = identity, class P2 = identity>
  concept bool Mergeable() {
    return InputIterator<I1>() &&
      InputIterator<I2>() &&
      WeaklyIncrementable<Out>() &&
      IndirectlyCopyable<I1, Out>() &&
      IndirectlyCopyable<I2, Out>() &&
      IndirectCallableStrictWeakOrder<R, @\oldtxt{P}\newtxt{p}@rojected<I1, P1>, @\oldtxt{P}\newtxt{p}@rojected<I2, P2>>();
  }
\end{codeblock}

\oldtxt{
\pnum
\enternote When \tcode{less<>} is used as the
relation, the value type must satisfy \tcode{TotallyOrdered}.\exitnote
}

{\color{oldclr}
\rSec2[commonalgoreq.mergemovable]{Concept MergeMovable}

\pnum
The \tcode{MergeMovable} concept specifies the requirements of
algorithms that merge sorted sequences into an output sequence by moving elements.

\indexlibrary{\idxcode{MergeMovable}}%
\begin{codeblock}
  template <class I1, class I2, class Out,
      class R = less<>, class P1 = identity, class P2 = identity>
  concept bool MergeMovable() {
    return InputIterator<I1>() &&
      InputIterator<I2>() &&
      WeaklyIncrementable<Out>() &&
      IndirectlyMovable<I1, Out>() &&
      IndirectlyMovable<I2, Out>() &&
      IndirectCallableStrictWeakOrder<R, Projected<I1, P1>, Projected<I2, P2>>();
  }
\end{codeblock}

\pnum
\enternote When \tcode{less<>} is used as the
relation, the value type must satisfy \tcode{TotallyOrdered}.\exitnote
} %% color{oldclr}

\rSec2[commonalgoreq.sortable]{Concept Sortable}

\pnum
The \tcode{Sortable} concept specifies the common requirements of algorithms that permute
sequences\oldtxt{ of iterators} into\oldtxt{ an} ordered sequence\newtxt{s} (e.g., \tcode{sort}).

\indexlibrary{\idxcode{Sortable}}%
\begin{codeblock}
  template <class I, class R = less<>, class P = identity>
  concept bool Sortable() {
    return Permutable<I>() &&
      IndirectCallableStrictWeakOrder<R, @\oldtxt{P}\newtxt{p}@rojected<I, P>>();
  }
\end{codeblock}

\oldtxt{
\pnum
\enternote When \tcode{less<>} is used as the
relation, the value type must satisfy \tcode{TotallyOrdered}.\exitnote
}
\end{addedblock}

\rSec1[iterator.synopsis]{Header \tcode{<experimental/ranges/iterator>} synopsis}

\indexlibrary{\idxhdr{experimental/ranges\oldtxt{_v1}/iterator}}%
\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  // \ref{iterator.primitives}, primitives:
  template<class Iterator> @\changed{struct}{using}@ iterator_traits@\added{ = \seebelow}@;
  @\removed{template<class T> struct iterator_traits<T*>;}@

  @\oldtxt{template<class Category, class T, class Distance = ptrdiff_t,}@
       @\oldtxt{class Pointer = T*, class Reference = T\&> struct iterator;}@
\end{codeblock}

\begin{addedblock}
\begin{codeblock}
  template <class> struct difference_type;
  template <class> struct value_type;
  template <class> struct iterator_category;
  template <class @\oldtxt{WeaklyIncrementable}\newtxt{T}@> using @\oldtxt{DifferenceType}\newtxt{difference_type_t}@
    = typename difference_type<@\oldtxt{WeaklyIncrementable}\newtxt{T}@>::type;
  template <class @\oldtxt{Readable}\newtxt{T}@> using @\oldtxt{ValueType}\newtxt{value_type_t}@
    = typename value_type<@\oldtxt{Readable}\newtxt{T}@>::type;
  template <class @\oldtxt{WeakInputIterator}\newtxt{T}@> using @\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@
    = typename iterator_category<@\oldtxt{WeakInputIterator}\newtxt{T}@>::type;

\end{codeblock}
\end{addedblock}
\begin{codeblock}
  struct output_iterator_tag { };
  @\oldtxt{struct weak_input_iterator_tag \{ \};}@
  struct input_iterator_tag @\oldtxt{: public weak_input_iterator_tag }@{ };
  struct forward_iterator_tag :@\oldoldtxt{ public}@ input_iterator_tag { };
  struct bidirectional_iterator_tag :@\oldoldtxt{ public}@ forward_iterator_tag { };
  struct random_access_iterator_tag :@\oldoldtxt{ public}@ bidirectional_iterator_tag { };

  // \ref{iterator.operations}, iterator operations:
\end{codeblock}
\begin{removedblock}
\begin{codeblock}
  template <class InputIterator, class Distance>
    void advance(InputIterator& i, Distance n);
  template <class InputIterator>
    typename iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last);
  template <class ForwardIterator>
    ForwardIterator next(ForwardIterator x,
      typename std::iterator_traits<ForwardIterator>::difference_type n = 1);
  template <class BidirectionalIterator>
    BidirectionalIterator prev(BidirectionalIterator x,
      typename std::iterator_traits<BidirectionalIterator>::difference_type n = 1);
\end{codeblock}
\end{removedblock}
\begin{addedblock}
\begin{codeblock}
  template <@\oldtxt{Weak}@Iterator I>
    void advance(I& i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);
  template <Iterator I, Sentinel<I> S>
    void advance(I& i, S bound);
  template <Iterator I, Sentinel<I> S>
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> advance(I& i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, S bound);
  template <Iterator I, Sentinel<I> S>
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> distance(I first, S last);
  template <@\oldtxt{Weak}@Iterator I>
    I next(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n = 1);
  template <Iterator I, Sentinel<I> S>
    I next(I x, S bound);
  template <Iterator I, Sentinel<I> S>
    I next(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, S bound);
  template <BidirectionalIterator I>
    I prev(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n = 1);
  template <BidirectionalIterator I>
    I prev(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, I bound);
\end{codeblock}
\end{addedblock}

\begin{codeblock}
  // \ref{iterators.predef}, predefined iterators\added{ and sentinels}:

  @\added{\itshape{\rmfamily{// \ref{iterators.reverse} Reverse iterators}}}@
  template <@\changed{class Iterator}{BidirectionalIterator I}@> class reverse_iterator;

  template <class @\removed{Iterator1}\oldtxt{BidirectionalIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{BidirectionalIterator }\added{I2}@>
      @\added{requires EqualityComparable<I1, I2>()}@
    bool operator==(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  @\newnewtxt{template <class I1, class I2>}@
      @\newnewtxt{requires EqualityComparable<I1, I2>()}@
    @\newnewtxt{bool operator!=(}@
      @\newnewtxt{const reverse_iterator<I1>\& x,}@
      @\newnewtxt{const reverse_iterator<I2>\& y);}@
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  @\oldoldtxt{template <class Iterator1, class Iterator2>}@
      @\oldtxt{requires EqualityComparable<I1, I2>()}@
    @\oldoldtxt{bool operator!=(}@
      @\oldoldtxt{const reverse_iterator<Iterator1>\& x,}@
      @\oldoldtxt{const reverse_iterator<Iterator2>\& y);}@
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>=(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<=(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);

  template <class @\removed{Iterator1}\oldtxt{BidirectionalIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{BidirectionalIterator }\added{I2}@>
      @\added{requires \oldtxt{SizedIteratorRange<I2, I1>}\newtxt{SizedSentinel<I1, I2>}()}@
    @\removed{auto}\oldtxt{DifferenceType<I2>}\newnewtxt{difference_type_t<I2>}@ operator-(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y)@\removed{ ->decltype(y.base() - x.base())}@;
  template <@\changed{class Iterator}{RandomAccessIterator I}@>
    reverse_iterator<@\changed{Iterator}{I}@>
      operator+(
    @\removed{typename reverse_iterator<Iterator>::difference_type}\oldtxt{DifferenceType<I>}\newnewtxt{difference_type_t<I>}@ n,
    const reverse_iterator<@\changed{Iterator}{I}@>& x);

  template <@\changed{class Iterator}{BidirectionalIterator I}@>
    reverse_iterator<@\changed{Iterator}{I}@> make_reverse_iterator(@\changed{Iterator}{I}@ i);

  @\added{\itshape{\rmfamily{// \ref{iterators.insert} Insert iterators}}}@
  template <class Container> class back_insert_iterator;
  template <class Container>
    back_insert_iterator<Container> back_inserter(Container& x);

  template <class Container> class front_insert_iterator;
  template <class Container>
    front_insert_iterator<Container> front_inserter(Container& x);

  template <class Container> class insert_iterator;
  template <class Container>
    insert_iterator<Container> inserter(Container& x, @\removed{typename Container::iterator}@
      @\oldtxt{IteratorType}\newtxt{iterator_t}\added{<Container>}@ i);

  @\added{\itshape{\rmfamily{// \ref{iterators.move} Move iterators}}}@
  template <@\removed{class Iterator}\oldtxt{Weak}\added{InputIterator I}@> class move_iterator;
  template <class @\removed{Iterator1}\oldtxt{InputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{InputIterator }\added{I2}@>
      @\added{requires EqualityComparable<I1, I2>()}@
    bool operator==(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{InputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{InputIterator }\added{I2}@>
      @\added{requires EqualityComparable<I1, I2>()}@
    bool operator!=(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<=(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>=(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);

  template <class @\removed{Iterator1}\oldtxt{WeakInputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{WeakInputIterator }\added{I2}@>
      @\added{requires \oldtxt{SizedIteratorRange<I2, I1>}\newtxt{SizedSentinel<I1, I2>}()}@
    @\removed{auto}\oldtxt{DifferenceType<I2>}\newnewtxt{difference_type_t<I2>}@ operator-(
      const move_iterator<@\changed{Iterator1}{I1}@>& x,
      const move_iterator<@\changed{Iterator2}{I2}@>& y)@\removed{ ->decltype(y.base() - x.base())}@;
  template <@\changed{class Iterator}{RandomAccessIterator I}@>
    move_iterator<@\changed{Iterator}{I}@>
      operator+(
    @\removed{typename move_iterator<Iterator>::difference_type}\oldtxt{DifferenceType<I>}\newnewtxt{difference_type_t<I>}@ n,
    const move_iterator<@\changed{Iterator}{I}@>& x);
  template <@\removed{class Iterator}\oldtxt{Weak}\added{InputIterator I}@>
    move_iterator<@\changed{Iterator}{I}@> make_move_iterator(@\changed{Iterator}{I}@ i);
\end{codeblock}

\begin{addedblock}
\begin{codeblock}
  @\newtxt{template <Semiregular S> class move_sentinel;}@
  @\newtxt{template <class I, Sentinel<I> S>}@
    @\newtxt{bool operator==(}@
      @\newtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\newtxt{template <class I, Sentinel<I> S>}@
    @\newtxt{bool operator==(}@
      @\newtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\newtxt{template <class I, Sentinel<I> S>}@
    @\newtxt{bool operator!=(}@
      @\newtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\newtxt{template <class I, Sentinel<I> S>}@
    @\newtxt{bool operator!=(}@
      @\newtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@

  @\newtxt{template <class I, SizedSentinel<I> S>}@
    @\newtxt{difference_type_t<I> operator-(}@
      @\newtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\newtxt{template <class I, SizedSentinel<I> S>}@
    @\newtxt{difference_type_t<I> operator-(}@
      @\newtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@

  @\newtxt{template <Semiregular S>}@
    @\newtxt{move_sentinel<S> make_move_sentinel(S s);}@

  // \ref{iterators.common} Common iterators
  @\oldtxt{template<class A, class B>}@
  @\oldtxt{concept bool \xname{WeaklyEqualityComparable} = \seebelow;  // \expos}@
  @\oldtxt{template<class S, class I>}@
  @\oldtxt{concept bool \xname{WeakSentinel} = \seebelow;              // \expos}@

  template <@\oldtxt{Input}@Iterator I, @\oldtxt{\xname{Weak}}@Sentinel<I> S>
    @\newtxt{requires !Same<I, S>()}@
  class common_iterator;

  @\newtxt{template <Readable I, class S>}@
  @\newtxt{struct value_type<common_iterator<I, S>{>};}@

  @\newtxt{template <InputIterator I, class S>}@
  @\newtxt{struct iterator_category<common_iterator<I, S>{>};}@
  @\newtxt{template <ForwardIterator I, class S>}@
  @\newtxt{struct iterator_category<common_iterator<I, S>{>};}@

  @\newtxt{template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>}@
  @\newtxt{bool operator==(}@
    @\newtxt{const common_iterator<I1, S1>\& x, const common_iterator<I2, S2>\& y);}@
  template <class I1, class @\oldtxt{S1}\newtxt{I2}@, @\oldtxt{class I2}\newtxt{Sentinel<I2> S1}@, @\oldtxt{class}\newtxt{Sentinel<I1>}@ S2>
    requires EqualityComparable<I1, I2>()@\oldtxt{ \&\& \xname{WeaklyEqualityComparable}<I1, S2> \&\&}@
      @\oldtxt{\xname{WeaklyEqualityComparable}<I2, S1>}@
  bool operator==(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
  template <class I1, class @\oldtxt{S1}\newtxt{I2}@, @\oldtxt{class I2}\newtxt{Sentinel<I2> S1}@, @\oldtxt{class}\newtxt{Sentinel<I1>}@ S2>
    @\oldtxt{requires EqualityComparable<I1, I2>() \&\& \xname{WeaklyEqualityComparable}<I1, S2> \&\&}@
      @\oldtxt{\xname{WeaklyEqualityComparable}<I2, S1>}@
  bool operator!=(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

  @\oldtxt{template <class I1, class S1, class I2, class S2>}@
    @\oldtxt{requires SizedIteratorRange<I1, I1>() \&\& SizedIteratorRange<I2, I2>() \&\&}@
      @\oldtxt{requires (const I1 i1, const S1 s1, const I2 i2, const S2 s2) \{}@
        @\oldtxt{\{i1-i2\}->DifferenceType<I2>; \{i2-i1\}->DifferenceType<I2>;}@
        @\oldtxt{\{i1-s2\}->DifferenceType<I2>; \{s2-i1\}->DifferenceType<I2>;}@
        @\oldtxt{\{i2-s1\}->DifferenceType<I2>; \{s1-i2\}->DifferenceType<I2>;}@
      @\oldtxt{\}}@
  @\newtxt{template <class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>}@
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I2> operator-(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

  // \ref{default.sentinels} Default sentinels
  class default_sentinel;
  @\oldtxt{constexpr bool operator==(default_sentinel x, default_sentinel y) noexcept;}@
  @\oldtxt{constexpr bool operator!=(default_sentinel x, default_sentinel y) noexcept;}@
  @\oldtxt{constexpr bool operator<(default_sentinel x, default_sentinel y) noexcept;}@
  @\oldtxt{constexpr bool operator<=(default_sentinel x, default_sentinel y) noexcept;}@
  @\oldtxt{constexpr bool operator>(default_sentinel x, default_sentinel y) noexcept;}@
  @\oldtxt{constexpr bool operator>=(default_sentinel x, default_sentinel y) noexcept;}@
  @\oldtxt{constexpr ptrdiff_t operator-(default_sentinel x, default_sentinel y) noexcept;}@

  // \ref{iterators.counted} Counted iterators
  template <@\oldtxt{Weak}@Iterator I> class counted_iterator;

  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator==(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    bool operator==(
      const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& x, default_sentinel@\oldtxt{ y}@);
  @\oldtxt{template <WeakIterator I>}@
    bool operator==(
      default_sentinel@\oldtxt{ x}@, const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& @\oldtxt{y}\newtxt{x}@);
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator!=(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    bool operator!=(
      const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& x, default_sentinel y);
  @\oldtxt{template <WeakIterator I>}@
    bool operator!=(
      default_sentinel x, const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& y);
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator<(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator<=(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<=(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<=(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator>(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator>=(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>=(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>=(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I2> operator-(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I>
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> operator-(
      const counted_iterator<I>& x, default_sentinel y);
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I>
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> operator-(
      default_sentinel x, const counted_iterator<I>& y);
  template <RandomAccessIterator I>
    counted_iterator<I>
      operator+(@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, const counted_iterator<I>& x);
  template <@\oldtxt{Weak}@Iterator I>
    counted_iterator<I> make_counted_iterator(I i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);

  template <@\oldtxt{Weak}@Iterator I>
    void advance(counted_iterator<I>& i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);

  // \ref{unreachable.sentinels} Unreachable sentinels
  @\oldtxt{struct}\newtxt{class}@ unreachable@\oldtxt{\{ \}}@;
  template <Iterator I>
    constexpr bool operator==(const I&, unreachable) noexcept;
  template <Iterator I>
    constexpr bool operator==(unreachable, const I&) noexcept;
  @\oldtxt{constexpr bool operator==(unreachable, unreachable) noexcept;}@
  template <Iterator I>
    constexpr bool operator!=(const I&, unreachable) noexcept;
  template <Iterator I>
    constexpr bool operator!=(unreachable, const I&) noexcept;
  @\oldtxt{constexpr bool operator!=(unreachable, unreachable) noexcept;}@

  // \ref{dangling.wrappers} Dangling wrapper
  template <class T> class dangling;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
  // \ref{iterators.stream}, stream iterators:
  template <class T, class charT = char, class traits = char_traits<charT>,
      class Distance = ptrdiff_t>
  class istream_iterator;
  template <class T, class charT, class traits, class Distance>
    bool operator==(const istream_iterator<T, charT, traits, Distance>& x,
            const istream_iterator<T, charT, traits, Distance>& y);
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator==(default_sentinel x,}@
            @\newtxt{const istream_iterator<T, charT, traits, Distance>\& y);}@
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator==(const istream_iterator<T, charT, traits, Distance>\& x,}@
            @\newtxt{default_sentinel y);}@
  template <class T, class charT, class traits, class Distance>
    bool operator!=(const istream_iterator<T, charT, traits, Distance>& x,
            const istream_iterator<T, charT, traits, Distance>& y);
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator!=(default_sentinel x,}@
            @\newtxt{const istream_iterator<T, charT, traits, Distance>\& y);}@
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator!=(const istream_iterator<T, charT, traits, Distance>\& x,}@
            @\newtxt{default_sentinel y);}@

  template <class T, class charT = char, class traits = char_traits<charT>>
      class ostream_iterator;

  template<class charT, class traits = char_traits<charT> >
    class istreambuf_iterator;
  template <class charT, class traits>
    bool operator==(const istreambuf_iterator<charT, traits>& a,
            const istreambuf_iterator<charT, traits>& b);
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator==(default_sentinel a,}@
            @\newtxt{const istreambuf_iterator<charT, traits>\& b);}@
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator==(const istreambuf_iterator<charT, traits>\& a,}@
            @\newtxt{default_sentinel b);}@
  template <class charT, class traits>
    bool operator!=(const istreambuf_iterator<charT, traits>& a,
            const istreambuf_iterator<charT, traits>& b);
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator!=(default_sentinel a,}@
            @\newtxt{const istreambuf_iterator<charT, traits>\& b);}@
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator!=(const istreambuf_iterator<charT, traits>\& a,}@
            @\newtxt{default_sentinel b);}@

  template <class charT, class traits = char_traits<charT> >
    class ostreambuf_iterator;

  // \ref{iterator.range}, Range access:
  @\removed{template <class C> auto begin(C\& c) -> decltype(c.begin());}@
  @\removed{template <class C> auto begin(const C\& c) -> decltype(c.begin());}@
  @\removed{template <class C> auto end(C\& c) -> decltype(c.end());}@
  @\removed{template <class C> auto end(const C\& c) -> decltype(c.end());}@
  @\removed{template <class T, size_t N> constexpr T* begin(T (\&array)[N]) noexcept;}@
  @\removed{template <class T, size_t N> constexpr T* end(T (\&array)[N]) noexcept;}@
  @\oldtxt{using std::begin;}@
  @\oldtxt{using std::end;}@
  @\oldtxt{template <class>}@
    @\oldtxt{concept bool _Auto = true; // \expos}@
  @\oldoldtxt{template <class C> constexpr auto cbegin(const C\& c) noexcept(noexcept(std::begin(c)))}@
    @\oldoldtxt{-> decltype(std::begin(c));}@
  @\oldoldtxt{template <class C> constexpr auto cend(const C\& c) noexcept(noexcept(std::end(c)))}@
    @\oldoldtxt{-> decltype(std::end(c));}@
  @\oldoldtxt{template <class C> auto rbegin(C\& c) -> decltype(c.rbegin());}@
  @\oldoldtxt{template <class C> auto rbegin(const C\& c) -> decltype(c.rbegin());}@
  @\oldoldtxt{template <class C> auto rend(C\& c) -> decltype(c.rend());}@
  @\oldoldtxt{template <class C> auto rend(const C\& c) -> decltype(c.rend());}@
  @\oldoldtxt{template <class T, size_t N> reverse_iterator<T*> rbegin(T (\&array)[N]);}@
  @\oldoldtxt{template <class T, size_t N> reverse_iterator<T*> rend(T (\&array)[N]);}@
  @\oldoldtxt{template <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il);}@
  @\oldoldtxt{template <class E> reverse_iterator<const E*> rend(initializer_list<E> il);}@
  @\oldoldtxt{template <class C> auto crbegin(const C\& c) -> decltype(std::rbegin(c));}@
  @\oldoldtxt{template <class C> auto crend(const C\& c) -> decltype(std::rend(c));}@
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  @\oldtxt{template <class C> auto size(const C\& c) -> decltype(c.size());}@
  @\oldtxt{template <class T, size_t N> constexpr size_t size(T (\&array)[N]) noexcept;}@
  @\oldtxt{template <class E> size_t size(initializer_list<E> il) noexcept;}@
  @\newtxt{namespace \{}@
    @\newtxt{constexpr \unspec begin = \unspec;}@
    @\newtxt{constexpr \unspec end = \unspec;}@
    @\newtxt{constexpr \unspec cbegin = \unspec;}@
    @\newtxt{constexpr \unspec cend = \unspec;}@
    @\newtxt{constexpr \unspec rbegin = \unspec;}@
    @\newtxt{constexpr \unspec rend = \unspec;}@
    @\newtxt{constexpr \unspec crbegin = \unspec;}@
    @\newtxt{constexpr \unspec crend = \unspec;}@
  @\newtxt{\}}@

  // \ref{range.primitives}, Range primitives:
  @\newtxt{namespace \{}@
    @\newtxt{constexpr \unspec size = \unspec;}@
    @\newtxt{constexpr \unspec empty = \unspec;}@
    @\newtxt{constexpr \unspec data = \unspec;}@
    @\newtxt{constexpr \unspec cdata = \unspec;}@
  @\newtxt{\}}@
  @\oldtxt{Range\{R\}}\newtxt{template <Range R>}@
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<@\oldtxt{IteratorType}\newtxt{iterator_t}@<R>> distance(R&& r);
  @\oldtxt{SizedRange\{R\}}\newtxt{template <SizedRange R>}@
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<@\oldtxt{IteratorType}\newtxt{iterator_t}@<R>> distance(R&& r);
\end{codeblock}
\end{addedblock}
\begin{codeblock}
}@\added{\}\}\newtxt{\}}}@
\end{codeblock}

\begin{addedblock}
\begin{codeblock}
namespace std {
  // \ref{iterator.stdtraits}, iterator traits
  template <experimental::ranges@\oldtxt{_v1}@::@\oldtxt{Weak}@Iterator I>
    struct iterator_traits;
  template <experimental::ranges@\oldtxt{_v1}@::@\oldtxt{Weak}@InputIterator I>
    struct iterator_traits;
  template <experimental::ranges@\oldtxt{_v1}@::InputIterator I>
      @\newtxt{requires Sentinel<I, I>()}@
    struct iterator_traits;

  @\oldtxt{// \ref{counted.traits.specializations} \tcode{common_type} specializations}@
  @\oldtxt{template<experimental::ranges_v1::WeakIterator I>}@
    @\oldtxt{struct common_type<experimental::ranges_v1::counted_iterator<I>,}@
                       @\oldtxt{experimental::ranges_v1::default_sentinel>;}@
  @\oldtxt{template<experimental::ranges_v1::WeakIterator I>}@
    @\oldtxt{struct common_type<experimental::ranges_v1::default_sentinel,}@
                       @\oldtxt{experimental::ranges_v1::counted_iterator<I>>;}@

  @\oldtxt{// \ref{unreachable.traits.specializations} \tcode{common_type} specializations}@
  @\oldtxt{template<experimental::ranges_v1::Iterator I>}@
    @\oldtxt{struct common_type<I, experimental::ranges_v1::unreachable>;}@
  @\oldtxt{template<experimental::ranges_v1::Iterator I>}@
    @\oldtxt{struct common_type<experimental::ranges_v1::unreachable, I>;}@
}
\end{codeblock}

\pnum
Any entities declared or defined in namespace \tcode{std} in header \tcode{<iterator>}
that are not already defined in namespace \tcode{std::experimental::ranges\oldtxt{_v1}} in header
\tcode{<experimental/ranges\oldtxt{_v1}/iterator>} are imported with
\grammarterm{using-declaration}{s}~(\cxxref{namespace.udecl}). \ednote{There are no such
entities, but there may be in the future.}
\end{addedblock}

\rSec1[iterator.primitives]{Iterator primitives}

\pnum
To simplify the task of defining iterators, the library provides
several classes and functions:

\rSec2[iterator.assoc]{Iterator \textcolor{remclr}{traits}\textcolor{addclr}{associated types}}

\pnum
To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
\removed{\tcode{Iterator} is the type of an iterator}
\added{\oldtxt{\tcode{WeaklyIncrementable}}\newtxt{\tcode{WI}} is the name of a type that
satisfies the \tcode{WeaklyIncrementable} concept~(\ref{iterators.weaklyincrementable}),
\oldtxt{\tcode{Readable}}\newtxt{\tcode{R}} is the name of a type that
satisfies the \tcode{Readable} concept~(\ref{iterators.readable}), and
\oldtxt{\tcode{WeakInputIterator}}\newtxt{\tcode{II}} is the name of a type that satisfies the
\tcode{\oldtxt{Weak}InputIterator} concept~(\ref{iterators.input}) concept}, the types

\begin{removedblock}
\begin{codeblock}
iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::iterator_category
\end{codeblock}
\end{removedblock}
\begin{addedblock}
\begin{codeblock}
@\oldtxt{DifferenceType<WeaklyIncrementable>}\newtxt{difference_type_t<WI>}@
@\oldtxt{ValueType<Readable>}\newtxt{value_type_t<R>}@
@\oldtxt{IteratorCategory<WeakInputIterator>}\newtxt{iterator_category_t<II>}@
\end{codeblock}
\end{addedblock}

be defined as the iterator's difference type, value type and iterator category, respectively.
In addition, the type\removed{s}

\begin{addedblock}
\begin{codeblock}
@\tcode{\oldtxt{ReferenceType<Readable>}}\tcode{\newtxt{reference_t<R>}}@
\end{codeblock}

shall be an alias for \tcode{decltype(*declval<\oldtxt{Readable}\newtxt{R\&}>())}.
\end{addedblock}

\begin{removedblock}
\begin{codeblock}
iterator_traits<Iterator>::reference
iterator_traits<Iterator>::pointer
\end{codeblock}

shall be defined as the iterator's reference and pointer types, that is, for an
iterator object \tcode{a}, the same type as the type of \tcode{*a} and \tcode{a->},
respectively. In the case of an output iterator, the types

\begin{codeblock}
iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::reference
iterator_traits<Iterator>::pointer
\end{codeblock}

may be defined as \tcode{void}.

\pnum
The template
\tcode{iterator_traits<Iterator>}
is defined as

\begin{codeblock}
namespace std {
  template<class Iterator> struct iterator_traits {
    typedef typename Iterator::difference_type difference_type;
    typedef typename Iterator::value_type value_type;
    typedef typename Iterator::pointer pointer;
    typedef typename Iterator::reference reference;
    typedef typename Iterator::iterator_category iterator_category;
  };
}
\end{codeblock}

\pnum
It is specialized for pointers as

\begin{codeblock}
namespace std {
  template<class T> struct iterator_traits<T*> {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T& reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
\end{codeblock}

and for pointers to const as

\begin{codeblock}
namespace std {
  template<class T> struct iterator_traits<const T*> {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef const T* pointer;
    typedef const T& reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
\end{codeblock}
\end{removedblock}

\begin{addedblock}
\pnum
\indexlibrary{\idxcode{difference_type_t}}%
\tcode{\oldtxt{DifferenceType<T>}}\tcode{\newtxt{difference_type_t<T>}} is implemented as if:

\indexlibrary{\idxcode{difference_type}}%
\begin{codeblock}
  template <class> struct difference_type { };
  template <class T>
  struct difference_type<T*>
    : enable_if<is_object<T>::value, ptrdiff_t> { };
  @\oldtxt{template <>}@
  @\oldtxt{struct difference_type<nullptr_t> \{}@
    @\oldtxt{using type = ptrdiff_t;}@
  @\oldtxt{\};}@
  template<class I>
    requires is_array<I>::value
  struct difference_type<I> : difference_type<decay_t<I>> { };
  template <class I>
  struct difference_type<I const> : difference_type<decay_t<I>> { };
  @\oldtxt{template <class I>}@
  @\oldtxt{struct difference_type<I volatile> : difference_type<decay_t<I>{}> \{ \};}@
  @\oldtxt{template <class I>}@
  @\oldtxt{struct difference_type<I const volatile> : difference_type<decay_t<I>{}> \{ \};}@
  template <class T>
    requires requires { typename T::difference_type; }
  struct difference_type<T> {
    using type = typename T::difference_type;
  };
  template <class T>
    requires @\oldtxt{is_integral<T>::value}\newtxt{!requires \{ typename T::difference_type; \} \&\&}@
      @\newtxt{requires (const T\& a, const T\& b) \{ \{ a - b \} -> Integral; \}}@
  struct difference_type<T>
    : make_signed< decltype(declval<T>() - declval<T>()) > {
  };
  template <class T>
    using @\oldtxt{DifferenceType}\newtxt{difference_type_t}@ = typename difference_type<T>::type;
\end{codeblock}

\ednote{REVIEW: The \tcode{difference_type} of unsigned \tcode{Integral} types
is not large enough to cover the entire range. The Palo Alto report used
a separate type trait for \tcode{WeaklyIncrementable}: \tcode{DistanceType}.
\tcode{\oldtxt{DifferenceType}}\tcode{\newtxt{difference_type_t}} is only used for
\tcode{RandomAccessIterator}s. Cue discussion about the pros and cons of the two approaches.}

\pnum
Users may specialize \tcode{difference_type} on user-defined types.

\pnum
\indexlibrary{\idxcode{iterator_category_t}}%
\tcode{\oldtxt{IteratorCategory<T>}}\tcode{\newtxt{iterator_category_t<T>}}
is implemented as if:

\indexlibrary{\idxcode{iterator_category}}%
\begin{codeblock}
  template <class> struct iterator_category { };
  template <class T>
  struct iterator_category<T*>
    : enable_if<is_object<T>::value, random_access_iterator_tag> { };
  template <class T>
  struct iterator_category<T const> : iterator_category<T> { };
  @\oldtxt{template <class T>}@
  @\oldtxt{struct iterator_category<T volatile> : iterator_category<T> \{ \};}@
  @\oldtxt{template <class T>}@
  @\oldtxt{struct iterator_category<T const volatile> : iterator_category<T> \{ \};}@
  template <class T>
    requires requires { typename T::iterator_category; }
  struct iterator_category<T> {
    using type = @\seebelow@;
  };
  template <class T>
    using @\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@ = typename iterator_category<T>::type;
\end{codeblock}

\pnum
Users may specialize \tcode{iterator_category} on user-defined types.

\pnum
If \oldtxt{type \tcode{T} has a nested type \tcode{iterator_category}}
\newtxt{\tcode{T::iterator_category} is valid and denotes a type}, then the
type \tcode{iterator_category<T>::type} is computed as follows:
\begin{itemize}
\item If \tcode{T::iterator_category} is the same as or derives from \tcode{std::random_access_iterator_tag},
      \tcode{iterator_category<T>::type} is \tcode{ranges\oldtxt{_v1}::random_access_iterator_tag}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{T::iterator_category} is the same as or derives from \tcode{std::bidirectional_iterator_tag},
      \tcode{iterator_category<T>::type} is \tcode{ranges\oldtxt{_v1}::bidirectional_iterator_tag}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{T::iterator_category} is the same as or derives from \tcode{std::forward_iterator_tag},
      \tcode{iterator_category<T>::type} is \tcode{ranges\oldtxt{_v1}::forward_iterator_tag}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{T::iterator_category} is the same as or derives from \tcode{std::input_iterator_tag},
      \tcode{iterator_category<T>::type} is \tcode{ranges\oldtxt{_v1}::input_iterator_tag}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{T::iterator_category} is the same as or derives from \tcode{std::output_iterator_tag},
      \tcode{iterator_category<T>} has no nested \tcode{type}.
\item Otherwise, \tcode{iterator_category<T>::type} is \tcode{T::iterator_category}
\end{itemize}
\end{addedblock}

\begin{removedblock}
\pnum
\enternote
If there is an additional pointer type
\tcode{\,\xname{far}}
such that the difference of two
\tcode{\,\xname{far}}
is of type
\tcode{long},
an implementation may define

\begin{codeblock}
  template<class T> struct iterator_traits<T @\xname{far}@*> {
    typedef long difference_type;
    typedef T value_type;
    typedef T @\xname{far}@* pointer;
    typedef T @\xname{far}@& reference;
    typedef random_access_iterator_tag iterator_category;
  };
\end{codeblock}
\exitnote
\end{removedblock}

\begin{addedblock}
\pnum
For the sake of backwards compatibility, this \oldtxt{standard}\newtxt{document} specifies the existence of an \tcode{iterator_traits}
alias that collects an iterator's associated types. It is defined as if:

\indexlibrary{\idxcode{iterator_traits}}%
\begin{codeblock}
  template <@\oldtxt{Weak}@InputIterator I> struct @\xname{pointer_type}@ {        @\newtxt{// \expos}@
    using type = add_pointer_t<@\oldtxt{ReferenceType}\newtxt{reference_t}@<I>>;
  };
  template <@\oldtxt{Weak}@InputIterator I>
    requires requires(I i) { { i.operator->() } -> auto&&; }
  struct @\xname{pointer_type}@<I> {                                    @\newtxt{// \expos}@
    using type = decltype(declval<I>().operator->());
  };
  template <class> struct @\xname{iterator_traits}@ { };                @\newtxt{// \expos}@
  template <@\oldtxt{Weak}@Iterator I> struct @\xname{iterator_traits}@<I> {
    using difference_type = @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
    using value_type = void;
    using reference = void;
    using pointer = void;
    using iterator_category = output_iterator_tag;
  };
  template <@\oldtxt{Weak}@InputIterator I> struct @\xname{iterator_traits}@<I> {  @\newtxt{// \expos}@
    using difference_type = @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
    using value_type = @\oldtxt{ValueType}\newtxt{value_type_t}@<I>;
    using reference = @\oldtxt{ReferenceType}\newtxt{reference_t}@<I>;
    using pointer = typename @\xname{pointer_type}@<I>::type;
    using iterator_category = @\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@<I>;
  };
  template <class I>
    using iterator_traits = @\xname{iterator_traits}@<I>;
\end{codeblock}

\pnum
\enternote
\tcode{iterator_traits} is an alias template
\oldtxt{to intentionally break code that tries to specialize it}
\newtxt{to prevent user code from specializing it}.
\exitnote

\end{addedblock}

\pnum
\enterexample
To implement a generic
\tcode{reverse}
function, a \Cpp program can do the following:

\begin{codeblock}
template <@\removed{class }@BidirectionalIterator@\added{ I}@>
void reverse(@\changed{BidirectionalIterator}{I}@ first, @\changed{BidirectionalIterator}{I}@ last) {
  @\removed{typename iterator_traits<BidirectionalIterator>::difference_type}\oldtxt{DifferenceType<I>}\newtxt{difference_type_t<I>}@ n =
    distance(first, last);
  --n;
  while(n > 0) {
    @\removed{typename iterator_traits<BidirectionalIterator>::value_type}\oldtxt{ValueType<I>}\newtxt{value_type_t<I>}@
      tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
\end{codeblock}
\exitexample

{\color{addclr}
\rSec2[iterator.stdtraits]{Standard iterator traits}

\pnum
To facilitate interoperability between new code using iterators conforming to this document
and older code using iterators \oldtxt{conforming to}\newtxt{that conform to the iterator
requirements specified in} ISO/IEC 14882, three specializations of \tcode{std::iterator_traits}
are provided to map the newer iterator categories \newtxt{and associated types} to the older ones.

\begin{codeblock}
namespace std {
  template <experimental::ranges@\oldtxt{_v1}@::@\oldtxt{Weak}@Iterator Out>
  struct iterator_traits<Out> {
    using difference_type   = experimental::ranges@\oldtxt{_v1}@::@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<Out>;
    using value_type        = @\seebelow@;
    using reference         = @\seebelow@;
    using pointer           = @\seebelow@;
    using iterator_category = std::output_iterator_tag;
  };
\end{codeblock}

\pnum
The nested type \tcode{value_type} is computed as follows:
\begin{itemize}
\item If \oldtxt{type \tcode{Out} has a nested type \tcode{value_type}}
      \newtxt{\tcode{Out::value_type} is valid and denotes a type}, then
      \tcode{std::iterator_traits<Out>::value_type} is \tcode{Out::value_type}.
\item Otherwise, \tcode{std::iterator_traits<Out>::value_type} is \tcode{void}.
\end{itemize}

\pnum
The nested type \tcode{reference} is computed as follows:
\begin{itemize}
\item If \oldtxt{type \tcode{Out} has a nested type \tcode{reference}}
      \newtxt{\tcode{Out::reference} is valid and denotes a type}, then
      \tcode{std::iterator_traits<Out>::reference} is \tcode{Out::\brk{}reference}.
\item Otherwise, \tcode{std::iterator_traits<Out>::reference} is \tcode{void}.
\end{itemize}

\pnum
The nested type \tcode{pointer} is computed as follows:
\begin{itemize}
\item If \oldtxt{type \tcode{Out} has a nested type \tcode{pointer}}
      \newtxt{\tcode{Out::pointer} is valid and denotes a type}, then
      \tcode{std::iterator_traits<Out>::pointer} is \tcode{Out::pointer}.
\item Otherwise, \tcode{std::iterator_traits<Out>::pointer} is \tcode{void}.
\end{itemize}

\begin{codeblock}
  template <experimental::ranges@\oldtxt{_v1}@::@\oldtxt{Weak}@InputIterator @\oldtxt{Weak}@In>
  struct iterator_traits<@\oldtxt{Weak}@In> { };

  template <experimental::ranges@\oldtxt{_v1}@::InputIterator In>
    @\newtxt{requires Sentinel<In, In>()}@
  struct iterator_traits<In> {
    using difference_type   = experimental::ranges@\oldtxt{_v1}@::@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<In>;
    using value_type        = experimental::ranges@\oldtxt{_v1}@::@\oldtxt{ValueType}\newtxt{value_type_t}@<In>;
    using reference         = @\seebelow@;
    using pointer           = @\seebelow@;
    using iterator_category = @\seebelow@;
  };
}
\end{codeblock}

\pnum
The nested type \tcode{reference} is computed as follows:
\begin{itemize}
\item If \oldtxt{type \tcode{In} has a nested type \tcode{reference}}
      \newtxt{\tcode{In::reference} is valid and denotes a type}, then
      \tcode{std::iterator_traits<In>::reference} is \tcode{In::reference}.
\item Otherwise, \tcode{std::iterator_traits<In>::reference} is
      \tcode{experimental::\-ranges\oldtxt{_v1}::\-\oldtxt{ReferenceType}\-\newtxt{reference_t}<In>}.
\end{itemize}

\pnum
The nested type \tcode{pointer} is computed as follows:
\begin{itemize}
\item If \oldtxt{type \tcode{In} has a nested type \tcode{pointer}}
      \newtxt{\tcode{In::pointer} is valid and denotes a type}, then
      \tcode{std::iterator_traits<In>::pointer} is \tcode{In::pointer}.
\item Otherwise, \tcode{std::iterator_traits<In>::pointer} is
      \tcode{experimental::ranges\oldtxt{_v1}::\brk{}iterator_traits<In>::\brk{}pointer}.
\end{itemize}

\pnum
Let type \tcode{C} be \tcode{experimental::ranges\oldtxt{_v1}::}\tcode{\oldtxt{IteratorCategory}}\tcode{\newtxt{iterator_category_t}}\tcode{<In>}.
The nested type \tcode{std::\brk{}iterator_traits<In>::\brk{}iterator_category} is computed as
follows:
\begin{itemize}
\item If \tcode{C} is the same as or inherits from \tcode{std::input_iterator_tag} or
      \tcode{std::output_iterator_tag}, \tcode{std::\brk{}iterator_traits<In>::\brk{}iterator_category}
      is \tcode{C}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{experimental::ranges\oldtxt{_v1}::\oldtxt{ReferenceType}\newtxt{reference_t}<In>} is not a reference type,
      \tcode{std::\brk{}iterator_traits<In>::\brk{}iterator_category} is \tcode{std::input_iterator_tag}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{C} is the same as or inherits from \tcode{experimental::\brk{}ranges\oldtxt{_v1}::\brk{}random_access_iterator_tag},
      \tcode{std::\brk{}iterator_traits<In>::\brk{}iterator_category} is \tcode{std::random_access_iterator_tag}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{C} is the same as or inherits from \tcode{experimental::\brk{}ranges\oldtxt{_v1}::\brk{}bidirectional_iterator_tag},
      \tcode{std::\brk{}iterator_traits<In>::\brk{}iterator_category} is \tcode{std::bidirectional_iterator_tag}.
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{C} is the same as or inherits from \tcode{experimental::\brk{}ranges\oldtxt{_v1}::\brk{}forward_iterator_tag},
      \tcode{std::\brk{}iterator_traits<In>::\brk{}iterator_category} is \tcode{std::forward_iterator_tag}.
\item Otherwise, \tcode{std::iterator_traits<In>::iterator_category} is \tcode{std::input_iterator_tag}.
\end{itemize}
} %% color{addclr}

{\color{newclr}
\pnum
\enternote Some implementations may find it necessary to add additional constraints to
these partial specializations to prevent them from being considered for types that
conform to the iterator requirements specified in ISO/IEC 14882.\exitnote
}

{\color{oldoldclr}
\rSec2[iterator.basic]{Basic iterator}

\pnum
The
\tcode{iterator}
template may be used as a base class to ease the definition of required types
for new iterators.

\begin{codeblock}
namespace std {
  template<class Category, class T, class Distance = ptrdiff_t,
    class Pointer = T*, class Reference = T&>
  struct iterator {
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
  };
}
\end{codeblock}
} %% color{oldoldclr}

\rSec2[std.iterator.tags]{Standard iterator tags}

\pnum
\indexlibrary{\idxcode{output_iterator_tag}}%
\indexlibrary{\idxcode{input_iterator_tag}}%
\indexlibrary{\idxcode{forward_iterator_tag}}%
\indexlibrary{\idxcode{bidirectional_iterator_tag}}%
\indexlibrary{\idxcode{random_access_iterator_tag}}%
It is often desirable for a
function template specialization
to find out what is the most specific category of its iterator
argument, so that the function can select the most efficient algorithm at compile time.
To facilitate this, the
library introduces
\techterm{category tag}
classes which \changed{are}{can be} used as compile time tags for algorithm selection.
\added{\enternote The preferred way to dispatch to more specialized algorithm implementations is
with concept-based overloading.\exitnote}
\changed{They}{The category tags} are:
\tcode{\oldtxt{weak_input_iterator_tag}},
\tcode{input_iterator_tag},
\tcode{output_iterator_tag},
\tcode{forward_iterator_tag},
\tcode{bidirectional_iterator_tag}
and
\tcode{random_access_iterator_tag}.
For every \oldtxt{weak }\added{input }iterator of type
\tcode{I\oldoldtxt{terator}},
\tcode{\removed{iterator_traits<Iterator>::it\-er\-a\-tor_ca\-te\-go\-ry}
\oldtxt{It\-er\-a\-tor\-Ca\-te\-go\-ry<Iterator>}\newtxt{it\-er\-a\-tor_\-ca\-te\-go\-ry_t<I>}}
shall be defined to be the most specific category tag that describes the
iterator's behavior.

\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  struct output_iterator_tag { };
  @\oldtxt{struct weak_input_iterator_tag \{ \};}@
  struct input_iterator_tag@\oldtxt{ : public weak_input_iterator_tag}@ { };
  struct forward_iterator_tag : @\oldoldtxt{public}@ input_iterator_tag { };
  struct bidirectional_iterator_tag : @\oldoldtxt{public}@ forward_iterator_tag { };
  struct random_access_iterator_tag : @\oldoldtxt{public}@ bidirectional_iterator_tag { };
}@\added{\}\}\newtxt{\}}}@
\end{codeblock}

\begin{addedblock}
\pnum
\enternote
The \tcode{output_iterator_tag} is provided for the sake of backward compatibility.
\exitnote
\end{addedblock}

\pnum
\indexlibrary{\idxcode{empty}}%
\indexlibrary{\idxcode{input_iterator_tag}}%
\indexlibrary{\idxcode{output_iterator_tag}}%
\indexlibrary{\idxcode{forward_iterator_tag}}%
\indexlibrary{\idxcode{bidirectional_iterator_tag}}%
\indexlibrary{\idxcode{random_access_iterator_tag}}%
\enterexample
For a program-defined iterator
\tcode{BinaryTreeIterator},
it could be included
into the bidirectional iterator category by specializing the
\tcode{\removed{iterator_traits}}\tcode{\added{difference_type}}\added{, }\tcode{\added{value_type}}\added{, and }
\tcode{\added{iterator_category}} template\added{s}:

\begin{removedblock}
\begin{codeblock}
template<class T> struct iterator_traits<BinaryTreeIterator<T> > {
  typedef std::ptrdiff_t difference_type;
  typedef T value_type;
  typedef T* pointer;
  typedef T& reference;
  typedef bidirectional_iterator_tag iterator_category;
};
\end{codeblock}
\end{removedblock}
\begin{addedblock}
\begin{codeblock}
template<class T> struct difference_type<BinaryTreeIterator<T>> {
  using type = std::ptrdiff_t;
};
template<class T> struct value_type<BinaryTreeIterator<T>> {
  using type = T;
};
template<class T> struct iterator_category<BinaryTreeIterator<T>> {
  using type = bidirectional_iterator_tag;
};
\end{codeblock}
\end{addedblock}

\oldoldtxt{Typically, however, it would be easier to derive
\tcode{BinaryTreeIterator<T>}
from}
\tcode{\oldoldtxt{iterator<bidirectional_iterator_tag, T, ptrdiff_t, T*, T\&>}}
\oldoldtxt{.}
\exitexample

{\color{oldoldclr}
\pnum
\enterexample
If
\tcode{evolve()}
is well defined for bidirectional iterators, but can be implemented more
efficiently for random access iterators, then the implementation is as
follows:

\begin{codeblock}
template <class BidirectionalIterator>
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {
  evolve(first, last,
    typename iterator_traits<BidirectionalIterator>::iterator_category());
}

template <class BidirectionalIterator>
void evolve(BidirectionalIterator first, BidirectionalIterator last,
  bidirectional_iterator_tag) {
  // more generic, but less efficient algorithm
}

template <class RandomAccessIterator>
void evolve(RandomAccessIterator first, RandomAccessIterator last,
  random_access_iterator_tag) {
  // more efficient, but less generic algorithm
}
\end{codeblock}
\exitexample

\pnum
\enterexample
If a \Cpp program wants to define a bidirectional iterator for some data structure containing
\tcode{double}
and such that it
works on a large memory model of the implementation, it can do so with:

\begin{codeblock}
class MyIterator :
  public iterator<bidirectional_iterator_tag, double, long, T*, T&> {
  // code implementing \tcode{++}, etc.
};
\end{codeblock}

\pnum
Then there is no need to specialize the
\tcode{iterator_traits} template.
\exitexample
} %%\color{oldoldclr}

\rSec2[iterator.operations]{Iterator operations}

\pnum
Since only \changed{random access iterators}{types that satisfy
\tcode{RandomAccessIterator}} provide \added{the }\tcode{+} \changed{and}{operator, and
types that satisfy \tcode{Sized\oldtxt{IteratorRange}\newtxt{Sentinel}} provide the} \tcode{-}
operator\removed{s}, the library provides \oldoldtxt{two}\newnewtxt{four} function templates
\tcode{advance}\newnewtxt{,}
\oldtxt{and}
\tcode{distance}\newnewtxt{, \tcode{next}, and \tcode{prev}}.
These
function templates
use
\tcode{+}
and
\tcode{-}
for random access iterators\added{ and\oldtxt{ sized iterator ranges} \newtxt{ranges that satisfy \tcode{SizedSentinel}}, respectively} (and are, therefore, constant
time for them); for \newnewtxt{output, }\oldtxt{weak input, }input, forward and bidirectional iterators they use
\tcode{++}
to provide linear time
implementations.

\indexlibrary{\idxcode{advance}}%
\begin{removedblock}
\begin{itemdecl}
template <class InputIterator, class Distance>
  void advance(InputIterator& i, Distance n);
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
\begin{itemdecl}
template <@\oldtxt{Weak}@Iterator I>
  void advance(I& i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\tcode{n}
shall be negative only for bidirectional\oldoldtxt{ and random access} iterators.

\pnum
\effects
\newnewtxt{For random access iterators, equivalent to \tcode{i += n}.
Otherwise, i}\oldoldtxt{I}ncrements (or decrements for negative
\tcode{n})
iterator\oldoldtxt{ reference}
\tcode{i}
by
\tcode{n}.
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  void advance(I& i, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\oldtxt{\tcode{bound} shall be reachable from \tcode{i}.}\newtxt{If
\tcode{Assignable<I\&, S\&\&>()} is not satisfied, \range{i}{bound}
shall denote a range.}

\pnum
\effects
\begin{itemize}
\item If \oldtxt{\tcode{I} and \tcode{S} are the same type, this function
      is constant time}\newtxt{\tcode{Assignable<I\&, S\&\&>()} is satisfied,
      equivalent to \tcode{i = std::move(bound)}}.

\item \oldtxt{If \tcode{SizedIteratorRange<I, S>()}}\newtxt{Otherwise, if
      \tcode{SizedSentinel<S, I>()}} is satisfied, \oldtxt{this function
      shall dispatch}\newtxt{equivalent} to \tcode{advance(i, bound - i)}.

\item Otherwise, increments \tcode{i} until \tcode{i == bound}.
\end{itemize}
\end{itemdescr}

\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> advance(I& i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\oldtxt{\tcode{n} shall be negative only for bidirectional and random access iterators. If \tcode{n}
is negative, \tcode{i} shall be reachable from \tcode{bound}; otherwise, \tcode{bound} shall be
reachable from \tcode{i}.}\newtxt{If \tcode{n > 0}, \range{i}{bound} shall denote a range. If
\tcode{n == 0}, \range{i}{bound} or \range{bound}{i} shall denote a range. If \tcode{n < 0},
\range{bound}{i} shall denote a range and \tcode{(BidirectionalIterator<I>() \&\& Same<I, S>())}
shall be satisfied.}

\pnum
\effects
\begin{itemize}
\item If \tcode{\oldtxt{SizedIteratorRange<I, S>}\newtxt{SizedSentinel<S, I>}()} is satisfied:
      \begin{itemize}
      \item If \oldtxt{\tcode{(0 <= n ? n >= $D$ : n <= $D$)} is \tcode{true}, where $D$ is \tcode{bound - i}, this
            function dispatches}\brk{}\newtxt{$|\tcode{n}| >= |\tcode{bound - i}|$, equivalent} to \tcode{advance(i, bound)}\oldtxt{,}\newtxt{.}

      \item Otherwise, \oldtxt{this function dispatches}\newtxt{equivalent} to \tcode{advance(i, n)}.
      \end{itemize}

\item \newtxt{Otherwise, i}\oldtxt{I}ncrements (or decrements for negative \tcode{n})
      iterator\oldtxt{ reference} \tcode{i} either \tcode{n} times or until \tcode{i == bound},
      whichever comes first.
\end{itemize}

\pnum
\returns
\tcode{n - $M$}, where $M$ is the distance from the starting position of
\tcode{i} to the ending position.
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{distance}}%
\begin{removedblock}
\begin{itemdecl}
  template<class InputIterator>
      typename iterator_traits<InputIterator>::difference_type
         distance(InputIterator first, InputIterator last);
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> distance(I first, S last);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\newnewtxt{\requires
\range{first}{last} shall denote a range, or \tcode{(Same<S, I>() \&\& SizedSentinel<S, I>())} shall be
satisfied and \range{last}{first} shall denote a range.}

\pnum
\effects
If \removed{\tcode{InputIterator} meets the requirements of random access iterator}
\oldtxt{\tcode{SizedIteratorRange<I, S>()}}\brk{}\added{\tcode{\newtxt{SizedSentinel<S, I>}()} is satisfied}, returns \tcode{(last - first)}; otherwise,
returns the number of increments needed to get from
\tcode{first}
to
\tcode{last}.

\pnum
\oldoldtxt{\requires
If }\removed{\tcode{InputIterator} meets the requirements of random access iterator}\oldtxt{
\tcode{SizedIteratorRange<I, S>()} is satisfied}\oldoldtxt{ \tcode{last} shall be reachable from
\tcode{first} or \tcode{first} shall be reachable from \tcode{last}; otherwise,
\tcode{last}
shall be reachable from
\tcode{first}.}
\end{itemdescr}

\indexlibrary{\idxcode{next}}%
\begin{removedblock}
\begin{itemdecl}
template <class ForwardIterator>
  ForwardIterator next(ForwardIterator x,
    typename std::iterator_traits<ForwardIterator>::difference_type n = 1);
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
\begin{itemdecl}
template <@\oldtxt{Weak}@Iterator I>
  I next(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n = 1);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{advance(x, n); return x;}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  I next(I x, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{advance(x, bound); return x;}
\end{itemdescr}

\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  I next(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{advance(x, n, bound); return x;}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{prev}}%
\begin{removedblock}
\begin{itemdecl}
template <class BidirectionalIterator>
  BidirectionalIterator prev(BidirectionalIterator x,
    typename std::iterator_traits<BidirectionalIterator>::difference_type n = 1);
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
\begin{itemdecl}
template <BidirectionalIterator I>
  I prev(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n = 1);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{advance(x, -n); return x;}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
template <BidirectionalIterator I>
  I prev(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, I bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{advance(x, -n, bound); return x;}
\end{itemdescr}
\end{addedblock}

\rSec1[iterators.predef]{Iterator adaptors}

\rSec2[iterators.reverse]{Reverse iterators}

\pnum
Class template \tcode{reverse_iterator} is an iterator adaptor that iterates from the end of the sequence defined by its underlying iterator to the beginning of that sequence.
The fundamental relation between a reverse iterator and its corresponding iterator
\tcode{i}
is established by the identity:
\tcode{\&*(reverse_iterator(i)) == \&*(i - 1)}.

\rSec3[reverse.iterator]{Class template \tcode{reverse_iterator}}

\indexlibrary{\idxcode{reverse_iterator}}%
\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  template <@\changed{class Iterator}{BidirectionalIterator I}@>
  class reverse_iterator @\changed{: public}{\{}@
\end{codeblock}\begin{removedblock}\begin{codeblock}
        iterator<typename iterator_traits<Iterator>::iterator_category,
        typename iterator_traits<Iterator>::value_type,
        typename iterator_traits<Iterator>::difference_type,
        typename iterator_traits<Iterator>::pointer,
        typename iterator_traits<Iterator>::reference> {
\end{codeblock}\end{removedblock}\begin{codeblock}
  public:
\end{codeblock}\begin{removedblock}\begin{codeblock}
    typedef Iterator                                            iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type difference_type;
    typedef typename iterator_traits<Iterator>::reference       reference;
    typedef typename iterator_traits<Iterator>::pointer         pointer;
\end{codeblock}\end{removedblock}\begin{addedblock}\begin{codeblock}
    using iterator_type = I;
    using difference_type = @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
    using value_type = @\oldtxt{ValueType}\newtxt{value_type_t}@<I>;
    using iterator_category = @\oldtxt{IteratorCategory}\newtxt{iterator_category_t}@<I>;
    using reference = @\oldtxt{ReferenceType}\newtxt{reference_t}@<I>;
    using pointer = I;
\end{codeblock}\end{addedblock}\begin{codeblock}
    reverse_iterator();
    explicit reverse_iterator(@\changed{Iterator}{I}@ x);
    @\oldoldtxt{template <class U>}@
      @\oldtxt{requires ConvertibleTo<U, I>()}@
    reverse_iterator(const reverse_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);
    @\oldoldtxt{template <class U>}@
      @\oldtxt{requires ConvertibleTo<U, I>()}@
    reverse_iterator& operator=(const reverse_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);

    @\changed{Iterator}{I}@ base() const;      @\oldoldtxt{// explicit}@
    reference operator*() const;
    pointer operator->() const;

    reverse_iterator& operator++();
    reverse_iterator  operator++(int);
    reverse_iterator& operator--();
    reverse_iterator  operator--(int);

    reverse_iterator  operator+ (difference_type n) const@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    reverse_iterator& operator+=(difference_type n)@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    reverse_iterator  operator- (difference_type n) const@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    reverse_iterator& operator-=(difference_type n)@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    @\oldoldtxt{\unspec}\newnewtxt{reference}@ operator[](difference_type n) const@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
  @\oldoldtxt{protected}\newnewtxt{private}@:
    @\changed{Iterator}{I}@ current; @\newnewtxt{// \expos}@
  };

  template <class @\removed{Iterator1}\oldtxt{BidirectionalIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{BidirectionalIterator }\added{I2}@>
      @\added{requires EqualityComparable<I1, I2>()}@
    bool operator==(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  @\newnewtxt{template <class I1, class I2>}@
      @\newnewtxt{requires EqualityComparable<I1, I2>()}@
    @\newnewtxt{bool operator!=(}@
      @\newnewtxt{const reverse_iterator<I1>\& x,}@
      @\newnewtxt{const reverse_iterator<I2>\& y);}@
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  @\oldoldtxt{template <class Iterator1, class Iterator2>}@
      @\oldtxt{requires EqualityComparable<I1, I2>()}@
    @\oldoldtxt{bool operator!=(}@
      @\oldoldtxt{const reverse_iterator<Iterator1>\& x,}@
      @\oldoldtxt{const reverse_iterator<Iterator2>\& y);}@
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>=(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<=(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{BidirectionalIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{BidirectionalIterator }\added{I2}@>
      @\added{requires \oldtxt{SizedIteratorRange<I2, I1>}\newtxt{SizedSentinel<I1, I2>}()}@
    @\removed{auto}\oldtxt{DifferenceType<I2>}\newnewtxt{difference_type_t<I2>}@ operator-(
      const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
      const reverse_iterator<@\changed{Iterator2}{I2}@>& y)@\removed{ ->decltype(y.base() - x.base())}@;
  template <@\changed{class Iterator}{RandomAccessIterator I}@>
    reverse_iterator<@\changed{Iterator}{I}@>
      operator+(
    @\removed{typename reverse_iterator<Iterator>::difference_type}\oldtxt{DifferenceType<I>}\newnewtxt{difference_type_t<I>}@ n,
    const reverse_iterator<@\changed{Iterator}{I}@>& x);

  template <@\changed{class Iterator}{BidirectionalIterator I}@>
    reverse_iterator<@\changed{Iterator}{I}@> make_reverse_iterator(@\changed{Iterator}{I}@ i);
}@\added{\}\}\newtxt{\}}}@
\end{codeblock}

\begin{removedblock}
\rSec3[reverse.iter.requirements]{\tcode{reverse_iterator} requirements}

\pnum
The template parameter
\tcode{Iterator}
shall meet all the requirements of a Bidirectional Iterator~(\ref{iterators.bidirectional}).

\pnum
Additionally,
\tcode{Iterator}
shall meet the requirements of a Random Access Iterator~(\ref{iterators.random.access})
if any of the members
\tcode{operator+}~(\ref{reverse.iter.op+}),
\tcode{operator-}~(\ref{reverse.iter.op-}),
\tcode{operator+=}~(\ref{reverse.iter.op+=}),
\tcode{operator-=}~(\ref{reverse.iter.op-=}),
\tcode{operator\,[]}~(\ref{reverse.iter.opindex}),
or the global operators
\tcode{operator<}~(\ref{reverse.iter.op<}),
\tcode{operator>}~(\ref{reverse.iter.op>}),\\
\tcode{operator\,<=}~(\ref{reverse.iter.op<=}),
\tcode{operator>=}~(\ref{reverse.iter.op>=}),
\tcode{operator-}~(\ref{reverse.iter.opdiff})
or
\tcode{operator+}~(\ref{reverse.iter.opsum})
are referenced in a way that requires instantiation~(\cxxref{temp.inst}).
\end{removedblock}

\rSec3[reverse.iter.ops]{\tcode{reverse_iterator} operations}

\rSec4[reverse.iter.cons]{\tcode{reverse_iterator} constructor}

\indexlibrary{\idxcode{reverse_iterator}!\tcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Value initializes
\tcode{current}.
Iterator operations applied to the resulting iterator have defined behavior
if and only if the corresponding operations are defined on a
value-initialized iterator of type
\tcode{\changed{Iterator}{I}}.
\end{itemdescr}

\indexlibrary{\idxcode{reverse_iterator}!constructor}%

\begin{itemdecl}
explicit reverse_iterator(@\changed{Iterator}{I}@ x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes
\tcode{current}
with \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{reverse_iterator}!constructor}%

\begin{itemdecl}
@\oldoldtxt{template <class U>}@
  @\oldtxt{requires ConvertibleTo<U, I>()}@
reverse_iterator(const reverse_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes
\tcode{current}
with
\tcode{\oldoldtxt{u}\newnewtxt{i}.current}.
\end{itemdescr}

\rSec4[reverse.iter.op=]{\tcode{reverse_iterator::operator=}}

\indexlibrary{\idxcode{operator=}!\tcode{reverse_iterator}}%
\begin{itemdecl}
@\oldoldtxt{template <class U>}@
  @\oldtxt{requires ConvertibleTo<U, I>()}@
reverse_iterator&
  operator=(const reverse_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Assigns \tcode{\oldoldtxt{u.base()}\newnewtxt{i.current}} to \tcode{current}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[reverse.iter.conv]{Conversion}

\indexlibrary{\idxcode{base}!\idxcode{reverse_iterator}}%
\indexlibrary{\idxcode{reverse_iterator}!\idxcode{base}}%
\begin{itemdecl}
@\changed{Iterator}{I}@ base() const;          @\oldoldtxt{// explicit}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{current}.
\end{itemdescr}

\rSec4[reverse.iter.op.star]{\tcode{operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
reference operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to \tcode{*prev(current)}}
\begin{codeblock}
@\oldoldtxt{Iterator tmp = current;}@
@\oldoldtxt{return *--tmp;}@
\end{codeblock}

\end{itemdescr}

\rSec4[reverse.iter.opref]{\tcode{operator->}}

\indexlibrary{\idxcode{operator->}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to}
\changed{\tcode{std::addressof(operator*())}}{\tcode{prev(current)}}.
\end{itemdescr}

\rSec4[reverse.iter.op++]{\tcode{operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{\dcr current;}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{reverse_iterator}}%
\indexlibrary{\idxcode{reverse_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
reverse_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
reverse_iterator tmp = *this;
--current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[reverse.iter.op\dcr]{\tcode{operator\dcr}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator& operator--();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{++current}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{reverse_iterator}}%
\indexlibrary{\idxcode{reverse_iterator}!\idxcode{operator\dcr}}%
\begin{itemdecl}
reverse_iterator operator--(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{codeblock}
reverse_iterator tmp = *this;
++current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[reverse.iter.op+]{\tcode{operator+}}

\indexlibrary{\idxcode{operator+}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator
  operator+(@\oldoldtxt{typename reverse_iterator<Iterator>::}@difference_type n) const@\removed{;}@
    @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{reverse_iterator(current-n)}.
\end{itemdescr}

\rSec4[reverse.iter.op+=]{\tcode{operator+=}}

\indexlibrary{\idxcode{operator+=}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator&
  operator+=(@\oldoldtxt{typename reverse_iterator<Iterator>::}@difference_type n)@\removed{;}@
    @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{current -= n;}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[reverse.iter.op-]{\tcode{operator-}}

\indexlibrary{\idxcode{operator-}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator
  operator-(@\oldoldtxt{typename reverse_iterator<Iterator>::}@difference_type n) const@\removed{;}@
    @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{reverse_iterator(current+n)}.
\end{itemdescr}

\rSec4[reverse.iter.op-=]{\tcode{operator-=}}

\indexlibrary{\idxcode{operator-=}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
reverse_iterator&
  operator-=(@\oldoldtxt{typename reverse_iterator<Iterator>::}@difference_type n)@\removed{;}@
    @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\tcode{current += n;}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[reverse.iter.opindex]{\tcode{operator[]}}

\indexlibrary{\idxcode{operator[]}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
@\oldoldtxt{\unspec}\newnewtxt{reference}@ operator[](
  @\oldoldtxt{typename reverse_iterator<Iterator>::}@difference_type n) const@\removed{;}@
    @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{current[-n-1]}.
\end{itemdescr}

\rSec4[reverse.iter.op==]{\tcode{operator==}}

\indexlibrary{\idxcode{operator==}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{BidirectionalIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{BidirectionalIterator }\added{I2}@>
    @\added{requires EqualityComparable<I1, I2>()}@
  bool operator==(
    const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
    const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.current == y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op!=]{\tcode{operator!=}}

\indexlibrary{\idxcode{operator"!=}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{BidirectionalIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{BidirectionalIterator }\added{I2}@>
    @\added{requires EqualityComparable<I1, I2>()}@
  bool operator!=(
    const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
    const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.current != y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op<]{\tcode{operator<}}

\indexlibrary{\idxcode{operator<}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator<(
    const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
    const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.current > y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op>]{\tcode{operator>}}

\indexlibrary{\idxcode{operator>}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator>(
    const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
    const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.current < y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op>=]{\tcode{operator>=}}

\indexlibrary{\idxcode{operator>=}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator>=(
    const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
    const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.current <= y.current}.
\end{itemdescr}

\rSec4[reverse.iter.op<=]{\tcode{operator<=}}

\indexlibrary{\idxcode{operator<=}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator<=(
    const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
    const reverse_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.current >= y.current}.
\end{itemdescr}

\rSec4[reverse.iter.opdiff]{\tcode{operator-}}

\indexlibrary{\idxcode{operator-}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{BidirectionalIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{BidirectionalIterator }\added{I2}@>
    @\added{requires \oldtxt{SizedIteratorRange<I2, I1>}\newtxt{SizedSentinel<I1, I2>}()}@
  @\removed{auto}\oldtxt{DifferenceType<I2>}\newnewtxt{difference_type_t<I2>}@ operator-(
    const reverse_iterator<@\changed{Iterator1}{I1}@>& x,
    const reverse_iterator<@\changed{Iterator2}{I2}@>& y)@\removed{ ->decltype(y.base() - x.base())}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{y.current - x.current}.
\end{itemdescr}

\rSec4[reverse.iter.opsum]{\tcode{operator+}}

\indexlibrary{\idxcode{operator+}!\idxcode{reverse_iterator}}%
\begin{itemdecl}
template <@\changed{class Iterator}{RandomAccessIterator I}@>
  reverse_iterator<@\changed{Iterator}{I}@>
    operator+(
  @\removed{typename reverse_iterator<Iterator>::difference_type}\oldtxt{DifferenceType<I>}\newtxt{difference_type_t<I>}@ n,
  const reverse_iterator<@\changed{Iterator}{I}@>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{reverse_iterator<\changed{Iterator}{I}>(x.current - n)}.
\end{itemdescr}

\rSec4[reverse.iter.make]{Non-member function \tcode{make_reverse_iterator()}}

\indexlibrary{\idxcode{reverse_iterator}!\idxcode{make_reverse_iterator}~non-member~function}
\indexlibrary{\idxcode{make_reverse_iterator}}%
\begin{itemdecl}
template <@\changed{class Iterator}{BidirectionalIterator I}@>
  reverse_iterator<@\changed{Iterator}{I}@> make_reverse_iterator(@\changed{Iterator}{I}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{reverse_iterator<\changed{Iterator}{I}>(i)}.
\end{itemdescr}

\rSec2[iterators.insert]{Insert iterators}

\pnum
To make it possible to deal with insertion in the same way as writing into an array, a special kind of iterator
adaptors, called
\techterm{insert iterators},
are provided in the library.
With regular iterator classes,

\begin{codeblock}
while (first != last) *result++ = *first++;
\end{codeblock}

causes a range \range{first}{last}
to be copied into a range starting with result.
The same code with
\tcode{result}
being an insert iterator will insert corresponding elements into the container.
This device allows all of the
copying algorithms in the library to work in the
\techterm{insert mode}
instead of the \techterm{regular overwrite} mode.

\pnum
An insert iterator is constructed from a container and possibly one of its iterators pointing to where
insertion takes place if it is neither at the beginning nor at the end of the container.
Insert iterators satisfy \oldoldtxt{the requirements of output iterators}\newnewtxt{\tcode{OutputIterator}}.
\tcode{operator*}
returns the insert iterator itself.
The assignment
\tcode{operator=(const T\& x)}
is defined on insert iterators to allow writing into them, it inserts
\tcode{x}
right before where the insert iterator is pointing.
In other words, an insert iterator is like a cursor pointing into the
container where the insertion takes place.
\tcode{back_insert_iterator}
inserts elements at the end of a container,
\tcode{front_insert_iterator}
inserts elements at the beginning of a container, and
\tcode{insert_iterator}
inserts elements where the iterator points to in a container.
\tcode{back_inserter},
\tcode{front_inserter},
and
\tcode{inserter}
are three
functions making the insert iterators out of a container.

\rSec3[back.insert.iterator]{Class template \tcode{back_insert_iterator}}

\indexlibrary{\idxcode{back_insert_iterator}}%
\ednote{REVIEW: Re-specify this in terms of a Container concept? Or Range? Or leave it?}
\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  template <class Container>
  class back_insert_iterator @\changed{:}{\{}@
    @\removed{public iterator<output_iterator_tag, void, void, void, void> \{}@
  @\oldoldtxt{protected}\newtxt{private}@:
    Container* container; @\newtxt{// \expos}@

  public:
    @\changed{typedef Container}{using}@ container_type@\added{ = Container}@;
    @\added{using difference_type = ptrdiff_t;}@
    @\oldtxt{using iterator_category = output_iterator_tag;}@
    @\added{\newnewtxt{constexpr} back_insert_iterator();}@
    explicit back_insert_iterator(Container& x);
    back_insert_iterator@\oldoldtxt{<Container>}@&
      operator=(const typename Container::value_type& value);
    back_insert_iterator@\oldoldtxt{<Container>}@&
      operator=(typename Container::value_type&& value);

    back_insert_iterator@\oldoldtxt{<Container>}@& operator*();
    back_insert_iterator@\oldoldtxt{<Container>}@& operator++();
    back_insert_iterator@\oldoldtxt{<Container>}@ operator++(int);
  };

  template <class Container>
    back_insert_iterator<Container> back_inserter(Container& x);
}@\added{\}\}\newtxt{\}}}@
\end{codeblock}

\rSec3[back.insert.iter.ops]{\tcode{back_insert_iterator} operations}

\rSec4[back.insert.iter.cons]{\tcode{back_insert_iterator} constructor}

\indexlibrary{\idxcode{back_insert_iterator}!\idxcode{back_insert_iterator}}%
\begin{addedblock}
\begin{itemdecl}
@\newnewtxt{constexpr}@ back_insert_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Value-initializes
\tcode{container}.
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{back_insert_iterator}!constructor}%

\begin{itemdecl}
explicit back_insert_iterator(Container& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes
\tcode{container}
with \tcode{std::addressof(x)}.
\end{itemdescr}

\rSec4[back.insert.iter.op=]{\tcode{back_insert_iterator::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{back_insert_iterator}}%
\begin{itemdecl}
back_insert_iterator@\oldoldtxt{<Container>}@&
  operator=(const typename Container::value_type& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to }
\tcode{container->push_back(value);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{back_insert_iterator}}%
\begin{itemdecl}
back_insert_iterator@\oldoldtxt{<Container>}@&
  operator=(typename Container::value_type&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to }
\tcode{container->push_back(std::move(value));}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[back.insert.iter.op*]{\tcode{back_insert_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{back_insert_iterator}}%
\begin{itemdecl}
back_insert_iterator@\oldoldtxt{<Container>}@& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[back.insert.iter.op++]{\tcode{back_insert_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{back_insert_iterator}}%
\begin{itemdecl}
back_insert_iterator@\oldoldtxt{<Container>}@& operator++();
back_insert_iterator@\oldoldtxt{<Container>}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[back.inserter]{ \tcode{back_inserter}}

\indexlibrary{\idxcode{back_inserter}}%
\begin{itemdecl}
template <class Container>
  back_insert_iterator<Container> back_inserter(Container& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{back_insert_iterator<Container>(x)}.
\end{itemdescr}

\rSec3[front.insert.iterator]{Class template \tcode{front_insert_iterator}}

\indexlibrary{\idxcode{front_insert_iterator}}%
\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  template <class Container>
  class front_insert_iterator @\changed{:}{\{}@
    @\removed{public iterator<output_iterator_tag, void, void, void, void> \{}@
  @\oldoldtxt{protected}\newtxt{private}@:
    Container* container; @\newtxt{// \expos}@

  public:
    @\changed{typedef Container}{using}@ container_type@\added{ = Container}@;
    @\added{using difference_type = ptrdiff_t;}@
    @\oldtxt{using iterator_category = output_iterator_tag;}@
    @\added{\newnewtxt{constexpr} front_insert_iterator();}@
    explicit front_insert_iterator(Container& x);
    front_insert_iterator@\oldoldtxt{<Container>}@&
      operator=(const typename Container::value_type& value);
    front_insert_iterator@\oldoldtxt{<Container>}@&
      operator=(typename Container::value_type&& value);

    front_insert_iterator@\oldoldtxt{<Container>}@& operator*();
    front_insert_iterator@\oldoldtxt{<Container>}@& operator++();
    front_insert_iterator@\oldoldtxt{<Container>}@ operator++(int);
  };

  template <class Container>
    front_insert_iterator<Container> front_inserter(Container& x);
}@\added{\}\}\newtxt{\}}}@
\end{codeblock}

\rSec3[front.insert.iter.ops]{\tcode{front_insert_iterator} operations}

\rSec4[front.insert.iter.cons]{\tcode{front_insert_iterator} constructor}

\indexlibrary{\idxcode{front_insert_iterator}!\idxcode{front_insert_iterator}}%
\begin{addedblock}
\begin{itemdecl}
@\newnewtxt{constexpr}@ front_insert_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Value-initializes
\tcode{container}.
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{front_insert_iterator}!constructor}%

\begin{itemdecl}
explicit front_insert_iterator(Container& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes
\tcode{container}
with \tcode{std::addressof(x)}.
\end{itemdescr}

\rSec4[front.insert.iter.op=]{\tcode{front_insert_iterator::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{front_insert_iterator}}%
\begin{itemdecl}
front_insert_iterator@\oldoldtxt{<Container>}@&
  operator=(const typename Container::value_type& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to }
\tcode{container->push_front(value);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{front_insert_iterator}}%
\begin{itemdecl}
front_insert_iterator@\oldoldtxt{<Container>}@&
  operator=(typename Container::value_type&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to }
\tcode{container->push_front(std::move(value));}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[front.insert.iter.op*]{\tcode{front_insert_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{front_insert_iterator}}%
\begin{itemdecl}
front_insert_iterator@\oldoldtxt{<Container>}@& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[front.insert.iter.op++]{\tcode{front_insert_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{front_insert_iterator}}%
\begin{itemdecl}
front_insert_iterator@\oldoldtxt{<Container>}@& operator++();
front_insert_iterator@\oldoldtxt{<Container>}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[front.inserter]{\tcode{front_inserter}}

\indexlibrary{\idxcode{front_inserter}}%
\begin{itemdecl}
template <class Container>
  front_insert_iterator<Container> front_inserter(Container& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{front_insert_iterator<Container>(x)}.
\end{itemdescr}

\rSec3[insert.iterator]{Class template \tcode{insert_iterator}}

\indexlibrary{\idxcode{insert_iterator}}%
\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  template <class Container>
  class insert_iterator @\changed{:}{\{}@
    @\removed{public iterator<output_iterator_tag, void, void, void, void> \{}@
  @\oldoldtxt{protected}\newtxt{private}@:
    Container* container;              @\newtxt{// \expos}@
    typename Container::iterator iter; @\newtxt{// \expos}@

  public:
    @\changed{typedef Container}{using}@ container_type@\added{ = Container}@;
    @\added{using difference_type = ptrdiff_t;}@
    @\oldtxt{using iterator_category = output_iterator_tag;}@
    @\added{insert_iterator();}@
    insert_iterator(Container& x, typename Container::iterator i);
    insert_iterator@\oldoldtxt{<Container>}@&
      operator=(const typename Container::value_type& value);
    insert_iterator@\oldoldtxt{<Container>}@&
      operator=(typename Container::value_type&& value);

    insert_iterator@\oldoldtxt{<Container>}@& operator*();
    insert_iterator@\oldoldtxt{<Container>}@& operator++();
    insert_iterator@\oldoldtxt{<Container>\&}@ operator++(int);
  };

  template <class Container>
    insert_iterator<Container> inserter(Container& x, typename Container::iterator i);
}@\added{\}\}\newtxt{\}}}@
\end{codeblock}

\rSec3[insert.iter.ops]{\tcode{insert_iterator} operations}

\rSec4[insert.iter.cons]{\tcode{insert_iterator} constructor}

\indexlibrary{\idxcode{insert_iterator}!\idxcode{insert_iterator}}%
\begin{addedblock}
\begin{itemdecl}
insert_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Value-initializes
\tcode{container} and \tcode{iter}.
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{insert_iterator}!constructor}%

\begin{itemdecl}
insert_iterator(Container& x, typename Container::iterator i);
\end{itemdecl}

\begin{itemdescr}
{\color{newclr}
\pnum
\requires
\tcode{i} is an iterator into \tcode{x}.
}%%\color{newclr}

\pnum
\effects
Initializes
\tcode{container}
with \tcode{std::addressof(x)} and
\tcode{iter}
with \tcode{i}.
\end{itemdescr}

\rSec4[insert.iter.op=]{\tcode{insert_iterator::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator@\oldoldtxt{<Container>}@&
  operator=(const typename Container::value_type& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to }
\begin{codeblock}
iter = container->insert(iter, value);
++iter;
\end{codeblock}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator@\oldoldtxt{<Container>}@&
  operator=(typename Container::value_type&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to }
\begin{codeblock}
iter = container->insert(iter, std::move(value));
++iter;
\end{codeblock}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[insert.iter.op*]{\tcode{insert_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator@\oldoldtxt{<Container>}@& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[insert.iter.op++]{\tcode{insert_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{insert_iterator}}%
\begin{itemdecl}
insert_iterator@\oldoldtxt{<Container>}@& operator++();
insert_iterator@\oldoldtxt{<Container>\&}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[inserter]{\tcode{inserter}}

\indexlibrary{\idxcode{inserter}}%
\begin{itemdecl}
template <class Container>
  insert_iterator<Container> inserter(Container& x, typename Container::iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{insert_iterator<Container>(x, i)}.
\end{itemdescr}

\rSec2[iterators.move]{Move iterators}

\pnum
Class template \tcode{move_iterator} is an iterator adaptor
with the same behavior as the underlying iterator except that its
indirection operator implicitly converts the value returned by the
underlying iterator's indirection operator to an rvalue \oldoldtxt{reference}
\newnewtxt{of the value type}.
Some generic algorithms can be called with move iterators to replace
copying with moving.

\pnum
\enterexample

\begin{codeblock}
list<string> s;
// populate the list \tcode{s}
vector<string> v1(s.begin(), s.end());          // copies strings into \tcode{v1}
vector<string> v2(make_move_iterator(s.begin()),
                  make_move_iterator(s.end())); // moves strings into \tcode{v2}
\end{codeblock}

\exitexample

\begin{addedblock}
{\color{newclr}
\pnum
Class template \tcode{move_sentinel} is a sentinel adaptor useful for denoting
ranges together with \tcode{move_iterator}. When an iterator type \tcode{I} and
sentinel type \tcode{S} satisfy \tcode{Sentinel<S, I>()},
\tcode{Sentinel<move_sentinel<S>, move_iterator<I>{>}()} is satisfied as well.

\pnum
\enterexample A \tcode{move_if} algorithm is easily implemented with
\tcode{copy_if} using \tcode{move_iterator} and \tcode{move_sentinel}:

\begin{codeblock}
template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
          IndirectCallablePredicate<I> Pred>
  requires IndirectlyMovable<I, O>()
void move_if(I first, S last, O out, Pred pred)
{
  copy_if(move_iterator<I>{first}, move_sentinel<S>{last}, out, pred);
}
\end{codeblock}

\exitexample
} %% color{newclr}
\end{addedblock}

\rSec3[move.iterator]{Class template \tcode{move_iterator}}

\indexlibrary{\idxcode{move_iterator}}%
\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  template <@\removed{class Iterator}\oldtxt{Weak}\added{InputIterator I}@>
    @\oldtxt{requires Same<ReferenceType<I>, ValueType<I>\&>()}@
  class move_iterator {
  public:
\end{codeblock}\begin{removedblock}\begin{codeblock}
    typedef Iterator                                              iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type   difference_type;
    typedef Iterator                                              pointer;
    typedef typename iterator_traits<Iterator>::value_type        value_type;
    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;
    typedef value_type&&                                          reference;
\end{codeblock}\end{removedblock}\begin{addedblock}\begin{codeblock}
    using iterator_type     = I;
    using difference_type   = @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
    using value_type        = @\oldtxt{ValueType}\newtxt{value_type_t}@<I>;
    using iterator_category = @\oldtxt{IteratorCategory<I>}\newtxt{input_iterator_tag}@;
    using reference         = @\oldtxt{ValueType<I>\&\&}\newtxt{\seebelow}@;
    @\oldtxt{using pointer}@           @\oldtxt{= I;}@
\end{codeblock}\end{addedblock}\begin{codeblock}

    move_iterator();
    explicit move_iterator(@\changed{Iterator}{I}@ i);
    @\oldoldtxt{template <class U>}@
      @\oldtxt{requires ConvertibleTo<U, I>()}@
    move_iterator(const move_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);
    @\oldoldtxt{template <class U>}@
      @\oldtxt{requires ConvertibleTo<U, I>()}@
    move_iterator& operator=(const move_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);

    @\oldoldtxt{iterator_type}\newnewtxt{I}@ base() const;
    reference operator*() const;
    @\oldoldtxt{pointer operator->() const;}@

    move_iterator& operator++();
    move_iterator operator++(int);
    move_iterator& operator--()@\removed{;}@
      @\added{requires BidirectionalIterator<I>();}@
    move_iterator operator--(int)@\removed{;}@
      @\added{requires BidirectionalIterator<I>();}@

    move_iterator operator+(difference_type n) const@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    move_iterator& operator+=(difference_type n)@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    move_iterator operator-(difference_type n) const@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    move_iterator& operator-=(difference_type n)@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@
    @\oldoldtxt{\unspec}\newnewtxt{reference}@ operator[](difference_type n) const@\removed{;}@
      @\added{requires RandomAccessIterator<I>();}@

  private:
    @\changed{Iterator}{I}@ current;   // \expos
  };

  template <class @\removed{Iterator1}\oldtxt{InputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{InputIterator }\added{I2}@>
      @\added{requires EqualityComparable<I1, I2>()}@
    bool operator==(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{InputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{InputIterator }\added{I2}@>
      @\added{requires EqualityComparable<I1, I2>()}@
    bool operator!=(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator<=(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
  template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
      @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
    bool operator>=(
      const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);

  template <class @\removed{Iterator1}\oldtxt{WeakInputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{WeakInputIterator }\added{I2}@>
      @\added{requires \oldtxt{SizedIteratorRange<I2, I1>}\newtxt{SizedSentinel<I1, I2>}()}@
    @\removed{auto}\oldtxt{DifferenceType<I2>}\newnewtxt{difference_type_t<I2>}@ operator-(
      const move_iterator<@\changed{Iterator1}{I1}@>& x,
      const move_iterator<@\changed{Iterator2}{I2}@>& y)@\removed{ ->decltype(y.base() - x.base())}@;
  template <@\changed{class Iterator}{RandomAccessIterator I}@>
    move_iterator<@\changed{Iterator}{I}@>
      operator+(
        @\removed{typename move_iterator<Iterator>::difference_type}\oldtxt{DifferenceType<I>}\newnewtxt{difference_type_t<I>}@ n,
        const move_iterator<@\changed{Iterator}{I}@>& x);
  template <@\removed{class Iterator}\oldtxt{Weak}\added{InputIterator I}@>
    move_iterator<@\changed{Iterator}{I}@> make_move_iterator(@\changed{Iterator}{I}@ i);
}@\added{\}\}\newtxt{\}}}@
\end{codeblock}

\begin{addedblock}
{\color{newclr}
\pnum
Let \tcode{\textit{R}} be \tcode{reference_t<I>}. If \tcode{is_reference<\textit{R}>::value}
is \tcode{true}, the template specialization \tcode{move_iterator<I>} shall define the nested
type named \tcode{reference} as a synonym for \tcode{remove_reference_t<\textit{R}>\&\&}, otherwise
as a synonym for \tcode{\textit{R}}.

\pnum
\enternote \tcode{move_iterator} does not provide an \tcode{operator->} because the class member access
expression \tcode{\textit{i}->\textit{m}} may have different semantics than the expression
\tcode{(*\textit{i}).\textit{m}} when the expression \tcode{*\textit{i}} is an rvalue.\exitnote
}
\end{addedblock}

\begin{removedblock}
\rSec3[move.iter.requirements]{\tcode{move_iterator} requirements}

\pnum
The template parameter \tcode{Iterator} shall meet
the requirements for an Input Iterator~(\ref{iterators.input}).
Additionally, if any of the bidirectional or random access traversal
functions are instantiated, the template parameter shall meet the
requirements for a Bidirectional Iterator~(\ref{iterators.bidirectional})
or a Random Access Iterator~(\ref{iterators.random.access}), respectively.
\end{removedblock}

\rSec3[move.iter.ops]{\tcode{move_iterator} operations}

\rSec4[move.iter.op.const]{\tcode{move_iterator} constructors}

\indexlibrary{\idxcode{move_iterator}!\idxcode{move_iterator}}%
\begin{itemdecl}
move_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, value\newnewtxt{-}initializing
\tcode{current}. Iterator operations applied to the resulting
iterator have defined behavior if and only if the corresponding operations are defined
on a value-initialized iterator of type \tcode{\changed{Iterator}{I}}.
\end{itemdescr}


\indexlibrary{\idxcode{move_iterator}!constructor}%
\begin{itemdecl}
explicit move_iterator(@\changed{Iterator}{I}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, initializing
\tcode{current} with \tcode{i}.
\end{itemdescr}


\indexlibrary{\idxcode{move_iterator}!constructor}%
\begin{itemdecl}
@\oldoldtxt{template <class U>}@
  @\oldtxt{requires ConvertibleTo<U, I>()}@
move_iterator(const move_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, initializing
\tcode{current} with \oldoldtxt{\tcode{u.base()}}\newnewtxt{\tcode{i.current}}.

\begin{removedblock}
\pnum
\requires \tcode{U} shall be convertible to
\tcode{Iterator}.
\end{removedblock}
\end{itemdescr}

\rSec4[move.iter.op=]{\tcode{move_iterator::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator=}}%
\begin{itemdecl}
@\oldoldtxt{template <class U>}@
  @\oldtxt{requires ConvertibleTo<U, I>()}@
move_iterator& operator=(const move_iterator<@\oldoldtxt{U}\newnewtxt{ConvertibleTo<I>}@>& @\oldoldtxt{u}\newnewtxt{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \oldoldtxt{\tcode{u.base()}}\newnewtxt{\tcode{i.current}} to
\tcode{current}.

\begin{removedblock}
\pnum
\requires \tcode{U} shall be convertible to
\tcode{Iterator}.
\end{removedblock}
\end{itemdescr}

\rSec4[move.iter.op.conv]{\tcode{move_iterator} conversion}

\indexlibrary{\idxcode{base}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{base}}%
\begin{itemdecl}
@\changed{Iterator}{I}@ base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[move.iter.op.star]{\tcode{move_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator*}}%
\begin{itemdecl}
reference operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\oldoldtxt{\tcode{std::move}}\newnewtxt{\tcode{static_cast<reference>}}\tcode{(*current)}.
\end{itemdescr}

\begin{removedblock}
{\color{oldclr}
\rSec4[move.iter.op.ref]{\tcode{move_iterator::operator->}}

\indexlibrary{\idxcode{operator->}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator->}}%
\begin{itemdecl}
pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}
} %% color{oldclr}
\end{removedblock}

\rSec4[move.iter.op.incr]{\tcode{move_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
move_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to} \tcode{++current}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
move_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to}
\begin{codeblock}
move_iterator tmp = *this;
++current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[move.iter.op.decr]{\tcode{move_iterator::operator-{-}}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator\dcr}}%
\begin{itemdecl}
move_iterator& operator--()@\removed{;}@
  @\added{requires BidirectionalIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to} \tcode{\dcr{}current}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator\dcr}}%
\begin{itemdecl}
move_iterator operator--(int)@\removed{;}@
  @\added{requires BidirectionalIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to}
\begin{codeblock}
move_iterator tmp = *this;
--current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[move.iter.op.+]{\tcode{move_iterator::operator+}}

\indexlibrary{\idxcode{operator+}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator+}}%
\begin{itemdecl}
move_iterator operator+(difference_type n) const@\removed{;}@
  @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{move_iterator(current + n)}.
\end{itemdescr}

\rSec4[move.iter.op.+=]{\tcode{move_iterator::operator+=}}

\indexlibrary{\idxcode{operator+=}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator+=}}%
\begin{itemdecl}
move_iterator& operator+=(difference_type n)@\removed{;}@
  @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to} \tcode{current += n}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[move.iter.op.-]{\tcode{move_iterator::operator-}}

\indexlibrary{\idxcode{operator-}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
move_iterator operator-(difference_type n) const@\removed{;}@
  @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{move_iterator(current - n)}.
\end{itemdescr}

\rSec4[move.iter.op.-=]{\tcode{move_iterator::operator-=}}

\indexlibrary{\idxcode{operator-=}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator-=}}%
\begin{itemdecl}
move_iterator& operator-=(difference_type n)@\removed{;}@
  @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to} \tcode{current -= n}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[move.iter.op.index]{\tcode{move_iterator::operator[]}}

\indexlibrary{\idxcode{operator[]}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator[]}}%
\begin{itemdecl}
@\oldoldtxt{\unspec}\newnewtxt{reference}@ operator[](difference_type n) const@\removed{;}@
  @\added{requires RandomAccessIterator<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\oldoldtxt{\tcode{std::move}}\newnewtxt{\tcode{static_cast<reference>}}\tcode{(current[n])}.
\end{itemdescr}

\rSec4[move.iter.op.comp]{\tcode{move_iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{InputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{InputIterator }\added{I2}@>
    @\added{requires EqualityComparable<I1, I2>()}@
  bool operator==(
    const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.\oldoldtxt{base()}\newnewtxt{current} == y.\oldoldtxt{base()}\newnewtxt{current}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{InputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{InputIterator }\added{I2}@>
    @\added{requires EqualityComparable<I1, I2>()}@
  bool operator!=(
    const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator<}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator<(
    const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.\oldoldtxt{base()}\newnewtxt{current} < y.\oldoldtxt{base()}\newnewtxt{current}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator<=}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator<=(
    const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator>}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator>(
    const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator>=}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{RandomAccessIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{RandomAccessIterator }\added{I2}@>
    @\added{requires \newtxt{Strict}TotallyOrdered<I1, I2>()}@
  bool operator>=(
    const move_iterator<@\changed{Iterator1}{I1}@>& x, const move_iterator<@\changed{Iterator2}{I2}@>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{!(x < y)}.
\end{itemdescr}

\rSec4[move.iter.nonmember]{\tcode{move_iterator} non-member functions}

\indexlibrary{\idxcode{operator-}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
template <class @\removed{Iterator1}\oldtxt{WeakInputIterator }\added{I1}@, class @\removed{Iterator2}\oldtxt{WeakInputIterator }\added{I2}@>
    @\added{requires \oldtxt{SizedIteratorRange<I2, I1>}\newtxt{SizedSentinel<I1, I2>}()}@
  @\removed{auto}\oldtxt{DifferenceType<I2>}\newnewtxt{difference_type_t<I2>}@ operator-(
    const move_iterator<@\changed{Iterator1}{I1}@>& x,
    const move_iterator<@\changed{Iterator2}{I2}@>& y)@\removed{ ->decltype(y.base() - x.base())}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x.\oldoldtxt{base()}\newnewtxt{current} - y.\oldoldtxt{base()}\newnewtxt{current}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{move_iterator}}%
\indexlibrary{\idxcode{move_iterator}!\idxcode{operator+}}%
\begin{itemdecl}
template <@\changed{class Iterator}{RandomAccessIterator I}@>
  move_iterator<@\changed{Iterator}{I}@>
    operator+(
      @\removed{typename move_iterator<Iterator>::difference_type}\oldtxt{DifferenceType<I>}\newnewtxt{difference_type_t<I>}@ n,
      const move_iterator<@\changed{Iterator}{I}@>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to }
\tcode{x + n}.
\end{itemdescr}

\indexlibrary{\idxcode{make_move_iterator}}%
\begin{itemdecl}
template <@\removed{class Iterator}\oldtxt{Weak}\added{InputIterator I}@>
  move_iterator<@\changed{Iterator}{I}@> make_move_iterator(@\changed{Iterator}{I}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_iterator<\changed{Iterator}{I}>(i)}.
\end{itemdescr}

\begin{addedblock}
{\color{newclr}
\rSec3[move.sentinel]{Class template \tcode{move_sentinel}}

\indexlibrary{\idxcode{move_sentinel}}%
\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template <Semiregular S>
  class move_sentinel {
  public:
    constexpr move_sentinel();
    explicit move_sentinel(S s);
    move_sentinel(const move_sentinel<ConvertibleTo<S>>& s);
    move_sentinel& operator=(const move_sentinel<ConvertibleTo<S>>& s);

    S base() const;

  private:
    S last; // \expos
  };

  template <class I, Sentinel<I> S>
    bool operator==(
      const move_iterator<I>& i, const move_sentinel<S>& s);
  template <class I, Sentinel<I> S>
    bool operator==(
      const move_sentinel<S>& s, const move_iterator<I>& i);
  template <class I, Sentinel<I> S>
    bool operator!=(
      const move_iterator<I>& i, const move_sentinel<S>& s);
  template <class I, Sentinel<I> S>
    bool operator!=(
      const move_sentinel<S>& s, const move_iterator<I>& i);

  template <class I, SizedSentinel<I> S>
    difference_type_t<I> operator-(
      const move_sentinel<S>& s, const move_iterator<I>& i);
  template <class I, SizedSentinel<I> S>
    difference_type_t<I> operator-(
      const move_iterator<I>& i, const move_sentinel<S>& s);

  template <Semiregular S>
    move_sentinel<S> make_move_sentinel(S s);
}}}}
\end{codeblock}

\rSec3[move.sent.ops]{\tcode{move_sentinel} operations}

\rSec4[move.sent.op.const]{\tcode{move_sentinel} constructors}

\indexlibrary{\idxcode{move_sentinel}!\idxcode{move_sentinel}}%
\begin{itemdecl}
constexpr move_sentinel();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, value-initializing
\tcode{last}. If \tcode{S} is a literal type, this constructor
shall be a \tcode{constexpr} constructor.
\end{itemdescr}

\indexlibrary{\idxcode{move_iterator}!constructor}%
\begin{itemdecl}
explicit move_sentinel(S s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, initializing
\tcode{last} with \tcode{s}.
\end{itemdescr}

\indexlibrary{\idxcode{move_sentinel}!constructor}%
\begin{itemdecl}
move_sentinel(const move_sentinel<ConvertibleTo<S>>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, initializing
\tcode{last} with \tcode{s.last}.
\end{itemdescr}

\rSec4[move.sent.op=]{\tcode{move_sentinel::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{move_sentinel}}%
\indexlibrary{\idxcode{move_sentinel}!\idxcode{operator=}}%
\begin{itemdecl}
move_sentinel& operator=(const move_sentinel<ConvertibleTo<S>>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{s.last} to \tcode{last}.
\end{itemdescr}

\rSec4[move.sent.op.comp]{\tcode{move_sentinel} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{move_sentinel}}%
\indexlibrary{\idxcode{move_sentinel}!\idxcode{operator==}}%
\begin{itemdecl}
template <class I, Sentinel<I> S>
  bool operator==(
    const move_iterator<I>& i, const move_sentinel<S>& s);
template <class I, Sentinel<I> S>
  bool operator==(
    const move_sentinel<S>& s, const move_iterator<I>& i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{i.current == s.last}.
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{move_sentinel}}%
\indexlibrary{\idxcode{move_sentinel}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class I, Sentinel<I> S>
  bool operator!=(
    const move_iterator<I>& i, const move_sentinel<S>& s);
template <class I, Sentinel<I> S>
  bool operator!=(
    const move_sentinel<S>& s, const move_iterator<I>& i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{!(i == s)}.
\end{itemdescr}

\rSec4[move.sent.nonmember]{\tcode{move_sentinel} non-member functions}

\indexlibrary{\idxcode{operator-}!\idxcode{move_sentinel}}%
\indexlibrary{\idxcode{move_sentinel}!\idxcode{operator-}}%
\begin{itemdecl}
template <class I, SizedSentinel<I> S>
  difference_type_t<I> operator-(
    const move_sentinel<S>& s, const move_iterator<I>& i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{s.last - i.current}.
\end{itemdescr}

\begin{itemdecl}
template <class I, SizedSentinel<I> S>
  difference_type_t<I> operator-(
    const move_iterator<I>& i, const move_sentinel<S>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{i.current - s.last}.
\end{itemdescr}

\indexlibrary{\idxcode{make_move_sentinel}}%
\begin{itemdecl}
template <Semiregular S>
  move_sentinel<S> make_move_sentinel(S s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_sentinel<S>(s)}.
\end{itemdescr}
} %% color{newclr}

\rSec2[iterators.common]{Common iterators}

\pnum
Class template \tcode{common_iterator} is an iterator/sentinel adaptor that is
capable of representing a non-bounded range of elements (where the types of the
iterator and sentinel differ) as a bounded range (where they are the same). It
does this by holding either an iterator or a sentinel, and implementing the
equality comparison operators appropriately.

\pnum
\enternote The \tcode{common_iterator} type is useful for interfacing with legacy
code that expects the begin and end of a range to have the same type\oldtxt{, and for
use in \tcode{common_type} specializations that are required to make
iterator/sentinel pairs satisfy the \tcode{EqualityComparable}
concept}.\exitnote

\pnum
\enterexample
\begin{codeblock}
template<class ForwardIterator>
void fun(ForwardIterator begin, ForwardIterator end);

list<int> s;
// populate the list \tcode{s}
using CI =
  common_iterator<counted_iterator<list<int>::iterator>,
                  default_sentinel>;
// call \tcode{fun} on a range of 10 ints
fun(CI(make_counted_iterator(s.begin(), 10)),
    CI(default_sentinel()));
\end{codeblock}
\exitexample

\rSec3[common.iterator]{Class template \tcode{common_iterator}}

\indexlibrary{\idxcode{common_iterator}}%
\begin{codeblock}
namespace std { namespace experimental { namespace ranges@\oldtxt{_v1} \newtxt{\{ inline namespace v1}@ {
  @\oldtxt{// \expos}@
  @\oldtxt{template<class A, class B>}@
  @\oldtxt{concept bool \xname{WeaklyEqualityComparable} =}@
    @\oldtxt{EqualityComparable<A>() \&\& EqualityComparable<B>() \&\&}@
    @\oldtxt{requires(const A a, const B b) \{}@
      @\oldtxt{\{a==b\} -> Boolean;}@
      @\oldtxt{\{a!=b\} -> Boolean;}@
      @\oldtxt{\{b==a\} -> Boolean;}@
      @\oldtxt{\{b!=a\} -> Boolean;}@
    @\oldtxt{\};}@
  @\oldtxt{template<class S, class I>}@
  @\oldtxt{concept bool \xname{WeakSentinel} =        // \expos}@
    @\oldtxt{Iterator<I>() \&\& Regular<S>() \&\&}@
    @\oldtxt{\xname{WeaklyEqualityComparable}<I, S>;}@
  @\oldtxt{template <InputIterator I>}@
    @\oldtxt{constexpr bool \xname{fwd_iter} = false; // \expos}@
  @\oldtxt{template <ForwardIterator I>}@
    @\oldtxt{constexpr bool \xname{fwd_iter}<I> = true;}@

  template <@\oldtxt{Input}@Iterator I, @\oldtxt{\xname{Weak}}@Sentinel<I> S>
    requires !Same<I, S>()
  class common_iterator {
  public:
    using difference_type = @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
    @\oldtxt{using value_type = ValueType<I>;}@
    @\oldtxt{using iterator_category =}@
      @\oldtxt{conditional_t<\xname{fwd_iter}<I>,}@
                    @\oldtxt{std::forward_iterator_tag,}@
                    @\oldtxt{std::input_iterator_tag>;}@
    @\oldtxt{using reference = ReferenceType<I>;}@

    common_iterator();
    common_iterator(I i);
    common_iterator(S s);
    @\oldtxt{template <class U, class V>}@
      @\oldtxt{requires ConvertibleTo<U, I>() \&\& ConvertibleTo<V, S>()}@
    common_iterator(const common_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@, @\oldtxt{V}\newtxt{ConvertibleTo<S>}@>& u);
    @\oldtxt{template <class U, class V>}@
      @\oldtxt{requires ConvertibleTo<U, I>() \&\& ConvertibleTo<V, S>()}@
    common_iterator& operator=(const common_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@, @\oldtxt{V}\newtxt{ConvertibleTo<S>}@>& u);

    ~common_iterator();

    @\newtxt{\seebelow}@ @{\newtxt{operator*();}@
    @\oldtxt{reference}\newtxt{\seebelow}@ operator*() const;
    @\newtxt{\seebelow}@ @\newtxt{operator->() const requires Readable<I>();}@

    common_iterator& operator++();
    common_iterator operator++(int);

  private:
    bool is_sentinel; // \expos
    I iter;           // \expos
    S sent;           // \expos
  };

  @\newtxt{template <Readable I, class S>}@
  @\newtxt{struct value_type<common_iterator<I, S>{>} \{}@
    @\newtxt{using type = value_type_t<I>;}@
  @\newtxt{\};}@

  @\newtxt{template <InputIterator I, class S>}@
  @\newtxt{struct iterator_category<common_iterator<I, S>{>} \{}@
    @\newtxt{using type = input_iterator_tag;}@
  @\newtxt{\};}@

  @\newtxt{template <ForwardIterator I, class S>}@
  @\newtxt{struct iterator_category<common_iterator<I, S>{>} \{}@
    @\newtxt{using type = forward_iterator_tag;}@
  @\newtxt{\};}@

  @\newtxt{template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>}@
  @\newtxt{bool operator==(}@
    @\newtxt{const common_iterator<I1, S1>\& x, const common_iterator<I2, S2>\& y);}@
  template <class I1, class @\oldtxt{S1}\newtxt{I2}@, @\oldtxt{class I2}\newtxt{Sentinel<I2> S1}@, @\oldtxt{class}\newtxt{Sentinel<I1>}@ S2>
    requires EqualityComparable<I1, I2>()@\oldtxt{ \&\& \xname{WeaklyEqualityComparable}<I1, S2> \&\&}@
      @\oldtxt{\xname{WeaklyEqualityComparable}<I2, S1>}@
  bool operator==(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
  template <class I1, class @\oldtxt{S1}\newtxt{I2}@, @\oldtxt{class I2}\newtxt{Sentinel<I2> S1}@, @\oldtxt{class}\newtxt{Sentinel<I1>}@ S2>
    @\oldtxt{requires EqualityComparable<I1, I2>() \&\& \xname{WeaklyEqualityComparable}<I1, S2> \&\&}@
      @\oldtxt{\xname{WeaklyEqualityComparable}<I2, S1>}@
  bool operator!=(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

  @\oldtxt{template <class I1, class S1, class I2, class S2>}@
    @\oldtxt{requires SizedIteratorRange<I1, I1>() \&\& SizedIteratorRange<I2, I2>() \&\&}@
      @\oldtxt{requires (const I1 i1, const S1 s1, const I2 i2, const S2 s2) \{}@
        @\oldtxt{\{i1-i2\}->DifferenceType<I2>; \{i2-i1\}->DifferenceType<I2>;}@
        @\oldtxt{\{i1-s2\}->DifferenceType<I2>; \{s2-i1\}->DifferenceType<I2>;}@
        @\oldtxt{\{i2-s1\}->DifferenceType<I2>; \{s1-i2\}->DifferenceType<I2>;}@
      @\oldtxt{\}}@
  @\newtxt{template <class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>}@
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I2> operator-(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
}}}@\newtxt{\}}@
\end{codeblock}

\oldtxt{
\pnum
\enternote The use of the expository \tcode{\xname{WeaklyEqualityComparable}} and
\tcode{\xname{WeakSentinel}} concepts is to avoid the self-referential requirements that
would happen if parameters \tcode{I} and \tcode{S} use \tcode{common_iterator<I, S>}
as their common type.\exitnote
}

\oldtxt{
\pnum
\enternote The ad hoc constraints on \tcode{common_iterator}'s \tcode{operator-}
exist for the same reason.\exitnote
}

\pnum
\enternote It is unspecified whether \tcode{common_iterator}'s members
\tcode{iter} and \tcode{sent} have distinct addresses or not.\exitnote

\rSec3[common.iter.ops]{\tcode{common_iterator} operations}

\rSec4[common.iter.op.const]{\tcode{common_iterator} constructors}

\indexlibrary{\idxcode{common_iterator}!\idxcode{common_iterator}}%
\begin{itemdecl}
common_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{common_iterator}, value-initializing \tcode{is_sentinel}
and \tcode{iter}. Iterator operations applied to the resulting iterator have defined
behavior if and only if the corresponding operations are defined on a
value-initialized iterator of type \tcode{I}.

\newtxt{
\pnum
\remarks} It is unspecified whether any initialization is performed for
\tcode{sent}.
\end{itemdescr}

\indexlibrary{\idxcode{common_iterator}!constructor}%
\begin{itemdecl}
common_iterator(I i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{common_iterator}, initializing
\tcode{is_sentinel} with \tcode{false} and \tcode{iter} with \tcode{i}.
\end{itemdescr}

\newtxt{
\pnum
\remarks} It is unspecified whether any initialization is performed for
\tcode{sent}.

\indexlibrary{\idxcode{common_iterator}!constructor}%
\begin{itemdecl}
common_iterator(S s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{common_iterator}, initializing
\tcode{is_sentinel} with \tcode{true} and \tcode{sent} with \tcode{s}.
\end{itemdescr}

\newtxt{
\pnum
\remarks} It is unspecified whether any initialization is performed for
\tcode{iter}.

\indexlibrary{\idxcode{common_iterator}!constructor}%
\begin{itemdecl}
@\oldtxt{template <class U, class V>}@
  @\oldtxt{requires ConvertibleTo<U, I>() \&\& ConvertibleTo<V, S>()}@
common_iterator(const common_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@, @\oldtxt{V}\newtxt{ConvertibleTo<S>}@>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{common_iterator}, initializing
\tcode{is_sentinel} with \tcode{u.is_sentinel}.
\begin{itemize}
\item If \tcode{u.is_sentinel} is \tcode{true}, \tcode{sent} is initialized with \tcode{u.sent}.
\item If \tcode{u.is_sentinel} is \tcode{false}, \tcode{iter} is initialized with \tcode{u.iter}.
\end{itemize}

\newtxt{
\remarks}
\begin{itemize}
\item \newtxt{If \tcode{u.is_sentinel} is \tcode{true},} it is unspecified whether any initialization
is performed for \tcode{iter}.
\item \newtxt{If \tcode{u.is_sentinel} is \tcode{false},} it is unspecified whether any initialization
is performed for \tcode{sent}.
\end{itemize}
\end{itemdescr}

\rSec4[common.iter.op=]{\tcode{common_iterator::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator=}}%
\begin{itemdecl}
@\oldtxt{template <class U, class V>}@
  @\oldtxt{requires ConvertibleTo<U, I>() \&\& ConvertibleTo<V, S>()}@
common_iterator& operator=(const common_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@, @\oldtxt{V}\newtxt{ConvertibleTo<S>}@>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{u.is_sentinel} to \tcode{is_sentinel}.
\begin{itemize}
\item If \tcode{u.is_sentinel} is \tcode{true}, assigns \tcode{u.sent} to \tcode{sent}.
\item If \tcode{u.is_sentinel} is \tcode{false}, assigns \tcode{u.iter} to \tcode{iter}.
\end{itemize}

\newtxt{
\remarks}
\begin{itemize}
\item \newtxt{If \tcode{u.is_sentinel} is \tcode{true},} it is unspecified whether any operation
is performed on \tcode{iter}.
\item \newtxt{If \tcode{u.is_sentinel} is \tcode{false},} it is unspecified whether any operation
is performed on \tcode{sent}.
\end{itemize}

\pnum
\returns \tcode{*this}
\end{itemdescr}

\indexlibrary{\idxcode{common_iterator}!destructor}%
\begin{itemdecl}
~common_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\oldtxt{Runs the destructor(s) for}\newtxt{Destroys} any members that are currently initialized.
\end{itemdescr}

\rSec4[common.iter.op.star]{\tcode{common_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator*}}%
\begin{itemdecl}
@\newtxt{decltype(auto) operator*();}@
@\oldtxt{reference}\newtxt{decltype(auto)}@ operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{!is_sentinel}

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to} \tcode{*iter}.
\end{itemdescr}

{\color{newclr}
\indexlibrary{\idxcode{operator->}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator->}}%
\begin{itemdecl}
@\newtxt{\seebelow}@ @\newtxt{operator->() const requires Readable<I>();}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{!is_sentinel}

\pnum
\effects Given an object \tcode{i} of type \tcode{I}
\begin{itemize}
\item if \tcode{I} is a pointer type or if the expression
      \tcode{i.operator->()} is well-formed, this function returns
      \tcode{iter}.
\item Otherwise, if the expression \tcode{*iter} is a glvalue, this function
      is equivalent to \tcode{addressof(*iter)}.
\item Otherwise, this function returns a proxy object of an unspecified type
      equivalent to the following:
      \begin{codeblock}
      class proxy {               // \expos
        value_type_t<I> keep_;
        proxy(reference_t<I>&& x)
          : keep_(std::move(x)) {}
      public:
        const value_type_t<I>* operator->() const {
          return addressof(keep_);
        }
      };
      \end{codeblock}
      that is initialized with \tcode{*iter}.
\end{itemize}
\end{itemdescr}
}

\rSec4[common.iter.op.incr]{\tcode{common_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
common_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{!is_sentinel}

\pnum
\effects \tcode{++iter}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
common_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{!is_sentinel}

\pnum
\effects \newtxt{Equivalent to}
\begin{codeblock}
common_iterator tmp = *this;
++iter;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[common.iter.op.comp]{\tcode{common_iterator} comparisons}

{\color{newclr}
\indexlibrary{\idxcode{operator==}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
bool operator==(
  const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to
\begin{codeblock}
x.is_sentinel ?
    (y.is_sentinel || y.iter == x.sent) :
    (!y.is_sentinel || x.iter == y.sent)
\end{codeblock}
\end{itemdescr}
} %% color{newclr}

\indexlibrary{\idxcode{operator==}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template <class I1, class @\oldtxt{S1}\newtxt{I2}@, @\oldtxt{class I2}\newtxt{Sentinel<I2> S1}@, @\oldtxt{class}\newtxt{Sentinel<I1>}@ S2>
  requires EqualityComparable<I1, I2>()@\oldtxt{ \&\& \xname{WeaklyEqualityComparable}<I1, S2> \&\&}@
    @\oldtxt{\xname{WeaklyEqualityComparable}<I2, S1>}@
bool operator==(
  const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\begin{codeblock}
x.is_sentinel ?
    (y.is_sentinel || y.iter == x.sent) :
    (y.is_sentinel ?
        x.iter == y.sent :
        x.iter == y.iter);
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class I1, class @\oldtxt{S1}\newtxt{I2}@, @\oldtxt{class I2}\newtxt{Sentinel<I2> S1}@, @\oldtxt{class}\newtxt{Sentinel<I1>}@ S2>
  @\oldtxt{requires EqualityComparable<I1, I2>() \&\& \xname{WeaklyEqualityComparable}<I1, S2> \&\&}@
    @\oldtxt{\xname{WeaklyEqualityComparable}<I2, S1>}@
bool operator!=(
  const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
@\oldtxt{template <class I1, class S1, class I2, class S2>}@
  @\oldtxt{requires SizedIteratorRange<I1, I1>() \&\& SizedIteratorRange<I2, I2>() \&\&}@
    @\oldtxt{requires (const I1 i1, const S1 s1, const I2 i2, const S2 s2) \{}@
      @\oldtxt{\{i1-i2\}->DifferenceType<I2>; \{i2-i1\}->DifferenceType<I2>;}@
      @\oldtxt{\{i1-s2\}->DifferenceType<I2>; \{s2-i1\}->DifferenceType<I2>;}@
      @\oldtxt{\{i2-s1\}->DifferenceType<I2>; \{s1-i2\}->DifferenceType<I2>;}@
    @\oldtxt{\}}@
@\newtxt{template <class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>}@
@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I2> operator-(
  const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\begin{codeblock}
x.is_sentinel ?
    (y.is_sentinel ? 0 : x.sent - y.iter) :
    (y.is_sentinel ?
         x.iter - y.sent :
         x.iter - y.iter);
\end{codeblock}
\end{itemdescr}

\rSec2[default.sentinels]{Default sentinels}

\rSec3[default.sent]{Class \tcode{default_sentinel}}

\indexlibrary{\idxcode{default_sentinel}}%
\begin{itemdecl}
namespace std { namespace experimental { namespace ranges@\oldtxt{_v1} \newtxt{\{ inline namespace v1}@ {
  class default_sentinel { };
}}}@\newtxt{\}}@
\end{itemdecl}

\pnum
Class \tcode{default_sentinel} is an empty type used to denote the end of a
range. It is intended to be used together with iterator types that know the bound
of their range (e.g., \tcode{counted_iterator}~(\ref{counted.iterator})).

{\color{oldclr}
\rSec3[default.sent.ops]{\tcode{default_sentinel} operations}

\rSec4[default.sent.op.comp]{\tcode{default_sentinel} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{default_sentinel}}%
\indexlibrary{\idxcode{default_sentinel}!\idxcode{operator==}}%
\begin{itemdecl}
constexpr bool operator==(default_sentinel x, default_sentinel y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true}
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{default_sentinel}}%
\indexlibrary{\idxcode{default_sentinel}!\idxcode{operator"!=}}%
\begin{itemdecl}
constexpr bool operator!=(default_sentinel x, default_sentinel y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{false}
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{default_sentinel}}%
\indexlibrary{\idxcode{default_sentinel}!\idxcode{operator<}}%
\begin{itemdecl}
constexpr bool operator<(default_sentinel x, default_sentinel y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{false}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{default_sentinel}}%
\indexlibrary{\idxcode{default_sentinel}!\idxcode{operator<=}}%
\begin{itemdecl}
constexpr bool operator<=(default_sentinel x, default_sentinel y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{default_sentinel}}%
\indexlibrary{\idxcode{default_sentinel}!\idxcode{operator>}}%
\begin{itemdecl}
constexpr bool operator>(default_sentinel x, default_sentinel y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{false}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{default_sentinel}}%
\indexlibrary{\idxcode{default_sentinel}!\idxcode{operator>=}}%
\begin{itemdecl}
constexpr bool operator>=(default_sentinel x, default_sentinel y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true}
\end{itemdescr}

\rSec4[default.sent.nonmember]{\tcode{default_sentinel} non-member functions}

\indexlibrary{\idxcode{operator-}!\idxcode{default_sentinel}}%
\indexlibrary{\idxcode{default_sentinel}!\idxcode{operator-}}%
\begin{itemdecl}
constexpr ptrdiff_t operator-(default_sentinel x, default_sentinel y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{0}
\end{itemdescr}
} %% color{oldclr}

\rSec2[iterators.counted]{Counted iterators}

\pnum
Class template \tcode{counted_iterator} is an iterator adaptor
with the same behavior as the underlying iterator except that it
keeps track of its distance from its starting position. It can be
used together with class \tcode{default_sentinel} in calls to generic
algorithms to operate on a range of $N$ elements starting at a given
position without needing to know the end position \textit{a priori}.

\pnum
\enterexample

\begin{codeblock}
list<string> s;
// populate the list \tcode{s}\newtxt{ with at least 10 strings}
vector<string> v(make_counted_iterator(s.begin(), 10),
                 default_sentinel()); // copies 10 strings into \tcode{v}
\end{codeblock}
\exitexample

\pnum
Two values \tcode{i1} and \tcode{i2} of (possibly differing) types
\tcode{counted_iterator<I1>} and \tcode{counted_iterator<I2>} refer to
elements of the same sequence if and only if \tcode{next(i1.base(), i1.count())}
and \tcode{next(i2.base(), i2.count())} refer to the same (possibly past-the-end) element.

\rSec3[counted.iterator]{Class template \tcode{counted_iterator}}

\indexlibrary{\idxcode{counted_iterator}}%
\begin{codeblock}
namespace std { namespace experimental { namespace ranges@\oldtxt{_v1} \newtxt{\{ inline namespace v1}@ {
  template <@\oldtxt{Weak}@Iterator I>
  class counted_iterator {
  public:
    using iterator_type = I;
    using difference_type = @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I>;
    @\oldtxt{using reference = ReferenceType<I>;}@

    counted_iterator();
    counted_iterator(I x, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);
    @\oldtxt{template <WeakIterator U>}@
      @\oldtxt{requires ConvertibleTo<U, I>()}@
    counted_iterator(const counted_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@>& @\oldtxt{u}\newtxt{i}@);
    @\oldtxt{template <WeakIterator U>}@
      @\oldtxt{requires ConvertibleTo<U, I>()}@
    counted_iterator& operator=(const counted_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@>& @\oldtxt{u}\newtxt{i}@);

    I base() const;
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> count() const;
    @\newtxt{\seebelow}@ @\newtxt{operator*();}@
    @\oldtxt{reference}\newtxt{\seebelow}@ operator*() const;

    counted_iterator& operator++();
    counted_iterator operator++(int);
    counted_iterator& operator--()
      requires BidirectionalIterator<I>();
    counted_iterator operator--(int)
      requires BidirectionalIterator<I>();

    counted_iterator  operator+ (difference_type n) const
      requires RandomAccessIterator<I>();
    counted_iterator& operator+=(difference_type n)
      requires RandomAccessIterator<I>();
    counted_iterator  operator- (difference_type n) const
      requires RandomAccessIterator<I>();
    counted_iterator& operator-=(difference_type n)
      requires RandomAccessIterator<I>();
    @\oldtxt{\unspec}\newtxt{\seebelow}@ operator[](difference_type n) const
      requires RandomAccessIterator<I>();
  @\oldtxt{protected}\newtxt{private}@:
    I current; @\newtxt{// \expos}@
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> cnt; @\newtxt{// \expos}@
  };

  template <@\oldtxt{WeakInputIterator}\newtxt{Readable}@ I>
  struct value_type<counted_iterator<I>>@\oldtxt{ : value_type<I>}@ {@\oldtxt{ \};}@
    @\newtxt{using type = value_type_t<I>;}@
  @\newtxt{\};}@

  template <@\oldtxt{Weak}@InputIterator I>
  struct iterator_category<counted_iterator<I>> {
    using type = @\oldtxt{input_iterator_tag}\newtxt{iterator_category_t<I>}@;
  };
  @\oldtxt{template <ForwardIterator I>}@
  @\oldtxt{struct iterator_category<counted_iterator<I>{>} : iterator_category<I> \{ \};}@

  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator==(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    bool operator==(
      const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& x, default_sentinel@\oldtxt{ y}@);
  @\oldtxt{template <WeakIterator I>}@
    bool operator==(
      default_sentinel@\oldtxt{ x}@, const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& @\oldtxt{y}\newtxt{x}@);

  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator!=(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    bool operator!=(
      const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& x, default_sentinel y);
  @\oldtxt{template <WeakIterator I>}@
    bool operator!=(
      default_sentinel x, const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& y);

  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator<(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator<=(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<=(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator<=(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator>(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    bool operator>=(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>=(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template <WeakIterator I>}@
    @\oldtxt{bool operator>=(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I2> operator-(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I>
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> operator-(
      const counted_iterator<I>& x, default_sentinel y);
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I>
    @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> operator-(
      default_sentinel x, const counted_iterator<I>& y);

  template <RandomAccessIterator I>
    counted_iterator<I>
      operator+(@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, const counted_iterator<I>& x);

  template <@\oldtxt{Weak}@Iterator I>
    counted_iterator<I> make_counted_iterator(I i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);

  template <@\oldtxt{Weak}@Iterator I>
    void advance(counted_iterator<I>& i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);
}}}@\newtxt{\}}@
\end{codeblock}

\rSec3[counted.iter.ops]{\tcode{counted_iterator} operations}

\rSec4[counted.iter.op.const]{\tcode{counted_iterator} constructors}

\indexlibrary{\idxcode{counted_iterator}!\idxcode{counted_iterator}}%
\begin{itemdecl}
counted_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{counted_iterator}, value\newtxt{-}initializing
\tcode{current} and \tcode{cnt}. Iterator operations applied to the
resulting iterator have defined behavior if and only if the corresponding operations
are defined on a value-initialized iterator of type \tcode{I}.
\end{itemdescr}

\indexlibrary{\idxcode{counted_iterator}!constructor}%
\begin{itemdecl}
counted_iterator(I i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n >= 0}

\pnum
\effects Constructs a \tcode{counted_iterator}, initializing
\tcode{current} with \tcode{i} and \tcode{cnt} with \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{counted_iterator}!constructor}%
\begin{itemdecl}
@\oldtxt{template <WeakIterator U>}@
  @\oldtxt{requires ConvertibleTo<U, I>()}@
counted_iterator(const counted_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@>& @\oldtxt{u}\newtxt{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{counted_iterator}, initializing
\tcode{current} with \tcode{\oldtxt{u.base()}\newtxt{i.current}} and \tcode{cnt} with \tcode{\oldtxt{u.count()}\newtxt{i.cnt}}.
\end{itemdescr}

\rSec4[counted.iter.op=]{\tcode{counted_iterator::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator=}}%
\begin{itemdecl}
@\oldtxt{template <WeakIterator U>}@
  @\oldtxt{requires ConvertibleTo<U, I>()}@
counted_iterator& operator=(const counted_iterator<@\oldtxt{U}\newtxt{ConvertibleTo<I>}@>& @\oldtxt{u}\newtxt{i}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{\oldtxt{u.base()}\newtxt{i.current}} to
\tcode{current} and \tcode{\oldtxt{u.count()}\newtxt{i.cnt}} to \tcode{cnt}.

\end{itemdescr}

\rSec4[counted.iter.op.conv]{\tcode{counted_iterator} conversion}

\indexlibrary{\idxcode{base}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{base}}%
\begin{itemdecl}
I base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[counted.iter.op.cnt]{\tcode{counted_iterator} count}

\indexlibrary{\idxcode{count}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{count}}%
\begin{itemdecl}
@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> count() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{cnt}.
\end{itemdescr}

\rSec4[counted.iter.op.star]{\tcode{counted_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator*}}%
\begin{itemdecl}
@\newtxt{decltype(auto) operator*();}@
@\oldtxt{reference}\newtxt{decltype(auto)}@ operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{*current}.
\end{itemdescr}

\rSec4[counted.iter.op.incr]{\tcode{counted_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
counted_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{cnt > 0}

\pnum
\effects \newtxt{Equivalent to}
\begin{codeblock}
++current;
@\dcr@cnt;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
counted_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{cnt > 0}

\pnum
\effects \newtxt{Equivalent to}
\begin{codeblock}
counted_iterator tmp = *this;
++current;
@\dcr@cnt;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[counted.iter.op.decr]{\tcode{counted_iterator::operator-{-}}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator\dcr}}%
\begin{itemdecl}
  counted_iterator& operator--();
    requires BidirectionalIterator<I>()
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to}
\begin{codeblock}
--current;
++cnt;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator\dcr}}%
\begin{itemdecl}
  counted_iterator operator--(int)
    requires BidirectionalIterator<I>();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to}
\begin{codeblock}
counted_iterator tmp = *this;
--current;
++cnt;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[counted.iter.op.+]{\tcode{counted_iterator::operator+}}

\indexlibrary{\idxcode{operator+}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator+}}%
\begin{itemdecl}
  counted_iterator operator+(difference_type n) const
    requires RandomAccessIterator<I>();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= cnt}

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{counted_iterator(current + n, cnt - n)}.
\end{itemdescr}

\rSec4[counted.iter.op.+=]{\tcode{counted_iterator::operator+=}}

\indexlibrary{\idxcode{operator+=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator+=}}%
\begin{itemdecl}
  counted_iterator& operator+=(difference_type n)
    requires RandomAccessIterator<I>();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= cnt}

\pnum
\effects
\begin{codeblock}
current += n;
cnt -= n;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[counted.iter.op.-]{\tcode{counted_iterator::operator-}}

\indexlibrary{\idxcode{operator-}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
  counted_iterator operator-(difference_type n) const
    requires RandomAccessIterator<I>();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{-n <= cnt}

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{counted_iterator(current - n, cnt + n)}.
\end{itemdescr}

\rSec4[counted.iter.op.-=]{\tcode{counted_iterator::operator-=}}

\indexlibrary{\idxcode{operator-=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator-=}}%
\begin{itemdecl}
  counted_iterator& operator-=(difference_type n)
    requires RandomAccessIterator<I>();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{-n <= cnt}

\pnum
\effects
\begin{codeblock}
current -= n;
cnt += n;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[counted.iter.op.index]{\tcode{counted_iterator::operator[]}}

\indexlibrary{\idxcode{operator[]}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator[]}}%
\begin{itemdecl}
  @\oldoldtxt{\unspec}\newnewtxt{decltype(auto)}@ operator[](difference_type n) const
    requires RandomAccessIterator<I>();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= cnt}

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{current[n]}.
\end{itemdescr}

\rSec4[counted.iter.op.comp]{\tcode{counted_iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
    requires Common<I1, I2>()
  bool operator==(
    const counted_iterator<I1>& x, const counted_iterator<I2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{x} and {y} shall refer to elements of the same
sequence~(\ref{iterators.counted}).

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{x.\oldtxt{count()}\newtxt{cnt} == y.\oldtxt{count()}\newtxt{cnt}}.
\end{itemdescr}

\begin{itemdecl}
@\oldtxt{template <WeakIterator I>}@
  bool operator==(
    const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& x, default_sentinel@\oldtxt{ y}@);
  @\newtxt{bool operator==(}@
    @\newtxt{default_sentinel, const counted_iterator<auto>\& x);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{x.\oldtxt{count()}\newtxt{cnt} == 0}.
\end{itemdescr}

{\color{oldclr}
\begin{itemdecl}
template <WeakIterator I>
  bool operator==(
    default_sentinel x, const counted_iterator<I>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to
\tcode{y.cnt == 0}.
\end{itemdescr}
} %% color{oldclr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
    requires Common<I1, I2>()
  bool operator!=(
    const counted_iterator<I1>& x, const counted_iterator<I2>& y);
@\oldtxt{template <WeakIterator I>}@
  bool operator!=(
    const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& x, default_sentinel@\oldtxt{ y}@);
@\oldtxt{template <WeakIterator I>}@
  bool operator!=(
    default_sentinel@\oldtxt{ x}@, const counted_iterator<@\oldtxt{I}\newtxt{auto}@>& @\oldtxt{y}\newtxt{x}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires For the first overload, \tcode{x} and {y} shall refer to
elements of the same sequence~(\ref{iterators.counted}).

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator<}}%
\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
    requires Common<I1, I2>()
  bool operator<(
    const counted_iterator<I1>& x, const counted_iterator<I2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{x} and {y} shall refer to
elements of the same sequence~(\ref{iterators.counted}).

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{y.\oldtxt{count()}\newtxt{cnt} < x.\oldtxt{count()}\newtxt{cnt}}.

\newtxt{
\note The argument order in the \textit{Effects} clause is reversed because \tcode{cnt}
counts down, not up.
}
\end{itemdescr}

{\color{oldclr}
\begin{itemdecl}
template <WeakIterator I>
  bool operator<(
    const counted_iterator<I>& x, default_sentinel y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.count() != 0}.
\end{itemdescr}

\begin{itemdecl}
template <WeakIterator I>
  bool operator<(
    default_sentinel x, const counted_iterator<I>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{false}.
\end{itemdescr}
} %% color{oldclr}

\indexlibrary{\idxcode{operator<=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator<=}}%
\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
    requires Common<I1, I2>()
  bool operator<=(
    const counted_iterator<I1>& x, const counted_iterator<I2>& y);
@\oldtxt{template <WeakIterator I>}@
  @\oldtxt{bool operator<=(}@
    @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
@\oldtxt{template <WeakIterator I>}@
  @\oldtxt{bool operator<=(}@
    @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \oldtxt{For the first overload, }\tcode{x} and {y} shall refer to
elements of the same sequence~(\ref{iterators.counted}).

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator>}}%
\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
    requires Common<I1, I2>()
  bool operator>(
    const counted_iterator<I1>& x, const counted_iterator<I2>& y);
@\oldtxt{template <WeakIterator I>}@
  @\oldtxt{bool operator>(}@
    @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
@\oldtxt{template <WeakIterator I>}@
  @\oldtxt{bool operator>(}@
    @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \oldtxt{For the first overload, }\tcode{x} and {y} shall refer to
elements of the same sequence~(\ref{iterators.counted}).

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator>=}}%
\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
    requires Common<I1, I2>()
  bool operator>=(
    const counted_iterator<I1>& x, const counted_iterator<I2>& y);
@\oldtxt{template <WeakIterator I>}@
  @\oldtxt{bool operator>=(}@
    @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
@\oldtxt{template <WeakIterator I>}@
  @\oldtxt{bool operator>=(}@
    @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \oldtxt{For the first overload, }\tcode{x} and {y} shall refer to
elements of the same sequence~(\ref{iterators.counted}).

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{!(x < y)}.
\end{itemdescr}

\rSec4[counted.iter.nonmember]{\tcode{counted_iterator} non-member functions}

\indexlibrary{\idxcode{operator-}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
  template <@\oldtxt{WeakIterator}\newtxt{class}@ I1, @\oldtxt{WeakIterator}\newtxt{class}@ I2>
      requires Common<I1, I2>()
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I2> operator-(
    const counted_iterator<I1>& x, const counted_iterator<I2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \oldtxt{For the first overload, }\tcode{x} and {y} shall refer to
elements of the same sequence~(\ref{iterators.counted}).

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{y.\oldtxt{count()}\newtxt{cnt} - x.\oldtxt{count()}\newtxt{cnt}}.
\end{itemdescr}

\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I>
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> operator-(
    const counted_iterator<I>& x, default_sentinel y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{-x.\oldtxt{count()}\newtxt{cnt}}.
\end{itemdescr}

\begin{itemdecl}
template <@\oldtxt{WeakIterator}\newtxt{class}@ I>
  @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> operator-(
    default_sentinel x, const counted_iterator<I>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{y.\oldtxt{count()}\newtxt{cnt}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator+}}%
\begin{itemdecl}
template <RandomAccessIterator I>
  counted_iterator<I>
    operator+(@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n, const counted_iterator<I>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= x.\oldtxt{count()}\newtxt{cnt}}.

\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{x + n}.
\end{itemdescr}

\indexlibrary{\idxcode{make_counted_iterator}}%
\begin{itemdecl}
template <@\oldtxt{Weak}@Iterator I>
  counted_iterator<I> make_counted_iterator(I i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n >= 0}.

\pnum
\returns \tcode{counted_iterator<I>(i, n)}.
\end{itemdescr}

\indexlibrary{\idxcode{advance}}%
\begin{itemdecl}
template <@\oldtxt{Weak}@Iterator I>
  void advance(counted_iterator<I>& i, @\oldtxt{DifferenceType}\newtxt{difference_type_t}@<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= i.\oldtxt{count()}\newtxt{cnt}}.

\pnum
\effects
\begin{codeblock}
i = make_counted_iterator(next(i.@\oldtxt{base()}\newtxt{current}@, n), i.@\oldtxt{count()}\newtxt{cnt}@ - n);
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
\rSec3[counted.traits.specializations]{Specializations of \tcode{common_type}}

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
namespace std {
  template<experimental::ranges_v1::WeakIterator I>
  struct common_type<experimental::ranges_v1::counted_iterator<I>,
                     experimental::ranges_v1::default_sentinel> {
    using type = experimental::ranges_v1::common_iterator<
      experimental::ranges_v1::counted_iterator<I>,
      experimental::ranges_v1::default_sentinel>;
  };
  template<experimental::ranges_v1::WeakIterator I>
  struct common_type<experimental::ranges_v1::default_sentinel,
                     experimental::ranges_v1::counted_iterator<I>> {
    using type = experimental::ranges_v1::common_iterator<
      experimental::ranges_v1::counted_iterator<I>,
      experimental::ranges_v1::default_sentinel>;
  };
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\enternote By specializing \tcode{common_type} this way, \tcode{counted_iterator}
and \tcode{default_sentinel} can satisfy the \tcode{Common} requirement of the
\tcode{EqualityComparable} concept.\exitnote
\end{itemdescr}
} %% color{oldclr}

\rSec2[dangling.wrappers]{Dangling wrapper}

\rSec3[dangling.wrap]{Class template \tcode{dangling}}

\pnum
\indexlibrary{\idxcode{dangling}}%
Class template \tcode{dangling} is a wrapper for an object that refers to another object whose
lifetime may have ended. It is used by algorithms that accept rvalue ranges and return iterators.

\begin{codeblock}
namespace std { namespace experimental { namespace ranges@\oldtxt{_v1} \newtxt{\{ inline namespace v1}@ {
  template <CopyConstructible T>
  class dangling {
  public:
    dangling() requires DefaultConstructible<T>();
    dangling(T t);
    T get_unsafe() const;
  private:
    T value; // \expos
  };

  template <Range R>
  using safe_iterator_t =
    conditional_t<is_lvalue_reference<R>::value,
      @\oldtxt{IteratorType}\newtxt{iterator_t}@<R>,
      dangling<@\oldtxt{IteratorType}\newtxt{iterator_t}@<R>>>;
}}}@\newtxt{\}}@
\end{codeblock}

\rSec3[dangling.wrap.ops]{\tcode{dangling} operations}

\rSec4[dangling.wrap.op.const]{\tcode{dangling} constructors}

\indexlibrary{\idxcode{dangling}!\idxcode{dangling}}%
\begin{itemdecl}
dangling() requires DefaultConstructible<T>();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{dangling}, value\newtxt{-}initializing \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{dangling}!\idxcode{dangling}}%
\begin{itemdecl}
dangling(T t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{dangling}, initializing \tcode{value} with \tcode{t}.
\end{itemdescr}

\rSec4[dangling.wrap.op.get]{\tcode{dangling::get_unsafe}}

\indexlibrary{\idxcode{get_unsafe}!\idxcode{dangling}}%
\indexlibrary{\idxcode{dangling}!\idxcode{get_unsafe}}%
\begin{itemdecl}
T get_unsafe() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{value}.
\end{itemdescr}

\rSec2[unreachable.sentinels]{Unreachable sentinel}

\rSec3[unreachable.sentinel]{Class \tcode{unreachable}}

\pnum
\indexlibrary{\idxcode{unreachable}}%
Class \tcode{unreachable} is a sentinel type that can be used with any
\tcode{Iterator} to denote an infinite range. Comparing an iterator for equality with
an object of type \tcode{unreachable} always returns \tcode{false}.

\enterexample
\begin{codeblock}
char* p;
// set \tcode{p} to point to a character buffer containing newlines
char* nl = find(p, unreachable(), '@\textbackslash@n');
\end{codeblock}

Provided a newline character really exists in the buffer, the use of \tcode{unreachable}
above potentially make\newtxt{s} the call to \tcode{find} more efficient since the loop test against
the sentinel does not require a conditional branch.
\exitexample

\begin{codeblock}
namespace std { namespace experimental { namespace ranges@\oldtxt{_v1} \newtxt{\{ inline namespace v1}@ {
  class unreachable { };
  template <Iterator I>
    constexpr bool operator==(const I&, unreachable) noexcept;
  template <Iterator I>
    constexpr bool operator==(unreachable, const I&) noexcept;
  @\oldtxt{constexpr bool operator==(unreachable, unreachable) noexcept;}@
  template <Iterator I>
    constexpr bool operator!=(const I&, unreachable) noexcept;
  template <Iterator I>
    constexpr bool operator!=(unreachable, const I&) noexcept;
  @\oldtxt{constexpr bool operator!=(unreachable, unreachable) noexcept;}@
}}}@\newtxt{\}}@
\end{codeblock}

\rSec3[unreachable.sentinel.ops]{\tcode{unreachable} operations}

\rSec4[unreachable.sentinel.op==]{\tcode{operator==}}

\indexlibrary{\idxcode{operator==}!\idxcode{unreachable}}%
\indexlibrary{\idxcode{unreachable}!\idxcode{operator==}}%
\begin{itemdecl}
template <Iterator I>
  constexpr bool operator==(const I&, unreachable) noexcept;
template <Iterator I>
  constexpr bool operator==(unreachable, const I&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{false}.
\end{itemdescr}

{\color{oldclr}
\begin{itemdecl}
constexpr bool operator==(unreachable, unreachable) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{true}.
\end{itemdescr}
} %% color{oldclr}

\rSec4[unreachable.sentinel.op!=]{\tcode{operator!=}}

\indexlibrary{\idxcode{operator"!=}!\idxcode{unreachable}}%
\indexlibrary{\idxcode{unreachable}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <Iterator I>
  constexpr bool operator!=(const I& x, unreachable y) noexcept;
template <Iterator I>
  constexpr bool operator!=(unreachable x, const I& y) noexcept;
@\oldtxt{constexpr bool operator!=(unreachable x, unreachable y) noexcept;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\oldtxt{\tcode{!(x == y)}}\newtxt{\tcode{true}.}
\end{itemdescr}

{\color{oldclr}
\rSec3[unreachable.traits.specializations]{Specializations of \tcode{common_type}}

\indexlibrary{\idxcode{common_type}}%
\begin{itemdecl}
namespace std {
  template<experimental::ranges_v1::Iterator I>
  struct common_type<I, experimental::ranges_v1::unreachable> {
    using type = experimental::ranges_v1::common_iterator<I, experimental::ranges_v1::unreachable>;
  };
  template<experimental::ranges_v1::Iterator I>
  struct common_type<experimental::ranges_v1::unreachable, I> {
    using type = experimental::ranges_v1::common_iterator<I, experimental::ranges_v1::unreachable>;
  };
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\enternote By specializing \tcode{common_type} this way, any iterator and
\tcode{unreachable} can satisfy the \tcode{Common} requirement of the
\tcode{EqualityComparable} concept.\exitnote
\end{itemdescr}
} %% color{oldclr}
\end{addedblock}

\rSec1[iterators.stream]{Stream iterators}

\pnum
To make it possible for algorithmic templates to work directly with input/output streams, appropriate
iterator-like
class templates
are provided.

\enterexample
\begin{codeblock}
partial_sum(istream_iterator<double, char>(cin),
  istream_iterator<double, char>(),
  ostream_iterator<double, char>(cout, "@\textbackslash@n"));
\end{codeblock}

reads a file containing floating point numbers from
\tcode{cin},
and prints the partial sums onto
\tcode{cout}.
\exitexample

\rSec2[istream.iterator]{Class template \tcode{istream_iterator}}

\pnum
\indexlibrary{\idxcode{istream_iterator}}%
The class template
\tcode{istream_iterator}
is an input iterator~(\ref{iterators.input}) that
reads (using
\tcode{operator\shr})
successive elements from the input stream for which it was constructed.
After it is constructed, and every time
\tcode{++}
is used, the iterator reads and stores a value of
\tcode{T}.
If the iterator fails to read and store a value of \tcode{T}
(\tcode{fail()}
on the stream returns
\tcode{true}),
the iterator becomes equal to the
\term{end-of-stream}
iterator value.
The constructor with no arguments
\tcode{istream_iterator()}
always constructs
an end-of-stream input iterator object, which is the only legitimate iterator to be used
for the end condition.
The result of
\tcode{operator*}
on an end-of-stream iterator is not defined.
For any other iterator value a
\tcode{const T\&}
is returned.
The result of
\tcode{operator->}
on an end-of-stream iterator is not defined.
For any other iterator value a
\tcode{const T*}
is returned.
The behavior of a program that applies \tcode{operator++()} to an end-of-stream
iterator is undefined.
It is impossible to store things into istream iterators.

\pnum
Two end-of-stream iterators are always equal.
An end-of-stream iterator is not
equal to a non-end-of-stream iterator.
Two non-end-of-stream iterators are equal when they are constructed from the same stream.

\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1}} \newtxt{\{ inline namespace v1 \{}@
  template <class T, class charT = char, class traits = char_traits<charT>,
      class Distance = ptrdiff_t>
  class istream_iterator@\removed{:}@
    @\removed{public iterator<input_iterator_tag, T, Distance, const T*, const T\&>}@ {
  public:
    @\added{typedef input_iterator_tag iterator_category;}@
    @\added{typedef Distance difference_type;}@
    @\added{typedef T value_type;}@
    @\added{typedef const T\& reference;}@
    @\added{typedef const T* pointer;}@
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream<charT, traits> istream_type;
    @\seebelow@ istream_iterator();
    @\newtxt{\seebelow}@ @\newtxt{istream_iterator(default_sentinel);}@
    istream_iterator(istream_type& s);
    istream_iterator(const istream_iterator& x) = default;
   ~istream_iterator() = default;

    const T& operator*() const;
    const T* operator->() const;
    istream_iterator@\oldoldtxt{<T, charT, traits, Distance>}@& operator++();
    istream_iterator@\oldoldtxt{<T, charT, traits, Distance>}@  operator++(int);
  private:
    basic_istream<charT, traits>* in_stream; // \expos
    T value;                                 // \expos
  };

  template <class T, class charT, class traits, class Distance>
    bool operator==(const istream_iterator<T, charT, traits, Distance>& x,
            const istream_iterator<T, charT, traits, Distance>& y);
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator==(default_sentinel x,}@
            @\newtxt{const istream_iterator<T, charT, traits, Distance>\& y);}@
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator==(const istream_iterator<T, charT, traits, Distance>\& x,}@
            @\newtxt{default_sentinel y);}@
  template <class T, class charT, class traits, class Distance>
    bool operator!=(const istream_iterator<T, charT, traits, Distance>& x,
            const istream_iterator<T, charT, traits, Distance>& y);
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator!=(default_sentinel x,}@
            @\newtxt{const istream_iterator<T, charT, traits, Distance>\& y);}@
  @\newtxt{template <class T, class charT, class traits, class Distance>}@
    @\newtxt{bool operator!=(const istream_iterator<T, charT, traits, Distance>\& x,}@
            @\newtxt{default_sentinel y);}@
}@\added{\}\}}\newtxt{\}}@
\end{codeblock}

\rSec3[istream.iterator.cons]{\tcode{istream_iterator} constructors and destructor}


\indexlibrary{\idxcode{istream_iterator}!constructor}%
\begin{itemdecl}
@\seebelow@ istream_iterator();
@\newtxt{\seebelow}@ @\newtxt{istream_iterator(default_sentinel);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs the end-of-stream iterator. If \tcode{T} is a literal type, then \oldoldtxt{this}\newnewtxt{these}
constructor\newnewtxt{s} shall be\oldoldtxt{ a} \tcode{constexpr} constructor\newnewtxt{s}.

\pnum
\postcondition \tcode{in_stream == \oldoldtxt{0}\newnewtxt{nullptr}}.
\end{itemdescr}

\indexlibrary{\idxcode{istream_iterator}!constructor}%
\begin{itemdecl}
istream_iterator(istream_type& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{in_stream} with \tcode{\&s}. \tcode{value} may be initialized during
construction or the first time it is referenced.

\pnum
\postcondition \tcode{in_stream == \&s}.
\end{itemdescr}

\indexlibrary{\idxcode{istream_iterator}!constructor}%
\begin{itemdecl}
istream_iterator(const istream_iterator& x) = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a copy of \tcode{x}. If \tcode{T} is a literal type, then this constructor shall be a trivial copy constructor.

\pnum
\postcondition \tcode{in_stream == x.in_stream}.
\end{itemdescr}

\indexlibrary{\idxcode{istream_iterator}!destructor}%
\begin{itemdecl}
~istream_iterator() = default;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The iterator is destroyed. If \tcode{T} is a literal type, then this destructor shall be a trivial destructor.
\end{itemdescr}

\rSec3[istream.iterator.ops]{\tcode{istream_iterator} operations}

\indexlibrary{\idxcode{operator*}!\idxcode{istream_iterator}}%
\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator*}}%
\begin{itemdecl}
const T& operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{operator->}!\idxcode{istream_iterator}}%
\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator->}}%
\begin{itemdecl}
const T* operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\changed{\tcode{\&(operator*())}}{\tcode{std::addressof(operator*())}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{istream_iterator}}%
\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
istream_iterator@\oldoldtxt{<T, charT, traits, Distance>}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{in_stream != \oldoldtxt{0}\newnewtxt{nullptr}}.

\pnum
\effects
\tcode{*in_stream \shr{} value}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{istream_iterator}}%
\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
istream_iterator@\oldoldtxt{<T, charT, traits, Distance>}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{in_stream != \oldoldtxt{0}\newnewtxt{nullptr}}.

\pnum
\effects
\begin{codeblock}
istream_iterator@\oldoldtxt{<T, charT, traits, Distance>}@ tmp = *this;
*in_stream >> value;
return @\oldoldtxt{(}@tmp@\oldoldtxt{)}@;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{istream_iterator}}%
\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template <class T, class charT, class traits, class Distance>
  bool operator==(const istream_iterator<T, charT, traits, Distance> &x,
                  const istream_iterator<T, charT, traits, Distance> &y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.in_stream == y.in_stream}.%
\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator==}}
\end{itemdescr}

{\color{newclr}
\begin{itemdecl}
template <class T, class charT, class traits, class Distance>
  bool operator==(default_sentinel x,
                  const istream_iterator<T, charT, traits, Distance> &y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{nullptr == y.in_stream}.%
\end{itemdescr}

\begin{itemdecl}
template <class T, class charT, class traits, class Distance>
  bool operator==(const istream_iterator<T, charT, traits, Distance> &x,
                  default_sentinel y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.in_stream == nullptr}.%
\end{itemdescr}
}

\indexlibrary{\idxcode{operator"!=}!\idxcode{istream_iterator}}%
\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <class T, class charT, class traits, class Distance>
  bool operator!=(const istream_iterator<T, charT, traits, Distance>& x,
                  const istream_iterator<T, charT, traits, Distance>& y);
@\newtxt{template <class T, class charT, class traits, class Distance>}@
  @\newtxt{bool operator!=(default_sentinel x,}@
                  @\newtxt{const istream_iterator<T, charT, traits, Distance>\& y);}@
@\newtxt{template <class T, class charT, class traits, class Distance>}@
  @\newtxt{bool operator!=(const istream_iterator<T, charT, traits, Distance>\& x,}@
                  @\newtxt{default_sentinel y);}@
\end{itemdecl}

\indexlibrary{\idxcode{istream_iterator}!\idxcode{operator"!=}}%
\begin{itemdescr}
\pnum
\returns
\tcode{!(x == y)}
\end{itemdescr}

\rSec2[ostream.iterator]{Class template \tcode{ostream_iterator}}

\pnum
\indexlibrary{\idxcode{ostream_iterator}}%
\tcode{ostream_iterator}
writes (using
\tcode{operator\shl})
successive elements onto the output stream from which it was constructed.
If it was constructed with
\tcode{charT*}
as a constructor argument, this string, called a
\term{delimiter string},
is written to the stream after every
\tcode{T}
is written.
It is not possible to get a value out of the output iterator.
Its only use is as an output iterator in situations like

\begin{codeblock}
while (first != last)
  *result++ = *first++;
\end{codeblock}

\pnum
\tcode{ostream_iterator}
is defined as:

\begin{codeblock}
namespace std { @\added{namespace experimental \{ namespace ranges\oldtxt{_v1} \newtxt{\{ inline namespace v1} \{}@
  template <class T, class charT = char, class traits = char_traits<charT>>
  class ostream_iterator@\removed{:}@
    @\removed{public iterator<output_iterator_tag, void, void, void, void>}@ {
  public:
    @\oldtxt{typedef output_iterator_tag iterator_category;}@
    @\added{typedef ptrdiff_t difference_type;}@
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream<charT, traits> ostream_type;
    @\added{constexpr ostream_iterator() noexcept;}@
    ostream_iterator(ostream_type& s) @\newtxt{noexcept}@;
    ostream_iterator(ostream_type& s, const charT* delimiter) @\newtxt{noexcept}@;
    ostream_iterator(const ostream_iterator@\oldoldtxt{<T, charT, traits>}@& x) @\newtxt{noexcept}@;
   ~ostream_iterator();
    ostream_iterator@\oldoldtxt{<T, charT, traits>}@& operator=(const T& value);

    ostream_iterator@\oldoldtxt{<T, charT, traits>}@& operator*();
    ostream_iterator@\oldoldtxt{<T, charT, traits>}@& operator++();
    ostream_iterator@\oldoldtxt{<T, charT, traits>\&}@ operator++(int);
  private:
    basic_ostream<charT, traits>* out_stream;  // \expos
    const charT* delim;                        // \expos
  };
}@\added{\}\}}\newtxt{\}}@
\end{codeblock}

\rSec3[ostream.iterator.cons.des]{\tcode{ostream_iterator} constructors and destructor}

\begin{addedblock}
\indexlibrary{\idxcode{ostream_iterator}!constructor}%
\begin{itemdecl}
constexpr ostream_iterator() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{out_stream} and \tcode{delim} with \oldtxt{null}\newtxt{\tcode{nullptr}}.
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{ostream_iterator}!constructor}%
\begin{itemdecl}
ostream_iterator(ostream_type& s) @\newtxt{noexcept}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{out_stream} with \tcode{\&s} and \tcode{delim} with \oldtxt{null}\newtxt{\tcode{nullptr}}.
\end{itemdescr}

\indexlibrary{\idxcode{ostream_iterator}!constructor}%
\begin{itemdecl}
ostream_iterator(ostream_type& s, const charT* delimiter) @\newtxt{noexcept}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{out_stream} with \tcode{\&s} and \tcode{delim} with \tcode{delimiter}.
\end{itemdescr}

\indexlibrary{\idxcode{ostream_iterator}!constructor}%
\begin{itemdecl}
ostream_iterator(const ostream_iterator& x) @\newtxt{noexcept}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a copy of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{ostream_iterator}!destructor}%
\begin{itemdecl}
~ostream_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
The iterator is destroyed.
\end{itemdescr}

\rSec3[ostream.iterator.ops]{\tcode{ostream_iterator} operations}

\indexlibrary{\idxcode{operator=}!\idxcode{ostream_iterator}}%
\indexlibrary{\idxcode{ostream_iterator}!\idxcode{operator=}}%
\begin{itemdecl}
ostream_iterator& operator=(const T& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Equivalent to:}
\begin{codeblock}
*out_stream << value;
if(delim != @\oldoldtxt{0}\newnewtxt{nullptr}@)
  *out_stream << delim;
return @\oldtxt{(}@*this@\oldtxt{)}@;
\end{codeblock}

{\color{oldclr}
\pnum
\requires \tcode{out_stream != 0}.
} %%\color{oldclr}
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{ostream_iterator}}%
\indexlibrary{\idxcode{ostream_iterator}!\idxcode{operator*}}%
\begin{itemdecl}
ostream_iterator& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{ostream_iterator}}%
\indexlibrary{\idxcode{ostream_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
ostream_iterator& operator++();
ostream_iterator@\oldoldtxt{\&}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec2[istreambuf.iterator]{Class template \tcode{istreambuf_iterator}}

\pnum
The
class template
\tcode{istreambuf_iterator}
defines an input iterator~(\ref{iterators.input}) that
reads successive
\textit{characters}
from the streambuf for which it was constructed.
\tcode{operator*}
provides access to the current input character, if any.
\enternote \tcode{operator->} may return a proxy. \exitnote
Each time
\tcode{operator++}
is evaluated, the iterator advances to the next input character.
If the end of stream is reached (\tcode{streambuf_type::sgetc()} returns
\tcode{traits::eof()}),
the iterator becomes equal to the
\term{end-of-stream}
iterator value.
The default constructor
\tcode{istreambuf_iterator()}
and the constructor
\tcode{istreambuf_iterator(\oldoldtxt{0}\newnewtxt{nullptr})}
both construct an end-of-stream iterator object suitable for use
as an end-of-range.
All specializations of \tcode{istreambuf_iterator} shall have a trivial copy
constructor, a \tcode{constexpr} default constructor, and a trivial destructor.

\pnum
The result of
\tcode{operator*()}
on an end-of-stream iterator is undefined.
\indextext{undefined behavior}%
For any other iterator value a
\tcode{char_type}
value is returned.
It is impossible to assign a character via an input iterator.

\indexlibrary{\idxcode{istreambuf_iterator}}%
\begin{codeblock}
namespace std { @\newtxt{namespace experimental \{ namespace ranges\oldtxt{_v1} \{ inline namespace v1 \{}@
  template<class charT, class traits = char_traits<charT>>
  class istreambuf_iterator
     @\removed{: public iterator<input_iterator_tag, charT,}@
                       @\removed{typename traits::off_type, \unspec, charT>}@ {
  public:
    @\added{typedef input_iterator_tag}@             @\added{iterator_category;}@
    @\added{typedef charT}@                          @\added{value_type;}@
    @\added{typedef typename traits::off_type}@      @\added{difference_type;}@
    @\added{typedef charT}@                          @\added{reference;}@
    @\added{typedef \unspec}@                   @\added{pointer;}@
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef typename traits::int_type      int_type;
    typedef basic_streambuf<charT, traits> streambuf_type;
    typedef basic_istream<charT, traits>   istream_type;

    class proxy;                           // \expos

    constexpr istreambuf_iterator() noexcept;
    @\newtxt{constexpr istreambuf_iterator(default_sentinel) noexcept;}@
    istreambuf_iterator(const istreambuf_iterator&) noexcept = default;
    ~istreambuf_iterator() = default;
    istreambuf_iterator(istream_type& s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const proxy& p) noexcept;
    charT operator*() const;
    pointer operator->() const;
    istreambuf_iterator@\oldoldtxt{<charT, traits>}@& operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator& b) const;
  private:
    streambuf_type* sbuf_;                // \expos
  };

  template <class charT, class traits>
    bool operator==(const istreambuf_iterator<charT, traits>& a,
            const istreambuf_iterator<charT, traits>& b);
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator==(default_sentinel a,}@
            @\newtxt{const istreambuf_iterator<charT, traits>\& b);}@
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator==(const istreambuf_iterator<charT, traits>\& a,}@
            @\newtxt{default_sentinel b);}@
  template <class charT, class traits>
    bool operator!=(const istreambuf_iterator<charT, traits>& a,
            const istreambuf_iterator<charT, traits>& b);
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator!=(default_sentinel a,}@
            @\newtxt{const istreambuf_iterator<charT, traits>\& b);}@
  @\newtxt{template <class charT, class traits>}@
    @\newtxt{bool operator!=(const istreambuf_iterator<charT, traits>\& a,}@
            @\newtxt{default_sentinel b);}@
}@\newtxt{\}\}\}}@
\end{codeblock}

\rSec3[istreambuf.iterator::proxy]{Class template \tcode{istreambuf_iterator::proxy}}

\indexlibrary{\idxcode{proxy}!\idxcode{istreambuf_iterator}}%
\begin{codeblock}
namespace std { @\newtxt{namespace experimental \{ namespace ranges\oldtxt{_v1} \{ inline namespace v1 \{}@
  template <class charT, class traits = char_traits<charT> >
  class istreambuf_iterator<charT, traits>::proxy { // \expos
    charT keep_;
    basic_streambuf<charT, traits>* sbuf_;
    proxy(charT c, basic_streambuf<charT, traits>* sbuf)
      : keep_(c), sbuf_(sbuf) { }
  public:
    charT operator*() { return keep_; }
  };
}@\newtxt{\}\}\}}@
\end{codeblock}

\pnum
Class
\tcode{istreambuf_iterator<charT, traits>::proxy}
is for exposition only.
An implementation is permitted to provide equivalent functionality without
providing a class with this name.
Class
\tcode{istreambuf_iterator<charT, traits>\colcol{}proxy}
provides a temporary
placeholder as the return value of the post-increment operator
(\tcode{operator++}).
It keeps the character pointed to by the previous value
of the iterator for some possible future access to get the character.

\rSec3[istreambuf.iterator.cons]{\tcode{istreambuf_iterator} constructors}


\indexlibrary{\idxcode{istreambuf_iterator}!constructor}%
\begin{itemdecl}
constexpr istreambuf_iterator() noexcept;
@\newtxt{constexpr istreambuf_iterator(default_sentinel) noexcept;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs the end-of-stream iterator.
\end{itemdescr}

\indexlibrary{\idxcode{istreambuf_iterator}!constructor}%
\begin{itemdecl}
istreambuf_iterator(basic_istream<charT, traits>& s) noexcept;
istreambuf_iterator(basic_streambuf<charT, traits>* s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs an
\tcode{istreambuf_iterator<>}
that uses the
\tcode{basic_streambuf<>}
object
\tcode{*(s.rdbuf())},
or
\tcode{*s},
respectively.
Constructs an end-of-stream iterator if
\tcode{s.rdbuf()}
is null.
\end{itemdescr}


\indexlibrary{\idxcode{istreambuf_iterator}!constructor}%
\begin{itemdecl}
istreambuf_iterator(const proxy& p) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a
\tcode{istreambuf_iterator<>}
that uses the
\tcode{basic_streambuf<>}
object pointed to by the
\tcode{proxy}
object's constructor argument \tcode{p}.
\end{itemdescr}

\rSec3[istreambuf.iterator::op*]{\tcode{istreambuf_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{istreambuf_iterator}}%
\begin{itemdecl}
charT operator*() const
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
The character obtained via the
\tcode{streambuf}
member
\tcode{sbuf_->sgetc()}.
\end{itemdescr}

\rSec3[istreambuf.iterator::op++]{\tcode{istreambuf_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{istreambuf_iterator}}%
\begin{itemdecl}
istreambuf_iterator@\oldoldtxt{<charT, traits>}@&
    istreambuf_iterator<charT, traits>::operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newnewtxt{Equivalent to }
\tcode{sbuf_->sbumpc()}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{istreambuf_iterator}}%
\indexlibrary{\idxcode{istreambuf_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
proxy istreambuf_iterator<charT, traits>::operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns}
\newtxt{\effects Equivalent to }
\tcode{proxy(sbuf_->sbumpc(), sbuf_)}.
\end{itemdescr}

\rSec3[istreambuf.iterator::equal]{\tcode{istreambuf_iterator::equal}}

\indexlibrary{\idxcode{equal}!\idxcode{istreambuf_iterator}}%
\begin{itemdecl}
bool equal(const istreambuf_iterator@\oldoldtxt{<charT, traits>}@& b) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if and only if both iterators are at end-of-stream,
or neither is at end-of-stream, regardless of what
\tcode{streambuf}
object they use.
\end{itemdescr}

\rSec3[istreambuf.iterator::op==]{\tcode{operator==}}

\indexlibrary{\idxcode{operator==}!\idxcode{istreambuf_iterator}}%
\begin{itemdecl}
template <class charT, class traits>
  bool operator==(const istreambuf_iterator<charT, traits>& a,
                  const istreambuf_iterator<charT, traits>& b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{\returns}
\newnewtxt{\effects Equivalent to}
\tcode{a.equal(b)}.
\end{itemdescr}

{\color{newclr}
\begin{itemdecl}
template <class charT, class traits>
  bool operator==(default_sentinel a,
                  const istreambuf_iterator<charT, traits>& b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to
\tcode{istreambuf_iterator<charT, traits>\{\}.equal(b)}.
\end{itemdescr}

\begin{itemdecl}
template <class charT, class traits>
  bool operator==(const istreambuf_iterator<charT, traits>& a,
                  default_sentinel b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to
\tcode{a.equal(istreambuf_iterator<charT, traits>\{\})}.
\end{itemdescr}
} %% color{newclr}

\rSec3[istreambuf.iterator::op!=]{\tcode{operator!=}}

\indexlibrary{\idxcode{operator"!=}!\idxcode{istreambuf_iterator}}%
\begin{itemdecl}
template <class charT, class traits>
  bool operator!=(const istreambuf_iterator<charT, traits>& a,
                  const istreambuf_iterator<charT, traits>& b);
@\newnewtxt{template <class charT, class traits>}@
  @\newnewtxt{bool operator!=(default_sentinel a,}@
                  @\newnewtxt{const istreambuf_iterator<charT, traits>\& b);}@
@\newnewtxt{template <class charT, class traits>}@
  @\newnewtxt{bool operator!=(const istreambuf_iterator<charT, traits>\& a,}@
                  @\newnewtxt{default_sentinel b);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldoldtxt{
\returns
\tcode{!a.equal(b)}.
}
\newnewtxt{
\effects Equivalent to
\tcode{!(a == b)}
}
\end{itemdescr}

\rSec2[ostreambuf.iterator]{Class template \tcode{ostreambuf_iterator}}

\indexlibrary{\idxcode{ostreambuf_iterator}}%
\begin{codeblock}
namespace std { @\newtxt{namespace experimental \{ namespace ranges\oldtxt{_v1} \{ inline namespace v1 \{}@
  template <class charT, class traits = char_traits<charT> >
  class ostreambuf_iterator @\removed{:}@
    @\removed{public iterator<output_iterator_tag, void, void, void, void>}@ {
  public:
    @\oldoldtxt{typedef output_iterator_tag}@            @\oldoldtxt{iterator_category;}@
    @\added{typedef ptrdiff_t}@                      @\added{difference_type;}@
    typedef charT                          char_type;
    typedef traits                         traits_type;
    typedef basic_streambuf<charT, traits> streambuf_type;
    typedef basic_ostream<charT, traits>   ostream_type;

  @\oldoldtxt{public:}@
    @\added{constexpr ostreambuf_iterator() noexcept;}@
    ostreambuf_iterator(ostream_type& s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator& operator=(charT c);

    ostreambuf_iterator& operator*();
    ostreambuf_iterator& operator++();
    ostreambuf_iterator@\oldoldtxt{\&}@ operator++(int);
    bool failed() const noexcept;

  private:
    streambuf_type* sbuf_;                // \expos
  };
}@\newtxt{\}\}\}}@
\end{codeblock}

\pnum
The
class template
\tcode{ostreambuf_iterator}
writes successive
\textit{characters}
onto the output stream from which it was constructed.
It is not possible to get a character value out of the output iterator.

\rSec3[ostreambuf.iter.cons]{\tcode{ostreambuf_iterator} constructors}

\begin{addedblock}
\indexlibrary{\idxcode{ostreambuf_iterator}!constructor}%
\begin{itemdecl}
constexpr ostreambuf_iterator() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{sbuf_} with \oldtxt{null}\newtxt{\tcode{nullptr}}.
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{ostreambuf_iterator}!constructor}%
\begin{itemdecl}
ostreambuf_iterator(ostream_type& s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{s.rdbuf()\newnewtxt{ != nullptr}}
\oldoldtxt{shall not null pointer}.
\end{itemdescr}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{sbuf_} with \tcode{s.rdbuf()}.
\end{itemdescr}

\indexlibrary{\idxcode{ostreambuf_iterator}!constructor}%
\begin{itemdecl}
ostreambuf_iterator(streambuf_type* s) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{s\newnewtxt{ != nullptr}}
\oldoldtxt{shall not be a null pointer}.

\pnum
\effects
Initializes \tcode{sbuf_} with \tcode{s}.
\end{itemdescr}

\rSec3[ostreambuf.iter.ops]{\tcode{ostreambuf_iterator} operations}

\indexlibrary{\idxcode{operator=}!\idxcode{ostreambuf_iterator}}%
\begin{itemdecl}
ostreambuf_iterator@\oldoldtxt{<charT, traits>}@&
  operator=(charT c);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\requires \tcode{sbuf_ != \oldoldtxt{0}\newnewtxt{nullptr}}.
\end{addedblock}

\pnum
\effects
If
\tcode{failed()}
yields
\tcode{false},
calls
\tcode{sbuf_->sputc(c)};
otherwise has no effect.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{ostreambuf_iterator}}%
\begin{itemdecl}
ostreambuf_iterator@\oldoldtxt{<charT, traits>}@& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{ostreambuf_iterator}}%
\begin{itemdecl}
ostreambuf_iterator@\oldoldtxt{<charT, traits>}@& operator++();
ostreambuf_iterator@\oldoldtxt{<charT, traits>\&}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{failed}!\idxcode{ostreambuf_iterator}}%
\begin{itemdecl}
bool failed() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\requires \tcode{sbuf_ != \oldoldtxt{0}\newnewtxt{nullptr}}.
\end{addedblock}

\pnum
\returns
\tcode{true}
if in any prior use of member
\tcode{operator=},
the call to
\tcode{sbuf_->sputc()}
returned
\tcode{traits::eof()};
or
\tcode{false}
otherwise.
\end{itemdescr}

\begin{addedblock}

\rSec1[ranges]{Range concepts}

\rSec2[ranges.general]{General}

\pnum
This subclause describes components for dealing with ranges of elements.

\pnum
The following subclauses describe
range and view requirements, and
components for
range primitives,
predefined ranges,
and stream ranges,
as summarized in Table~\ref{tab:ranges.lib.summary}.

\begin{libsumtab}{Ranges library summary}{tab:ranges.lib.summary}
  \ref{ranges.requirements} & Requirements      & \\ \rowsep
  \ref{iterator.range}      & Range access      & \tcode{<\newtxt{experimental/ranges\oldtxt{_v1}/}iterator>} \\
  \ref{range.primitives}    & Range primitives  & \\
\end{libsumtab}

\rSec2[ranges.requirements]{Range requirements}

\rSec3[ranges.requirements.general]{In general}

\pnum
Ranges are an abstraction of containers that allow a \Cpp program to
operate on elements of data structures uniformly. It their simplest form, a
range object is one on which one can call \tcode{begin} and
\tcode{end} to get an iterator~(\ref{iterators.iterator}) and a
sentinel~(\ref{iterators.sentinel})\oldtxt{ or an iterator}. To be able to construct
template algorithms and range adaptors that work correctly and efficiently on
different types of sequences, the library formalizes not just the interfaces but
also the semantics and complexity assumptions of ranges.

\pnum
This \oldtxt{International Standard}\newtxt{document} defines three fundamental categories of ranges
based on the syntax and semantics supported by each: \techterm{range},
\techterm{sized range} and \techterm{view}, as shown in
Table~\ref{tab:ranges.relations}.

\begin{floattable}{Relations among range categories}{tab:ranges.relations}
  {lll}
  \topline
  \textbf{Sized Range}  &               &                   \\
                        & $\searrow$    &                   \\
                        &               &  \textbf{Range}   \\
                        & $\nearrow$    &                   \\
  \textbf{View}         &               &                   \\
\end{floattable}

\pnum
The \tcode{Range} concept requires only that \tcode{begin} and \tcode{end}
return an iterator and a sentinel. \oldtxt{\enternote An iterator is a valid sentinel.
\exitnote} The \tcode{SizedRange} concept refines \tcode{Range} \oldtxt{but adds}
\newtxt{with} the requirement that the number of elements in the range can be determined
in constant time \oldtxt{with}\newtxt{using} the \tcode{size} function. The \tcode{View} concept
\oldtxt{describes}\newtxt{specifies} requirements on an \tcode{Range} type
with constant-time copy and assign operations.

\pnum
In addition to the three fundamental range categories, this \oldtxt{standard}\newtxt{document} defines
a number of convenience refinements of \tcode{Range} that group together requirements
that appear often in the concepts, algorithms, and range adaptors.
\techterm{Bounded ranges} are ranges for which \tcode{begin} and \tcode{end} return objects of the
same type. \techterm{Random access ranges} are ranges for which
\tcode{begin} returns a \oldtxt{model of}\newtxt{type that satisfies}
\tcode{RandomAccessIterator}~(\ref{iterators.random.access}). The range
categories \techterm{bidirectional ranges},
\techterm{forward ranges},
\techterm{input ranges}, and
\techterm{output ranges} are defined similarly.
\oldtxt{\enternote There are no \techterm{weak input ranges} or
\techterm{weak output ranges} because of the \tcode{EqualityComparable}
requirement on iterators and sentinels. \exitnote}

\rSec3[ranges.range]{Ranges}

\pnum
The \tcode{Range} concept defines the requirements of a type that allows
iteration over its elements by providing a \tcode{begin} iterator and an
\tcode{end}\oldtxt{ iterator or} sentinel.
\enternote Most algorithms requiring this concept simply forward to an
\tcode{Iterator}-based algorithm by calling \tcode{begin} and \tcode{end}. \exitnote

\begin{itemdecl}
template <class T>
using @\oldtxt{IteratorType}\newtxt{iterator_t}@ = decltype(@\newtxt{ranges::}@begin(declval<T@\newtxt{\&}@>()));

template <class T>
using @\oldtxt{SentinelType}\newtxt{sentinel_t}@ = decltype(@\newtxt{ranges::}@end(declval<T@\newtxt{\&}@>()));

template <class T>
concept bool Range() {
  return requires@\oldtxt{(T t)}@ {
    @\oldtxt{typename IteratorType<T>;}@
    typename @\oldtxt{SentinelType}\newtxt{sentinel_t}@<T>;
    @\oldtxt{\{ begin(t) \} -> IteratorType<T>;}@
    @\oldtxt{\{ end(t) \} -> SentinelType<T>;}@
    @\oldtxt{requires Sentinel<SentinelType<T>, IteratorType<T>{}>;}@
  };
@\newtxt{\}}@
\end{itemdecl}

\begin{itemdescr}

\oldtxt{\tcode{begin} and \tcode{end} are required to be amortized constant time.}

\pnum
\newtxt{Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{Range<T>()} is satisfied
if and only if}

\begin{itemize}
\item \newtxt{\range{begin(t)}{end(t)} denotes a range.}

\item \newtxt{Both \tcode{begin(t)} and \tcode{end(t)} are amortized constant time
and non-modifying. \enternote \tcode{begin(t)} and \tcode{end(t)} do not require
implicit expression variants. \exitnote}

\item \newtxt{If \tcode{\oldtxt{IteratorType<T>}}\tcode{\newtxt{iterator_t<T>}} satisfies \tcode{ForwardIterator},
\tcode{begin(t)} is equality preserving.}
\end{itemize}
\end{itemdescr}

\pnum \newtxt{\enternote
Equality preservation of both \tcode{begin} and \tcode{end} enables passing a \tcode{Range}
whose \tcode{\oldtxt{IteratorType}}iterator type satisfies \tcode{ForwardIterator}
to multiple algorithms and
making multiple passes over the range by repeated calls to \tcode{begin} and \tcode{end}.
Since \tcode{begin} is not required to be equality preserving when the return type does
not satisfy \tcode{ForwardIterator}, repeated calls might not return equal values or
might not be well-defined; \tcode{begin} should be called at most once for such a range.
\exitnote}

\rSec3[ranges.sized]{Sized ranges}

\pnum
The \tcode{SizedRange} concept \oldtxt{describes}\newtxt{specifies} the requirements
of a \tcode{Range} type that knows its size in constant time with the
\tcode{size} function.

\begin{itemdecl}
@\oldtxt{// \expos}@
@\oldtxt{template <class T>}@
@\oldtxt{concept bool \xname{SizedRangeLike} =}@
  @\oldtxt{Range<T> \&\&}@
  @\oldtxt{requires(T t) \{}@
    @\oldtxt{\{ size(t) \} -> Integral;}@
    @\oldtxt{requires Convertible<decltype(size(t)),}@
                         @\oldtxt{DifferenceType<IteratorType<T>{>}{>};}@
  @\oldtxt{\};}@

@\newtxt{template <class R>}@
@\newtxt{constexpr bool disable_sized_range = false;}@

template <class T>
concept bool SizedRange() {
  @\oldtxt{\xname{SizedRangeLike}<T> \&\& is_sized_range<T>::value;}@
  @\newtxt{return Range<T>() \&\&}@
    @\newtxt{!disable_sized_range<remove_cv_t<remove_reference_t<T>{>}{>} \&\&}@
    @\newtxt{requires (const remove_reference_t<T>\& t) \{}@
      @\newtxt{\{ ranges::size(t) \} -> Integral;}@
      @\newtxt{\{ ranges::size(t) \} -> ConvertibleTo<\oldtxt{DifferenceType}difference_type_t<\oldtxt{IteratorType}iterator_t<T>{>}{>};}@
    @\newtxt{\};}@
@\newtxt{\}}@
\end{itemdecl}

\begin{itemdescr}
{\color{newclr}
\pnum
Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{SizedRange<T>()} is satisfied if and only if:

\begin{itemize}
\item \tcode{size(t)} returns the number of elements in \tcode{t}.
\item If \tcode{\oldtxt{IteratorType}iterator_t<T>} satisfies \tcode{ForwardIterator},
\tcode{size(t)} is well-defined regardless of the evaluation of
\tcode{begin(t)}. \enternote \tcode{size(t)} is otherwise not required be
well-defined after evaluating \tcode{begin(t)}. For a \tcode{SizedRange}
whose \tcode{\oldtxt{IteratorType}}iterator type does not model \tcode{ForwardIterator}, for
example, \tcode{size(t)} might only be well-defined if evaluated before
the first call to \tcode{begin(t)}. \exitnote
\end{itemize}

\pnum
The \tcode{disable_sized_range} predicate provides a mechanism to enable use
of range types with the library that meet the syntactic requirements but do
not in fact satisfy \tcode{SizedRange}.

\pnum
\enternote A program that instantiates a library template that requires a
\tcode{Range} with such a range type \tcode{R} is ill-formed with no
diagnostic required unless
\tcode{disable_sized_range<remove_cv_t<remove_reference_t<R>{>}{>}} evaluates
to \tcode{true}~(\ref{structure.requirements}). \exitnote
} %% color{newclr}

{\color{oldclr}
\pnum
For any type \tcode{T}, \tcode{disable_sized_range<T>}
derives from \tcode{false_type} if \tcode{T}
is a non-reference cv-unqualified type, and from
\tcode{disable_sized_range<remove_cv_t<remove_reference_t<T>{>}{>}} otherwise.

\pnum
Users are free to specialize \tcode{disable_sized_range}.
\enternote Users must specialize
\tcode{disable_sized_range} so that its member
\tcode{value} is \tcode{true} to override the default for \tcode{Range} types that meet only the
syntactic requirements of \tcode{SizedRange} when instantiating a library
template that has differing behavior for \tcode{Range} and \tcode{SizedRange}. \exitnote

\pnum
\enternote A possible implementation for
\tcode{disable_sized_range} is given below:

\begin{codeblock}
// \expos
template <class T>
using @\xname{uncvref}@ = remove_cv_t<remove_reference_t<T>>;

template <class R>
struct disable_sized_range :
  disable_sized_range<@\xname{uncvref}@<R>> { };

template <class R>
  requires Same<R, @\xname{uncvref}@<R>>()
struct disable_sized_range<R> : false_type { };
\end{codeblock}
\exitnote
} %% color{oldclr}
\end{itemdescr}

\rSec3[ranges.view]{Views}

\pnum
The \tcode{View} concept \oldtxt{describes}\newtxt{specifies} the requirements of a
\tcode{Range} type that has constant time copy, move and assignment operators; that
is, the cost of these operations is not proportional to the number of elements in
the \tcode{View}.

\pnum
\enterexample
Examples of \tcode{View}s are:

\begin{itemize}
\item A \tcode{Range} type that wraps a pair of iterators.

\item A \tcode{Range} type that hold\newtxt{s} its elements by \tcode{shared_ptr}
and shares ownership with all its copies.

\item A \tcode{Range} type that generates its elements on demand.
\end{itemize}

A container~(\cxxref{containers}) is not a \tcode{View} since copying the
container copies the elements, which cannot be done in constant time.
\exitexample

\begin{itemdecl}
@\newtxt{template <class T>}@
@\newtxt{struct enable_view \{ \};}@

@\newtxt{struct view_base \{ \};}@

// \expos
@\newtxt{template <class T>}@
@\newtxt{constexpr bool \xname{view_predicate} = \seebelow;}@

template <class T>
concept bool View() {
  return Range<T>() &&
    Semiregular<T>() &&
    @\oldtxt{is_view}\newtxt{\xname{view_predicate}}@<T>@\oldtxt{::value}@;
@\newtxt{\}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
Since the difference between \tcode{Range} and \tcode{View} is largely semantic, the
two are differentiated with the help of the \tcode{\oldtxt{is}\newtxt{enable}_view}
trait. Users may specialize \oldtxt{the} \tcode{\oldtxt{is}\newtxt{enable}_view}
\oldtxt{trait} \newtxt{to derive from \tcode{true_type} or \tcode{false_type}}.
\oldtxt{By default, \tcode{\oldtxt{is_view}\newtxt{\xname{view_predicate}}}
uses the following heuristics to determine whether a \tcode{Range} type \tcode{T}
is a \tcode{View}:}
\begin{itemize}
\item \oldtxt{If \tcode{T} derives from \tcode{view_base}, \tcode{is_view<T>::value}
is true.}
\item \oldtxt{If a top-level \tcode{const} changes \tcode{T}'s \tcode{IteratorType}'s
\tcode{ReferenceType} type, \tcode{is_view<T>::value}
is false. \enternote Deep \tcode{const}-ness implies element ownership, whereas shallow
\tcode{const}-ness implies reference semantics. \exitnote}
\end{itemize}

{\color{newclr}
\pnum
For a type \tcode{T}, the value of \tcode{\xname{view_predicate<T>}} shall be:
\begin{itemize}
\item If \tcode{enable_view<T>} has a member type \tcode{type}, \tcode{enable_view<T>::type::value};
\item \oldtxt{If}\newtxt{Otherwise, if} \tcode{T} is derived from \tcode{view_base}, \tcode{true};
\item \newtxt{Otherwise, if \tcode{T} is an instantiation of class template
\tcode{initializer_list}~(\cxxref{support.initlist}),
\tcode{set}~(\cxxref{set}),
\tcode{multiset}~(\cxxref{multiset}),
\tcode{unordered_set}~(\cxxref{unord.set}), or
\tcode{unordered_multiset}~(\cxxref{unord.multiset}), \tcode{false}};
\item \oldtxt{If}\newtxt{Otherwise, if} both \tcode{T} and \tcode{const T} satisfy \tcode{Range} and \tcode{\oldtxt{ReferenceType}reference_t}
\tcode{<\oldtxt{IteratorType}iterator_t<T>{>}} is not the same type as \tcode{\oldtxt{ReferenceType}reference_t}
\tcode{<\oldtxt{IteratorType}iterator_t<const T>{>}},
\tcode{false}; \enternote Deep \tcode{const}-ness implies element ownership, whereas shallow \tcode{const}-ness
implies reference semantics. \exitnote
\item Otherwise, \tcode{true}.
\end{itemize}
} %% color{newclr}

{\color{oldclr}
\pnum
\enternote
Below is a possible implementation of \tcode{\xname{view_predicate}}.

\begin{codeblock}
// \expos
template <class T>
concept bool @\xname{ContainerLike}@ =
  Range<T>() && Range<const T>() &&
  !Same<reference_t<iterator_t<T>>,
        reference_t<iterator_t<const T>>>();

template <class T>
constexpr bool @\xname{view_predicate}@ = true;

template <class T>
  requires requires { typename enable_view<T>::type; }
constexpr bool @\xname{view_predicate}@<T> = enable_view<T>::type::value;

template <@\xname{ContainerLike}@ T>
  requires !(DerivedFrom<T, view_base>() ||
             requires { typename enable_view<T>::type; })
constexpr bool @\xname{view_predicate}@<T> = false;
\end{codeblock}
\exitnote
} %% color{oldclr}
\end{itemdescr}

\rSec3[ranges.bounded]{Bounded ranges}

\pnum
The \tcode{BoundedRange} concept \oldtxt{describes}\newtxt{specifies} requirements
of an \tcode{Range} type for which \tcode{begin} and \tcode{end} return objects of
the same type. \enternote The standard containers~(\cxxref{containers})
\oldtxt{are models of} \newtxt{satisfy} \tcode{BoundedRange}.\exitnote

\begin{codeblock}
template <class T>
concept bool BoundedRange() {
  return Range<T>() && Same<@\oldtxt{IteratorType}\newtxt{iterator_t}@<T>, @\oldtxt{SentinelType}\newtxt{sentinel_t}@<T>>();
@\newtxt{\}}@
\end{codeblock}

\rSec3[ranges.input]{Input ranges}

\pnum
The \tcode{InputRange} concept \oldtxt{describes}\newtxt{specifies} requirements of
an \tcode{Range} type for which \tcode{begin} returns a \oldtxt{model of}\newtxt{type
that satisfies} \tcode{InputIterator}~(\ref{iterators.input}).

\begin{codeblock}
template <class T>
concept bool InputRange() {
  return Range<T>() && InputIterator<@\oldtxt{IteratorType}\newtxt{iterator_t}@<T>>();
@\newtxt{\}}@
\end{codeblock}

{\color{newclr}
\rSec3[ranges.output]{Output ranges}

\pnum
The \tcode{OutputRange} concept specifies requirements of
an \tcode{Range} type for which \tcode{begin} returns a type that satisfies
\tcode{OutputIterator}~(\ref{iterators.output}).

\begin{codeblock}
template <class R, class T>
concept bool OutputRange() {
  return Range<R>() && OutputIterator<@\oldtxt{IteratorType}\newtxt{iterator_t}@<R>, T>();
}
\end{codeblock}
}

\rSec3[ranges.forward]{Forward ranges}

\pnum
The \tcode{ForwardRange} concept \oldtxt{describes}\newtxt{specifies} requirements of an
\tcode{InputRange} type for which \tcode{begin} returns a \oldtxt{model of}\newtxt{type that satisfies}
\tcode{ForwardIterator}~(\ref{iterators.forward}).

\begin{codeblock}
template <class T>
concept bool ForwardRange() {
  return InputRange<T>() && ForwardIterator<@\oldtxt{IteratorType}\newtxt{iterator_t}@<T>>();
}
\end{codeblock}

\rSec3[ranges.bidirectional]{Bidirectional ranges}

\pnum
The \tcode{BidirectionalRange} concept \oldtxt{describes}\newtxt{specifies} requirements of a
\tcode{ForwardRange} type for which \tcode{begin} returns a \oldtxt{model of}\newtxt{type that satisfies}
\tcode{BidirectionalIterator}~(\ref{iterators.bidirectional}).

\begin{codeblock}
template <class T>
concept bool BidirectionalRange() {
  return ForwardRange<T>() && BidirectionalIterator<@\oldtxt{IteratorType}\newtxt{iterator_t}@<T>>();
}
\end{codeblock}

\rSec3[ranges.random.access]{Random access ranges}

\pnum
The \tcode{RandomAccessRange} concept \oldtxt{describes}\newtxt{specifies} requirements of a
\tcode{BidirectionalRange} type for which \tcode{begin} returns a \oldtxt{model of}\newtxt{type that satisfies}
\tcode{RandomAccessIterator}~(\ref{iterators.random.access}).

\begin{codeblock}
template <class T>
concept bool RandomAccessRange() {
  return BidirectionalRange<T>() && RandomAccessIterator<@\oldtxt{IteratorType}\newtxt{iterator_t}@<T>>();
}
\end{codeblock}

\end{addedblock}

\rSec1[iterator.range]{Range access}

{\color{remclr}
\pnum
In addition to being available via inclusion of the \tcode{<iterator>} header,
the function templates in \ref{iterator.range} are available when any of the following
headers are included: \tcode{<array>}, \tcode{<deque>}, \tcode{<forward_list>},
\tcode{<list>}, \tcode{<map>}, \tcode{<regex>}, \tcode{<set>}, \tcode{<string>},
\tcode{<unordered_map>}, \tcode{<unordered_set>}, and \tcode{<vector>}.
}

{\color{remclr}
\indexlibrary{\idxcode{begin(C\&)}}%
\begin{itemdecl}
template <class C> auto begin(C& c) -> decltype(c.begin());
template <class C> auto begin(const C& c) -> decltype(c.begin());
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{c.begin()}.
\end{itemdescr}

\indexlibrary{\idxcode{end(C\&)}}%
\begin{itemdecl}
template <class C> auto end(C& c) -> decltype(c.end());
template <class C> auto end(const C& c) -> decltype(c.end());
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{c.end()}.
\end{itemdescr}

\indexlibrary{\idxcode{begin(T (\&)[N])}}%
\begin{itemdecl}
template <class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{array}.
\end{itemdescr}

\indexlibrary{\idxcode{end(T (\&)[N])}}%
\begin{itemdecl}
template <class T, size_t N> constexpr T* end(T (&array)[N]) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{array + N}.
\end{itemdescr}

\indexlibrary{\idxcode{cbegin(const C\&)}}%
\begin{itemdecl}
template <class C> constexpr auto cbegin(const C& c) noexcept(noexcept(std::begin(c)))
  -> decltype(std::begin(c));
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{std::begin(c)}.
\end{itemdescr}

\indexlibrary{\idxcode{cend(const C\&)}}%
\begin{itemdecl}
template <class C> constexpr auto cend(const C& c) noexcept(noexcept(std::end(c)))
  -> decltype(std::end(c));
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{std::end(c)}.
\end{itemdescr}

\indexlibrary{\idxcode{rbegin(C\&)}}%
\begin{itemdecl}
template <class C> auto rbegin(C& c) -> decltype(c.rbegin());
template <class C> auto rbegin(const C& c) -> decltype(c.rbegin());
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{c.rbegin()}.
\end{itemdescr}

\indexlibrary{\idxcode{rend(const C\&)}}%
\begin{itemdecl}
template <class C> auto rend(C& c) -> decltype(c.rend());
template <class C> auto rend(const C& c) -> decltype(c.rend());
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{c.rend()}.
\end{itemdescr}

\indexlibrary{\idxcode{rbegin(T (\&array)[N])}}%
\begin{itemdecl}
template <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{reverse_iterator<T*>(array + N)}.
\end{itemdescr}

\indexlibrary{\idxcode{rend(T (\&array)[N])}}%
\begin{itemdecl}
template <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{reverse_iterator<T*>(array)}.
\end{itemdescr}

\indexlibrary{\idxcode{rbegin(initializer_list<E>)}}%
\begin{itemdecl}
template <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il);
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{reverse_iterator<const E*>(il.end())}.
\end{itemdescr}

\indexlibrary{\idxcode{rend(initializer_list<E>)}}%
\begin{itemdecl}
template <class E> reverse_iterator<const E*> rend(initializer_list<E> il);
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{reverse_iterator<const E*>(il.begin())}.
\end{itemdescr}

\indexlibrary{\idxcode{crbegin(const C\& c)}}%
\begin{itemdecl}
template <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{std::rbegin(c)}.
\end{itemdescr}

\indexlibrary{\idxcode{crend(const C\& c)}}%
\begin{itemdecl}
template <class C> auto crend(const C& c) -> decltype(std::rend(c));
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{std::rend(c)}.
\end{itemdescr}
} %%\color{remclr}

{\color{newclr}
\rSec2[iterator.range.begin]{\tcode{begin}}
\pnum
The name \tcode{begin} denotes a customization point
 object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::begin(E)} for some expression \tcode{E} is equivalent to:

\begin{itemize}
\item
  \tcode{ranges::begin((const T\&)(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::begin(E)} behaves similarly to \tcode{std::begin(E)}
  as defined in ISO/IEC 14882 when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{(E) + 0} if \tcode{E} has array
  type~(\cxxref{basic.compound}).

\item
  Otherwise, \tcode{(E).begin()} if its type \tcode{I} meets the
  syntactic requirements of \tcode{Iterator<I>()}. If
  \tcode{Iterator} is not satisfied, the program is ill-formed
  with no diagnostic required.

\item
  Otherwise, \tcode{begin(E)} if its type \tcode{I} meets the
  syntactic requirements of \tcode{Iterator<I>()} with overload
  resolution performed in a context that includes the declaration
  \tcode{void begin(auto\&) = delete;} and does not include
  a declaration of \tcode{ranges::begin}. If \tcode{Iterator}
  is not satisfied, the program is ill-formed with no diagnostic
  required.

\item
  Otherwise, \tcode{ranges::begin(E)} is ill-formed.
\end{itemize}

\pnum
\remark Whenever \tcode{ranges::begin(E)} is a valid expression, the
type of \tcode{ranges::begin(E)} satisfies \tcode{Iterator}.

\rSec2[iterator.range.end]{\tcode{end}}
\pnum
The name \tcode{end} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::end(E)} for some expression \tcode{E} is equivalent to:

\begin{itemize}
\item
  \tcode{ranges::end((const T\&)(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::end(E)} behaves similarly to \tcode{std::end(E)}
  as defined in ISO/IEC 14882 when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{(E) + extent<T>::value} if \tcode{E} has array
  type~(\cxxref{basic.compound}) \tcode{T}.

\item
  Otherwise, \tcode{(E).end()} if its type \tcode{S} meets the
  syntactic requirements of
  \tcode{Sentinel<\brk{}S, decltype(\brk{}ranges::\brk{}begin(E)>()}. If
  \tcode{Sentinel} is not satisfied, the program is ill-formed with
  no diagnostic required.

\item
  Otherwise, \tcode{end(E)} if its type \tcode{S} meets the
  syntactic requirements of
  \tcode{Sentinel<\brk{}S, decltype(\brk{}ranges::\brk{}begin(E))>()} with overload
  resolution performed in a context that includes the declaration
  \tcode{void end(auto\&) = delete;} and does not include
  a declaration of \tcode{ranges::end}. If \tcode{Sentinel} is not
  satisfied, the program is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{ranges::end(E)} is ill-formed.
\end{itemize}

\pnum
\remark Whenever \tcode{ranges::end(E)} is a valid expression, the
types of \tcode{ranges::end(E)} and \tcode{ranges::\brk{}begin(E)} satisfy
\tcode{Sentinel}.

\rSec2[iterator.range.cbegin]{\tcode{cbegin}}
\pnum
The name \tcode{cbegin} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::\brk{}cbegin(E)} for some expression \tcode{E} of type \tcode{T}
is equivalent to \tcode{ranges::\brk{}begin((const T\&)(E))}.

\pnum
Use of \tcode{ranges::cbegin(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::cbegin(E)}
behaves similarly to \tcode{std::cbegin(E)} as defined in ISO/IEC 14882 when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::cbegin(E)} is a valid expression, the
type of \tcode{ranges::cbegin(E)} satisfies \tcode{Iterator}. \exitnote

\rSec2[iterator.range.cend]{\tcode{cend}}
\pnum
The name \tcode{cend} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::cend(E)} for some expression \tcode{E} of type \tcode{T}
is equivalent to \tcode{ranges::end((const T\&)(E))}.

\pnum
Use of \tcode{ranges::cend(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::cend(E)}
behaves similarly to \tcode{std::cend(E)} as defined in ISO/IEC 14882 when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::cend(E)} is a valid expression, the
types of \tcode{ranges::cend(E)} and \tcode{ranges::cbegin(E)} satisfy
\tcode{Sentinel}. \exitnote

\rSec2[iterator.range.rbegin]{\tcode{rbegin}}
\pnum
The name \tcode{rbegin} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::rbegin(E)} for some expression \tcode{E} is equivalent
to:

\begin{itemize}
\item
  \tcode{ranges::rbegin((const T\&)(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::rbegin(E)} behaves similarly to \tcode{std::rbegin(E)}
  as defined in ISO/IEC 14882 when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{make_reverse_iterator((E) + extent<T>::value)} if
  \tcode{E} has array type~(\cxxref{basic.compound}) \tcode{T}.

\item
  Otherwise, \tcode{(E).rbegin()} if its type \tcode{I} meets the
  syntactic requirements of \tcode{Iterator<I>()}. If \tcode{Iterator}
  is not satisfied, the program is ill-formed with no diagnostic
  required.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::end(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges::end(E)} have the same
  type \tcode{I} which meets the syntactic requirements of
  \tcode{BidirectionalIterator<I>()}~(\ref{iterators.bidirectional}).
  If \tcode{BidirectionalIterator} is not satisfied, the program
  is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{ranges::rbegin(E)} is ill-formed.
\end{itemize}

\pnum
\remark Whenever \tcode{ranges::rbegin(E)} is a valid expression, the
type of \tcode{ranges::rbegin(E)} satisfies \tcode{Iterator}.

\rSec2[iterator.range.rend]{\tcode{rend}}
\pnum
The name \tcode{rend} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::rend(E)} for some expression \tcode{E} is equivalent to:

\begin{itemize}
\item
  \tcode{ranges::rend((const T\&)(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::rend(E)} behaves similarly to \tcode{std::rend(E)}
  as defined in ISO/IEC 14882 when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{make_reverse_iterator((E) + 0)} if \tcode{E} has
  array type~(\cxxref{basic.compound}).

\item
  Otherwise, \tcode{(E).rend()} if its type \tcode{S} meets the
  syntactic requirements of
  \tcode{Sentinel<\brk{}S, decltype(\brk{}ranges::\brk{}rbegin(E))>()}. If
  \tcode{Sentinel} is not satisfied, the program is ill-formed with
  no diagnostic required.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::begin(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges::end(E)} have the same
  type \tcode{I} which meets the syntactic requirements of
  \tcode{BidirectionalIterator<I>()}~(\ref{iterators.bidirectional}).
  If \tcode{BidirectionalIterator} is not satisfied, the program is
  ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{ranges::rend(E)} is ill-formed.
\end{itemize}

\pnum
\remark Whenever \tcode{ranges::rend(E)} is a valid expression, the
types of \tcode{ranges::rend(E)} and \tcode{ranges::rbegin(E)} satisfy
\tcode{Sentinel}.

\rSec2[iterator.range.crbegin]{\tcode{crbegin}}
\pnum
The name \tcode{crbegin} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::\brk{}crbegin(E)} for some expression \tcode{E} of type \tcode{T}
is equivalent to \tcode{ranges::\brk{}rbegin((const T\&)(E))}.

\pnum
Use of \tcode{ranges::crbegin(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::crbegin(E)}
behaves similarly to \tcode{std::crbegin(E)} as defined in ISO/IEC 14882 when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::crbegin(E)} is a valid expression, the
type of \tcode{ranges::crbegin(E)} satisfies \tcode{Iterator}. \exitnote

\rSec2[iterator.range.crend]{\tcode{crend}}
\pnum
The name \tcode{crend} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::crend(E)} for some expression \tcode{E} of type \tcode{T}
is equivalent to \tcode{ranges::rend((const T\&)(E))}.

\pnum
Use of \tcode{ranges::crend(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::crend(E)}
behaves similarly to \tcode{std::crend(E)} as defined in ISO/IEC 14882 when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::crend(E)} is a valid expression, the
types of \tcode{ranges::crend(E)} and \tcode{ranges::crbegin(E)} satisfy
\tcode{Sentinel}. \exitnote
} %%\color{newclr}

{\color{newclr}
\rSec1[range.primitives]{Range primitives}
}

{\color{oldclr}
\indexlibrary{\idxcode{size}}%
\begin{itemdecl}
template <_Auto C> auto size(const C& c) -> decltype(c.size());
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{c.size()}.
\end{itemdescr}

\begin{itemdecl}
template <_Auto T, size_t N> constexpr size_t size(T (&array)[N]) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{N}.
\end{itemdescr}

\begin{itemdecl}
template <_Auto E> constexpr size_t size(initializer_list<E> il) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum \returns \tcode{il.size()}.
\end{itemdescr}
} %%\color{oldclr}

{\color{newclr}
\indexlibrary{\idxcode{distance(R\&\& r)}}%
\begin{itemdecl}
@\oldtxt{Range\{R\}}\newtxt{template <Range R>}@
@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<@\oldtxt{IteratorType}\newtxt{iterator_t}@<R>> distance(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to: \tcode{return ranges\oldtxt{_v1}::distance(\newtxt{ranges::}begin(r), \newtxt{ranges::}end(r));}
\end{itemdescr}

\indexlibrary{\idxcode{distance(R\&\& r)}}%
\begin{itemdecl}
@\oldtxt{SizedRange\{R\}}\newtxt{template <SizedRange R>}@
@\oldtxt{DifferenceType}\newtxt{difference_type_t}@<@\oldtxt{IteratorType}\newtxt{iterator_t}@<R>> distance(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum \effects Equivalent to: \tcode{return \newtxt{ranges::}size(r);}
\end{itemdescr}

\rSec2[range.primitives.size]{\tcode{size}}
\pnum
The name \tcode{size} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::size(E)} for some expression \tcode{E} with type
\tcode{T} is equivalent to:

\begin{itemize}
\item
  \tcode{extent<T>::value} if \tcode{T} is an array
  type~(\cxxref{basic.compound}).

\item
  Otherwise, \tcode{((const T\&)(E)).size()} if its type \tcode{I}
  satisfies \tcode{Integral<I>()} and
  \tcode{disable_\-sized_\-range<T>}~(\ref{ranges.sized}) is
  \tcode{false}.

\item
  Otherwise, \tcode{size((const T\&)(E))} if its type \tcode{I}
  satisfies \tcode{Integral<I>()} with overload resolution
  performed in a context that includes the declaration
  \tcode{void size(const auto\&) = delete;} and does not include
  a declaration of \tcode{ranges::size}, and
  \tcode{disable_\-sized_\-range<T>} is \tcode{false}.

\item
  Otherwise,
  \tcode{ranges::cend(E) - ranges::cbegin(E)}, except that \tcode{E}
  is only evaluated once, if the types \tcode{I} and \tcode{S} of
  \tcode{ranges::cbegin(E)} and \tcode{ranges::cend(E)} meet the
  syntactic requirements of
  \tcode{SizedSentinel<S, I>()}~(\ref{iterators.sizedsentinel}).
  If \tcode{SizedSentinel} is not satisfied, the program is
  ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{ranges::size(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::size(E)} is a valid expression, the
type of \tcode{ranges::size(E)} satisfies \tcode{Integral}. \exitnote

\rSec2[range.primitives.empty]{\tcode{empty}}
\pnum
The name \tcode{empty} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::empty(E)} for some expression \tcode{E} is
equivalent to:

\begin{itemize}
\item
  \tcode{bool((E).empty())} if it is valid.

\item
  Otherwise, \tcode{ranges::size(E) != 0} if it is valid.

\item
  Otherwise, \tcode{bool(ranges::begin(E) != ranges::end(E))},
  except that \tcode{E} is only evaluated once.

\item
  Otherwise, \tcode{ranges::empty(E)} is ill-formed.
\end{itemize}

\pnum
\remark Whenever \tcode{ranges::empty(E)} is a valid expression, it
has type \tcode{bool}.

\rSec2[range.primitives.data]{\tcode{data}}
\pnum
The name \tcode{data} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::data(E)} for some expression \tcode{E} is
equivalent to:

\begin{itemize}
\item
  \tcode{ranges::data((const T\&)(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated. \enternote
  This deprecated usage exists so that \tcode{ranges::data(E)} behaves
  similarly to \tcode{std::data(E)} as defined in the \Cpp Working
  Paper when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{(E).data()} if it has pointer to object type.

\item
  Otherwise, \tcode{ranges::begin(E)} if it has pointer to object type.

\item
  Otherwise, \tcode{ranges::data(E)} is ill-formed.
\end{itemize}

\pnum
\remark Whenever \tcode{ranges::data(E)} is a valid expression, it
has pointer to object type.

\rSec2[range.primitives.cdata]{\tcode{cdata}}
\pnum
The name \tcode{cdata} denotes a customization point
object~(\ref{customization.point.object}). The effect of the expression
\tcode{ranges::cdata(E)} for some expression \tcode{E} of type \tcode{T}
is equivalent to \tcode{ranges::data((const T\&)(E))}.

\pnum
Use of \tcode{ranges::cdata(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::cdata(E)}
has behavior consistent with \tcode{ranges::data(E)} when \tcode{E} is
an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::cdata(E)} is a valid expression, it
has pointer to object type. \exitnote
} %% color{newclr}
