%!TEX root = Dxxxx.tex

\setcounter{chapter}{9}
\rSec0[ranges]{Ranges library}

\ednote{To the section ``Header \tcode{<experimental/ranges/range>} synopsis''
10.3 [range.synopsis], add the following:}

\begin{codeblock}
// \ref{ranges.view_interface}:
template <class D>
class view_interface;

// \ref{ranges.iterator_range}:
template <Iterator I, Sentinel<I> S = I>
class iterator_range;

// \ref{ranges.sized_iterator_range}:
template <Iterator I, Sentinel<I> S = I>
class sized_iterator_range;

// \ref{ranges.adaptors.all}:
namespace view { inline constexpr @\unspec@ all = @\unspec@; }

template <Range R>
    requires std::is_lvalue_reference_v<Rng> || View<decay_t<Rng>>
using all_view = decay_t<decltype(view::all(declval<R>()))>;

// \ref{ranges.adaptors.filter}:
template <InputRange R, IndirectUnaryPredicate<iterator_t<R>> Pred>
  requires View<R>
class filter_view;

namespace view { inline constexpr @\unspec@ filter = @\unspec@; }

// \ref{ranges.adaptors.transform}:
template <InputRange R, CopyConstructible F>
  requires View<R> && Invocable<F&, reference_t<iterator_t<R>>>
class transform_view;

namespace view { inline constexpr @\unspec@ transform = @\unspec@; }
\end{codeblock}

\ednote{After Ranges TS subclause 10.6 [ranges.requirements], insert a new subclause
10.7, ``Range utilities'' with stable name [ranges.utilities]}

\setcounter{section}{6}
\rSec1[ranges.utilities]{Range utilities}

\pnum
The components in this section are general utilities for representing and manipulating
ranges.

\rSec2[ranges.view_interface]{View interface}

\pnum
The \tcode{view_interface} is a helper for defining \tcode{View}-like types that offer a
container-like interface. It is parameterized with the type that inherits from it.

\indexlibrary{\idxcode{view_interface}}%
\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1
{
  // \expos
  template <Range Rng>
  struct @\textit{range-common-iterator-impl}@ {
    using type = common_iterator<iterator_t<Rng>, sentinel_t<Rng>>;
  };
  template <BoundedRange Rng>
  struct @\textit{range-common-iterator-impl}@<Rng> {
    using type = iterator_t<Rng>;
  };
  template <Range Rng>
    using @\textit{range-common-iterator}@ =
      typename @\textit{range-common-iterator-impl}@<Rng>::type;

  template <class D>
  class view_interface : view_base {
  private:
    constexpr D& derived() noexcept { // \expos
      return static_cast<D&>(*this);
    }
    constexpr const D& derived() const noexcept { // \expos
      return static_cast<const D&>(*this);
    }
  public:
    constexpr bool empty() const requires ForwardRange<const D>;
    constexpr explicit operator bool() const requires ForwardRange<const D>;
    constexpr bool operator!() const requires ForwardRange<const D>;
  
    template <ForwardRange R = const D>
    constexpr auto size() const
      requires SizedSentinel<sentinel_t<R>, iterator_t<R>>;
  
    constexpr decltype(auto) front() requires ForwardRange<D>;
    constexpr decltype(auto) front() const requires ForwardRange<const D>;
  
    constexpr decltype(auto) back()
      requires BidirectionalRange<D> && BoundedRange<D>;
    constexpr decltype(auto) back() const
      requires BidirectionalRange<const D> && BoundedRange<const D>;
  
    template <RandomAccessRange R = D>
      constexpr decltype(auto) operator[](difference_type_t<iterator_t<R>> n);
    template <RandomAccessRange R = const D>
      constexpr decltype(auto) operator[](difference_type_t<iterator_t<R>> n) const;
  
    template <RandomAccessRange R = D>
        requires SizedRange<R>
      constexpr decltype(auto) at(difference_type_t<iterator_t<R>> n);
    template <RandomAccessRange R = const D>
        requires SizedRange<R>
      constexpr decltype(auto) at(difference_type_t<iterator_t<R>> n) const;
  
    template <ForwardRange C, InputRange R = const D>
        requires !View<C> && MoveConstructible<C> &&
          ConvertibleTo<value_type_t<iterator_t<R>>, value_type_t<iterator_t<C>>> &&
          Constructible<C, @\textit{range-common-iterator}@<R>, @\textit{range-common-iterator}@<R>>
      operator C () const;
  };
}}}}
\end{codeblock}

\rSec3[ranges.view_interface.accessors]{\tcode{view_interface} accessors}

\indexlibrary{\idxcode{empty}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr bool empty() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{ranges::begin(derived()) == ranges::end(derived())}.
\end{itemdescr}

\indexlibrary{\idxcode{operator bool}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr explicit operator bool() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{!empty()}.
\end{itemdescr}

\indexlibrary{\idxcode{operator!}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr bool operator!() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{empty()}.
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{view_interface}}%
\begin{itemdecl}
template <ForwardRange R = const D>
constexpr auto size() const
  requires SizedSentinel<sentinel_t<R>, iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{ranges::end(derived()) - ranges::begin(derived())}.
\end{itemdescr}

\indexlibrary{\idxcode{front}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr decltype(auto) front() requires ForwardRange<D>;
constexpr decltype(auto) front() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{!empty()}.

\pnum
\returns Equivalent to \tcode{*ranges::begin(derived())}.
\end{itemdescr}

\indexlibrary{\idxcode{back}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr decltype(auto) back()
  requires BidirectionalRange<D> && BoundedRange<D>;
constexpr decltype(auto) back() const
  requires BidirectionalRange<const D> && BoundedRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{!empty()}.

\pnum
\returns Equivalent to \tcode{*prev(ranges::end(derived()))}.
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{view_interface}}%
\begin{itemdecl}
template <RandomAccessRange R = D>
  constexpr decltype(auto) operator[](difference_type_t<iterator_t<R>> n);
template <RandomAccessRange R = const D>
  constexpr decltype(auto) operator[](difference_type_t<iterator_t<R>> n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{ranges::begin(derived()) + n} is well-formed.

\pnum
\returns Equivalent to \tcode{ranges::begin(derived())[n]}.
\end{itemdescr}

\indexlibrary{\idxcode{at}!\idxcode{view_interface}}%
\begin{itemdecl}
template <RandomAccessRange R = D>
    requires SizedRange<R>
  constexpr decltype(auto) at(difference_type_t<iterator_t<R>> n);
template <RandomAccessRange R = const D>
    requires SizedRange<R>
  constexpr decltype(auto) at(difference_type_t<iterator_t<R>> n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{ranges::begin(derived())[n]}.

\pnum
\throws \tcode{std::out_of_range} if \tcode{n < 0 || n >= ranges::size(derived())}.
\end{itemdescr}

\indexlibrary{\idxcode{at}!\idxcode{view_interface}}%
\begin{itemdecl}
template <ForwardRange C, InputRange R = const D>
    requires !View<C> && MoveConstructible<C> &&
        ConvertibleTo<value_type_t<iterator_t<R>>, value_type_t<iterator_t<C>>> &&
        Constructible<C, @\textit{range-common-iterator}@<R>, @\textit{range-common-iterator}@<R>>
  operator C () const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
using I = @\textit{range-common-iterator}@<R>;
return C{I{ranges::begin(derived())}, I{ranges::end(derived())}};
\end{codeblock}
\end{itemdescr}

\rSec2[ranges.iterator.ranges]{Iterator ranges}

\pnum
The \tcode{iterator_range} and \tcode{sized_iterator_range} classes bundle together an
iterator and a sentinel into a single object that satisfies the \tcode{View} concept.
\tcode{sized_iterator_range} additionally stores the range's size and satisfies the
\tcode{SizedRange} concept.

\rSec3[ranges.iterator_range]{\tcode{iterator_range}}

\indexlibrary{\idxcode{iterator_range}}%
\begin{codeblock}
template <Iterator I, Sentinel<I> S = I>
class iterator_range
  : tagged_pair<tag::begin(I), tag::end(S)>,
    view_interface<iterator_range<I, S>> {
public:
  using iterator = I;
  using sentinel = S;

  iterator_range() = default;
  constexpr iterator_range(I i, S s);

  template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
    constexpr iterator_range(iterator_range<X, Y> r);
  template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
    constexpr iterator_range(pair<X, Y> r);

  template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
    constexpr iterator_range& operator=(iterator_range<X, Y> r);

  template <Constructible<const I&> X, Constructible<const S&> Y>
    constexpr operator pair<X, Y>() const;

  constexpr bool empty() const;
};
\end{codeblock}

\rSec4[ranges.iterator_range.ctors]{\tcode{iterator_range} constructors}

\indexlibrary{\idxcode{iterator_range}!\idxcode{iterator_range}}%
\begin{itemdecl}
constexpr iterator_range(I i, S s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{tagged_pair<tag::begin(I), tag::end(S)>} with
\tcode{i} and \tcode{s}.
\end{itemdescr}

\indexlibrary{\idxcode{iterator_range}!\idxcode{iterator_range}}%
\begin{itemdecl}
template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
  constexpr iterator_range(iterator_range<X, Y> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{tagged_pair<tag::begin(I), tag::end(S)>} with
\tcode{r.begin()} and \tcode{r.end()}.
\end{itemdescr}

\indexlibrary{\idxcode{iterator_range}!\idxcode{iterator_range}}%
\begin{itemdecl}
template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
  constexpr iterator_range(pair<X, Y> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{tagged_pair<tag::begin(I), tag::end(S)>} with
\tcode{r.first} and \tcode{r.second}.
\end{itemdescr}

\rSec4[ranges.iterator_range.ops]{\tcode{iterator_range} operators}

\indexlibrary{\idxcode{operator=}!\idxcode{iterator_range}}%
\begin{itemdecl}
template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
  constexpr iterator_range& operator=(iterator_range<X, Y> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
this->first = r.begin();
this->second = r.end();
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator pair}!\idxcode{iterator_range}}%
\begin{itemdecl}
template <Constructible<const I&> X, Constructible<const S&> Y>
  constexpr operator pair<X, Y>() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{\{this->first, this->second\}}.
\end{itemdescr}

\rSec4[ranges.iterator_range.accessors]{\tcode{iterator_range} accessors}

\indexlibrary{\idxcode{empty}!\idxcode{iterator_range}}%
\begin{itemdecl}
constexpr bool empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{this->first == this->second}.
\end{itemdescr}


\rSec3[ranges.sized_iterator_range]{\tcode{sized_iterator_range}}

\indexlibrary{\idxcode{sized_iterator_range}}%
\begin{codeblock}
template <Iterator I, Sentinel<I> S = I>
class sized_iterator_range
  : view_interface<sized_iterator_range<I, S>> {
private:
  iterator_range<I, S> rng_; // \expos
  difference_type_t<I> size_; // \expos
public:
  using iterator = I;
  using sentinel = S;

  sized_iterator_range() = default;
  constexpr sized_iterator_range(I i, S s, difference_type_t<I> n);

  template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
    constexpr sized_iterator_range(pair<X, Y> r, difference_type_t<I> n);
  template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
    constexpr sized_iterator_range(iterator_range<X, Y> r, difference_type_t<I> n);
  template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
    constexpr sized_iterator_range(sized_iterator_range<X, Y> r);

  template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
    constexpr sized_iterator_range& operator=(sized_iterator_range<X, Y> r);

  template <Constructible<const I&> X, Constructible<const S&> Y>
    constexpr operator pair<X, Y>() const;
  template <Constructible<const I&> X, Constructible<const S&> Y>
    constexpr operator iterator_range<X, Y>() const;

  constexpr operator iterator_range<I, S> const &() const & noexcept;

  constexpr I begin() const;
  constexpr S end() const;
  constexpr difference_type_t<I> size() const noexcept;
};
\end{codeblock}

\rSec4[ranges.sized_iterator_range.ctors]{\tcode{sized_iterator_range} constructors}

\indexlibrary{\idxcode{sized_iterator_range}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
constexpr sized_iterator_range(I i, S s, difference_type_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{distance(i, s) == n}.

\pnum
\effects Initializes \tcode{rng_} with \tcode{i} and \tcode{s}, and initializes
\tcode{size_} with \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{sized_iterator_range}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
  constexpr sized_iterator_range(pair<X, Y> r, difference_type_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{distance(r.first, r.second) == n}.

\pnum
\effects Initializes \tcode{rng_} with \tcode{r.first} and \tcode{r.second}, and
initializes \tcode{size_} with \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{sized_iterator_range}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
  constexpr sized_iterator_range(iterator_range<X, Y> r, difference_type_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{distance(r.begin(), r.end()) == n}.

\pnum
\effects Initializes \tcode{rng_} with \tcode{r.begin()} and \tcode{r.end()}, and
initializes \tcode{size_} with \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{sized_iterator_range}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
  constexpr sized_iterator_range(sized_iterator_range<X, Y> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{rng_} with \tcode{r.begin()} and \tcode{r.end()}, and
initializes \tcode{size_} with \tcode{r.size()}.
\end{itemdescr}

\rSec4[ranges.sized_iterator_range.ops]{\tcode{sized_iterator_range} operators}

\indexlibrary{\idxcode{operator=}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
template <ConvertibleTo<I> X, ConvertibleTo<S> Y>
  constexpr sized_iterator_range& operator=(sized_iterator_range<X, Y> r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
rng_.first = r.begin();
rng_.second = r.end();
size_ = r.size();
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator pair}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
template <Constructible<const I&> X, Constructible<const S&> Y>
  constexpr operator pair<X, Y>() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{\{rng_.first, rng_.second\}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator iterator_range}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
template <Constructible<const I&> X, Constructible<const S&> Y>
  constexpr operator iterator_range<X, Y>() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{\{rng_.first, rng_.second\}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator iterator_range}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
constexpr operator iterator_range<I, S> const &() const & noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{rng_}.
\end{itemdescr}

\rSec4[ranges.sized_iterator_range.accessors]{\tcode{sized_iterator_range} accessors}

\indexlibrary{\idxcode{begin}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
constexpr I begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{rng_.first}.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
constexpr S end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{rng_.second}.
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{sized_iterator_range}}%
\begin{itemdecl}
constexpr difference_type_t<I> size() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns Equivalent to \tcode{size_}.
\end{itemdescr}

\rSec1[ranges.adaptors]{Range adaptors}

\pnum
This section defines \techterm{range adaptors}, which are utilities that transform a \tcode{Range}
into a \tcode{View} with custom behaviors. These adaptors can be chained to create pipelines of
range transformations that evaluate lazily as the resulting view is iterated.

\pnum
Range adaptors are declared in namespace \tcode{std::experimental::ranges::v1::view}.

\pnum
The bitwise or operator is overloaded for the purpose of creating adaptor chain pipelines. The
adaptors also support function call syntax with equivalent semantics.

\pnum
\enterexample
\begin{codeblock}
std::vector<int> ints{0,1,2,3,4,5};
auto even = [](int i){ return 0 == i % 2; };
auto square = [](int i) { return i * i; };
for (int i : ints | view::filter(even) | view::transform(square)) {
  cout << i << ' '; // prints: 0 4 16
}
\end{codeblock}
\exitexample

\rSec2[ranges.adaptor.object]{Range adaptor objects}

\pnum
A \techterm{range adaptor object} is a customization point object~(\cxxref{??}) that accepts a
\tcode{Range} as its first argument and that returns a \tcode{View}. If the adaptor accepts only one
argument, then the following alternate syntaxes are semantically equivalent:

\begin{codeblock}
@\textit{adaptor}@(rng)
rng | @\textit{adaptor}@
\end{codeblock}

If the adaptor accepts more than one argument, then the following alternate syntaxes are
semantically equivalent:

\begin{codeblock}
@\textit{adaptor}@(rng, args...)
rng | @\textit{adaptor}@(args...)
\end{codeblock}

\pnum
The first argument to a range adaptor shall be either an lvalue \tcode{Range} or a \tcode{View}.

\rSec2[ranges.adaptor.semiregular_wrapper]{Semiregular wrapper}

\pnum
Many of the types in this section are specified in terms of an exposition-only helper
called \tcode{\textit{semiregular}<T>}. This type behaves exactly like \tcode{optional<T>}
with the following exceptions:

\begin{itemize}
\item \tcode{\textit{semiregular}<T>} constrains its argument with \tcode{CopyConstructible<T>}.
\item If \tcode{T} satisfies \tcode{DefaultConstructble}, the default constructor of
\tcode{\textit{semiregular}<T>} is equivalent to:
\begin{codeblock}
constexpr @\textit{semiregular}@()
    noexcept(is_nothrow_default_constructible<T>::value)
  : @\textit{semiregular}@{in_place} {}
\end{codeblock}
\item If the syntactic requirements of \tcode{Assignable<T\&, const T\&>} are not satisfied, the
copy assignment operator is equivalent to:
\begin{codeblock}
constexpr @\textit{semiregular}@& operator=(const @\textit{semiregular}@& that)
    noexcept(is_nothrow_copy_constructible<T>::value) {
  if (that) emplace(*that)
  else reset();
  return *this;
}
\end{codeblock}
\item If the syntactic requirements of \tcode{Assignable<T\&, T>} are not satisfied, the
move assignment operator is equivalent to:
\begin{codeblock}
constexpr @\textit{semiregular}@& operator=(@\textit{semiregular}@&& that)
    noexcept(is_nothrow_move_constructible<T>::value) {
  if (that) emplace(std::move(*that))
  else reset();
  return *this;
}
\end{codeblock}
\end{itemize}

\rSec2[ranges.adaptors.all]{\tcode{view::all}}

\pnum
The purpose of \tcode{view::all} is to return a \tcode{View} that includes all
elements of the \tcode{Range} passed in.

\pnum
The name \tcode{view::any} denotes a range adaptor
object~(\ref{ranges.adaptor.object}). Given an expression \tcode{E} and a type \tcode{T}
such that \tcode{decltype((E))} is \tcode{T}, then the expression \tcode{view::all(E)}
for some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item \tcode{\textit{DECAY_COPY}(E)} if the type of \tcode{E} satisfies concepts
  \tcode{View}.
\item \tcode{sized_iterator_range<iterator_t<T>, sentinel_t<T>{>}\{ranges::begin(E), ranges::end(E), ranges::size(E)\}}
  if \tcode{E} is an lvalue and has a type that satisfies concept \tcode{SizedRange}.
\item \tcode{iterator_range<iterator_t<T>, sentinel_t<T>{>}\{ranges::begin(E), ranges::end(E)\}}
  if \tcode{E} is an lvalue and has a type that satisfies concept \tcode{Range}.
\item Otherwise, \tcode{view::all(E)} is ill-formed.
\end{itemize}

\rSec2[ranges.adaptors.filter_view]{Class template \tcode{filter_view}}

\pnum
The purpose of \tcode{filter_view} is to present a view of an underlying
sequence without the elements that fail to satisfy a predicate.

\pnum
\enterexample
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4, 5, 6 };
filter_view evens{is, [](int i) { return 0 == i % 2; }};
for (int i : evens)
  cout << i << ' '; // prints: 0 2 4 6
\end{codeblock}
\exitexample

\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template <InputRange R, IndirectUnaryPredicate<iterator_t<R>> Pred>
    requires View<R>
  class filter_view : view_interface<filter_view<R, Pred>> {
  private:
    R base_; // \expos
    @\textit{semiregular}@<Pred> pred_; // \expos
  public:
    filter_view() = default;
    constexpr filter_view(R base, Pred pred);
    template <InputRange O>
        requires Constructible<R, all_view<O>>
      constexpr filter_view(O&& o, Pred pred);

    R base() const;

    class iterator;
    class sentinel;

    constexpr iterator begin();
    constexpr sentinel end();
    constexpr iterator end() requires BoundedRange<R>;
  };

  template <class R, class Pred>
  filter_view(R&&, Pred) -> filter_view<all_view<R>, Pred>;
}}}}
\end{codeblock}

\rSec3[ranges.adaptors.filter_view.ops]{\tcode{filter_view} operations}
\rSec4[ranges.adaptors.filter_view.ctor]{\tcode{filter_view} constructors}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr filter_view(R base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and initializes
\tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
template <InputRange O>
    requires Constructible<R, all_view<O>>
  constexpr filter_view(O&& o, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}
and initializes \tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\rSec4[ranges.adaptors.filter_view.conv]{\tcode{filter_view} conversion}

\indexlibrary{\idxcode{base}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{base_}.
\end{itemdescr}

\rSec4[ranges.adaptors.filter_view.begin]{\tcode{filter_view} range begin}

\indexlibrary{\idxcode{begin}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr iterator begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return {*this, ranges::find_if(base_, ref(*pred_))};
\end{codeblock}

\pnum
\remarks In order to provide the amortized constant time complexity required by
the \tcode{Range} concept, this function caches the result within the
\tcode{filter_view} for use on subsequent calls.
\end{itemdescr}

\rSec4[ranges.adaptors.filter_view.end]{\tcode{filter_view} range end}

\indexlibrary{\idxcode{end}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr sentinel end();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{sentinel\{*this\}}.
\end{itemdescr}

\begin{itemdecl}
constexpr iterator end() requires BoundedRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{iterator\{*this, ranges::end(base_)\}}.
\end{itemdescr}

\rSec3[ranges.adaptors.filter_view.iterator]{Class template \tcode{filter_view::iterator}}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view}}%
\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template <class R, class Pred>
  class filter_view<R, Pred>::iterator {
  private:
    iterator_t<R> current_ {}; // \expos
    filter_view* parent_ = nullptr; // \expos
  public:
    using iterator_category = @\seebelow@;
    using value_type = value_type_t<iterator_t<R>>;
    using difference_type = difference_type_t<iterator_t<R>>;

    iterator() = default;
    constexpr iterator(filter_view& parent, iterator_t<R> current);

    constexpr iterator_t<R> base() const;
    constexpr reference_t<iterator_t<R>> operator*() const;

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires ForwardRange<R>;

    constexpr iterator& operator--() requires BidirectionalRange<R>;
    constexpr iterator operator--(int) requires BidirectionalRange<R>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<R>>;
    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<R>>;

    friend constexpr rvalue_reference_t<iterator_t<R>> iter_move(const iterator& i)
      noexcept(@\seebelow@);
    friend constexpr void iter_swap(const iterator& x, const iterator& y)
      noexcept(@\seebelow@);
  };
}}}}
\end{codeblock}

\pnum
The type \tcode{filter_view<R>::iterator::iterator_category} is defined as follows:
\begin{itemize}
\item If \tcode{R} satisfies \tcode{BidirectionalRange<R>}, then \tcode{iterator_category}
is an alias for \tcode{ranges::bidirectional_iterator_tag}.
\item If \tcode{R} satisfies \tcode{ForwardRange<R>}, then \tcode{iterator_category}
is an alias for \tcode{ranges::forward_iterator_tag}.
\item Otherwise, \tcode{iterator_category} is an alias for
\tcode{ranges::input_iterator_tag}.
\end{itemize}

\rSec4[ranges.adaptors.filter_view.iterator]{\tcode{filter_view::iterator} operations}
\rSec5[ranges.adaptors.filter_view.iterator.ctor]{\tcode{filter_view::iterator} constructors}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator(filter_view& parent, iterator_t<R> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{current} and \tcode{parent_}
with \tcode{\&parent}.
\end{itemdescr}

\rSec5[ranges.adaptors.filter_view.iterator.conv]{\tcode{filter_view::iterator} conversion}

\indexlibrary{\idxcode{base}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator_t<R> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current_}.
\end{itemdescr}

\rSec5[ranges.adaptors.filter_view.iterator.op.star]{\tcode{filter_view::iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr reference_t<iterator_t<R>> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{*current_}.
\end{itemdescr}

\rSec5[ranges.adaptors.filter_view.iterator.op.inc]{\tcode{filter_view::iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ = find_if(++current_, ranges::end(parent_->base_), ref(*parent_->pred_));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{(void)++*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator operator++(int) requires ForwardRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[ranges.adaptors.filter_view.iterator.op.dec]{\tcode{filter_view::iterator::operator\dcr}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator--() requires BidirectionalRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
do
  --current_;
while(invoke(*parent_->pred_, *current_));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator operator--(int) requires BidirectionalRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[ranges.adaptors.filter_view.iterator.op.comp]{\tcode{filter_view::iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.current_ == y.current_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\rSec4[ranges.adaptors.filter_view.iterator.nonmember]{\tcode{filter_view::iterator} non-member functions}

\indexlibrary{\idxcode{iter_move}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr rvalue_reference_t<iterator_t<R>> iter_move(const iterator& i)
  noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ranges::iter_move(i.current_)}.

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
noexcept(ranges::iter_move(i.current_))
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr void iter_swap(const iterator& x, const iterator& y)
  noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(x.current_, y.current_)}.

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
noexcept(ranges::iter_swap(x.current_, y.current_))
\end{codeblock}
\end{itemdescr}

\rSec3[ranges.adaptors.filter_view.sentinel]{Class template \tcode{filter_view::sentinel}}

\indexlibrary{\idxcode{sentinel}!\idxcode{filter_view}}%
\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template <class R, class Pred>
  class filter_view<R, Pred>::sentinel {
  private:
    sentinel_t<R> end_; // \expos
  public:
    sentinel() = default;
    explicit constexpr sentinel(filter_view& parent);

    constexpr sentinel_t<R> base() const;

    friend constexpr bool operator==(const iterator& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator& y);
    friend constexpr bool operator!=(const iterator& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator& y);
  };
}}}}
\end{codeblock}

\rSec4[ranges.adaptors.filter_view.sentinel.ctor]{\tcode{filter_view::sentinel} constructors}

\indexlibrary{\idxcode{sentinel}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
explicit constexpr sentinel(filter_view& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{ranges::end(parent)}.
\end{itemdescr}

\rSec4[ranges.adaptors.filter_view.sentinel.conv]{\tcode{filter_view::sentinel} conversion}

\indexlibrary{\idxcode{base}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
constexpr sentinel_t<R> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{end_}.
\end{itemdescr}

\rSec4[ranges.adaptors.filter_view.sentinel.comp]{\tcode{filter_view::sentinel} comparison}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.current_ == y.end_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y == x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y == x)}.
\end{itemdescr}


\rSec2[ranges.adaptors.filter]{\tcode{view::filter}}

\pnum
The name \tcode{view::filter} denotes a range adaptor
object~(\ref{ranges.adaptor.object}). Let \tcode{E} and \tcode{P} be expressions such
that types \tcode{T} and \tcode{U} are \tcode{decltype((E))} and \tcode{decltype((P))}
respectively. Then the expression \tcode{view::filter(E, P)} is expression-equivalent to:

\begin{itemize}
\item \tcode{filter_view\{E, P\}} if
\tcode{InputRange<T> \&\& IndirectUnaryPredicate<decay_t<U>, iterator_t<T>{>}}
is satisfied.
\item Otherwise, \tcode{view::filter(E, P)} is ill-formed.
\end{itemize}

\rSec2[ranges.adaptors.transform_view]{Class template \tcode{transform_view}}

\pnum
The purpose of \tcode{transform_view} is to present a view of an underlying
sequence after applying a transformation function to each element.

\pnum
\enterexample
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4 };
transform_view squares{is, [](int i) { return i * i; }};
for (int i : squares)
  cout << i << ' '; // prints: 0 1 4 9 16
\end{codeblock}
\exitexample

\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template <InputRange R, CopyConstructible F>
    requires View<R> && Invocable<F&, reference_t<iterator_t<R>>>
  class transform_view : view_interface<transform_view<R, F>> {
  private:
    R base_; // \expos
    @\textit{semiregular}@<F> fun_; // \expos
    template <bool Const>
      struct @\xname{iterator}@; // \expos
    template <bool Const>
      struct @\xname{sentinel}@; // \expos
  public:
    transform_view() = default;
    constexpr transform_view(R base, F fun);
    template <InputRange O>
      requires Constructible<R, all_view<O>>
    constexpr transform_view(O&& o, F fun);

    using iterator = @\xname{iterator}@<false>;
    using const_iterator = @\xname{iterator}@<true>;
    using sentinel = @\xname{sentinel}@<false>;
    using const_sentinel = @\xname{sentinel}@<true>;

    R base() const;

    constexpr iterator begin();
    constexpr const_iterator begin() const
      requires View<const R> && Invocable<const F&, reference_t<iterator_t<const R>>>;

    constexpr sentinel end();
    constexpr const_sentinel end() const
      requires View<const R> && Invocable<const F&, reference_t<iterator_t<const R>>>;
    constexpr iterator end() requires BoundedRange<R>;
    constexpr const_iterator end() const
      requires BoundedRange<R> && View<const R> &&
        Invocable<const F&, reference_t<iterator_t<const R>>>;

    constexpr auto size() requires SizedRange<R>;
    constexpr auto size() const requires SizedRange<const R>;
  };

  template <class R, class F>
  transform_view(R&& r, F fun) -> transform_view<all_view<R>, F>;
}}}}
\end{codeblock}

\rSec3[ranges.adaptors.transform_view.ops]{\tcode{transform_view} operations}
\rSec4[ranges.adaptors.transform_view.ctor]{\tcode{transform_view} constructors}

\indexlibrary{\idxcode{transform_view}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr transform_view(R base, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and initializes
\tcode{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\indexlibrary{\idxcode{transform_view}!\idxcode{transform_view}}%
\begin{itemdecl}
template <InputRange O>
  requires Constructible<R, all_view<O>>
constexpr transform_view(O&& o, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}
and initializes \tcode{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\rSec4[ranges.adaptors.transform_view.conv]{\tcode{transform_view} conversion}

\indexlibrary{\idxcode{base}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{base_}.
\end{itemdescr}

\rSec4[ranges.adaptors.transform_view.begin]{\tcode{transform_view} range begin}

\indexlibrary{\idxcode{begin}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr iterator begin();
constexpr const_iterator begin() const
  requires View<const R> && Invocable<const F&, reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return {*this, ranges::begin(base_)};
\end{codeblock}
\end{itemdescr}

\rSec4[ranges.adaptors.transform_view.end]{\tcode{transform_view} range end}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr sentinel end();
constexpr const_sentinel end() const
  requires View<const R> && Invocable<const F&, reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{sentinel\{ranges::end(base_)\}} and
\tcode{const_sentinel\{ranges::end(base_)\}} for the first and second overload,
respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr iterator end() requires BoundedRange<R>;
constexpr const_iterator end() const
  requires BoundedRange<R> && View<const R> &&
    Invocable<const F&, reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return {*this, ranges::end(base_)};
\end{codeblock}
\end{itemdescr}

\rSec4[ranges.adaptors.transform_view.size]{\tcode{transform_view} range size}

\indexlibrary{\idxcode{size}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr auto size() requires SizedRange<R>;
constexpr auto size() const requires SizedRange<const R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{ranges::size(base_)}.
\end{itemdescr}

\rSec3[ranges.adaptors.transform_view.iterator]{Class template \tcode{transform_view::\xname{iterator}}}

\pnum
\tcode{transform_view<R, F>::\xname{iterator}} is an exposition-only type.

\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template <class R, class F>
    template <bool Const>
      class transform_view<R, F>::@\xname{iterator}@ { // \expos
      private:
        using Parent = conditional_t<Const, const transform_view, transform_view>;
        using Base = conditional_t<Const, const R, R>;
        iterator_t<Base> current_ {};
        Parent* parent_ = nullptr;
      public:
        using iterator_category = iterator_category_t<iterator_t<Base>>;
        using value_type = remove_const_t<remove_reference_t<
            std::invoke_result_t<F&, reference_t<iterator_t<Base>>>>>;
        using difference_type = difference_type_t<iterator_t<Base>>;

        @\xname{iterator}@() = default;
        constexpr @\xname{iterator}@(Parent& parent, iterator_t<Base> current);
        constexpr @\xname{iterator}@(@\xname{iterator}@<!Const> i)
          requires Const && View<R> && ConvertibleTo<iterator_t<R>, iterator_t<const R>>;

        constexpr iterator_t<Base> base() const;
        constexpr decltype(auto) operator*() const;
    
        constexpr @\xname{iterator}@& operator++();
        constexpr void operator++(int);
        constexpr @\xname{iterator}@ operator++(int) requires ForwardRange<Base>;

        constexpr @\xname{iterator}@& operator--() requires BidirectionalRange<Base>;
        constexpr @\xname{iterator}@ operator--(int) requires BidirectionalRange<Base>;

        constexpr @\xname{iterator}@& operator+=(difference_type n)
          requires RandomAccessRange<Base>;
        constexpr @\xname{iterator}@& operator-=(difference_type n)
          requires RandomAccessRange<Base>;
        constexpr decltype(auto) operator[](difference_type n) const
          requires RandomAccessRange<Base>;
        
        friend constexpr bool operator==(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          requires EqualityComparable<iterator_t<Base>>;
        friend constexpr bool operator!=(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          requires EqualityComparable<iterator_t<Base>>;

        friend constexpr bool operator<(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          requires RandomAccessRange<Base>;
        friend constexpr bool operator>(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          requires RandomAccessRange<Base>;
        friend constexpr bool operator<=(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          requires RandomAccessRange<Base>;
        friend constexpr bool operator>=(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          requires RandomAccessRange<Base>;

        friend constexpr @\xname{iterator}@ operator+(@\xname{iterator}@ i, difference_type n)
          requires RandomAccessRange<Base>;
        friend constexpr @\xname{iterator}@ operator+(difference_type n, @\xname{iterator}@ i)
          requires RandomAccessRange<Base>;

        friend constexpr @\xname{iterator}@ operator-(@\xname{iterator}@ i, difference_type n)
          requires RandomAccessRange<Base>;
        friend constexpr difference_type operator-(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          requires RandomAccessRange<Base>;

        friend constexpr decltype(auto) iter_move(const @\xname{iterator}@& i)
          noexcept(@\seebelow@);
        friend constexpr void iter_swap(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
          noexcept(@\seebelow@);
      };
}}}}
\end{codeblock}

\rSec4[ranges.adaptors.transform_view.iterator.op]{\tcode{transform_view::\xname{iterator} operations}}
\rSec5[ranges.adaptors.transform_view.iterator.op.ctor]{\tcode{transform_view::\xname{iterator} constructors}}

\indexlibrary{\idxcode{\xname{iterator}}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr @\xname{iterator}@(Parent& parent, iterator_t<Base> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{current} and
initializes \tcode{parent_} with \tcode{\&parent}. 
\end{itemdescr}

\indexlibrary{\idxcode{\xname{iterator}}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
constexpr @\xname{iterator}@(@\xname{iterator}@<!Const> i)
  requires Const && View<R> && ConvertibleTo<iterator_t<R>, iterator_t<const R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{i.parent_} and \tcode{current_}
with \tcode{i.current_}.
\end{itemdescr}

\rSec5[ranges.adaptors.transform_view.iterator.op.conv]{\tcode{transform_view::\xname{iterator} conversion}}

\indexlibrary{\idxcode{base}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr iterator_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current_}.
\end{itemdescr}

\rSec5[ranges.adaptors.transform_view.iterator.op.star]{\tcode{transform_view::\xname{iterator}::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr decltype(auto) operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{invoke(*parent_->fun_, *current_)}.
\end{itemdescr}

\rSec5[ranges.adaptors.transform_view.iterator.op.inc]{\tcode{transform_view::\xname{iterator}::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr @\xname{iterator}@& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
++current_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
++current_;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr @\xname{iterator}@ operator++(int) requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[ranges.adaptors.transform_view.iterator.op.dec]{\tcode{transform_view::\xname{iterator}::operator\dcr}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr @\xname{iterator}@& operator--() requires BidirectionalRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
--current_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr @\xname{iterator}@ operator--(int) requires BidirectionalRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[ranges.adaptors.transform_view.iterator.op.adv]{\tcode{transform_view::\xname{iterator}} advance}

\indexlibrary{\idxcode{operator+=}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr @\xname{iterator}@& operator+=(difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ += n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
constexpr @\xname{iterator}@& operator-=(difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ -= n;
return *this;
\end{codeblock}
\end{itemdescr}

\rSec5[ranges.adaptors.transform_view.iterator.op.idx]{\tcode{transform_view::\xname{iterator}} index}

\indexlibrary{\idxcode{operator[]}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
constexpr decltype(auto) operator[](difference_type n) const
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return invoke(*parent_->fun_, current_[n]);
\end{codeblock}
\end{itemdescr}

\rSec4[ranges.adaptors.transform_view.iterator.comp]{\tcode{transform_view::\xname{iterator}} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
friend constexpr bool operator==(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  requires EqualityComparable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.current_ == y.current_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
friend constexpr bool operator!=(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  requires EqualityComparable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
friend constexpr bool operator<(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.current_ < y.current_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
friend constexpr bool operator>(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
friend constexpr bool operator<=(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
friend constexpr bool operator>=(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec4[ranges.adaptors.transform_view.iterator.nonmember]{\tcode{transform_view::\xname{iterator}} non-member functions}

\indexlibrary{\idxcode{operator+}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
friend constexpr @\xname{iterator}@ operator+(@\xname{iterator}@ i, difference_type n)
  requires RandomAccessRange<Base>;
friend constexpr @\xname{iterator}@ operator+(difference_type n, @\xname{iterator}@ i)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\xname{iterator}\{*i.parent_, i.current_ + n\}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
friend constexpr @\xname{iterator}@ operator-(@\xname{iterator}@ i, difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\xname{iterator}\{*i.parent_, i.current_ - n\}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{transform_view::\xname{iterator}}}%
\begin{itemdecl}
friend constexpr difference_type operator-(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.current_ - y.current_}.
\end{itemdescr}

\indexlibrary{\idxcode{iter_move}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
friend constexpr decltype(auto) iter_move(const @\xname{iterator}@& i)
  noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If the expression \tcode{*i} is an lvalue, then
\tcode{std::move(*i)}.
\item Otherwise, \tcode{*i}.
\end{itemize}

\pnum
\remarks The expression in the \tcode{noexcept} is equivalent to:
\begin{codeblock}
noexcept(invoke(*i.parent_->fun_, *i.current_))
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{transform_view::\xname{iterator}}}
\begin{itemdecl}
friend constexpr void iter_swap(const @\xname{iterator}@& x, const @\xname{iterator}@& y)
  noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(x.current_, y.current_)}.

\pnum
\remarks The expression in the \tcode{noexcept} is equivalent to:
\begin{codeblock}
noexcept(ranges::iter_swap(x.current_, y.current_))
\end{codeblock}
\end{itemdescr}


\rSec3[ranges.adaptors.transform_view.sentinel]{Class template \tcode{transform_view::\xname{sentinel}}}

\pnum
\tcode{transform_view<R, F>::\xname{sentinel}} is an exposition-only type.

\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template <class R, class F>
    template <bool Const>
      class transform_view<R, F>::@\xname{sentinel}@ {
      private:
        using Parent = conditional_t<Const, const transform_view, transform_view>;
        using Base = conditional_t<Const, const R, R>;
        sentinel_t<Base> end_ {};
      public:
        @\xname{sentinel}@() = default;
        explicit constexpr @\xname{sentinel}@(sentinel_t<Base> end);
        constexpr @\xname{sentinel}@(@\xname{sentinel}@<!Const> i)
          requires Const && View<R> && ConvertibleTo<sentinel_t<R>, sentinel_t<const R>>;
      
        constexpr sentinel_t<Base> base() const;
    
        friend constexpr bool operator==(const @\xname{iterator}@<Const>& x, const @\xname{sentinel}@& y);
        friend constexpr bool operator==(const @\xname{sentinel}@& x, const @\xname{iterator}@<Const>& y);
        friend constexpr bool operator!=(const @\xname{iterator}@<Const>& x, const @\xname{sentinel}@& y);
        friend constexpr bool operator!=(const @\xname{sentinel}@& x, const @\xname{iterator}@<Const>& y);

        friend constexpr difference_type_t<iterator_t<Base>>
          operator-(const @\xname{iterator}@<Const>& x, const @\xname{sentinel}@& y)
            requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
        friend constexpr difference_type_t<iterator_t<Base>>
          operator-(const @\xname{sentinel}@& y, const @\xname{iterator}@<Const>& x)
            requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
      };
}}}}
\end{codeblock}

\rSec3[ranges.adaptors.transform_view.sentinel.ctor]{\tcode{transform_view::\xname{sentinel} constructors}}

\indexlibrary{\idxcode{\xname{sentinel}}!\idxcode{transform_view::\xname{sentinel}}}
\begin{itemdecl}
explicit constexpr @\xname{sentinel}@(sentinel_t<Base> end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{end}.
\end{itemdescr}

\indexlibrary{\idxcode{\xname{sentinel}}!\idxcode{transform_view::\xname{sentinel}}}
\begin{itemdecl}
constexpr @\xname{sentinel}@(@\xname{sentinel}@<!Const> i)
  requires Const && View<R> && ConvertibleTo<sentinel_t<R>, sentinel_t<const R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{i.end_}.
\end{itemdescr}

\rSec3[ranges.adaptors.transform_view.sentinel.conv]{\tcode{transform_view::\xname{sentinel} conversion}}

\indexlibrary{\idxcode{base}!\idxcode{transform_view::\xname{sentinel}}}
\begin{itemdecl}
constexpr sentinel_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{end_}.
\end{itemdescr}

\rSec3[ranges.adaptors.transform_view.sentinel.comp]{\tcode{transform_view::\xname{sentinel} comparison}}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::\xname{sentinel}}}
\begin{itemdecl}
friend constexpr bool operator==(const @\xname{iterator}@<Const>& x, const @\xname{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.current_ == y.end_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::\xname{sentinel}}}
\begin{itemdecl}
friend constexpr bool operator==(const @\xname{sentinel}@& x, const @\xname{iterator}@<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y == x}.
\end{itemdescr}
 
\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::\xname{sentinel}}}%
\begin{itemdecl}
friend constexpr bool operator!=(const @\xname{iterator}@<Const>& x, const @\xname{sentinel}@& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::\xname{sentinel}}}%
\begin{itemdecl}
friend constexpr bool operator!=(const @\xname{sentinel}@& x, const @\xname{iterator}@<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y == x)}.
\end{itemdescr}

\rSec3[ranges.adaptors.transform_view.sentinel.nonmember]{\tcode{transform_view::\xname{sentinel} non-member functions}}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::\xname{sentinel}}}%
\begin{itemdecl}
friend constexpr difference_type_t<iterator_t<Base>>
  operator-(const @\xname{iterator}@<Const>& x, const @\xname{sentinel}@& y)
    requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.current_ - y.end_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::\xname{sentinel}}}%
\begin{itemdecl}
friend constexpr difference_type_t<iterator_t<Base>>
  operator-(const @\xname{sentinel}@& y, const @\xname{iterator}@<Const>& x)
    requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.end_ - y.current_}.
\end{itemdescr}

\rSec2[ranges.adaptors.transform]{\tcode{view::transform}}

\pnum
The name \tcode{view::transform} denotes a range adaptor
object~(\ref{ranges.adaptor.object}). Let \tcode{E} and \tcode{F} be expressions such
that types \tcode{T} and \tcode{U} are \tcode{decltype((E))} and \tcode{decltype((F))}
respectively. Then the expression \tcode{view::transform(E, F)} is expression-equivalent to:

\begin{itemize}
\item \tcode{transform_view\{E, F\}} if
\tcode{InputRange<T> \&\& CopyConstructible<decay_t<U>{>} \&\& Invocable<decay_t<U>\&, reference_t<iterator_t<T>{>}>}
is satisfied.
\item Otherwise, \tcode{view::transform(E, F)} is ill-formed.
\end{itemize}
