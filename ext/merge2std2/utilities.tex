%!TEX root = P0896.tex
\setcounter{chapter}{23}
\rSec0[utilities]{General utilities library}

% TODO: Add stuff to Table 34?

\setcounter{section}{1}
\rSec1[utility]{Utility components}

\rSec2[utility.syn]{Header \tcode{<utility>} synopsis}

\ednote{Add declarations to the \tcode{<utility>} synopsis (class template
\tcode{tagged} and associated machinery from the Ranges TS are intentionally
ommitted.):}

\begin{codeblock}
  [...]
  template<size_t I>
    struct in_place_index_t {
      explicit in_place_index_t() = default;
    };
  template<size_t I> inline constexpr in_place_index_t<I> in_place_index{};
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  @\newtxt{namespace ranges \{}@
    // \ref{range.swap}, \tcode{\newtxt{ranges::}swap}
    @\newtxt{inline}@ namespace @\newtxt{\unspec}@ {
      @\newtxt{inline}@ constexpr @\unspec@ swap = @\unspecnc@;
    }
  }@\oldtxt{\}\}}@
\end{codeblock}
\end{addedblock}
\begin{codeblock}
}
\end{codeblock}

{\color{addclr}
\setcounter{section}{2}
\setcounter{subsection}{2}
\ednote{Insert the specification of \tcode{ranges::swap} after [utility.swap]:}
\rSec2[range.swap]{\tcode{ranges::swap}}

\indexlibrary{\idxcode{ranges::swap}}%
\pnum The name \tcode{ranges::swap} denotes a customization point
object\cxxiref{customization.point.object}. The \oldtxt{effect of the} expression
\tcode{ranges::swap(\brk{}E1, E2)} for some \newtxt{sub}expressions \tcode{E1}
and \tcode{E2} is \newtxt{expression-}equivalent to:

\begin{itemize}
\item
  \tcode{(void)swap(E1, E2)}\footnote{The name \tcode{swap} is used here unqualified.}, if that expression is valid, with overload resolution
  performed in a context that includes the declarations
\begin{codeblock}
  template<class T>
  void swap(T&, T&) = delete;
  template<class T, size_t N>
  void swap(T(&)[N], T(&)[N]) = delete;
\end{codeblock}
  and does not include a declaration of \tcode{ranges::swap}.
  If the function selected by overload resolution does not
  exchange the values referenced by \tcode{E1} and \tcode{E2},
  the program is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{(void)ranges::swap_ranges(E1, E2)} if \tcode{E1} and
  \tcode{E2} are lvalues of array types\cxxiref{basic.compound}
  with equal extent and \tcode{ranges::swap(*(E1), *(E2))}
  is a valid expression, except that
  \tcode{noexcept(\brk{}ranges::swap(E1, E2))} is equal to
  \tcode{noexcept(\brk{}ranges::swap(*(E1), *(E2)))}.

\item
  Otherwise, if \tcode{E1} and \tcode{E2} are lvalues of the
  same type \tcode{T} which meets the syntactic requirements of
  \tcode{MoveConstructible<T>} and
  \tcode{Assignable<T\&, T>}, exchanges the referenced values.
  \tcode{ranges::swap(\brk{}E1, E2)} is a constant expression if
  the constructor selected by overload resolution for
  \tcode{T\{std::move(E1)\}} is a constexpr constructor and
  the expression \tcode{E1 = std::move(E2)} can appear in a
  constexpr function. \tcode{noexcept(ranges::swap(E1, E2))}
  is equal to \tcode{is_nothrow_move_constructible\newtxt{_v}<T>\oldtxt{::value}
  \&\& is_nothrow_move_assignable\newtxt{_v}<T>\oldtxt{::value}}. If either
  \libconcept{MoveConstructible} or
  \libconcept{Assignable} is not satisfied, the program
  is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{ranges::swap(E1, E2)} is ill-formed.
\end{itemize}

\pnum
\oldtxt{\remarks}
\begin{note}
Whenever \tcode{ranges::swap(E1, E2)} is a valid
expression, it exchanges the values referenced by \tcode{E1}
and \tcode{E2} and has type \tcode{void}.
\end{note}
} % \color{addclr}

[...]

\setcounter{section}{9}
\rSec1[memory]{Memory}

[...]

\setcounter{subsection}{1}
\rSec2[memory.syn]{Header \tcode{<memory>} synopsis}

[...]

\indexhdr{memory}%
\begin{codeblock}
namespace std {
  [...]

  // \cxxref{default.allocator}, the default allocator
  template<class T> class allocator;
  template<class T, class U>
    bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
  template<class T, class U>
    bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;

  // \ref{specialized.algorithms}, specialized algorithms
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  // \ref{special.mem.concepts}, special memory concepts
  template<class I>
  concept @\placeholdernc{no-throw-input-iterator}@ = @\seebelownc@; // \expos

  template<class I>
  concept @\placeholdernc{no-throw-forward-iterator}@ = @\seebelownc@; // \expos

  template<class S, class I>
  concept @\placeholdernc{no-throw-sentinel}@ = @\seebelownc@; // \expos

  template<class Rng>
  concept @\placeholdernc{no-throw-input-range}@ = @\seebelownc@; // \expos

  template<class Rng>
  concept @\placeholdernc{no-throw-forward-range}@ = @\seebelownc@; // \expos
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class T>
    constexpr T* addressof(T& r) noexcept;
  template<class T>
    const T* addressof(const T&&) = delete;
  template<class ForwardIterator>
    void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void uninitialized_default_construct(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                         ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator uninitialized_default_construct_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                                      ForwardIterator first, Size n);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
        requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
      I uninitialized_default_construct(I first, S last);
    template<@\placeholdernc{no-throw-forward-range}@ Rng>
        requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>>
      safe_iterator_t<Rng> uninitialized_default_construct(Rng&& rng);

    template<@\placeholdernc{no-throw-forward-iterator}@ I>
        requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
      I uninitialized_default_construct_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class ForwardIterator>
    void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void uninitialized_value_construct(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                       ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator uninitialized_value_construct_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                                    ForwardIterator first, Size n);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
        requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
      I uninitialized_value_construct(I first, S last);
    template<@\placeholdernc{no-throw-forward-range}@ Rng>
        requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>>
      safe_iterator_t<Rng> uninitialized_value_construct(Rng&& rng);

    template<@\placeholdernc{no-throw-forward-iterator}@ I>
        requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
      I uninitialized_value_construct_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class InputIterator, class Size, class ForwardIterator>
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                         ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator>
    ForwardIterator uninitialized_copy_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                         InputIterator first, Size n,
                                         ForwardIterator result);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    @\newtxt{template<class I, class O>}@
    @\newtxt{struct uninitialized_copy_result \{}@
      @\newtxt{I in;}@
      @\newtxt{I out;}@
    @\newtxt{\};}@
    template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@reference_t<I>>
      @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
      @\newtxt{uninitialized_copy_result<I, O>}@
        uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
    template<InputRange IRng, @\placeholdernc{no-throw-forward-range}@ ORng>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<ORng>>, @\newtxt{iter_}@reference_t<iterator_t<IRng>>>
      @\oldtxt{tagged_pair<tag::in(safe_iterator_t<IRng>), tag::out(safe_iterator_t<ORng>)>}@
      @\newtxt{uninitialized_copy_result<iterator_t<IRng>, iterator_t<ORng>}@
        uninitialized_copy(IRng&& irng, ORng&& orng);

    @\newtxt{template<class I, class O>}@
    @\newtxt{using uninitialized_copy_n_result = uninitialized_copy_result<I, O>;}@
    template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@reference_t<I>>
      @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
      @\newtxt{uninitialized_copy_n_result<I, O>}@
        uninitialized_copy_n(I ifirst, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, O ofirst, S olast);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_move(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class InputIterator, class Size, class ForwardIterator>
    pair<InputIterator, ForwardIterator> uninitialized_move_n(InputIterator first, Size n,
                                                              ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator>
    pair<InputIterator, ForwardIterator> uninitialized_move_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                                              InputIterator first, Size n,
                                                              ForwardIterator result);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    @\newtxt{template<class I, class O>}@
    @\newtxt{using uninitialized_move_result = uninitialized_copy_result<I, O>;}@
    template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@rvalue_reference_t<I>>
      @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
      @\newtxt{uninitialized_move_result<I, O>}@
        uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
    template<InputRange IRng, @\placeholdernc{no-throw-forward-range}@ ORng>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<ORng>>, @\newtxt{iter_}@rvalue_reference_t<iterator_t<IRng>>>
      @\oldtxt{tagged_pair<tag::in(safe_iterator_t<IRng>), tag::out(safe_iterator_t<ORng>)>}@
      @\newtxt{uninitialized_move_result<safe_iterator_t<IRng>, safe_iterator_t<ORng>>}@
        uninitialized_move(IRng&& irng, ORng&& orng);

    @\newtxt{template<class I, class O>}@
    @\newtxt{using uninitialized_move_n_result = uninitialized_copy_result<I, O>;}@
    template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@rvalue_reference_t<I>>
      @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
      @\newtxt{uninitialized_move_n_result<I, O>}@
        uninitialized_move_n(I ifirst, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, O ofirst, S olast);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class ForwardIterator, class T>
    void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void uninitialized_fill(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                            ForwardIterator first, ForwardIterator last, const T& x);
  template<class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                         ForwardIterator first, Size n, const T& x);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S, class T>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>, const T&>
      I uninitialized_fill(I first, S last, const T& x);
    template<@\placeholdernc{no-throw-forward-range}@ Rng, class T>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>, const T&>
      safe_iterator_t<Rng> uninitialized_fill(Rng&& rng, const T& x);

    template<@\placeholdernc{no-throw-forward-iterator}@ I, class T>
        requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>, const T&>
      I uninitialized_fill_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, const T& x);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class T>
    void destroy_at(T* location);
  template<class ForwardIterator>
    void destroy(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void destroy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator destroy_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator destroy_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                              ForwardIterator first, Size n);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<Destructible T>
      void destroy_at(T* location) noexcept;

    template<@\placeholdernc{no-throw-input-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
        requires Destructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
      I destroy(I first, S last) noexcept;
    template<@\placeholdernc{no-throw-input-range}@ Rng>
        requires Destructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>
      safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;

    template<@\placeholdernc{no-throw-input-iterator}@ I>
        requires Destructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
      I destroy_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n) noexcept;
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  [...]
}
\end{codeblock}

[...]

\setcounter{subsection}{10}
\rSec2[specialized.algorithms]{Specialized algorithms}

\pnum
\oldtxt{Throughout this subclause,} \newtxt{For the algorithms in this subclause
defined directly in namespace \tcode{std},} the names of template parameters are
used to express type requirements.
\begin{itemize}
\item
If an algorithm's template parameter is named \tcode{InputIterator},
the template argument shall satisfy the
\oldconcept{InputIterator} requirements\iref{input.iterators}.
\item
If an algorithm's template parameter is named \tcode{ForwardIterator},
the template argument shall satisfy the
\oldconcept{ForwardIterator} requirements\iref{forward.iterators}, and
is required to have the property that no exceptions are thrown
from increment, assignment, comparison, or indirection through valid iterators.
\end{itemize}
Unless otherwise specified,
if an exception is thrown in the following algorithms there are no effects.

\ednote{The following paragraphs incorporate various paragraphs from
[algorithms.requirements]. We should consider simply relocating this entire
subclause under [algorithms]:}

{\color{newclr}
\pnum
In the description of the algorithms operators
\tcode{+}
and
\tcode{-}
are used for some of the iterator categories for which
they do not have to be defined.
In these cases the semantics of
\tcode{a+n}
is the same as that of

\begin{codeblock}
X tmp = a;
advance(tmp, n);
return tmp;
\end{codeblock}

and that of
\tcode{b-a}
is the same as of

\begin{codeblock}
return distance(a, b);
\end{codeblock}

\pnum
For the algorithms in this subclause defined in namespace \tcode{std::ranges},
the following additional requirements apply:
\begin{itemize}
\item The function templates defined in the \tcode{std::ranges} namespace
  in this subclause are not found by argument-dependent
  name lookup\cxxiref{basic.lookup.argdep}. When found by
  unqualified\cxxiref{basic.lookup.unqual} name lookup for the
  \grammarterm{postfix-expression} in a function call\cxxiref{expr.call}, they
  inhibit argument-dependent name lookup.
\item Overloads of algorithms that take \libconcept{Range} arguments\iref{range.range}
  behave as if they are implemented by calling \tcode{\newtxt{ranges::}begin}
  and \tcode{\newtxt{ranges::}end} on the \libconcept{Range}(s) and dispatching to the
  overload that takes separate iterator and sentinel arguments.
\item The number and order of template parameters for algorithm declarations
  is unspecified, except where explicitly stated otherwise.
\end{itemize}
} %% \color{newclr}

\begin{addedblock}
\pnum
\begin{note}
\newtxt{Invocation of} the algorithms specified in this
subclause\iref{specialized.algorithms}) \oldtxt{shall only operate on ranges of
complete objects\cxxiref{intro.object}. Use of these functions} on ranges of
\newtxt{potentially overlapping} subobjects\newtxt{\cxxiref{intro.object}}
\oldtxt{is} \newtxt{results in} undefined \newtxt{behavior}.
\end{note}

\rSec3[special.mem.concepts]{Special memory concepts}

\pnum
Some algorithms in this subclause are constrained with the following
exposition-only concepts:

\begin{itemdecl}
template<class I>
concept @\placeholdernc{no-throw-input-iterator}@ = // exposition only
  InputIterator<I> &&
  is_lvalue_reference_v<@\newtxt{iter_}@reference_t<I>> &&
  Same<remove_cvref_t<@\newtxt{iter_}@reference_t<I>>, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
No exceptions are thrown from increment, copy, move, assignment, or indirection through valid
iterators.

\pnum
\begin{note}
The distinction between \libconcept{InputIterator} and
\tcode{\placeholdernc{no-throw-input-iterator}} is purely semantic.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class S, class I>
concept @\placeholdernc{no-throw-sentinel}@ = Sentinel<S, I>; // exposition only
\end{itemdecl}

\begin{itemdescr}
\pnum
No exceptions are thrown from comparisons between objects of type \tcode{I} and \tcode{S}.

\pnum
\begin{note}
The distinction between \libconcept{Sentinel} and
\tcode{\placeholdernc{no-throw-sentinel}} is purely semantic.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class Rng>
concept @\placeholdernc{no-throw-input-range}@ = // exposition only
  Range<Rng> &&
  @\placeholder{no-throw-input-iterator}@<iterator_t<Rng>> &&
  @\placeholdernc{no-throw-sentinel}@<sentinel_t<Rng>, iterator_t<Rng>>;
\end{itemdecl}

\begin{itemdescr}
\pnum No exceptions are thrown from calls to \tcode{begin} and \tcode{end} on an object of type
\tcode{Rng}.

\pnum
\begin{note}
The distinction between \libconcept{InputRange} and
\tcode{\placeholdernc{no-throw-input-range}} is purely semantic.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class I>
concept @\placeholdernc{no-throw-forward-iterator}@ = // exposition only
  @\placeholder{no-throw-input-iterator}@<I> &&
  ForwardIterator<I> &&
  @\placeholdernc{no-throw-sentinel}@<I, I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{note}
The distinction between \libconcept{ForwardIterator} and
\tcode{\placeholdernc{no-throw-forward-iterator}} is purely semantic.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class Rng>
concept @\placeholdernc{no-throw-forward-range}@ = // exposition only
  @\placeholder{no-throw-input-range}@<Rng> &&
  @\placeholder{no-throw-forward-iterator}@<iterator_t<Rng>> @\oldtxt{\&\&}@
  @\oldtxt{ForwardRange<Rng>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{note} The distinction between \libconcept{ForwardRange} and
\tcode{\placeholdernc{no-throw-forward-range}} is purely semantic.
\end{note}
\end{itemdescr}
\end{addedblock}

\rSec3[specialized.addressof]{\tcode{addressof}}

[...]

\rSec3[uninitialized.construct.default]{\tcode{uninitialized_default_construct}}

\indexlibrary{\idxcode{uninitialized_default_construct}}%
\begin{itemdecl}
template<class ForwardIterator>
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_default_construct}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
    I uninitialized_default_construct(I first, S last);
  template<@\placeholdernc{no-throw-forward-range}@ Rng>
      requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>>
    safe_iterator_t<Rng> uninitialized_default_construct(Rng&& rng);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (const_cast<void*>(static_cast<const volatile void*>(addressof(*first))))
    remove_reference_t<@\newtxt{iter_}@reference_t<I>>;
return first;
\end{codeblock}

\ednote{Conversion to \tcode{void*} is necessary to ensure that \tcode{::operator new<void*>} (`True
Placement New') is called. \tcode{const}-ness is cast away after calling
\tcode{addressof} to allow users to pass ranges of \tcode{const} object types.\\
\\
Note that \tcode{const}-qualified means `do not modify', and that the \tcode{const_cast}
ignores this (and is thus lying). However, these algorithms are also claiming that they iterate
over objects of type \tcode{T}: nary a \tcode{T} is in the range. We present this as `the objects
in this range should be \tcode{const}', rather than `the memory here is \tcode{const}'.}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_default_construct_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type;
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_default_construct_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I>
      requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
    I uninitialized_default_construct_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return uninitialized_default_construct(make_counted_iterator(first, n),
                                       default_sentinel{}).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.construct.value]{\tcode{uninitialized_value_construct}}

\indexlibrary{\idxcode{uninitialized_value_construct}}%
\begin{itemdecl}
template<class ForwardIterator>
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type();
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_value_construct}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
    I uninitialized_value_construct(I first, S last);
  template<@\placeholdernc{no-throw-forward-range}@ Rng>
      requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>>
    safe_iterator_t<Rng> uninitialized_value_construct(Rng&& rng);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (const_cast<void*>(static_cast<const volatile void*>(addressof(*first))))
    remove_reference_t<@\newtxt{iter_}@reference_t<I>>();
return first;
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_value_construct_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type();
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_value_construct_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I>
      requires DefaultConstructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
    I uninitialized_value_construct_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return uninitialized_value_construct(make_counted_iterator(first, n),
                                     default_sentinel{}).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.copy]{\tcode{uninitialized_copy}}

\indexlibrary{\idxcode{uninitialized_copy}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
{\color{newclr}
\pnum
\expects
\range{result}{result + (last - first)} shall not overlap with \range{first}{last}.
} %% \color{newclr}

\pnum
\effects
As if by:
\begin{codeblock}
for (; first != last; ++result, (void) ++first)
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(*first);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_copy}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@reference_t<I>>
    @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
    @\newtxt{uninitialized_copy_result<I, O>}@
      uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<InputRange IRng, @\placeholdernc{no-throw-forward-range}@ ORng>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<ORng>>, @\newtxt{iter_}@reference_t<iterator_t<IRng>>>
    @\oldtxt{tagged_pair<tag::in(safe_iterator_t<IRng>), tag::out(safe_iterator_t<ORng>)>}@
    @\newtxt{uninitialized_copy_result<iterator_t<IRng>, iterator_t<ORng>}@
      uninitialized_copy(IRng&& irng, ORng&& orng);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\range{ofirst}{olast} shall not overlap with \range{ifirst}{ilast}.

\pnum
\effects Equivalent to:
\begin{codeblock}
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst) {
  ::new (const_cast<void*>(static_cast<const volatile void*>(addressof(*ofirst))))
    remove_reference_t<@\newtxt{iter_}@reference_t<O>>(*ifirst);
}
return {ifirst, ofirst};
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_copy_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
{\color{newclr}
\pnum
\expects
\range{result}{result + n} shall not overlap with \range{first}{first + n}.
} %% \color{newclr}

\pnum
\effects
As if by:
\begin{codeblock}
for ( ; n > 0; ++result, (void) ++first, --n) {
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(*first);
}
\end{codeblock}

\pnum
\returns \tcode{result}.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_copy_n}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@reference_t<I>>
    @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
    @\newtxt{uninitialized_copy_n_result<I, O>}@
      uninitialized_copy_n(I ifirst, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, O ofirst, S olast);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\range{ofirst}{olast} shall not overlap with
\range{ifirst}{\newtxt{ifirst + n} \oldtxt{next(ifirst, n)}}.

\pnum
\effects Equivalent to:
\begin{codeblock}
auto t = uninitialized_copy(make_counted_iterator(ifirst, n),
                            default_sentinel{}, ofirst, olast)@\oldtxt{.base()}@;
return {t.in().base(), t.out()};
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.move]{\tcode{uninitialized_move}}

\indexlibrary{\idxcode{uninitialized_move}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
{\color{newclr}
\pnum
\expects
\range{result}{result + (last - first)} shall not overlap with \range{first}{last}.
} %% \color{newclr}

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; (void)++result, ++first)
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
return result;
\end{codeblock}

\pnum
\remarks
If an exception is thrown, some objects in the range \range{first}{last}
are left in a valid but unspecified state.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_move}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@rvalue_reference_t<I>>
    @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
    @\newtxt{uninitialized_move_result<I, O>}@
      uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<InputRange IRng, @\placeholdernc{no-throw-forward-range}@ ORng>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<ORng>>, @\newtxt{iter_}@rvalue_reference_t<iterator_t<IRng>>>
    @\oldtxt{tagged_pair<tag::in(safe_iterator_t<IRng>), tag::out(safe_iterator_t<ORng>)>}@
    @\newtxt{uninitialized_move_result<safe_iterator_t<IRng>, safe_iterator_t<ORng>>}@
      uninitialized_move(IRng&& irng, ORng&& orng);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\range{ofirst}{olast} shall not overlap with \range{ifirst}{ilast}.

\pnum
\effects Equivalent to:
\begin{codeblock}
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst) {
  ::new (const_cast<void*>(static_cast<const volatile void*>(addressof(*ofirst))))
    remove_reference_t<@\newtxt{iter_}@reference_t<O>>(@\newtxt{ranges::}@iter_move(ifirst));
}
return {ifirst, ofirst};
\end{codeblock}

\pnum
\begin{note}
If an exception is thrown, some objects in the range \range{first}{last} are
left in a valid, but unspecified state.
\end{note}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_move_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class ForwardIterator>
  pair<InputIterator, ForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
{\color{newclr}
\pnum
\expects
\range{result}{result + n} shall not overlap with \range{first}{first + n}.
} %% \color{newclr}

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; ++result, (void) ++first, --n)
  ::new (static_cast<void*>(addressof(*result)))
    typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
return {first,result};
\end{codeblock}

\pnum
\remarks
If an exception is thrown, some objects in the range
\range{first}{\newtxt{first + n} \oldtxt{std::next(first,n)}}
are left in a valid but unspecified state.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_move_n}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<O>, @\newtxt{iter_}@rvalue_reference_t<I>>
    @\oldtxt{tagged_pair<tag::in(I), tag::out(O)>}@
    @\newtxt{uninitialized_move_n_result<I, O>}@
      uninitialized_move_n(I ifirst, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, O ofirst, S olast);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\range{ofirst}{olast} shall not overlap with
\range{ifirst}{\newtxt{ifirst + n} \oldtxt{next(ifirst, n)}}.

\pnum
\effects Equivalent to:
\begin{codeblock}
auto t = uninitialized_move(make_counted_iterator(ifirst, n),
                            default_sentinel{}, ofirst, olast)@\oldtxt{.base()}@;
return {t.in().base(), t.out()};
\end{codeblock}

\pnum
\begin{note}
If an exception is thrown, some objects in the range
\range{first}{\newtxt{first + n} \oldtxt{next(first, n)}}
are left in a valid but unspecified state.
\end{note}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.fill]{\tcode{uninitialized_fill}}

\indexlibrary{\idxcode{uninitialized_fill}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
for (; first != last; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type(x);
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_fill}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S, class T>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>, const T&>
    I uninitialized_fill(I first, S last, const T& x);
  template<@\placeholdernc{no-throw-forward-range}@ Rng, class T>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>, const T&>
    safe_iterator_t<Rng> uninitialized_fill(Rng&& rng, const T& x);
}
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first) {
  ::new (const_cast<void*>(static_cast<const volatile void*>(addressof(*first))))
    remove_reference_t<@\newtxt{iter_}@reference<I>>(x);
}
\end{codeblock}
return first;
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_fill_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
for (; n--; ++first)
  ::new (static_cast<void*>(addressof(*first)))
    typename iterator_traits<ForwardIterator>::value_type(x);
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_fill_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, class T>
      requires Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>, const T&>
    I uninitialized_fill_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, const T& x);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return uninitialized_fill(make_counted_iterator(first, n), default_sentinel{}, x).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[specialized.destroy]{\tcode{destroy}}

\indexlibrary{\idxcode{destroy_at}}%
\begin{itemdecl}
template<class T>
  void destroy_at(T* location);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<Destructible T>
    void destroy_at(T* location) noexcept;
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
location->~T();
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{destroy}}%
\begin{itemdecl}
template<class ForwardIterator>
  void destroy(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first!=last; ++first)
  destroy_at(addressof(*first));
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{destroy}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-input-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires Destructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
    I destroy(I first, S last) noexcept;
  template<@\placeholdernc{no-throw-input-range}@ Rng>
      requires Destructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Rng>>
    safe_iterator_t<Rng> destroy(Rng&& rng) noexcept;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  destroy_at(addressof(*first));
return first;
\end{codeblock}

\ednote{The International Standard requires \tcode{destroy} be a
\tcode{ForwardIterator} to ensure that the iterator's \tcode{reference} type is
a reference type. This requirement is relaxed for \tcode{ranges::destroy}, since
\tcode{\placeholder{no-throw-input-iterator}} requires that
\tcode{iter_reference_t<I>} is an lvalue reference type.\\
\\
The choice to weaken the iterator requirement from the International Standard is
because the algorithm is a single-pass algorithm; thus, semantically, works on
input ranges.}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{destroy_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator destroy_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  destroy_at(addressof(*first));
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{destroy_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-input-iterator}@ I>
      requires Destructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>>
    I destroy_n(I first, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n) noexcept;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return destroy(make_counted_iterator(first, n), default_sentinel{}).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

[...]

\setcounter{section}{13}
\rSec1[function.objects]{Function Objects}

\rSec2[functional.syn]{Header \tcode{<functional>} synopsis}

\ednote{Add declarations to \tcode{<functional>}:}
\begin{codeblock}
  [...]

  template<class T>
    inline constexpr bool is_bind_expression_v = is_bind_expression<T>::value;
  template<class T>
    inline constexpr int is_placeholder_v = is_placeholder<T>::value;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}

  namespace ranges {
    // \ref{range.comparisons}, comparisons
    template<class T = void>
      requires @\seebelow@
    struct equal_to;

    template<class T = void>
      requires @\seebelow@
    struct not_equal_to;

    template<class T = void>
      requires @\seebelow@
    struct greater;

    template<class T = void>
      requires @\seebelow@
    struct less;

    template<class T = void>
      requires @\seebelow@
    struct greater_equal;

    template<class T = void>
      requires @\seebelow@
    struct less_equal;

    template<> struct equal_to<void>;
    template<> struct not_equal_to<void>;
    template<> struct greater<void>;
    template<> struct less<void>;
    template<> struct greater_equal<void>;
    template<> struct less_equal<void>;
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}
}
\end{codeblock}

\ednote{Add new subclause [range.comparisons] between [comparisons] and [logical.operations]:}
{\color{addclr}
\setcounter{subsection}{7}
\rSec2[range.comparisons]{Comparisons (\tcode{ranges})}

\pnum
\oldtxt{The library provides basic function object classes for all of the comparison
operators in the language~(\cxxref{expr.rel}, \cxxref{expr.eq}).}

\pnum
In this section, \tcode{\textit{BUILTIN_PTR_CMP}(T, $op$, U)} for types \tcode{T}
and \tcode{U} and where $op$ is an equality\cxxiref{expr.eq} or relational
operator\cxxiref{expr.rel} is a boolean constant expression.
\tcode{\textit{BUILTIN_PTR_CMP}(T, $op$, U)} is \tcode{true} if and only if $op$
in the expression \tcode{declval<T>() $op$ declval<U>()} resolves to a built-in
operator comparing pointers.

\pnum
There is an implementation-defined strict total ordering over all pointer values
of a given type. This total ordering is consistent with the partial order imposed
by the builtin operators \tcode{<}, \tcode{>}, \tcode{<=}, and \tcode{>=}.

\indexlibrary{\idxcode{equal_to}}%
\begin{itemdecl}
template<class T = void>
  requires EqualityComparable<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, ==, const T&)
struct equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return ranges::equal_to<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to}}%
\begin{itemdecl}
template<class T = void>
  requires EqualityComparable<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, ==, const T&)
struct not_equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return !ranges::equal_to<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{greater}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct greater {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return ranges::less<>{}(y, x);}
\end{itemdescr}

\indexlibrary{\idxcode{less}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct less {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return ranges::less<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct greater_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return !ranges::less<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{less_equal}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct less_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return !ranges::less<>{}(y, x);}
\end{itemdescr}

\indexlibrary{\idxcode{equal_to<>}}%
\begin{itemdecl}
template<> struct equal_to<void> {
  template<class T, class U>
    requires EqualityComparableWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, ==, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
If the expression \tcode{std::forward<T>(t) == std::forward<U>(u)}
results in a call to a built-in operator \tcode{==} comparing pointers of type
\tcode{P}, the conversion sequences from both \tcode{T} and \tcode{U} to \tcode{P}
shall be equality-preserving\cxxiref{concepts.general.equality}.

\pnum
\effects
\begin{itemize}
\item
If the expression \tcode{std::forward<T>(t) == std::forward<U>(u)} results in a
call to a built-in operator \tcode{==} comparing pointers of type \tcode{P}:
returns \tcode{false} if either (the converted value of) \tcode{t} precedes
\tcode{u} or \tcode{u} precedes \tcode{t} in the implementation-defined strict
total order over pointers of type \tcode{P} and otherwise \tcode{true}.

\item
Otherwise, equivalent to: \tcode{return std::forward<T>(t) == std::forward<U>(u);}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to<>}}%
\begin{itemdecl}
template<> struct not_equal_to<void> {
  template<class T, class U>
    requires EqualityComparableWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, ==, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::equal_to<>{}(std::forward<T>(t), std::forward<U>(u));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{greater<>}}%
\begin{itemdecl}
template<> struct greater<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(U, <, T)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return ranges::less<>{}(std::forward<U>(u), std::forward<T>(t));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{less<>}}%
\begin{itemdecl}
template<> struct less<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, <, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
If the expression \tcode{std::forward<T>(t) < std::forward<U>(u)} results in a
call to a built-in operator \tcode{<} comparing pointers of type \tcode{P}, the
conversion sequences from both \tcode{T} and \tcode{U} to \tcode{P} shall be
equality-preserving\cxxiref{concepts.general.equality}. For any expressions
\tcode{ET} and \tcode{EU} such that \tcode{decltype((ET))} is \tcode{T} and
\tcode{decltype((EU))} is \tcode{U}, exactly one of \tcode{ranges::less<>\{\}(ET, EU)},
\tcode{ranges::less<>\{\}(EU, ET)} or \tcode{ranges::equal_to<>\{\}(ET, EU)} shall be
\tcode{true}.

\pnum
\effects
\begin{itemize}
\item
If the expression \tcode{std::forward<T>(t) < std::forward<U>(u)} results in a
call to a built-in operator \tcode{<} comparing pointers of type \tcode{P}:
returns \tcode{true} if (the converted value of) \tcode{t} precedes \tcode{u} in
the implementation-defined strict total order over pointers of type \tcode{P}
and otherwise \tcode{false}.

\item
Otherwise, equivalent to: \tcode{return std::forward<T>(t) < std::forward<U>(u);}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal<>}}%
\begin{itemdecl}
template<> struct greater_equal<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, <, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::less<>{}(std::forward<T>(t), std::forward<U>(u));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{less_equal<>}}%
\begin{itemdecl}
template<> struct less_equal<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(U, <, T)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::less<>{}(std::forward<U>(u), std::forward<T>(t));
\end{codeblock}
\end{itemdescr}
} % \color{addclr}
