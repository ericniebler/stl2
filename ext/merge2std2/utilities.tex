%!TEX root = P0896.tex
\setcounter{chapter}{22}
\rSec0[utilities]{General utilities library}

% TODO: Add stuff to Table 34?

\setcounter{section}{1}
\rSec1[utility]{Utility components}

\rSec2[utility.syn]{Header \tcode{<utility>} synopsis}

\ednote{Add declarations to the \tcode{<utility>} synopsis:}

\begin{codeblock}
  [...]
  template<size_t I>
    struct in_place_index_t {
      explicit in_place_index_t() = default;
    };
  template<size_t I> inline constexpr in_place_index_t<I> in_place_index{};
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  // \ref{taggedtup.tagged}, struct with named accessors
  template <class T>
  concept @\oldtxt{bool}@ TagSpecifier = @\seebelow@;

  template <class F>
  concept @\oldtxt{bool}@ TaggedType = @\seebelow@;

  template <class Base, TagSpecifier... Tags>
    requires sizeof...(Tags) <= tuple_size@\newtxt{_v}@<Base>@\oldtxt{::value}@
  struct tagged;

  // \ref{tagged.pairs}, tagged pairs
  template <TaggedType T1, TaggedType T2> using tagged_pair = @\seebelow@;

  template <TagSpecifier Tag1, TagSpecifier Tag2, class T1, class T2>
  constexpr @\seebelow@ make_tagged_pair(T1&& x, T2&& y);

  // \ref{tagged.astuple}, tuple-like access to tagged
  template <class Base, class... Tags>
  struct tuple_size<@\oldtxt{experimental::ranges::}@tagged<Base, Tags...>>;

  template <size_t N, class Base, class... Tags>
  struct tuple_element<N, @\oldtxt{experimental::ranges::}@tagged<Base, Tags...>>;

  // \ref{tagged.tagspec}, tag specifiers:
  namespace tag {
    struct in;
    struct in1;
    struct in2;
    struct out;
    struct out1;
    struct out2;
    struct fun;
    struct min;
    struct max;
    struct begin;
    struct end;
  }

  @\newtxt{namespace ranges \{}@
    // \ref{range.swap}, \tcode{\newtxt{ranges::}swap}:
    @\newtxt{inline}@ namespace @\newtxt{\unspec}@ {
      @\newtxt{inline}@ constexpr @\unspec@ swap = @\unspec@;
    }
  }@\oldtxt{\}\}}@
\end{codeblock}
\end{addedblock}
\begin{codeblock}
}
\end{codeblock}

{\color{addclr}
\setcounter{section}{2}
\setcounter{subsection}{2}
\ednote{Insert the specification of \tcode{ranges::swap} after [utility.swap]:}
\rSec2[range.swap]{\tcode{ranges::swap}}

\indexlibrary{\idxcode{ranges::swap}}%
\pnum The name \tcode{ranges::swap} denotes a customization point
object~(\cxxref{customization.point.object}). The \oldtxt{effect of the} expression
\tcode{ranges\colcol{}swap(\brk{}E1, E2)} for some \newtxt{sub}expressions \tcode{E1}
and \tcode{E2} is \newtxt{expression-}equivalent to:

\begin{itemize}
\item
  \tcode{(void)swap(E1, E2)}\footnote{The name \tcode{swap} is used here unqualified.}, if that expression is valid, with overload resolution
  performed in a context that includes the declarations
\begin{codeblock}
  template <class T>
  void swap(T&, T&) = delete;
  template <class T, size_t N>
  void swap(T(&)[N], T(&)[N]) = delete;
\end{codeblock}
  and does not include a declaration of \tcode{ranges::swap}.
  If the function selected by overload resolution does not
  exchange the values referenced by \tcode{E1} and \tcode{E2},
  the program is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{(void)ranges::swap_ranges(E1, E2)} if \tcode{E1} and
  \tcode{E2} are lvalues of array types~(\cxxref{basic.compound})
  with equal extent and \tcode{ranges::swap(*(E1), *(E2))}
  is a valid expression, except that
  \tcode{noexcept(\brk{}ranges::swap(E1, E2))} is equal to
  \tcode{noexcept(\brk{}ranges::swap(*(E1), *(E2)))}.

\item
  Otherwise, if \tcode{E1} and \tcode{E2} are lvalues of the
  same type \tcode{T} which meets the syntactic requirements of
  \tcode{MoveConstructible<T>} and
  \tcode{Assignable<T\&, T>}, exchanges the referenced values.
  \tcode{ranges\colcol{}swap(\brk{}E1, E2)} is a constant expression if
  the constructor selected by overload resolution for
  \tcode{T\{std\colcol{}move(E1)\}} is a constexpr constructor and
  the expression \tcode{E1 = std::move(E2)} can appear in a
  constexpr function. \tcode{noexcept(ranges\colcol{}swap(\brk{}E1, E2))}
  is equal to \tcode{is_nothrow_move_construct\-ible<T>\colcol{}value
  \&\& is_nothrow_move_assignable<T>\colcol{}value}. If either
  \tcode{Move\-Const\-ructible} or
  \tcode{Assign\-able} is not satisfied, the program
  is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{ranges::swap(E1, E2)} is ill-formed.
\end{itemize}

\pnum
\remark Whenever \tcode{ranges::swap(E1, E2)} is a valid
expression, it exchanges the values referenced by \tcode{E1}
and \tcode{E2} and has type \tcode{void}.
} % \color{addclr}

\setcounter{section}{4}
\rSec1[tuple]{Tuples}
\rSec2[tuple.syn]{Header \tcode{<tuple>} synopsis}
\ednote{Add declarations to \tcode<tuple> as follows:}
\begin{codeblock}
namespace std {
  [...]

  @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  // \ref{tagged.tuple}, tagged tuple:
  template <TaggedType... Types>
  using tagged_tuple = @\seebelow@;

  template <TagSpecifier... Tags, class... Types>
    requires sizeof...(Tags) == sizeof...(Types)
      constexpr @\seebelow@ make_tagged_tuple(Types&&... t);
  @\oldtxt{\}\}\}}@
}
\end{codeblock}


\ednote{Add a new subclause to Clause~\cxxref{utilities} between [tuple] and [optional]:}
{\color{addclr}
\rSec1[taggedtup]{Tagged tuple-like types}

\rSec2[taggedtup.general]{General}

\pnum The library provides a template for augmenting a tuple-like type with named element accessor
member functions. The library also provides several templates that provide access to \tcode{tagged}
objects as if they were \tcode{tuple} objects (see~\cxxref{tuple.elem}).

\rSec2[taggedtup.tagged]{Class template \tcode{tagged}}

\pnum
Class template \tcode{tagged} augments a tuple-like class type (e.g., \tcode{pair}~(\cxxref{pairs}),
\tcode{tuple} (\cxxref{tuple})) by giving it named accessors. It is used to define the alias
templates \tcode{tagged_pair}~(\ref{tagged.pairs}) and
\tcode{tagged_tuple}~(\ref{tagged.tuple}).

\pnum In the class synopsis below, let $i$ be in the range
\range{0}{sizeof...(Tags)} and $T_i$ be the $i^{th}$ type in \tcode{Tags}, where indexing
is zero-based.

\indexlibrary{\idxcode{tagged}}%
\begin{codeblock}
@\oldtxt{// defined in header <experimental/ranges/utility>}@

namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  template <class T>
  concept @\oldtxt{bool}@ TagSpecifier = @\impdef@;

  template <class F>
  concept @\oldtxt{bool}@ TaggedType = @\impdef@;

  template <class Base, TagSpecifier... Tags>
    requires sizeof...(Tags) <= tuple_size@\newtxt{_v}@<Base>@\oldtxt{::value}@
  struct tagged :
    Base, @\textit{TAGGET}@(tagged<Base, Tags...>, @$T_i$@, @$i$@)... { // \seebelow
    using Base::Base;
    tagged() = default;
    tagged(tagged&&) = default;
    tagged(const tagged&) = default;
    tagged &operator=(tagged&&) = default;
    tagged &operator=(const tagged&) = default;
    tagged(Base&&) noexcept(@\seebelow@)
      requires MoveConstructible<Base>;
    tagged(const Base&) noexcept(@\seebelow@)
      requires CopyConstructible<Base>;
    template <class Other>
      requires Constructible<Base, Other>
    constexpr tagged(tagged<Other, Tags...> &&@\oldtxt{that}@) noexcept(@\seebelow@);
    template <class Other>
      requires Constructible<Base, const Other&>
    constexpr tagged(const tagged<Other, Tags...> &@\oldtxt{that}@);
    template <class Other>
      requires Assignable<Base&, Other>
    constexpr tagged& operator=(tagged<Other, Tags...>&& @\oldtxt{that}@) noexcept(@\seebelow@);
    template <class Other>
      requires Assignable<Base&, const Other&>
    constexpr tagged& operator=(const tagged<Other, Tags...>& @\oldtxt{that}@);
    template <class U>
      requires Assignable<Base&, U> && !Same<@\oldtxt{decay_t}\newtxt{remove_cvref_t}@<U>, tagged>
    constexpr tagged& operator=(U&& @\oldtxt{u}@) noexcept(@\seebelow@);
    constexpr void swap(tagged& @\oldtxt{that}@) noexcept(@\seebelow@)
      requires Swappable<Base>;
    friend constexpr void swap(tagged&, tagged&) noexcept(@\seebelow@)
      requires Swappable<Base>;
  };
}@\oldtxt{\}\}\}}@
\end{codeblock}

\pnum A \techterm{tagged getter} is an empty trivial class type that has a named member function that
returns a reference to a member of a tuple-like object that is assumed to be derived from the getter
class. The tuple-like type of a tagged getter is called its \techterm{DerivedCharacteristic}.
The index of the tuple element returned from the getter's member functions is called its
\techterm{ElementIndex}. The name of the getter's member function is called its
\techterm{ElementName}

\pnum A tagged getter class with DerivedCharacteristic \tcode{\textit{D}}, ElementIndex
\tcode{\textit{N}}, and ElementName \tcode{\textit{name}} shall provide the following interface:

\begin{codeblock}
struct @\xname{\textit{TAGGED_GETTER}}@ {
  constexpr decltype(auto) @$name$@() &       { return get<@$N$@>(static_cast<@$D$@&>(*this)); }
  constexpr decltype(auto) @$name$@() &&      { return get<@$N$@>(static_cast<@$D$@&&>(*this)); }
  constexpr decltype(auto) @$name$@() const & { return get<@$N$@>(static_cast<const @$D$@&>(*this)); }
};
\end{codeblock}

\pnum
A \techterm{tag specifier} is a type that facilitates a mapping from a tuple-like type and an
element index into a \textit{tagged getter} that gives named access to the element at that index.
\tcode{TagSpecifier<T>} is satisfied if and only if \tcode{T} is a tag specifier. The tag specifiers in the
\tcode{Tags} parameter pack shall be unique. \enternote The mapping mechanism from tag specifier to
tagged getter is unspecified.\exitnote

\pnum Let \tcode{\textit{TAGGET}(D, T, $N$)} name a tagged getter type that gives named
access to the $N$-th element of the tuple-like type \tcode{D}.

\pnum It shall not be possible to delete an instance of class template \tcode{tagged} through a
pointer to any base other than \tcode{Base}.

\pnum
\tcode{TaggedType<F>} is satisfied if and only if \tcode{F} is a unary function
type with return type \tcode{T} which satisfies \tcode{TagSpecifier<T>}. Let
\tcode{\textit{TAGSPEC}(F)} name the tag specifier of the \tcode{TaggedType} \tcode{F}, and let
\tcode{\textit{TAGELEM}(F)} name the argument type of the \tcode{TaggedType} \tcode{F}.

\indexlibrary{\idxcode{tagged}!\idxcode{tagged}}

\begin{itemdecl}
tagged(Base&& that) noexcept(@\seebelow@)
  requires MoveConstructible<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{Base} with \tcode{std::move(that)}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_move_constructible@\newtxt{_v}@<Base>@\oldtxt{::value}@
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
tagged(const Base& that) noexcept(@\seebelow@)
  requires CopyConstructible<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{Base} with \tcode{that}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_copy_constructible@\newtxt{_v}@<Base>@\oldtxt{::value}@
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class Other>
  requires Constructible<Base, Other>
constexpr tagged(tagged<Other, Tags...> &&that) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{Base} with \tcode{static_cast<Other\&\&>(that)}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_constructible@\newtxt{_v}@<Base, Other>@\oldtxt{::value}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{tagged}!\idxcode{tagged}}
\begin{itemdecl}
template <class Other>
  requires Constructible<Base, const Other&>
constexpr tagged(const tagged<Other, Tags...>& that);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{Base} with \tcode{static_cast<const Other\&>(that)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{tagged}}
\indexlibrary{\idxcode{tagged}!\idxcode{operator=}}
\begin{itemdecl}
template <class Other>
  requires Assignable<Base&, Other>
constexpr tagged& operator=(tagged<Other, Tags...>&& that) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{static_cast<Other\&\&>(that)} to \tcode{static_cast<Base\&>(*this)}.

\pnum
\returns \tcode{*this}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_assignable@\newtxt{_v}@<Base&, Other>@\oldtxt{::value}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{tagged}}
\indexlibrary{\idxcode{tagged}!\idxcode{operator=}}
\begin{itemdecl}
template <class Other>
  requires Assignable<Base&, const Other&>
constexpr tagged& operator=(const tagged<Other, Tags...>& that);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{static_cast<const Other\&>(that)} to \tcode{static_cast<Base\&>(*this)}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{tagged}}
\indexlibrary{\idxcode{tagged}!\idxcode{operator=}}
\begin{itemdecl}
template <class U>
  requires Assignable<Base&, U> && !Same<@\oldtxt{decay_t}\newtxt{remove_cvref_t}@<U>, tagged>
constexpr tagged& operator=(U&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{std::forward<U>(u)} to \tcode{static_cast<Base\&>(*this)}.

\pnum
\returns \tcode{*this}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
is_nothrow_assignable@\newtxt{_v}@<Base&, U>@\oldtxt{::value}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{swap}!\idxcode{tagged}}
\indexlibrary{\idxcode{tagged}!\idxcode{swap}}
\begin{itemdecl}
constexpr void swap(tagged& @\oldtxt{rhs}\newtxt{that}@) noexcept(@\seebelow@)
  requires Swappable<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \oldtxt{Calls \tcode{ranges::swap} on the result of applying \tcode{static_cast} to \tcode{*this} and
\tcode{that}.} \newtxt{Equivalent to:}
\begin{codeblock}
@\newtxt{return ranges::swap(static_cast<Base\&>(*this), static_cast<Base\&>(that));}@
\end{codeblock}

\pnum
\oldtxt{\throws Nothing unless the call to \tcode{ranges::swap} on the \tcode{Base} sub-objects throws.}

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
noexcept(@\newtxt{ranges::}@swap(declval<Base&>(), declval<Base&>()))
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{swap}!\tcode{tagged}}%
\begin{itemdecl}
friend constexpr void swap(tagged& lhs, tagged& rhs) noexcept(@\seebelow@)
  requires Swappable<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{lhs.swap(rhs)}.

\pnum
\remarks The expression inside \tcode{noexcept} is equivalent to:

\begin{codeblock}
noexcept(lhs.swap(rhs))
\end{codeblock}
\end{itemdescr}

\rSec2[tagged.astuple]{Tuple-like access to \tcode{tagged}}

\indexlibrary{\idxcode{tuple_size}}%
\indexlibrary{\idxcode{tuple_element}}%
\begin{itemdecl}
namespace std {
  template <class Base, class... Tags>
  struct tuple_size<@\oldtxt{experimental::ranges::}@tagged<Base, Tags...>>
    : tuple_size<Base> { };

  template <size_t N, class Base, class... Tags>
  struct tuple_element<N, @\oldtxt{experimental::ranges::}@tagged<Base, Tags...>>
    : tuple_element<N, Base> { };
}
\end{itemdecl}

\rSec2[tagged.tagspec]{Tag specifiers}

\begin{itemdecl}
namespace tag {
  struct in { /* @\impdef@ */ };
  struct in1 { /* @\impdef@ */ };
  struct in2 { /* @\impdef@ */ };
  struct out { /* @\impdef@ */ };
  struct out1 { /* @\impdef@ */ };
  struct out2 { /* @\impdef@ */ };
  struct fun { /* @\impdef@ */ };
  struct min { /* @\impdef@ */ };
  struct max { /* @\impdef@ */ };
  struct begin { /* @\impdef@ */ };
  struct end { /* @\impdef@ */ };
}
\end{itemdecl}

\begin{itemdescr}
\pnum In the following description, let \tcode{$X$} be the name of a type in the \tcode{tag}
namespace above.

\pnum \tcode{tag::$X$} is a tag specifier~(\ref{taggedtup.tagged}) such that
\tcode{\textit{TAGGET}($D$, tag::$X$, $N$)} names a tagged getter~(\ref{taggedtup.tagged})
with DerivedCharacteristic \tcode{$D$}, ElementIndex \tcode{$N$}, and ElementName \tcode{$X$}.

\pnum \enterexample \tcode{tag::in} is a type such that \tcode{\textit{TAGGET}($D$, tag::in, $N$)}
names a type with the following interface:

\begin{codeblock}
struct @\xname{input_getter}@ {
  constexpr decltype(auto) in() &       { return get<@$N$@>(static_cast<@$D$@&>(*this)); }
  constexpr decltype(auto) in() &&      { return get<@$N$@>(static_cast<@$D$@&&>(*this)); }
  constexpr decltype(auto) in() const & { return get<@$N$@>(static_cast<const @$D$@&>(*this)); }
};
\end{codeblock}
\exitexample
\end{itemdescr}

\rSec2[tagged.pairs]{Alias template \tcode{tagged_pair}}

\begin{codeblock}
@\oldtxt{// defined in header <experimental/ranges/utility>}@

namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  // ...
  template <TaggedType T1, TaggedType T2>
  using tagged_pair = tagged<pair<@\textit{TAGELEM}@(T1), @\textit{TAGELEM}@(T2)>,
                             @\textit{TAGSPEC}@(T1), @\textit{TAGSPEC}@(T2)>;
}@\oldtxt{\}\}\}}@

\end{codeblock}

\pnum \enterexample
\begin{codeblock}
@\oldtxt{// See \ref{tagged.tagspec}:}@
tagged_pair<tag::min(int), tag::max(int)> p{0, 1};
assert(&p.min() == &p.first);
assert(&p.max() == &p.second);
\end{codeblock}
\exitexample

\rSec3[tagged.pairs.creation]{Tagged pair creation functions}

\indexlibrary{\idxcode{make_tagged_pair}}%
\begin{itemdecl}
@\oldtxt{// defined in header <experimental/ranges/utility>}@

namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  template <TagSpecifier Tag1, TagSpecifier Tag2, class T1, class T2>
    constexpr @\seebelow@ make_tagged_pair(T1&& x, T2&& y);
}@\oldtxt{\}\}\}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{P} be the type of \tcode{make_pair(std::forward<T1>(x), std::forward<T2>(y))}.
Then the return type is \tcode{tagged<P, Tag1, Tag2>}.

\pnum
\returns \tcode{\{std::forward<T1>(x), std::forward<T2>(y)\}}.

\pnum
\enterexample
In place of:

\begin{codeblock}
  return tagged_pair<tag::min(int), tag::max(double)>(5, 3.1415926);   // explicit types
\end{codeblock}

a \Cpp program may contain:

\begin{codeblock}
  return make_tagged_pair<tag::min, tag::max>(5, 3.1415926);           // types are deduced
\end{codeblock}
\exitexample
\end{itemdescr}

\rSec2[tagged.tuple]{Alias template \tcode{tagged_tuple}}

\pnum
\begin{codeblock}
template <TaggedType... Types>
using tagged_tuple = tagged<tuple<@\textit{TAGELEM}@(Types)...>,
                            @\textit{TAGSPEC}@(Types)...>;
\end{codeblock}

\pnum
\enterexample
\begin{codeblock}
@\oldtxt{// See \ref{tagged.tagspec}:}@
tagged_tuple<tag::in(char*), tag::out(char*)> t{0, 0};
assert(&t.in() == &get<0>(t));
assert(&t.out() == &get<1>(t));
\end{codeblock}
\exitexample

\rSec3[tagged.tuple.creation]{Tagged tuple creation function}

\indexlibrary{\idxcode{make_tagged_tuple}}%
\indexlibrary{\idxcode{tagged_tuple}!\idxcode{make_tagged_tuple}}%
\begin{itemdecl}
template <TagSpecifier... Tags, class... Types>
  requires sizeof...(Tags) == sizeof...(Types)
    constexpr @\seebelow@ make_tagged_tuple(Types&&... t);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{T} be the type of \tcode{make_tuple(std::forward<Types>(t)...)}.
Then the return type is \tcode{tagged<\brk{}T, Tags...>}.

\pnum
\returns \tcode{tagged<T, Tags...>(std::forward<Types>(t)...)}.

\pnum
\enterexample

\begin{codeblock}
int i; float j;
make_tagged_tuple<tag::in1, tag::in2, tag::out>(1, ref(i), cref(j))
\end{codeblock}

creates a tagged tuple of type

\begin{codeblock}
tagged_tuple<tag::in1(int), tag::in2(int&), tag::out(const float&)>
\end{codeblock}
\exitexample
\end{itemdescr}
} % \color{addclr}

\setcounter{section}{13}
\ednote{Add declarations to \tcode{<functional>}:}
\rSec1[function.objects]{Function Objects}

\rSec2[functional.syn]{Header \tcode{<functional>} synopsis}

\begin{codeblock}
  [...]

  template<class T>
    inline constexpr bool is_bind_expression_v = is_bind_expression<T>::value;
  template<class T>
    inline constexpr int is_placeholder_v = is_placeholder<T>::value;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}

  namespace ranges {
    // \ref{range.comparisons}, comparisons:
    template <class T = void>
      requires @\seebelow@
    struct equal_to;

    template <class T = void>
      requires @\seebelow@
    struct not_equal_to;

    template <class T = void>
      requires @\seebelow@
    struct greater;

    template <class T = void>
      requires @\seebelow@
    struct less;

    template <class T = void>
      requires @\seebelow@
    struct greater_equal;

    template <class T = void>
      requires @\seebelow@
    struct less_equal;

    template <> struct equal_to<void>;
    template <> struct not_equal_to<void>;
    template <> struct greater<void>;
    template <> struct less<void>;
    template <> struct greater_equal<void>;
    template <> struct less_equal<void>;
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}
}
\end{codeblock}

\ednote{Add new subclause [range.comparisons] between [comparisons] and [logical.operations]:}
{\color{addclr}
\setcounter{subsection}{7}
\rSec2[range.comparisons]{Comparisons (\tcode{ranges})}

\pnum
\oldtxt{The library provides basic function object classes for all of the comparison
operators in the language~(\cxxref{expr.rel}, \cxxref{expr.eq}).}

\pnum
In this section, \tcode{\textit{BUILTIN_PTR_CMP}(T, $op$, U)} for types \tcode{T}
and \tcode{U} and where $op$ is an equality~(\cxxref{expr.eq}) or relational
operator~(\cxxref{expr.rel}) is a boolean constant expression.
\tcode{\textit{BUILTIN_PTR_CMP}(T, $op$, U)} is \tcode{true} if and only if $op$
in the expression \tcode{declval<T>() $op$ declval<U>()} resolves to a built-in
operator comparing pointers.

\pnum
There is an implementation-defined strict total ordering over all pointer values
of a given type. This total ordering is consistent with the partial order imposed
by the builtin operators \tcode{<}, \tcode{>}, \tcode{<=}, and \tcode{>=}.

\indexlibrary{\idxcode{equal_to}}%
\begin{itemdecl}
template <class T = void>
  requires EqualityComparable<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, ==, const T&)
struct equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return ranges::equal_to<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to}}%
\begin{itemdecl}
template <class T = void>
  requires EqualityComparable<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, ==, const T&)
struct not_equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return !ranges::equal_to<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{greater}}%
\begin{itemdecl}
template <class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct greater {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return ranges::less<>{}(y, x);}
\end{itemdescr}

\indexlibrary{\idxcode{less}}%
\begin{itemdecl}
template <class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct less {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return ranges::less<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal}}%
\begin{itemdecl}
template <class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct greater_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return !ranges::less<>{}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{less_equal}}%
\begin{itemdecl}
template <class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(const T&, <, const T&)
struct less_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to: \tcode{return !ranges::less<>{}(y, x);}
\end{itemdescr}

\indexlibrary{\idxcode{equal_to<>}}%
\begin{itemdecl}
template <> struct equal_to<void> {
  template <class T, class U>
    requires EqualityComparableWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, ==, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires If the expression \tcode{std::forward<T>(t) == std::forward<U>(u)}
results in a call to a built-in operator \tcode{==} comparing pointers of type
\tcode{P}, the conversion sequences from both \tcode{T} and \tcode{U} to \tcode{P}
shall be equality-preserving~(\cxxref{concepts.lib.general.equality}).

\pnum
\effects
\begin{itemize}
\item
If the expression \tcode{std::forward<T>(t) == std::forward<U>(u)} results in a
call to a built-in operator \tcode{==} comparing pointers of type \tcode{P}:
returns \tcode{false} if either (the converted value of) \tcode{t} precedes
\tcode{u} or \tcode{u} precedes \tcode{t} in the implementation-defined strict
total order over pointers of type \tcode{P} and otherwise \tcode{true}.

\item
Otherwise, equivalent to: \tcode{return std::forward<T>(t) == std::forward<U>(u);}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to<>}}%
\begin{itemdecl}
template <> struct not_equal_to<void> {
  template <class T, class U>
    requires EqualityComparableWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, ==, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::equal_to<>{}(std::forward<T>(t), std::forward<U>(u));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{greater<>}}%
\begin{itemdecl}
template <> struct greater<void> {
  template <class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(U, <, T)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return ranges::less<>{}(std::forward<U>(u), std::forward<T>(t));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{less<>}}%
\begin{itemdecl}
template <> struct less<void> {
  template <class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, <, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
If the expression \tcode{std::forward<T>(t) < std::forward<U>(u)} results in a
call to a built-in operator \tcode{<} comparing pointers of type \tcode{P}, the
conversion sequences from both \tcode{T} and \tcode{U} to \tcode{P} shall be
equality-preserving~(\cxxref{concepts.lib.general.equality}). For any expressions
\tcode{ET} and \tcode{EU} such that \tcode{decltype((ET))} is \tcode{T} and
\tcode{decltype((EU))} is \tcode{U}, exactly one of \tcode{ranges::less<>\{\}(ET, EU)},
\tcode{ranges::less<>\{\}(EU, ET)} or \tcode{ranges::equal_to<>\{\}(ET, EU)} shall be
\tcode{true}.

\pnum
\effects
\begin{itemize}
\item
If the expression \tcode{std::forward<T>(t) < std::forward<U>(u)} results in a
call to a built-in operator \tcode{<} comparing pointers of type \tcode{P}:
returns \tcode{true} if (the converted value of) \tcode{t} precedes \tcode{u} in
the implementation-defined strict total order over pointers of type \tcode{P}
and otherwise \tcode{false}.

\item
Otherwise, equivalent to: \tcode{return std::forward<T>(t) < std::forward<U>(u);}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal<>}}%
\begin{itemdecl}
template <> struct greater_equal<void> {
  template <class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(T, <, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::less<>{}(std::forward<T>(t), std::forward<U>(u));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{less_equal<>}}%
\begin{itemdecl}
template <> struct less_equal<void> {
  template <class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\textit{\tcode{BUILTIN_PTR_CMP}}@(U, <, T)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspec@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::less<>{}(std::forward<U>(u), std::forward<T>(t));
\end{codeblock}
\end{itemdescr}
} % \color{addclr}
