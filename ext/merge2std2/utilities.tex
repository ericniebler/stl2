%!TEX root = P0896.tex
\setcounter{chapter}{18}
\rSec0[utilities]{General utilities library}

\setcounter{section}{9}
\rSec1[memory]{Memory}

\setcounter{subsection}{1}
\rSec2[memory.syn]{Header \tcode{<memory>} synopsis}

[...]

\indexhdr{memory}%
\begin{codeblock}
namespace std {
  [...]

  // \cxxref{default.allocator}, the default allocator
  template<class T> class allocator;
  template<class T, class U>
    bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
  template<class T, class U>
    bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;

  // \ref{specialized.algorithms}, specialized algorithms
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  // \ref{special.mem.concepts}, special memory concepts
  template<class I>
    concept @\placeholdernc{no-throw-input-iterator}@ = @\seebelownc@; // \expos

  template<class I>
    concept @\placeholdernc{no-throw-forward-iterator}@ = @\seebelownc@; // \expos

  template<class S, class I>
    concept @\placeholdernc{no-throw-sentinel}@ = @\seebelownc@; // \expos

  template<class R>
    concept @\placeholdernc{no-throw-input-range}@ = @\seebelownc@; // \expos

  template<class R>
    concept @\placeholdernc{no-throw-forward-range}@ = @\seebelownc@; // \expos
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class T>
    constexpr T* addressof(T& r) noexcept;
  template<class T>
    const T* addressof(const T&&) = delete;
  template<class ForwardIterator>
    void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void uninitialized_default_construct(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                         ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator uninitialized_default_construct_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                                      ForwardIterator first, Size n);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires DefaultConstructible<iter_value_t<I>>
        I uninitialized_default_construct(I first, S last);
    template<@\placeholdernc{no-throw-forward-range}@ R>
      requires DefaultConstructible<iter_value_t<iterator_t<R>>>
        safe_iterator_t<R> uninitialized_default_construct(R&& r);

    template<@\placeholdernc{no-throw-forward-iterator}@ I>
      requires DefaultConstructible<iter_value_t<I>>
        I uninitialized_default_construct_n(I first, iter_difference_t<I> n);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class ForwardIterator>
    void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void uninitialized_value_construct(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                       ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator uninitialized_value_construct_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                                    ForwardIterator first, Size n);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires DefaultConstructible<iter_value_t<I>>
        I uninitialized_value_construct(I first, S last);
    template<@\placeholdernc{no-throw-forward-range}@ R>
      requires DefaultConstructible<iter_value_t<iterator_t<R>>>
        safe_iterator_t<R> uninitialized_value_construct(R&& r);

    template<@\placeholdernc{no-throw-forward-iterator}@ I>
      requires DefaultConstructible<iter_value_t<I>>
        I uninitialized_value_construct_n(I first, iter_difference_t<I> n);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class InputIterator, class Size, class ForwardIterator>
    ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
                                         ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator>
    ForwardIterator uninitialized_copy_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                         InputIterator first, Size n,
                                         ForwardIterator result);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using uninitialized_copy_result = copy_result<I, O>;
    template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
      requires Constructible<iter_value_t<O>, iter_reference_t<I>>
        uninitialized_copy_result<I, O>
          uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
    template<InputRange IR, @\placeholdernc{no-throw-forward-range}@ OR>
      requires Constructible<iter_value_t<iterator_t<OR>>, iter_reference_t<iterator_t<IR>>>
        uninitialized_copy_result<safe_iterator_t<IR>, safe_iterator_t<OR>>
          uninitialized_copy(IR&& ir, OR&& or);

    template<class I, class O>
      using uninitialized_copy_n_result = uninitialized_copy_result<I, O>;
    template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
      requires Constructible<iter_value_t<O>, iter_reference_t<I>>
        uninitialized_copy_n_result<I, O>
          uninitialized_copy_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
    ForwardIterator uninitialized_move(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                       InputIterator first, InputIterator last,
                                       ForwardIterator result);
  template<class InputIterator, class Size, class ForwardIterator>
    pair<InputIterator, ForwardIterator> uninitialized_move_n(InputIterator first, Size n,
                                                              ForwardIterator result);
  template<class ExecutionPolicy, class InputIterator, class Size, class ForwardIterator>
    pair<InputIterator, ForwardIterator> uninitialized_move_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                                              InputIterator first, Size n,
                                                              ForwardIterator result);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<class I, class O>
      using uninitialized_move_result = uninitialized_copy_result<I, O>;
    template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
      requires Constructible<iter_value_t<O>, iter_rvalue_reference_t<I>>
        uninitialized_move_result<I, O>
          uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
    template<InputRange IR, @\placeholdernc{no-throw-forward-range}@ OR>
      requires Constructible<iter_value_t<iterator_t<OR>>, iter_rvalue_reference_t<iterator_t<IR>>>
        uninitialized_move_result<safe_iterator_t<IR>, safe_iterator_t<OR>>
          uninitialized_move(IR&& ir, OR&& or);

    template<class I, class O>
      using uninitialized_move_n_result = uninitialized_copy_result<I, O>;
    template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
      requires Constructible<iter_value_t<O>, iter_rvalue_reference_t<I>>
        uninitialized_move_n_result<I, O>
          uninitialized_move_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class ForwardIterator, class T>
    void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void uninitialized_fill(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                            ForwardIterator first, ForwardIterator last, const T& x);
  template<class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
    ForwardIterator uninitialized_fill_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                         ForwardIterator first, Size n, const T& x);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S, class T>
      requires Constructible<iter_value_t<I>, const T&>
        I uninitialized_fill(I first, S last, const T& x);
    template<@\placeholdernc{no-throw-forward-range}@ R, class T>
      requires Constructible<iter_value_t<iterator_t<R>>, const T&>
        safe_iterator_t<R> uninitialized_fill(R&& r, const T& x);

    template<@\placeholdernc{no-throw-forward-iterator}@ I, class T>
      requires Constructible<iter_value_t<I>, const T&>
        I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  template<class T>
    void destroy_at(T* location);
  template<class ForwardIterator>
    void destroy(ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    void destroy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Size>
    ForwardIterator destroy_n(ForwardIterator first, Size n);
  template<class ExecutionPolicy, class ForwardIterator, class Size>
    ForwardIterator destroy_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                              ForwardIterator first, Size n);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  namespace ranges {
    template<Destructible T>
      void destroy_at(T* location) noexcept;

    template<@\placeholdernc{no-throw-input-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires Destructible<iter_value_t<I>>
        I destroy(I first, S last) noexcept;
    template<@\placeholdernc{no-throw-input-range}@ R>
      requires Destructible<iter_value_t<iterator_t<R>>
        safe_iterator_t<R> destroy(R&& r) noexcept;

    template<@\placeholdernc{no-throw-input-iterator}@ I>
      requires Destructible<iter_value_t<I>>
        I destroy_n(I first, iter_difference_t<I> n) noexcept;
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}

  [...]
}
\end{codeblock}

[...]

\setcounter{subsection}{10}
\rSec2[specialized.algorithms]{Specialized algorithms}

\pnum
Throughout this subclause, the names of template parameters are used to
express type requirements \added{for those algorithms defined directly
in namespace \tcode{std}}.
\begin{itemize}
\item
If an algorithm's template parameter is named \tcode{InputIterator},
the template argument shall \changed{satisfy}{meet} the
\oldconcept{InputIterator} requirements\iref{input.iterators}.
\item
If an algorithm's template parameter is named \tcode{ForwardIterator},
the template argument shall \changed{satisfy}{meet} the
\oldconcept{ForwardIterator} requirements\iref{forward.iterators}, and
is required to have the property that no exceptions are thrown
from increment, assignment, comparison, or indirection through valid iterators.
\end{itemize}
\removed{Unless otherwise specified,
if an exception is thrown in the following algorithms there are no effects.}

\begin{addedblock}
\pnum
Unless otherwise specified,
if an exception is thrown in the following algorithms there are no effects.

\pnum
In the description of the algorithms, operator \tcode{-}
is used for some of the iterator categories for which
it need not be defined.
In these cases, the value of the expression \tcode{b - a}
is the number of increments of \tcode{a} needed to make
\tcode{bool(a == b)} be \tcode{true}.

\pnum
The following additional requirements apply for those algorithms
defined in namespace \tcode{std::ranges}:
\begin{itemize}
\item The entities defined in the \tcode{std::ranges} namespace
  in this subclause are not found by argument-dependent
  name lookup\cxxiref{basic.lookup.argdep}. When found by
  unqualified\cxxiref{basic.lookup.unqual} name lookup for the
  \grammarterm{postfix-expression} in a function call\cxxiref{expr.call}, they
  inhibit argument-dependent name lookup.
\item Overloads of algorithms that take \libconcept{Range} arguments\iref{range.range}
  behave as if they are implemented by calling \tcode{ranges::begin}
  and \tcode{ranges::end} on the \libconcept{Range}(s) and dispatching to the
  overload that takes separate iterator and sentinel arguments.
\item The number and order of template parameters for algorithm declarations
  is unspecified, except where explicitly stated otherwise.
  \begin{note}
  Consequently, these algorithms may not be called with
  explicitly-specified template argument lists.
  \end{note}
\end{itemize}

\pnum
\begin{note}
When invoked on ranges of
potentially overlapping subobjects\cxxiref{intro.object},
the algorithms specified in this subclause \ref{specialized.algorithms}
result in undefined behavior.
\end{note}

\pnum
Some algorithms defined in this clause make use of the exposition-only function
\tcode{\placeholdernc{voidify}}:
\begin{codeblock}
template<class T>
  void* @\placeholdernc{voidify}@(T& ptr) noexcept {
    return const_cast<void*>(static_cast<const volatile void*>(addressof(ptr)));
  }
\end{codeblock}

\rSec3[special.mem.concepts]{Special memory concepts}

\pnum
Some algorithms in this subclause are constrained with the following
exposition-only concepts:

\begin{itemdecl}
template<class I>
concept @\placeholdernc{no-throw-input-iterator}@ = // exposition only
  InputIterator<I> &&
  is_lvalue_reference_v<iter_reference_t<I>> &&
  Same<remove_cvref_t<iter_reference_t<I>>, iter_value_t<I>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
No exceptions are thrown from increment,
copy construction, move construction,
copy assignment, move assignment,
or indirection through valid iterators.

\pnum
\begin{note}
This concept does not require that all operations required by
\tcode{InputIterator}\iref{iterator.concept.input} are non-throwing.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class S, class I>
concept @\placeholdernc{no-throw-sentinel}@ = Sentinel<S, I>; // exposition only
\end{itemdecl}

\begin{itemdescr}
\pnum
No exceptions are thrown from copy construction, move construction,
copy assignment, move assignment, or comparisons between
valid values of type \tcode{I} and \tcode{S}.

\pnum
\begin{note}
This concept does not require that all operations required by
\tcode{Sentinel}\iref{iterator.concept.sentinel} are non-throwing.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class R>
concept @\placeholdernc{no-throw-input-range}@ = // exposition only
  Range<R> &&
  @\placeholder{no-throw-input-iterator}@<iterator_t<R>> &&
  @\placeholdernc{no-throw-sentinel}@<sentinel_t<R>, iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum No exceptions are thrown from calls to \tcode{ranges::begin} and
\tcode{ranges::end} on an object of type \tcode{R}.
\end{itemdescr}

\begin{itemdecl}
template<class I>
concept @\placeholdernc{no-throw-forward-iterator}@ = // exposition only
  @\placeholder{no-throw-input-iterator}@<I> &&
  ForwardIterator<I> &&
  @\placeholdernc{no-throw-sentinel}@<I, I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{note}
This concept does not require that all operations required by
\tcode{ForwardIterator}\iref{iterator.concept.forward} are non-throwing.
\end{note}
\end{itemdescr}

\begin{itemdecl}
template<class R>
concept @\placeholdernc{no-throw-forward-range}@ = // exposition only
  @\placeholder{no-throw-input-range}@<R> &&
  @\placeholder{no-throw-forward-iterator}@<iterator_t<R>>;
\end{itemdecl}
\end{addedblock}

\rSec3[specialized.addressof]{\tcode{addressof}}

[...]

\rSec3[uninitialized.construct.default]{\tcode{uninitialized_default_construct}}

\indexlibrary{\idxcode{uninitialized_default_construct}}%
\begin{itemdecl}
template<class ForwardIterator>
  void uninitialized_default_construct(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*first)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_default_construct}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires DefaultConstructible<iter_value_t<I>>
    I uninitialized_default_construct(I first, S last);
  template<@\placeholdernc{no-throw-forward-range}@ R>
      requires DefaultConstructible<iter_value_t<iterator_t<R>>>
    safe_iterator_t<R> uninitialized_default_construct(R&& r);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first)) remove_reference_t<iter_reference_t<I>>;
return first;
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_default_construct_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator uninitialized_default_construct_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*first)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type;
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_default_construct_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I>
      requires DefaultConstructible<iter_value_t<I>>
    I uninitialized_default_construct_n(I first, iter_difference_t<I> n);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return uninitialized_default_construct(counted_iterator(first, n),
                                       default_sentinel{}).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.construct.value]{\tcode{uninitialized_value_construct}}

\indexlibrary{\idxcode{uninitialized_value_construct}}%
\begin{itemdecl}
template<class ForwardIterator>
  void uninitialized_value_construct(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*first)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type();
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_value_construct}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires DefaultConstructible<iter_value_t<I>>
    I uninitialized_value_construct(I first, S last);
  template<@\placeholdernc{no-throw-forward-range}@ R>
      requires DefaultConstructible<iter_value_t<iterator_t<R>>>
    safe_iterator_t<R> uninitialized_value_construct(R&& r);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\placeholdernc{voidify}@(*first)) remove_reference_t<iter_reference_t<I>>();
return first;
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_value_construct_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator uninitialized_value_construct_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*first)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type();
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_value_construct_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I>
      requires DefaultConstructible<iter_value_t<I>>
    I uninitialized_value_construct_n(I first, iter_difference_t<I> n);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return uninitialized_value_construct(counted_iterator(first, n),
                                     default_sentinel{}).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.copy]{\tcode{uninitialized_copy}}

\indexlibrary{\idxcode{uninitialized_copy}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\expects
\range{result}{(last - first)} shall not overlap with \range{first}{last}.
\end{addedblock}

\pnum
\effects
\changed{As if by}{Equivalent to}:
\begin{codeblock}
for (; first != last; ++result, (void) ++first)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*result)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type(*first);
\end{codeblock}

\pnum
\returns
\tcode{result}.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_copy}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
      requires Constructible<iter_value_t<O>, iter_reference_t<I>>
    uninitialized_copy_result<I, O>
      uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<InputRange IR, @\placeholdernc{no-throw-forward-range}@ OR>
      requires Constructible<iter_value_t<iterator_t<OR>>, iter_reference_t<iterator_t<IR>>>
    uninitialized_copy_result<safe_iterator_t<IR>, safe_iterator_t<OR>>
      uninitialized_copy(IR&& ir, OR&& or);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} shall not overlap with \range{ifirst}{ilast}.

\pnum
\effects Equivalent to:
\begin{codeblock}
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst) {
  ::new (@\placeholdernc{voidify}@(*ofirst)) remove_reference_t<iter_reference_t<O>>(*ifirst);
}
return {ifirst, ofirst};
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_copy_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class ForwardIterator>
  ForwardIterator uninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\expects
\range{result}{n} shall not overlap with \range{first}{n}.
\end{addedblock}

\pnum
\effects
\changed{As if by}{Equivalent to}:
\begin{codeblock}
for ( ; n > 0; ++result, (void) ++first, --n) {
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*result)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type(*first);
}
\end{codeblock}

\pnum
\returns \tcode{result}.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_copy_n}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
      requires Constructible<iter_value_t<O>, iter_reference_t<I>>
    uninitialized_copy_n_result<I, O>
      uninitialized_copy_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} shall not overlap with
\range{ifirst}{n}.

\pnum
\effects Equivalent to:
\begin{codeblock}
auto t = uninitialized_copy(counted_iterator(ifirst, n),
                            default_sentinel{}, ofirst, olast);
return {t.in.base(), t.out};
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.move]{\tcode{uninitialized_move}}

\indexlibrary{\idxcode{uninitialized_move}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_move(InputIterator first, InputIterator last,
                                     ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\expects
\range{result}{(last - first)} shall not overlap with \range{first}{last}.
\end{addedblock}

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first != last; (void)++result, ++first)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*result)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
return result;
\end{codeblock}

\pnum
\remarks
If an exception is thrown, some objects in the range \range{first}{last}
are left in a valid but unspecified state.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_move}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S1, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S2>
      requires Constructible<iter_value_t<O>, iter_rvalue_reference_t<I>>
    uninitialized_move_result<I, O>
      uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);
  template<InputRange IR, @\placeholdernc{no-throw-forward-range}@ OR>
      requires Constructible<iter_value_t<iterator_t<OR>>, iter_rvalue_reference_t<iterator_t<IR>>>
    uninitialized_move_result<safe_iterator_t<IR>, safe_iterator_t<OR>>
      uninitialized_move(IR&& ir, OR&& or);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} shall not overlap with \range{ifirst}{ilast}.

\pnum
\effects Equivalent to:
\begin{codeblock}
for (; ifirst != ilast && ofirst != olast; ++ofirst, (void)++ifirst) {
  ::new (@\placeholdernc{voidify}@(*ofirst)) remove_reference_t<iter_reference_t<O>>(ranges::iter_move(ifirst));
}
return {ifirst, ofirst};
\end{codeblock}

\pnum
\begin{note}
If an exception is thrown, some objects in the range \range{first}{last} are
left in a valid, but unspecified state.
\end{note}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_move_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class ForwardIterator>
  pair<InputIterator, ForwardIterator>
    uninitialized_move_n(InputIterator first, Size n, ForwardIterator result);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\expects
\range{result}{n} shall not overlap with \range{first}{n}.
\end{addedblock}

\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; ++result, (void) ++first, --n)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*result)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
return {first,result};
\end{codeblock}

\pnum
\remarks
If an exception is thrown, some objects in the range
\range{first}{\changed{std::next(first,n)}{n}}
are left in a valid but unspecified state.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_move_n}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, @\placeholdernc{no-throw-forward-iterator}@ O, @\placeholdernc{no-throw-sentinel}@<O> S>
      requires Constructible<iter_value_t<O>, iter_rvalue_reference_t<I>>
    uninitialized_move_n_result<I, O>
      uninitialized_move_n(I ifirst, iter_difference_t<I> n, O ofirst, S olast);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\range{ofirst}{olast} shall not overlap with
\range{ifirst}{n}.

\pnum
\effects Equivalent to:
\begin{codeblock}
auto t = uninitialized_move(counted_iterator(ifirst, n),
                            default_sentinel{}, ofirst, olast);
return {t.in.base(), t.out};
\end{codeblock}

\pnum
\begin{note}
If an exception is thrown, some objects in the range
\range{first}{n}
are left in a valid but unspecified state.
\end{note}
\end{itemdescr}
\end{addedblock}

\rSec3[uninitialized.fill]{\tcode{uninitialized_fill}}

\indexlibrary{\idxcode{uninitialized_fill}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\changed{As if by}{Equivalent to}:
\begin{codeblock}
for (; first != last; ++first)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*first)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type(x);
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_fill}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S, class T>
      requires Constructible<iter_value_t<I>, const T&>
    I uninitialized_fill(I first, S last, const T& x);
  template<@\placeholdernc{no-throw-forward-range}@ R, class T>
      requires Constructible<iter_value_t<iterator_t<R>>, const T&>
    safe_iterator_t<R> uninitialized_fill(R&& r, const T& x);
}
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first) {
  ::new (@\placeholdernc{voidify}@(*first)) remove_reference_t<iter_reference_t<I>>(x);
}
return first;
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{uninitialized_fill_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size, class T>
  ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\changed{As if by}{Equivalent to}:
\begin{codeblock}
for (; n--; ++first)
  ::new (@\changed{static_cast<void*>(addressof}{\placeholder{voidify}}@(*first)@\removed{)}@)
    typename iterator_traits<ForwardIterator>::value_type(x);
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{uninitialized_fill_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-forward-iterator}@ I, class T>
      requires Constructible<iter_value_t<I>, const T&>
    I uninitialized_fill_n(I first, iter_difference_t<I> n, const T& x);
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return uninitialized_fill(counted_iterator(first, n), default_sentinel{}, x).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[specialized.destroy]{\tcode{destroy}}

\indexlibrary{\idxcode{destroy_at}}%
\begin{itemdecl}
template<class T>
  void destroy_at(T* location);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<Destructible T>
    void destroy_at(T* location) noexcept;
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item \added{If \tcode{T} is an array type, equivalent to
  \tcode{destroy(begin(*location), end(*location))}.}
\item \added{Otherwise,} equivalent to
  \tcode{location->\~T()\removed{;}}\added{.}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{destroy}}%
\begin{itemdecl}
template<class ForwardIterator>
  void destroy(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; first!=last; ++first)
  destroy_at(addressof(*first));
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{destroy}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-input-iterator}@ I, @\placeholdernc{no-throw-sentinel}@<I> S>
      requires Destructible<iter_value_t<I>>
    I destroy(I first, S last) noexcept;
  template<@\placeholdernc{no-throw-input-range}@ R>
      requires Destructible<iter_value_t<iterator_t<R>>>
    safe_iterator_t<R> destroy(R&& r) noexcept;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
for (; first != last; ++first)
  destroy_at(addressof(*first));
return first;
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{destroy_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size>
  ForwardIterator destroy_n(ForwardIterator first, Size n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
for (; n > 0; (void)++first, --n)
  destroy_at(addressof(*first));
return first;
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{destroy_n}}%
\begin{itemdecl}
namespace ranges {
  template<@\placeholdernc{no-throw-input-iterator}@ I>
      requires Destructible<iter_value_t<I>>
    I destroy_n(I first, iter_difference_t<I> n) noexcept;
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return destroy(counted_iterator(first, n), default_sentinel{}).base();
\end{codeblock}
\end{itemdescr}
\end{addedblock}

[...]

\setcounter{section}{13}
\rSec1[function.objects]{Function Objects}

\rSec2[functional.syn]{Header \tcode{<functional>} synopsis}

\begin{codeblock}
  [...]

  template<class T>
    inline constexpr bool is_bind_expression_v = is_bind_expression<T>::value;
  template<class T>
    inline constexpr int is_placeholder_v = is_placeholder<T>::value;
\end{codeblock}
\begin{addedblock}
\begin{codeblock}

  namespace ranges {
    // \ref{range.comparisons}, comparisons
    template<class T = void>
      requires @\seebelow@
    struct equal_to;

    template<class T = void>
      requires @\seebelow@
    struct not_equal_to;

    template<class T = void>
      requires @\seebelow@
    struct greater;

    template<class T = void>
      requires @\seebelow@
    struct less;

    template<class T = void>
      requires @\seebelow@
    struct greater_equal;

    template<class T = void>
      requires @\seebelow@
    struct less_equal;

    template<> struct equal_to<void>;
    template<> struct not_equal_to<void>;
    template<> struct greater<void>;
    template<> struct less<void>;
    template<> struct greater_equal<void>;
    template<> struct less_equal<void>;
  }
\end{codeblock}
\end{addedblock}
\begin{codeblock}
}
\end{codeblock}

[...]

\setcounter{subsection}{6}
\rSec2[comparisons]{Comparisons}

[...]

\begin{addedblock}
\rSec2[range.comparisons]{Comparisons (\tcode{ranges})}

\pnum
In this subclause, \tcode{\placeholdernc{BUILTIN_PTR_CMP}(T, $op$, U)} for types \tcode{T}
and \tcode{U} and where $op$ is an equality\cxxiref{expr.eq} or relational
operator\cxxiref{expr.rel} is a boolean constant expression.
\tcode{\placeholdernc{BUILTIN_PTR_CMP}(T, $op$, U)} is \tcode{true} if and only if $op$
in the expression \tcode{declval<T>() $op$ declval<U>()} resolves to a built-in
operator comparing pointers.

\pnum
There is an implementation-defined strict total ordering over all pointer values
of a given type. This total ordering is consistent with the partial order imposed
by the builtin operators \tcode{<}, \tcode{>}, \tcode{<=}, and \tcode{>=}.

\indexlibrary{\idxcode{equal_to}}%
\begin{itemdecl}
template<class T = void>
  requires EqualityComparable<T> || Same<T, void> || @\placeholdernc{BUILTIN_PTR_CMP}@(const T&, ==, const T&)
struct equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\tcode{return ranges::equal_to<>\{\}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to}}%
\begin{itemdecl}
template<class T = void>
  requires EqualityComparable<T> || Same<T, void> || @\placeholdernc{BUILTIN_PTR_CMP}@(const T&, ==, const T&)
struct not_equal_to {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\tcode{return !ranges::equal_to<>\{\}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{greater}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\placeholdernc{BUILTIN_PTR_CMP}@(const T&, <, const T&)
struct greater {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\tcode{return ranges::less<>\{\}(y, x);}
\end{itemdescr}

\indexlibrary{\idxcode{less}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\placeholdernc{BUILTIN_PTR_CMP}@(const T&, <, const T&)
struct less {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\tcode{return ranges::less<>\{\}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\placeholdernc{BUILTIN_PTR_CMP}@(const T&, <, const T&)
struct greater_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\tcode{return !ranges::less<>\{\}(x, y);}
\end{itemdescr}

\indexlibrary{\idxcode{less_equal}}%
\begin{itemdecl}
template<class T = void>
  requires StrictTotallyOrdered<T> || Same<T, void> || @\placeholdernc{BUILTIN_PTR_CMP}@(const T&, <, const T&)
struct less_equal {
  constexpr bool operator()(const T& x, const T& y) const;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\tcode{return !ranges::less<>\{\}(y, x);}
\end{itemdescr}

\indexlibrary{\idxcode{equal_to<>}}%
\begin{itemdecl}
template<> struct equal_to<void> {
  template<class T, class U>
    requires EqualityComparableWith<T, U> || @\placeholdernc{BUILTIN_PTR_CMP}@(T, ==, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
If the expression \tcode{std::forward<T>(t) == std::forward<U>(u)}
results in a call to a built-in operator \tcode{==} comparing pointers of type
\tcode{P}, the conversion sequences from both \tcode{T} and \tcode{U} to \tcode{P}
shall be equality-preserving\cxxiref{concepts.equality}.

\pnum
\effects
\begin{itemize}
\item
  If the expression \tcode{std::forward<T>(t) == std::forward<U>(u)} results in
  a call to a built-in operator \tcode{==} comparing pointers of type \tcode{P}:
  returns \tcode{false} if either (the converted value of) \tcode{t} precedes
  \tcode{u} or \tcode{u} precedes \tcode{t} in the implementation-defined strict
  total order over pointers of type \tcode{P} and otherwise \tcode{true}.

\item
  Otherwise, equivalent to:
  \tcode{return std::forward<T>(t) == std::forward<U>(u);}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{not_equal_to<>}}%
\begin{itemdecl}
template<> struct not_equal_to<void> {
  template<class T, class U>
    requires EqualityComparableWith<T, U> || @\placeholdernc{BUILTIN_PTR_CMP}@(T, ==, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::equal_to<>{}(std::forward<T>(t), std::forward<U>(u));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{greater<>}}%
\begin{itemdecl}
template<> struct greater<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\placeholdernc{BUILTIN_PTR_CMP}@(U, <, T)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return ranges::less<>{}(std::forward<U>(u), std::forward<T>(t));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{less<>}}%
\begin{itemdecl}
template<> struct less<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\placeholdernc{BUILTIN_PTR_CMP}@(T, <, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
If the expression \tcode{std::forward<T>(t) < std::forward<U>(u)} results in a
call to a built-in operator \tcode{<} comparing pointers of type \tcode{P}, the
conversion sequences from both \tcode{T} and \tcode{U} to \tcode{P} shall be
equality-preserving\cxxiref{concepts.equality}. For any expressions
\tcode{ET} and \tcode{EU} such that \tcode{decltype((ET))} is \tcode{T} and
\tcode{decltype((EU))} is \tcode{U}, exactly one of
\tcode{ranges::less<>\{\}(ET, EU)},
\tcode{ranges::less<>\{\}(EU, ET)}, or
\tcode{ranges::equal_to<>\{\}(ET, EU)}
shall be \tcode{true}.

\pnum
\effects
\begin{itemize}
\item
If the expression \tcode{std::forward<T>(t) < std::forward<U>(u)} results in a
call to a built-in operator \tcode{<} comparing pointers of type \tcode{P}:
returns \tcode{true} if (the converted value of) \tcode{t} precedes \tcode{u} in
the implementation-defined strict total order over pointers of type \tcode{P}
and otherwise \tcode{false}.

\item
Otherwise, equivalent to:
\tcode{return std::forward<T>(t) < std::forward<U>(u);}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{greater_equal<>}}%
\begin{itemdecl}
template<> struct greater_equal<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\placeholdernc{BUILTIN_PTR_CMP}@(T, <, U)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::less<>{}(std::forward<T>(t), std::forward<U>(u));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{less_equal<>}}%
\begin{itemdecl}
template<> struct less_equal<void> {
  template<class T, class U>
    requires StrictTotallyOrderedWith<T, U> || @\placeholdernc{BUILTIN_PTR_CMP}@(U, <, T)
  constexpr bool operator()(T&& t, U&& u) const;

  using is_transparent = @\unspecnc@;
};
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{operator()} has effects equivalent to:
\begin{codeblock}
return !ranges::less<>{}(std::forward<U>(u), std::forward<T>(t));
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec2[logical.operations]{Logical operations}

[...]
