%!TEX root = P0896.tex
\setcounter{chapter}{28}
\ednote{Add a new clause between [algorithm] and [numerics] with the following content:}
{\color{addclr}
\rSec0[range]{Ranges library}

\rSec1[range.general]{General}

\pnum
This clause describes components for dealing with ranges of elements.

\pnum
The following subclauses describe
range and view requirements, and
components for
range primitives
as summarized in Table~\ref{tab:ranges.lib.summary}.

\begin{libsumtab}{Ranges library summary}{tab:ranges.lib.summary}
  \ref{range.iterators}    & Iterators         & \tcode{<\oldtxt{experimental/ranges/}range>} \\
  \ref{range.access}       & Range access      & \\
  \ref{range.primitives}   & Range primitives  & \\
  \ref{range.requirements} & Requirements      & \\
  \ref{range.algorithms}   & Algorithms        & \\
\end{libsumtab}

\rSec1[range.decaycopy]{decay_copy}

\ednote{TODO: Replace the definition of [thread.decaycopy] with this definition.}

\pnum
Several places in this clause use the expression \tcode{\textit{DECAY_COPY}(x)},
which is expression-equivalent to:
\begin{codeblock}
  decay_t<decltype((x))>(x)
\end{codeblock}

\rSec1[range.synopsis]{Header \tcode{<range>} synopsis}

\indexlibrary{\idxhdr{range}}%
\begin{codeblock}
@\oldtxt{\#include <experimental/ranges/iterator>}@
#include <initializer_list>

namespace std { @\oldtxt{namespace experimental \{}@
  namespace ranges { @\oldtxt{inline namespace v1 \{}@
    template <class T> concept @\oldtxt{bool}@ @\placeholder{dereferenceable}@ // \expos
      = requires(T& t) { {*t} -> auto&&; };

    // \ref{range.iterator.requirements}, iterator requirements:
    // \ref{range.iterator.custpoints}, customization points:
    @\newtxt{inline}@ namespace @\newtxt{\unspec}@ {
      // \ref{range.iterator.custpoints.iter_move}, iter_move:
      @\newtxt{inline}@ constexpr @\unspec@ iter_move = @\unspec@;

      // \ref{range.iterator.custpoints.iter_swap}, iter_swap:
      @\newtxt{inline}@ constexpr @\unspec@ iter_swap = @\unspec@;
    }

    // \ref{range.iterator.assoc.types}, associated types:
    // \ref{range.iterator.assoc.types.difference_type}, difference_type:
    template <class> struct difference_type;
    template <class T> using difference_type_t
      = typename difference_type<T>::type;

    // \ref{range.iterator.assoc.types.value_type}, value_type:
    template <class> struct value_type;
    template <class T> using value_type_t
      = typename value_type<T>::type;

    // \ref{range.iterator.assoc.types.iterator_category}, iterator_category:
    template <class> struct iterator_category;
    template <class T> using iterator_category_t
      = typename iterator_category<T>::type;

    template <@\placeholder{dereferenceable}@ T> using reference_t
      = decltype(*declval<T&>());

    template <@\placeholder{dereferenceable}@ T>
        requires @\seebelow@ using rvalue_reference_t
      = decltype(ranges::iter_move(declval<T&>()));

    // \ref{range.iterators.readable}, Readable:
    template <class In>
    concept @\oldtxt{bool}@ Readable = @\seebelow@;

    // \ref{range.iterators.writable}, Writable:
    template <class Out, class T>
    concept @\oldtxt{bool}@ Writable = @\seebelow@;

    // \ref{range.iterators.weaklyincrementable}, WeaklyIncrementable:
    template <class I>
    concept @\oldtxt{bool}@ WeaklyIncrementable = @\seebelow@;

    // \ref{range.iterators.incrementable}, Incrementable:
    template <class I>
    concept @\oldtxt{bool}@ Incrementable = @\seebelow@;

    // \ref{range.iterators.iterator}, Iterator:
    template <class I>
    concept @\oldtxt{bool}@ Iterator = @\seebelow@;

    // \ref{range.iterators.sentinel}, Sentinel:
    template <class S, class I>
    concept @\oldtxt{bool}@ Sentinel = @\seebelow@;

    // \ref{range.iterators.sizedsentinel}, SizedSentinel:
    template <class S, class I>
    constexpr bool disable_sized_sentinel = false;

    template <class S, class I>
    concept @\oldtxt{bool}@ SizedSentinel = @\seebelow@;

    // \ref{range.iterators.input}, InputIterator:
    template <class I>
    concept @\oldtxt{bool}@ InputIterator = @\seebelow@;

    // \ref{range.iterators.output}, OutputIterator:
    template <class I>
    concept @\oldtxt{bool}@ OutputIterator = @\seebelow@;

    // \ref{range.iterators.forward}, ForwardIterator:
    template <class I>
    concept @\oldtxt{bool}@ ForwardIterator = @\seebelow@;

    // \ref{range.iterators.bidirectional}, BidirectionalIterator:
    template <class I>
    concept @\oldtxt{bool}@ BidirectionalIterator = @\seebelow@;

    // \ref{range.iterators.random.access}, RandomAccessIterator:
    template <class I>
    concept @\oldtxt{bool}@ RandomAccessIterator = @\seebelow@;

    // \ref{range.indirectcallable}, indirect callable requirements:
    // \ref{range.indirectcallable.indirectinvocable}, indirect callables:
    template <class F, class I>
    concept @\oldtxt{bool}@ IndirectUnaryInvocable = @\seebelow@;

    template <class F, class I>
    concept @\oldtxt{bool}@ IndirectRegularUnaryInvocable = @\seebelow@;

    template <class F, class I>
    concept @\oldtxt{bool}@ IndirectUnaryPredicate = @\seebelow@;

    template <class F, class I1, class I2 = I1>
    concept @\oldtxt{bool}@ IndirectRelation = @\seebelow@;

    template <class F, class I1, class I2 = I1>
    concept @\oldtxt{bool}@ IndirectStrictWeakOrder = @\seebelow@;

    template <class@\newtxt{, class...}@>
    struct indirect_result@\oldtxt{_of}@ @\newtxt{\{ \}}@;

    template <class F, class... Is>
      requires @\newtxt{(Readable<Is> \&\& ...) \&\&}@ Invocable<F, reference_t<Is>...>
    struct indirect_result@\oldtxt{_of}@<F@\oldtxt{(}\newtxt{, }@Is...@\oldtxt{)}@>;

    template <class F@\newtxt{, class... Is}@>
    using indirect_result@\oldtxt{_of}@_t
      = typename indirect_result@\oldtxt{_of}@<F@\newtxt{, Is...}@>::type;

    // \ref{range.projected}, projected:
    template <Readable I, IndirectRegularUnaryInvocable<I> Proj>
    struct projected;

    template <WeaklyIncrementable I, class Proj>
    struct difference_type<projected<I, Proj>>;

    // \ref{range.commonalgoreq}, common algorithm requirements:
    // \ref{range.commonalgoreq.indirectlymovable} IndirectlyMovable:
    template <class In, class Out>
    concept @\oldtxt{bool}@ IndirectlyMovable = @\seebelow@;

    template <class In, class Out>
    concept @\oldtxt{bool}@ IndirectlyMovableStorable = @\seebelow@;

    // \ref{range.commonalgoreq.indirectlycopyable} IndirectlyCopyable:
    template <class In, class Out>
    concept @\oldtxt{bool}@ IndirectlyCopyable = @\seebelow@;

    template <class In, class Out>
    concept @\oldtxt{bool}@ IndirectlyCopyableStorable = @\seebelow@;

    // \ref{range.commonalgoreq.indirectlyswappable} IndirectlySwappable:
    template <class I1, class I2 = I1>
    concept @\oldtxt{bool}@ IndirectlySwappable = @\seebelow@;

    // \ref{range.commonalgoreq.indirectlycomparable} IndirectlyComparable:
    template <class I1, class I2, class R = equal_to<>, class P1 = identity,
        class P2 = identity>
    concept @\oldtxt{bool}@ IndirectlyComparable = @\seebelow@;

    // \ref{range.commonalgoreq.permutable} Permutable:
    template <class I>
    concept @\oldtxt{bool}@ Permutable = @\seebelow@;

    // \ref{range.commonalgoreq.mergeable} Mergeable:
    template <class I1, class I2, class Out,
        class R = less<>, class P1 = identity, class P2 = identity>
    concept @\oldtxt{bool}@ Mergeable = @\seebelow@;

    template <class I, class R = less<>, class P = identity>
    concept @\oldtxt{bool}@ Sortable = @\seebelow@;

    // \ref{range.iterator.primitives}, primitives:
    // \ref{range.iterator.traits}, traits:
    template <class Iterator> using iterator_traits = @\seebelow@;

    template <Readable T> using iter_common_reference_t
      = common_reference_t<reference_t<T>, value_type_t<T>&>;

    // \ref{range.iterator.tags}, iterator tags:
    struct output_iterator_tag { };
    struct input_iterator_tag { };
    struct forward_iterator_tag : input_iterator_tag { };
    struct bidirectional_iterator_tag : forward_iterator_tag { };
    struct random_access_iterator_tag : bidirectional_iterator_tag { };

    // \ref{range.iterator.operations}, iterator operations:
    @\newtxt{inline}@ namespace @\newtxt{\unspec}@ {
      @\newtxt{inline}@ constexpr @\unspec@ advance = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ distance = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ next = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ prev = @\unspec@;
    }

    // \ref{range.iterators.predef}, predefined iterators and sentinels:

    // \ref{range.iterators.reverse}, reverse iterators:
    template <BidirectionalIterator I> class reverse_iterator;

    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator==(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator!=(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>=(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<=(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);

    template <class I1, class I2>
        requires SizedSentinel<I1, I2>
      constexpr difference_type_t<I2> operator-(
        const reverse_iterator<I1>& x,
        const reverse_iterator<I2>& y);
    template <RandomAccessIterator I>
      constexpr reverse_iterator<I> operator+(
        difference_type_t<I> n,
        const reverse_iterator<I>& x);

    template <BidirectionalIterator I>
      constexpr reverse_iterator<I> make_reverse_iterator(I i);

    // \ref{range.iterators.insert}, insert iterators:
    template <class Container> class back_insert_iterator;
    template <class Container>
      back_insert_iterator<Container> back_inserter(Container& x);

    template <class Container> class front_insert_iterator;
    template <class Container>
      front_insert_iterator<Container> front_inserter(Container& x);

    template <class Container> class insert_iterator;
    template <class Container>
      insert_iterator<Container> inserter(Container& x, iterator_t<Container> i);

    // \ref{range.iterators.move}, move iterators and sentinels:
    template <InputIterator I> class move_iterator;
    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator==(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires EqualityComparableWith<I1, I2>
      constexpr bool operator!=(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator<=(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>(
        const move_iterator<I1>& x, const move_iterator<I2>& y);
    template <class I1, class I2>
        requires StrictTotallyOrderedWith<I1, I2>
      constexpr bool operator>=(
        const move_iterator<I1>& x, const move_iterator<I2>& y);

    template <class I1, class I2>
        requires SizedSentinel<I1, I2>
      constexpr difference_type_t<I2> operator-(
        const move_iterator<I1>& x,
        const move_iterator<I2>& y);
    template <RandomAccessIterator I>
      constexpr move_iterator<I> operator+(
        difference_type_t<I> n,
        const move_iterator<I>& x);
    template <InputIterator I>
      constexpr move_iterator<I> make_move_iterator(I i);

    template <Semiregular S> class move_sentinel;

    template <class I, Sentinel<I> S>
      constexpr bool operator==(
        const move_iterator<I>& i, const move_sentinel<S>& s);
    template <class I, Sentinel<I> S>
      constexpr bool operator==(
        const move_sentinel<S>& s, const move_iterator<I>& i);
    template <class I, Sentinel<I> S>
      constexpr bool operator!=(
        const move_iterator<I>& i, const move_sentinel<S>& s);
    template <class I, Sentinel<I> S>
      constexpr bool operator!=(
        const move_sentinel<S>& s, const move_iterator<I>& i);

    template <class I, SizedSentinel<I> S>
      constexpr difference_type_t<I> operator-(
        const move_sentinel<S>& s, const move_iterator<I>& i);
    template <class I, SizedSentinel<I> S>
      constexpr difference_type_t<I> operator-(
        const move_iterator<I>& i, const move_sentinel<S>& s);

    template <Semiregular S>
      constexpr move_sentinel<S> make_move_sentinel(S s);

    // \ref{range.iterators.common}, common iterators:
    template <Iterator I, Sentinel<I> S>
      requires !Same<I, S>
    class common_iterator;

    template <Readable I, class S>
    struct value_type<common_iterator<I, S>>;

    template <InputIterator I, class S>
    struct iterator_category<common_iterator<I, S>>;

    template <ForwardIterator I, class S>
    struct iterator_category<common_iterator<I, S>>;

    template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
    bool operator==(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
    template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
      requires EqualityComparableWith<I1, I2>
    bool operator==(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
    template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
    bool operator!=(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

    template <class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>
    difference_type_t<I2> operator-(
      const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

    // \ref{range.default.sentinels}, default sentinels:
    class default_sentinel;

    // \ref{range.iterators.counted}, counted iterators:
    template <Iterator I> class counted_iterator;

    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator==(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    @\newtxt{template <class I>}@
      constexpr bool operator==(
        const counted_iterator<@\oldtxt{auto}\newtxt{I}@>& x, default_sentinel);
    @\newtxt{template <class I>}@
      constexpr bool operator==(
        default_sentinel, const counted_iterator<@\oldtxt{auto}\newtxt{I}@>& x);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator!=(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    @\newtxt{template <class I>}@
      constexpr bool operator!=(
        const counted_iterator<@\oldtxt{auto}\newtxt{I}@>& x, default_sentinel y);
    @\newtxt{template <class I>}@
      constexpr bool operator!=(
        default_sentinel x, const counted_iterator<@\oldtxt{auto}\newtxt{I}@>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator<(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator<=(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator>(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr bool operator>=(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I1, class I2>
        requires Common<I1, I2>
      constexpr difference_type_t<I2> operator-(
        const counted_iterator<I1>& x, const counted_iterator<I2>& y);
    template <class I>
      constexpr difference_type_t<I> operator-(
        const counted_iterator<I>& x, default_sentinel y);
    template <class I>
      constexpr difference_type_t<I> operator-(
        default_sentinel x, const counted_iterator<I>& y);
    template <RandomAccessIterator I>
      constexpr counted_iterator<I>
        operator+(difference_type_t<I> n, const counted_iterator<I>& x);
    template <Iterator I>
      constexpr counted_iterator<I> make_counted_iterator(I i, difference_type_t<I> n);

    // \ref{range.unreachable.sentinels}, unreachable sentinels:
    class unreachable;
    template <Iterator I>
      constexpr bool operator==(const I&, unreachable) noexcept;
    template <Iterator I>
      constexpr bool operator==(unreachable, const I&) noexcept;
    template <Iterator I>
      constexpr bool operator!=(const I&, unreachable) noexcept;
    template <Iterator I>
      constexpr bool operator!=(unreachable, const I&) noexcept;

    // \ref{range.dangling.wrap}, dangling wrapper:
    template <class T> class dangling;
    template <Range R> using safe_iterator_t = @\seebelow@;

    // \ref{range.iterators.stream}, stream iterators:
    template <class T, class charT = char, class traits = char_traits<charT>,
        class Distance = ptrdiff_t>
    class istream_iterator;
    template <class T, class charT, class traits, class Distance>
      bool operator==(const istream_iterator<T, charT, traits, Distance>& x,
              const istream_iterator<T, charT, traits, Distance>& y);
    template <class T, class charT, class traits, class Distance>
      bool operator==(default_sentinel x,
              const istream_iterator<T, charT, traits, Distance>& y);
    template <class T, class charT, class traits, class Distance>
      bool operator==(const istream_iterator<T, charT, traits, Distance>& x,
              default_sentinel y);
    template <class T, class charT, class traits, class Distance>
      bool operator!=(const istream_iterator<T, charT, traits, Distance>& x,
              const istream_iterator<T, charT, traits, Distance>& y);
    template <class T, class charT, class traits, class Distance>
    bool operator!=(default_sentinel x,
              const istream_iterator<T, charT, traits, Distance>& y);
    template <class T, class charT, class traits, class Distance>
      bool operator!=(const istream_iterator<T, charT, traits, Distance>& x,
              default_sentinel y);

    template <class T, class charT = char, class traits = char_traits<charT>>
        class ostream_iterator;

    template <class charT, class traits = char_traits<charT> >
      class istreambuf_iterator;
    template <class charT, class traits>
      bool operator==(const istreambuf_iterator<charT, traits>& a,
              const istreambuf_iterator<charT, traits>& b);
    template <class charT, class traits>
      bool operator==(default_sentinel a,
              const istreambuf_iterator<charT, traits>& b);
    template <class charT, class traits>
      bool operator==(const istreambuf_iterator<charT, traits>& a,
              default_sentinel b);
    template <class charT, class traits>
      bool operator!=(const istreambuf_iterator<charT, traits>& a,
              const istreambuf_iterator<charT, traits>& b);
    template <class charT, class traits>
      bool operator!=(default_sentinel a,
              const istreambuf_iterator<charT, traits>& b);
    template <class charT, class traits>
      bool operator!=(const istreambuf_iterator<charT, traits>& a,
              default_sentinel b);

    template <class charT, class traits = char_traits<charT> >
      class ostreambuf_iterator;
  }

  // \ref{range.iterator.stdtraits}, iterator traits:
  template <@\oldtxt{experimental::}@ranges::Iterator Out>
    struct iterator_traits<Out>;
  template <@\oldtxt{experimental::}@ranges::InputIterator In>
    struct iterator_traits<In>;
  template <@\oldtxt{experimental::}@ranges::InputIterator In>
      requires @\oldtxt{experimental::}@ranges::Sentinel<In, In>
    struct iterator_traits;

  namespace ranges {
    @\newtxt{inline}@ namespace @\newtxt{\unspec}@ {
      // \ref{range.access}, range access:
      @\newtxt{inline}@ constexpr @\unspec@ begin = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ end = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ cbegin = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ cend = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ rbegin = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ rend = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ crbegin = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ crend = @\unspec@;

      // \ref{range.primitives}, range primitives:
      @\newtxt{inline}@ constexpr @\unspec@ size = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ empty = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ data = @\unspec@;
      @\newtxt{inline}@ constexpr @\unspec@ cdata = @\unspec@;
    }

    template <class T>
    using iterator_t = decltype(ranges::begin(declval<T&>()));

    template <class T>
    using sentinel_t = decltype(ranges::end(declval<T&>()));

    template <class>
    constexpr bool disable_sized_range = false;

    template <class T>
    struct enable_view { };

    struct view_base { };

    // \ref{range.requirements}, range requirements:

    // \ref{range.range}, Range:
    template <class T>
    concept @\oldtxt{bool}@ Range = @\seebelow@;

    // \ref{range.sized}, SizedRange:
    template <class T>
    concept @\oldtxt{bool}@ SizedRange = @\seebelow@;

    // \ref{range.view}, View:
    template <class T>
    concept @\oldtxt{bool}@ View = @\seebelow@;

    // \ref{range.common}, \oldtxt{BoundedRange}\newtxt{CommonRange}:
    template <class T>
    concept @\oldtxt{bool}@ @\oldtxt{BoundedRange}\newtxt{CommonRange}@ = @\seebelow@;

    // \ref{range.input}, InputRange:
    template <class T>
    concept @\oldtxt{bool}@ InputRange = @\seebelow@;

    // \ref{range.output}, OutputRange:
    template <class R, class T>
    concept @\oldtxt{bool}@ OutputRange = @\seebelow@;

    // \ref{range.forward}, ForwardRange:
    template <class T>
    concept @\oldtxt{bool}@ ForwardRange = @\seebelow@;

    // \ref{range.bidirectional}, BidirectionalRange:
    template <class T>
    concept @\oldtxt{bool}@ BidirectionalRange = @\seebelow@;

    // \ref{range.random.access}, RandomAccessRange:
    template <class T>
    concept @\oldtxt{bool}@ RandomAccessRange = @\seebelow@;

    // \ref{range.alg.nonmodifying}, non-modifying sequence operations:
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      bool all_of(I first, S last, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      bool all_of(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      bool any_of(I first, S last, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      bool any_of(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      bool none_of(I first, S last, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      bool none_of(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryInvocable<projected<I, Proj>> Fun>
      tagged_pair<tag::in(I), tag::fun(Fun)>
        for_each(I first, S last, Fun f, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryInvocable<projected<iterator_t<Rng>, Proj>> Fun>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::fun(Fun)>
        for_each(Rng&& rng, Fun f, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, projected<I, Proj>, const T*>
      I find(I first, S last, const T& value, Proj proj = Proj{});

    template <InputRange Rng, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, projected<iterator_t<Rng>, Proj>, const T*>
      safe_iterator_t<Rng>
        find(Rng&& rng, const T& value, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      I find_if(I first, S last, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      safe_iterator_t<Rng>
        find_if(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      safe_iterator_t<Rng>
        find_if_not(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Proj = identity,
        IndirectRelation<I2, projected<I1, Proj>> Pred = equal_to<>>
      I1
        find_end(I1 first1, S1 last1, I2 first2, S2 last2,
                Pred pred = Pred{}, Proj proj = Proj{});

    template <ForwardRange Rng1, ForwardRange Rng2, class Proj = identity,
        IndirectRelation<iterator_t<Rng2>,
          projected<iterator_t<Rng>, Proj>> Pred = equal_to<>>
      safe_iterator_t<Rng1>
        find_end(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{}, Proj proj = Proj{});

    template <InputIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<projected<I1, Proj1>, projected<I2, Proj2>> Pred = equal_to<>>
      I1
        find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                      Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, ForwardRange Rng2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectRelation<projected<iterator_t<Rng1>, Proj1>,
          projected<iterator_t<Rng2>, Proj2>> Pred = equal_to<>>
      safe_iterator_t<Rng1>
        find_first_of(Rng1&& rng1, Rng2&& rng2,
                      Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectRelation<projected<I, Proj>> Pred = equal_to<>>
      I adjacent_find(I first, S last, Pred pred = Pred{},
                      Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectRelation<projected<iterator_t<Rng>, Proj>> Pred = equal_to<>>
      safe_iterator_t<Rng>
        adjacent_find(Rng&& rng, Pred pred = Pred{}, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, projected<I, Proj>, const T*>
      difference_type_t<I>
        count(I first, S last, const T& value, Proj proj = Proj{});

    template <InputRange Rng, class T, class Proj = identity>
      requires IndirectRelation<equal_to<>, projected<iterator_t<Rng>, Proj>, const T*>
      difference_type_t<iterator_t<Rng>>
        count(Rng&& rng, const T& value, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      difference_type_t<I>
        count_if(I first, S last, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      difference_type_t<iterator_t<Rng>>
        count_if(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<projected<I1, Proj1>, projected<I2, Proj2>> Pred = equal_to<>>
      tagged_pair<tag::in1(I1), tag::in2(I2)>
        mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<projected<iterator_t<Rng1>, Proj1>,
          projected<iterator_t<Rng2>, Proj2>> Pred = equal_to<>>
      tagged_pair<tag::in1(safe_iterator_t<Rng1>),
                  tag::in2(safe_iterator_t<Rng2>)>
        mismatch(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Pred = equal_to<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                Pred pred = Pred{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<Rng1>, iterator_t<Rng2>, Pred, Proj1, Proj2>
      bool equal(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Pred = equal_to<>, class Proj1 = identity,
        class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                          Pred pred = Pred{},
                          Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<Rng1>, iterator_t<Rng2>, Pred, Proj1, Proj2>
      bool is_permutation(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
                          Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      I1 search(I1 first1, S1 last1, I2 first2, S2 last2,
                Pred pred = Pred{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <ForwardRange Rng1, ForwardRange Rng2, class Pred = equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<Rng1>, iterator_t<Rng2>, Pred, Proj1, Proj2>
      safe_iterator_t<Rng1>
        search(Rng1&& rng1, Rng2&& rng2, Pred pred = Pred{},
              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <ForwardIterator I, Sentinel<I> S, class T,
        class Pred = equal_to<>, class Proj = identity>
      requires IndirectlyComparable<I, const T*, Pred, Proj>
      I search_n(I first, S last, difference_type_t<I> count,
                const T& value, Pred pred = Pred{},
                Proj proj = Proj{});

    template <ForwardRange Rng, class T, class Pred = equal_to<>,
        class Proj = identity>
      requires IndirectlyComparable<iterator_t<Rng>, const T*, Pred, Proj>
      safe_iterator_t<Rng>
        search_n(Rng&& rng, difference_type_t<iterator_t<Rng>> count,
                const T& value, Pred pred = Pred{}, Proj proj = Proj{});

    // \ref{range.alg.modifying.operations}, modifying sequence operations:
    // \ref{range.alg.copy}, copy:
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<tag::in(I), tag::out(O)>
        copy(I first, S last, O result);

    template <InputRange Rng, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        copy(Rng&& rng, O result);

    template <InputIterator I, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<tag::in(I), tag::out(O)>
        copy_n(I first, difference_type_t<I> n, O result);

    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      tagged_pair<tag::in(I), tag::out(O)>
        copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        copy_if(Rng&& rng, O result, Pred pred, Proj proj = Proj{});

    template <BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
      requires IndirectlyCopyable<I1, I2>
      tagged_pair<tag::in(I1), tag::out(I2)>
        copy_backward(I1 first, S1 last, I2 result);

    template <BidirectionalRange Rng, BidirectionalIterator I>
      requires IndirectlyCopyable<iterator_t<Rng>, I>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(I)>
        copy_backward(Rng&& rng, I result);

    // \ref{range.alg.move}, move:
    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyMovable<I, O>
      tagged_pair<tag::in(I), tag::out(O)>
        move(I first, S last, O result);

    template <InputRange Rng, WeaklyIncrementable O>
      requires IndirectlyMovable<iterator_t<Rng>, O>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        move(Rng&& rng, O result);

    template <BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
      requires IndirectlyMovable<I1, I2>
      tagged_pair<tag::in(I1), tag::out(I2)>
        move_backward(I1 first, S1 last, I2 result);

    template <BidirectionalRange Rng, BidirectionalIterator I>
      requires IndirectlyMovable<iterator_t<Rng>, I>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(I)>
        move_backward(Rng&& rng, I result);

    template <ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2>
      requires IndirectlySwappable<I1, I2>
      tagged_pair<tag::in1(I1), tag::in2(I2)>
        swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);

    template <ForwardRange Rng1, ForwardRange Rng2>
      requires IndirectlySwappable<iterator_t<Rng1>, iterator_t<Rng2>>
      tagged_pair<tag::in1(safe_iterator_t<Rng1>), tag::in2(safe_iterator_t<Rng2>)>
        swap_ranges(Rng1&& rng1, Rng2&& rng2);

    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        CopyConstructible F, class Proj = identity>
      requires Writable<O, indirect_result@\oldtxt{_of}@_t<F&@\oldtxt{(}\newtxt{, }@projected<I, Proj>@\oldtxt{)}@>>
      tagged_pair<tag::in(I), tag::out(O)>
        transform(I first, S last, O result, F op, Proj proj = Proj{});

    template <InputRange Rng, WeaklyIncrementable O, CopyConstructible F,
        class Proj = identity>
      requires Writable<O, indirect_result@\oldtxt{_of}@_t<F&@\oldtxt{(}\newtxt{,}@
        projected<iterator_t<R>, Proj>@\oldtxt{)}@>>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        transform(Rng&& rng, O result, F op, Proj proj = Proj{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
        class Proj2 = identity>
      requires Writable<O, indirect_result@\oldtxt{_of}@_t<F&@\oldtxt{(}\newtxt{, }@projected<I1, Proj1>,
        projected<I2, Proj2>@\oldtxt{)}@>>
      tagged_tuple<tag::in1(I1), tag::in2(I2), tag::out(O)>
        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        CopyConstructible F, class Proj1 = identity, class Proj2 = identity>
      requires Writable<O, indirect_result@\oldtxt{_of}@_t<F&@\oldtxt{(}\newtxt{,}@
        projected<iterator_t<Rng1>, Proj1>, projected<iterator_t<Rng2>, Proj2>@\oldtxt{)}@>>
      tagged_tuple<tag::in1(safe_iterator_t<Rng1>),
                   tag::in2(safe_iterator_t<Rng2>),
                   tag::out(O)>
        transform(Rng1&& rng1, Rng2&& rng2, O result,
                  F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputIterator I, Sentinel<I> S, class T1, class T2, class Proj = identity>
      requires Writable<I, const T2&> &&
        IndirectRelation<equal_to<>, projected<I, Proj>, const T1*>
      I replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = Proj{});

    template <InputRange Rng, class T1, class T2, class Proj = identity>
      requires Writable<iterator_t<Rng>, const T2&> &&
        IndirectRelation<equal_to<>, projected<iterator_t<Rng>, Proj>, const T1*>
      safe_iterator_t<Rng>
        replace(Rng&& rng, const T1& old_value, const T2& new_value, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires Writable<I, const T&>
      I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = Proj{});

    template <InputRange Rng, class T, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires Writable<iterator_t<Rng>, const T&>
      safe_iterator_t<Rng>
        replace_if(Rng&& rng, Pred pred, const T& new_value, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class T1, class T2, OutputIterator<const T2&> O,
        class Proj = identity>
      requires IndirectlyCopyable<I, O> &&
        IndirectRelation<equal_to<>, projected<I, Proj>, const T1*>
      tagged_pair<tag::in(I), tag::out(O)>
        replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                    Proj proj = Proj{});

    template <InputRange Rng, class T1, class T2, OutputIterator<const T2&> O,
        class Proj = identity>
      requires IndirectlyCopyable<iterator_t<Rng>, O> &&
        IndirectRelation<equal_to<>, projected<iterator_t<Rng>, Proj>, const T1*>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        replace_copy(Rng&& rng, O result, const T1& old_value, const T2& new_value,
                    Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, class T, OutputIterator<const T&> O,
        class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      tagged_pair<tag::in(I), tag::out(O)>
        replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                        Proj proj = Proj{});

    template <InputRange Rng, class T, OutputIterator<const T&> O, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        replace_copy_if(Rng&& rng, O result, Pred pred, const T& new_value,
                        Proj proj = Proj{});

    template <class T, OutputIterator<const T&> O, Sentinel<O> S>
      O fill(O first, S last, const T& value);

    template <class T, OutputRange<const T&> Rng>
      safe_iterator_t<Rng>
        fill(Rng&& rng, const T& value);

    template <class T, OutputIterator<const T&> O>
      O fill_n(O first, difference_type_t<O> n, const T& value);

    template <Iterator O, Sentinel<O> S, CopyConstructible F>
        requires Invocable<F&> && Writable<O, @\oldtxt{result_of_t<F\&()>}\newtxt{invoke_result_t<F\&>}@>
      O generate(O first, S last, F gen);

    template <class Rng, CopyConstructible F>
        requires Invocable<F&> && OutputRange<Rng, @\oldtxt{result_of_t<F\&()>}\newtxt{invoke_result_t<F\&>}@>
      safe_iterator_t<Rng>
        generate(Rng&& rng, F gen);

    template <Iterator O, CopyConstructible F>
        requires Invocable<F&> && Writable<O, @\oldtxt{result_of_t<F\&()>}\newtxt{invoke_result_t<F\&>}@>
      O generate_n(O first, difference_type_t<O> n, F gen);

    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires Permutable<I> &&
        IndirectRelation<equal_to<>, projected<I, Proj>, const T*>
      I remove(I first, S last, const T& value, Proj proj = Proj{});

    template <ForwardRange Rng, class T, class Proj = identity>
      requires Permutable<iterator_t<Rng>> &&
        IndirectRelation<equal_to<>, projected<iterator_t<Rng>, Proj>, const T*>
      safe_iterator_t<Rng>
        remove(Rng&& rng, const T& value, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires Permutable<I>
      I remove_if(I first, S last, Pred pred, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        remove_if(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class T,
        class Proj = identity>
      requires IndirectlyCopyable<I, O> &&
        IndirectRelation<equal_to<>, projected<I, Proj>, const T*>
      tagged_pair<tag::in(I), tag::out(O)>
        remove_copy(I first, S last, O result, const T& value, Proj proj = Proj{});

    template <InputRange Rng, WeaklyIncrementable O, class T, class Proj = identity>
      requires IndirectlyCopyable<iterator_t<Rng>, O> &&
        IndirectRelation<equal_to<>, projected<iterator_t<Rng>, Proj>, const T*>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        remove_copy(Rng&& rng, O result, const T& value, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      tagged_pair<tag::in(I), tag::out(O)>
        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        remove_copy_if(Rng&& rng, O result, Pred pred, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectRelation<projected<I, Proj>> R = equal_to<>>
      requires Permutable<I>
      I unique(I first, S last, R comp = R{}, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectRelation<projected<iterator_t<Rng>, Proj>> R = equal_to<>>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        unique(Rng&& rng, R comp = R{}, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        class Proj = identity, IndirectRelation<projected<I, Proj>> R = equal_to<>>
      requires IndirectlyCopyable<I, O> &&
        (ForwardIterator<I> ||
        (InputIterator<O> && Same<value_type_t<I>, value_type_t<O>>) ||
        IndirectlyCopyableStorable<I, O>)
      tagged_pair<tag::in(I), tag::out(O)>
        unique_copy(I first, S last, O result, R comp = R{}, Proj proj = Proj{});

    template <InputRange Rng, WeaklyIncrementable O, class Proj = identity,
        IndirectRelation<projected<iterator_t<Rng>, Proj>> R = equal_to<>>
      requires IndirectlyCopyable<iterator_t<Rng>, O> &&
        (ForwardIterator<iterator_t<Rng>> ||
        (InputIterator<O> && Same<value_type_t<iterator_t<Rng>>, value_type_t<O>>) ||
        IndirectlyCopyableStorable<iterator_t<Rng>, O>)
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        unique_copy(Rng&& rng, O result, R comp = R{}, Proj proj = Proj{});

    template <BidirectionalIterator I, Sentinel<I> S>
      requires Permutable<I>
      I reverse(I first, S last);

    template <BidirectionalRange Rng>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        reverse(Rng&& rng);

    template <BidirectionalIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<tag::in(I), tag::out(O)> reverse_copy(I first, S last, O result);

    template <BidirectionalRange Rng, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        reverse_copy(Rng&& rng, O result);

    template <ForwardIterator I, Sentinel<I> S>
      requires Permutable<I>
      tagged_pair<tag::begin(I), tag::end(I)>
        rotate(I first, I middle, S last);

    template <ForwardRange Rng>
      requires Permutable<iterator_t<Rng>>
      tagged_pair<tag::begin(safe_iterator_t<Rng>),
                  tag::end(safe_iterator_t<Rng>)>
        rotate(Rng&& rng, iterator_t<Rng> middle);

    template <ForwardIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      tagged_pair<tag::in(I), tag::out(O)>
        rotate_copy(I first, I middle, S last, O result);

    template <ForwardRange Rng, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<Rng>, O>
      tagged_pair<tag::in(safe_iterator_t<Rng>), tag::out(O)>
        rotate_copy(Rng&& rng, iterator_t<Rng> middle, O result);

    // \ref{range.alg.random.shuffle}, shuffle:
    template <RandomAccessIterator I, Sentinel<I> S, class Gen>
      requires Permutable<I> &&
        UniformRandom@\oldtxt{Number}\newtxt{Bit}@Generator<remove_reference_t<Gen>> &&
        ConvertibleTo<@\oldtxt{result_of_t<Gen\&()>}\newtxt{invoke_result_t<Gen\&>}@, difference_type_t<I>>
      I shuffle(I first, S last, Gen&& g);

    template <RandomAccessRange Rng, class Gen>
      requires Permutable<I> &&
        UniformRandom@\oldtxt{Number}\newtxt{Bit}@Generator<remove_reference_t<Gen>> &&
        ConvertibleTo<@\oldtxt{result_of_t<Gen\&()>}\newtxt{invoke_result_t<Gen\&>}@, difference_type_t<I>>
      safe_iterator_t<Rng>
        shuffle(Rng&& rng, Gen&& g);

    // \ref{range.alg.partitions}, partitions:
    template <InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      bool is_partitioned(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires Permutable<I>
      I partition(I first, S last, Pred pred, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        partition(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <BidirectionalIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires Permutable<I>
      I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});

    template <BidirectionalRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires Permutable<iterator_t<Rng>>
      safe_iterator_t<Rng>
        stable_partition(Rng&& rng, Pred pred, Proj proj = Proj{});

    template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O1, WeaklyIncrementable O2,
        class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O1> && IndirectlyCopyable<I, O2>
      tagged_tuple<tag::in(I), tag::out1(O1), tag::out2(O2)>
        partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                      Proj proj = Proj{});

    template <InputRange Rng, WeaklyIncrementable O1, WeaklyIncrementable O2,
        class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<Rng>, O1> &&
        IndirectlyCopyable<iterator_t<Rng>, O2>
      tagged_tuple<tag::in(safe_iterator_t<Rng>), tag::out1(O1), tag::out2(O2)>
        partition_copy(Rng&& rng, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      I partition_point(I first, S last, Pred pred, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<Rng>, Proj>> Pred>
      safe_iterator_t<Rng>
        partition_point(Rng&& rng, Pred pred, Proj proj = Proj{});

    // \ref{range.alg.sorting}, sorting and related operations:
    // \ref{range.alg.sort}, sorting:
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        sort(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I stable_sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        stable_sort(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I partial_sort(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        partial_sort(Rng&& rng, iterator_t<Rng> middle, Comp comp = Comp{},
                    Proj proj = Proj{});

    template <InputIterator I1, Sentinel<I1> S1, RandomAccessIterator I2, Sentinel<I2> S2,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyCopyable<I1, I2> && Sortable<I2, Comp, Proj2> &&
          IndirectStrictWeakOrder<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
      I2 partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                           Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, RandomAccessRange Rng2, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyCopyable<iterator_t<Rng1>, iterator_t<Rng2>> &&
          Sortable<iterator_t<Rng2>, Comp, Proj2> &&
          IndirectStrictWeakOrder<Comp, projected<iterator_t<Rng1>, Proj1>,
            projected<iterator_t<Rng2>, Proj2>>
      safe_iterator_t<Rng2>
        partial_sort_copy(Rng1&& rng, Rng2&& result_rng, Comp comp = Comp{},
                          Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = less<>>
      bool is_sorted(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      bool is_sorted(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = less<>>
      I is_sorted_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        is_sorted_until(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I nth_element(I first, I nth, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        nth_element(Rng&& rng, iterator_t<Rng> nth, Comp comp = Comp{}, Proj proj = Proj{});

    // \ref{range.alg.binary.search}, binary search:
    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = less<>>
      I lower_bound(I first, S last, const T& value, Comp comp = Comp{},
                    Proj proj = Proj{});

    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        lower_bound(Rng&& rng, const T& value, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = less<>>
      I upper_bound(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        upper_bound(Rng&& rng, const T& value, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = less<>>
      tagged_pair<tag::begin(I), tag::end(I)>
        equal_range(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<Rng>, Proj>> Comp = less<>>
      tagged_pair<tag::begin(safe_iterator_t<Rng>),
                  tag::end(safe_iterator_t<Rng>)>
        equal_range(Rng&& rng, const T& value, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = less<>>
      bool binary_search(I first, S last, const T& value, Comp comp = Comp{},
                         Proj proj = Proj{});

    template <ForwardRange Rng, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<Rng>, Proj>> Comp = less<>>
      bool binary_search(Rng&& rng, const T& value, Comp comp = Comp{},
                         Proj proj = Proj{});

    // \ref{range.alg.merge}, merge:
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>, class Proj1 = identity,
        class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_tuple<tag::in1(I1), tag::in2(I2), tag::out(O)>
        merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O, class Comp = less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_tuple<tag::in1(safe_iterator_t<Rng1>),
                   tag::in2(safe_iterator_t<Rng2>),
                   tag::out(O)>
        merge(Rng1&& rng1, Rng2&& rng2, O result,
              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <BidirectionalIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I inplace_merge(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <BidirectionalRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        inplace_merge(Rng&& rng, iterator_t<Rng> middle, Comp comp = Comp{},
                      Proj proj = Proj{});

    // \ref{range.alg.set.operations}, set operations:
    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectStrictWeakOrder<projected<I1, Proj1>, projected<I2, Proj2>> Comp = less<>>
      bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = Comp{},
                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng1>, Proj1>,
          projected<iterator_t<Rng2>, Proj2>> Comp = less<>>
      bool includes(Rng1&& rng1, Rng2&& rng2, Comp comp = Comp{},
                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_tuple<tag::in1(I1), tag::in2(I2), tag::out(O)>
        set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = Comp{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_tuple<tag::in1(safe_iterator_t<Rng1>),
                   tag::in2(safe_iterator_t<Rng2>),
                   tag::out(O)>
        set_union(Rng1&& rng1, Rng2&& rng2, O result, Comp comp = Comp{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      O set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      O set_intersection(Rng1&& rng1, Rng2&& rng2, O result,
                         Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_pair<tag::in1(I1), tag::out(O)>
        set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_pair<tag::in1(safe_iterator_t<Rng1>), tag::out(O)>
        set_difference(Rng1&& rng1, Rng2&& rng2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      tagged_tuple<tag::in1(I1), tag::in2(I2), tag::out(O)>
        set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp = Comp{}, Proj1 proj1 = Proj1{},
                                 Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, WeaklyIncrementable O,
        class Comp = less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<Rng1>, iterator_t<Rng2>, O, Comp, Proj1, Proj2>
      tagged_tuple<tag::in1(safe_iterator_t<Rng1>),
                   tag::in2(safe_iterator_t<Rng2>),
                   tag::out(O)>
        set_symmetric_difference(Rng1&& rng1, Rng2&& rng2, O result, Comp comp = Comp{},
                                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    // \ref{range.alg.heap.operations}, heap operations:
    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I push_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        push_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I pop_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        pop_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I make_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        make_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I sort_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Comp = less<>, class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      safe_iterator_t<Rng>
        sort_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = less<>>
      bool is_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      bool is_heap(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = less<>>
      I is_heap_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <RandomAccessRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        is_heap_until(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    // \ref{range.alg.min.max}, minimum and maximum:
    template <class T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = less<>>
      constexpr const T& min(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});

    template <Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = less<>>
      constexpr T min(initializer_list<T> t, Comp comp = Comp{}, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      requires Copyable<value_type_t<iterator_t<Rng>>>
      value_type_t<iterator_t<Rng>>
        min(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <class T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = less<>>
      constexpr const T& max(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});

    template <Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = less<>>
      constexpr T max(initializer_list<T> t, Comp comp = Comp{}, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      requires Copyable<value_type_t<iterator_t<Rng>>>
      value_type_t<iterator_t<Rng>>
        max(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <class T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = less<>>
      constexpr tagged_pair<tag::min(const T&), tag::max(const T&)>
        minmax(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});

    template <Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = less<>>
      constexpr tagged_pair<tag::min(T), tag::max(T)>
        minmax(initializer_list<T> t, Comp comp = Comp{}, Proj proj = Proj{});

    template <InputRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      requires Copyable<value_type_t<iterator_t<Rng>>>
      tagged_pair<tag::min(value_type_t<iterator_t<Rng>>),
                  tag::max(value_type_t<iterator_t<Rng>>)>
        minmax(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = less<>>
      I min_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        min_element(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = less<>>
      I max_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      safe_iterator_t<Rng>
        max_element(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = less<>>
      tagged_pair<tag::min(I), tag::max(I)>
        minmax_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <ForwardRange Rng, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng>, Proj>> Comp = less<>>
      tagged_pair<tag::min(safe_iterator_t<Rng>),
                  tag::max(safe_iterator_t<Rng>)>
        minmax_element(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectStrictWeakOrder<projected<I1, Proj1>, projected<I2, Proj2>> Comp = less<>>
      bool
        lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    template <InputRange Rng1, InputRange Rng2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectStrictWeakOrder<projected<iterator_t<Rng1>, Proj1>,
          projected<iterator_t<Rng2>, Proj2>> Comp = less<>>
      bool
        lexicographical_compare(Rng1&& rng1, Rng2&& rng2, Comp comp = Comp{},
                                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});

    // \ref{range.alg.permutation.generators}, permutations:
    template <BidirectionalIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      bool next_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <BidirectionalRange Rng, class Comp = less<>,
        class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      bool next_permutation(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});

    template <BidirectionalIterator I, Sentinel<I> S, class Comp = less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      bool prev_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});

    template <BidirectionalRange Rng, class Comp = less<>,
        class Proj = identity>
      requires Sortable<iterator_t<Rng>, Comp, Proj>
      bool prev_permutation(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{});
  }
}@\oldtxt{\}\}}@
\end{codeblock}

\input{iterators}

\rSec1[range.access]{Range access}

{\color{oldclr}
\pnum
In addition to being available via inclusion of the \tcode{<experimental/ranges/range>}
header, the customization point objects in \ref{range.access} are
available when \tcode{<experimental/ranges/iterator>} is included.
} % \color{oldclr}

\ednote{The customization point objects in this subsection all have deprecated
behavior that permits them to work with rvalues. This is for compatability with
the similarly named facilities in namespace \tcode{std}. The authors intend to
replace the deprecated behavior with proper support for rvalue ranges, pending
some ongoing work on an improved design. We hope to bring forward such a design
in the summer meeting in Geneva later this year. See discussion in issue
\href{https://github.com/ericniebler/stl2/issues/547}{stl2\#547}.}

\rSec2[range.access.begin]{\tcode{begin}}
\pnum
The name \tcode{begin} denotes a customization point
 object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::begin(E)} for some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item
  \tcode{ranges::begin(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::begin(E)} behaves similarly to \tcode{std::begin(E)}
  \oldtxt{as defined in ISO/IEC 14882} when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{(E) + 0} if \tcode{E} has array
  type~(\cxxref{basic.compound}).

\item
  Otherwise, \tcode{\textit{DECAY_COPY}((E).begin())} if it is a valid expression and its type \tcode{I} meets the
  syntactic requirements of \tcode{Iterator<I>}. If
  \tcode{Iterator} is not satisfied, the program is ill-formed
  with no diagnostic required.

\item
  Otherwise, \tcode{\textit{DECAY_COPY}(begin(E))} if it is a valid expression and its type \tcode{I} meets the
  syntactic requirements of \tcode{Iterator<I>} with overload
  resolution performed in a context that includes the declaration
  \tcode{\newtxt{template <class T>} void begin(\oldtxt{auto}\newtxt{T}\&) = delete;} and does not include
  a declaration of \tcode{ranges::begin}. If \tcode{Iterator}
  is not satisfied, the program is ill-formed with no diagnostic
  required.

\item
  Otherwise, \tcode{ranges::begin(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::begin(E)} is a valid expression, its
type satisfies \tcode{Iterator}. \exitnote

\rSec2[range.access.end]{\tcode{end}}
\pnum
The name \tcode{end} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::end(E)} for some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item
  \tcode{ranges::end(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::end(E)} behaves similarly to \tcode{std::end(E)}
  \oldtxt{as defined in ISO/IEC 14882} when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{(E) + extent\newtxt{_v}<T>\oldtxt{::value}} if \tcode{E} has array
  type~(\cxxref{basic.compound}) \tcode{T}.

\item
  Otherwise, \tcode{\textit{DECAY_COPY}((E).end())} if it is a valid expression and its type \tcode{S} meets the
  syntactic requirements of
  \tcode{Sentinel<\brk{}S, decltype(\brk{}ranges::\brk{}begin(E))>}. If
  \tcode{Sentinel} is not satisfied, the program is ill-formed with
  no diagnostic required.

\item
  Otherwise, \tcode{\textit{DECAY_COPY}(end(E))} if it is a valid expression and its type \tcode{S} meets the
  syntactic requirements of
  \tcode{Sentinel<\brk{}S, decltype(\brk{}ranges::\brk{}begin(E))>} with overload
  resolution performed in a context that includes the declaration
  \tcode{\newtxt{template <class T>} void end(\oldtxt{auto}\newtxt{T}\&) = delete;} and does not include
  a declaration of \tcode{ranges::end}. If \tcode{Sentinel} is not
  satisfied, the program is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{ranges::end(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::end(E)} is a valid expression, the
types of \tcode{ranges::end(E)} and \tcode{ranges::\brk{}begin(E)} satisfy
\tcode{Sentinel}. \exitnote

\rSec2[range.access.cbegin]{\tcode{cbegin}}
\pnum
The name \tcode{cbegin} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::\brk{}cbegin(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to \tcode{ranges::\brk{}begin(static_cast<const T\&>(E))}.

\pnum
Use of \tcode{ranges::cbegin(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::cbegin(E)}
behaves similarly to \tcode{std::cbegin(E)} \oldtxt{as defined in ISO/IEC 14882} when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::cbegin(E)} is a valid expression, its
type satisfies \tcode{Iterator}. \exitnote

\rSec2[range.access.cend]{\tcode{cend}}
\pnum
The name \tcode{cend} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::cend(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to \tcode{ranges::end(static_cast<const T\&>(E))}.

\pnum
Use of \tcode{ranges::cend(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::\brk{}cend(E)}
behaves similarly to \tcode{std::cend(E)} \oldtxt{as defined in ISO/IEC 14882} when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::cend(E)} is a valid expression, the
types of \tcode{ranges::cend(E)} and \tcode{ranges::\brk{}cbegin(E)} satisfy
\tcode{Sentinel}. \exitnote

\rSec2[range.access.rbegin]{\tcode{rbegin}}
\pnum
The name \tcode{rbegin} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::rbegin(E)} for some subexpression \tcode{E} is expression-equivalent
to:

\begin{itemize}
\item
  \tcode{ranges::rbegin(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::rbegin(E)} behaves similarly to \tcode{std::rbegin(E)}
  \oldtxt{as defined in ISO/IEC 14882} when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{\textit{DECAY_COPY}((E).rbegin())} if it is a valid expression and its type \tcode{I} meets the
  syntactic requirements of \tcode{Iterator<I>}. If \tcode{Iterator}
  is not satisfied, the program is ill-formed with no diagnostic
  required.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::end(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges::\brk{}end(\brk{}E)} are valid expressions of the same
  type \tcode{I} which meets the syntactic requirements of
  \tcode{Bi\-direct\-ional\-Iterator<I>}~(\ref{range.iterators.bidirectional}).

\item
  Otherwise, \tcode{ranges::rbegin(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::rbegin(E)} is a valid expression, its
type satisfies \tcode{Iterator}. \exitnote

\rSec2[range.access.rend]{\tcode{rend}}
\pnum
The name \tcode{rend} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::rend(E)} for some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item
  \tcode{ranges::rend(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \enternote This deprecated usage exists so that
  \tcode{ranges::rend(E)} behaves similarly to \tcode{std::rend(E)}
  \oldtxt{as defined in ISO/IEC 14882} when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{\textit{DECAY_COPY}((E).rend())} if it is a valid expression and its type \tcode{S} meets the
  syntactic requirements of
  \tcode{Sentinel<\brk{}S, decltype(\brk{}ranges::\brk{}rbegin(E))>}. If
  \tcode{Sentinel} is not satisfied, the program is ill-formed with
  no diagnostic required.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges\colcol{}begin(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges\colcol{}end(\brk{}E)} are valid expressions of the same
  type \tcode{I} which meets the syntactic requirements of
  \tcode{Bi\-dir\-ect\-ion\-al\-It\-er\-at\-or<I>}~(\ref{range.iterators.bidirectional}).

\item
  Otherwise, \tcode{ranges::rend(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::rend(E)} is a valid expression, the
types of \tcode{ranges::\brk{}rend(E)} and \tcode{ranges::\brk{}rbegin(E)} satisfy
\tcode{Sentinel}. \exitnote

\rSec2[range.access.crbegin]{\tcode{crbegin}}
\pnum
The name \tcode{crbegin} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::\brk{}crbegin(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to \tcode{ranges::\brk{}rbegin(static_cast<const T\&>(E))}.

\pnum
Use of \tcode{ranges::crbegin(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::crbegin(E)}
behaves similarly to \tcode{std::crbegin(E)} \oldtxt{as defined in ISO/IEC 14882} when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::crbegin(E)} is a valid expression, its
type satisfies \tcode{Iterator}. \exitnote

\rSec2[range.access.crend]{\tcode{crend}}
\pnum
The name \tcode{crend} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::crend(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to \tcode{ranges::rend(static_cast<const T\&>(E))}.

\pnum
Use of \tcode{ranges::crend(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::crend(E)}
behaves similarly to \tcode{std::crend(E)} \oldtxt{as defined in ISO/IEC 14882} when
\tcode{E} is an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::crend(E)} is a valid expression, the
types of \tcode{ranges::crend(E)} and \tcode{ranges::\brk{}crbegin(\brk{}E)} satisfy
\tcode{Sentinel}. \exitnote

\rSec1[range.primitives]{Range primitives}

\pnum
\oldtxt{In addition to being available via inclusion of the \tcode{<experimental/ranges/range>}
header, the customization point objects in \ref{range.primitives} are
available when \tcode{<experimental/ranges/iterator>} is included.}

\rSec2[range.primitives.size]{\tcode{size}}
\pnum
The name \tcode{size} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::size(E)} for some subexpression \tcode{E} with type
\tcode{T} is expression-equivalent to:

\begin{itemize}
\item
  \tcode{\textit{DECAY_COPY}(extent\newtxt{_v}<T>\oldtxt{::value})} if \tcode{T} is an array
  type~(\cxxref{basic.compound}).

\item
  Otherwise, \tcode{\textit{DECAY_COPY}(static_cast<const T\&>(E).size())} if it is a valid expression and its type \tcode{I}
  satisfies \tcode{Integral<I>} and
  \tcode{disable_\-sized_\-range<T>}~(\ref{range.sized}) is
  \tcode{false}.

\item
  Otherwise, \tcode{\textit{DECAY_COPY}(size(static_cast<const T\&>(E)))} if it is a valid expression and its type \tcode{I}
  satisfies \tcode{Integral<I>} with overload resolution
  performed in a context that includes the declaration
  \tcode{\newtxt{template <class T>} void size(const \oldtxt{auto}\newtxt{T}\&) = delete;} and does not include
  a declaration of \tcode{ranges::size}, and
  \tcode{disable_\-sized_\-range<T>} is \tcode{false}.

\item
  Otherwise,
  \tcode{\textit{DECAY_COPY}(ranges::cend(E) - ranges::cbegin(E))}, except that \tcode{E}
  is only evaluated once, if it is a valid expression and the types \tcode{I} and \tcode{S} of
  \tcode{ranges::cbegin(E)} and \tcode{ranges\colcol{}cend(\brk{}E)} meet the
  syntactic requirements of
  \tcode{SizedSentinel<S, I>}~(\ref{range.iterators.sizedsentinel}) and
  \tcode{Forward\-Iter\-at\-or<I>}. If \tcode{SizedSentinel} and
  \tcode{Forward\-Iter\-at\-or} are not satisfied, the program is ill-formed with no
  diagnostic required.

\item
  Otherwise, \tcode{ranges::size(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::size(E)} is a valid expression, its
type satisfies \tcode{Integral}. \exitnote

\rSec2[range.primitives.empty]{\tcode{empty}}
\pnum
The name \tcode{empty} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::empty(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  \tcode{bool((E).empty())} if it is a valid expression.

\item
  Otherwise, \tcode{ranges::size(E) == 0} if it is a valid expression.

\item
  Otherwise, \tcode{bool(ranges::begin(E) == ranges::end(E))},
  except that \tcode{E} is only evaluated once, if it is a valid expression and the type of
  \tcode{ranges::begin(E)} satisfies \tcode{ForwardIterator}.

\item
  Otherwise, \tcode{ranges::empty(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::empty(E)} is a valid expression, it
has type \tcode{bool}. \exitnote

\rSec2[range.primitives.data]{\tcode{data}}
\pnum
The name \tcode{data} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::data(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  \tcode{ranges::data(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated. \enternote
  This deprecated usage exists so that \tcode{ranges::data(E)} behaves
  similarly to \tcode{std::data(E)} \oldtxt{as defined in the \Cpp Working
  Paper} when \tcode{E} is an rvalue. \exitnote

\item
  Otherwise, \tcode{\textit{DECAY_COPY}((E).data())} if it is a valid expression of pointer to object type.

\item
  Otherwise, \tcode{ranges::begin(E)} if it is a valid expression of pointer to object type.

\item
  Otherwise, \tcode{ranges::data(E)} is ill-formed.
\end{itemize}

\pnum
\enternote Whenever \tcode{ranges::data(E)} is a valid expression, it
has pointer to object type. \exitnote

\rSec2[range.primitives.cdata]{\tcode{cdata}}
\pnum
The name \tcode{cdata} denotes a customization point
object~(\cxxref{customization.point.object}). The expression
\tcode{ranges::cdata(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to \tcode{ranges::data(static_cast<const T\&>(E))}.

\pnum
Use of \tcode{ranges::cdata(E)} with rvalue \tcode{E} is deprecated.
\enternote This deprecated usage exists so that \tcode{ranges::cdata(E)}
has behavior consistent with \tcode{ranges::data(E)} when \tcode{E} is
an rvalue. \exitnote

\pnum
\enternote Whenever \tcode{ranges::cdata(E)} is a valid expression, it
has pointer to object type. \exitnote

\rSec1[range.requirements]{Range requirements}

\rSec2[range.requirements.general]{General}

\pnum
Ranges are an abstraction of containers that allow a \Cpp program to
operate on elements of data structures uniformly. It their simplest form, a
range object is one on which one can call \tcode{begin} and
\tcode{end} to get an iterator~(\ref{range.iterators.iterator}) and a
sentinel~(\ref{range.iterators.sentinel}). To be able to construct
template algorithms and range adaptors that work correctly and efficiently on
different types of sequences, the library formalizes not just the interfaces but
also the semantics and complexity assumptions of ranges.

\pnum
This document defines three fundamental categories of ranges
based on the syntax and semantics supported by each: \techterm{range},
\techterm{sized range} and \techterm{view}, as shown in
Table~\ref{tab:ranges.relations}.

\begin{floattable}{Relations among range categories}{tab:ranges.relations}
  {lll}
  \topline
  \textbf{Sized Range}  &               &                   \\
                        & $\searrow$    &                   \\
                        &               &  \textbf{Range}   \\
                        & $\nearrow$    &                   \\
  \textbf{View}         &               &                   \\
\end{floattable}

\pnum
The \tcode{Range} concept requires only that \tcode{begin} and \tcode{end}
return an iterator and a sentinel. The \tcode{SizedRange} concept refines \tcode{Range}
with the requirement that the number of elements in the range can be determined
in constant time using the \tcode{size} function. The \tcode{View} concept
specifies requirements on a \tcode{Range} type
with constant-time copy and assign operations.

\pnum
In addition to the three fundamental range categories, this document defines
a number of convenience refinements of \tcode{Range} that group together requirements
that appear often in the concepts and algorithms.
\oldtxt{\textit{Bounded ranges}}\newtxt{\techterm{Common ranges}} are ranges for which
\tcode{begin} and \tcode{end} return objects of the
same type. \techterm{Random access ranges} are ranges for which
\tcode{begin} returns a type that satisfies
\tcode{RandomAccessIterator}~(\ref{range.iterators.random.access}). The range
categories \techterm{bidirectional ranges},
\techterm{forward ranges},
\techterm{input ranges}, and
\techterm{output ranges} are defined similarly.

\rSec2[range.range]{Ranges}

\pnum
The \tcode{Range} concept defines the requirements of a type that allows
iteration over its elements by providing a \tcode{begin} iterator and an
\tcode{end} sentinel.
\enternote Most algorithms requiring this concept simply forward to an
\tcode{Iterator}-based algorithm by calling \tcode{begin} and \tcode{end}. \exitnote

\begin{itemdecl}
template <class T>
concept @\oldtxt{bool}@ Range =
  requires(T&& t) {
    @ranges@::begin(t); // not necessarily equality-preserving (see below)
    @ranges@::end(t);
  };
\end{itemdecl}

\begin{itemdescr}

\pnum
Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{Range<T>} is satisfied
only if

\begin{itemize}
\item \range{begin(t)}{end(t)} denotes a range.

\item Both \tcode{begin(t)} and \tcode{end(t)} are amortized constant time
and non-modifying. \enternote \tcode{begin(t)} and \tcode{end(t)} do not require
implicit expression variations~(\cxxref{concepts.lib.general.equality}). \exitnote

\item If \tcode{iterator_t<T>} satisfies \tcode{ForwardIterator},
\tcode{begin(t)} is equality preserving.
\end{itemize}
\end{itemdescr}

\pnum \enternote
Equality preservation of both \tcode{begin} and \tcode{end} enables passing a \tcode{Range}
whose iterator type satisfies \tcode{ForwardIterator}
to multiple algorithms and
making multiple passes over the range by repeated calls to \tcode{begin} and \tcode{end}.
Since \tcode{begin} is not required to be equality preserving when the return type does
not satisfy \tcode{ForwardIterator}, repeated calls might not return equal values or
might not be well-defined; \tcode{begin} should be called at most once for such a range.
\exitnote

\rSec2[range.sized]{Sized ranges}

\pnum
The \tcode{SizedRange} concept specifies the requirements
of a \tcode{Range} type that knows its size in constant time with the
\tcode{size} function.

\begin{itemdecl}
template <class T>
concept @\oldtxt{bool}@ SizedRange =
  Range<T> &&
  !disable_sized_range<remove_cv_t<remove_reference_t<T>>> &&
  requires(T& t) {
    { @ranges@::size(t) } -> ConvertibleTo<difference_type_t<iterator_t<T>>>;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{SizedRange<T>} is satisfied only if:

\begin{itemize}
\item \tcode{ranges::size(t)} is \bigoh{1}, does not modify \tcode{t}, and is equal
to \tcode{ranges::distance(t)}.

\item If \tcode{iterator_t<T>} satisfies \tcode{ForwardIterator},
\tcode{size(t)} is well-defined regardless of the evaluation of
\tcode{begin(t)}. \enternote \tcode{size(t)} is otherwise not required be
well-defined after evaluating \tcode{begin(t)}. For a \tcode{SizedRange}
whose iterator type does not model \tcode{ForwardIterator}, for
example, \tcode{size(t)} might only be well-defined if evaluated before
the first call to \tcode{begin(t)}. \exitnote
\end{itemize}

\pnum
\enternote The \tcode{disable_sized_range} predicate provides a mechanism to enable use
of range types with the library that meet the syntactic requirements but do
not in fact satisfy \tcode{SizedRange}. A program that instantiates a library template
that requires a \tcode{Range} with such a range type \tcode{R} is ill-formed with no
diagnostic required unless
\tcode{disable_sized_range<remove_cv_t<remove_reference_t<R>{>}{>}} evaluates
to \tcode{true}~(\cxxref{structure.requirements}). \exitnote
\end{itemdescr}

\rSec2[range.view]{Views}

\pnum
The \tcode{View} concept specifies the requirements of a
\tcode{Range} type that has constant time copy, move and assignment operators; that
is, the cost of these operations is not proportional to the number of elements in
the \tcode{View}.

\pnum
\enterexample
Examples of \tcode{View}s are:

\begin{itemize}
\item A \tcode{Range} type that wraps a pair of iterators.

\item A \tcode{Range} type that holds its elements by \tcode{shared_ptr}
and shares ownership with all its copies.

\item A \tcode{Range} type that generates its elements on demand.
\end{itemize}

A container~(\cxxref{containers}) is not a \tcode{View} since copying the
container copies the elements, which cannot be done in constant time.
\exitexample

\begin{itemdecl}
template <class T>
constexpr bool @\placeholder{view-predicate}@ // \expos
  = @\seebelow@;

template <class T>
concept @\oldtxt{bool}@ View =
  Range<T> &&
  Semiregular<T> &&
  @\placeholder{view-predicate}@<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Since the difference between \tcode{Range} and \tcode{View} is largely semantic, the
two are differentiated with the help of the \tcode{enable_view}
trait. Users may specialize \tcode{enable_view}
to derive from \tcode{true_type} or \tcode{false_type}.

\pnum
For a type \tcode{T}, the value of \tcode{\placeholder{view-predicate}<T>} shall be:
\begin{itemize}
\item If \tcode{enable_view<T>} has a member type \tcode{type}, \tcode{enable_view<T>::type::value};
\item Otherwise, if \tcode{T} is derived from \tcode{view_base}, \tcode{true};
\item Otherwise, if \tcode{T} is an instantiation of class template
\tcode{initializer_list}~(\cxxref{support.initlist}),
\tcode{set}~(\cxxref{set}),
\tcode{multiset}~(\cxxref{multiset}),
\tcode{unordered_set}~(\cxxref{unord.set}), or
\tcode{unordered_multiset}~(\cxxref{unord.multiset}), \tcode{false};
\item Otherwise, if both \tcode{T} and \tcode{const T} satisfy \tcode{Range} and
\tcode{reference_t<iterator_t<T>{>}} is not the same type as \tcode{reference_t<iterator_t<const T>{>}},
\tcode{false}; \enternote Deep \tcode{const}-ness implies element ownership, whereas shallow \tcode{const}-ness
implies reference semantics. \exitnote
\item Otherwise, \tcode{true}.
\end{itemize}
\end{itemdescr}

\rSec2[range.common]{Common ranges}

\ednote{We've renamed ``\tcode{BoundedRange}'' to ``\tcode{CommonRange}''. The authors believe
this is a better name than ``\tcode{ClassicRange}'', which LEWG weakly preferred. The reason is
that the iterator and sentinel of a Common range have the same type in \textit{common}.
A non-Common range can be turned into a Common range with the help of \tcode{common_iterator}.
P0789 ``Range Adaptors and Utilities'' will be proposing a \tcode{view::common} adaptor that
does precisely that.}

\pnum
The \oldtxt{\tcode{BoundedRange}}\newtxt{\tcode{CommonRange}} concept specifies requirements
of a \tcode{Range} type for which \tcode{begin} and \tcode{end} return objects of
the same type. \enternote The standard containers~(\cxxref{containers})
satisfy \oldtxt{\tcode{BoundedRange}}\newtxt{\tcode{CommonRange}}.\exitnote

\begin{codeblock}
template <class T>
concept @\oldtxt{bool}@ @\oldtxt{BoundedRange}\newtxt{CommonRange}@ =
  Range<T> && Same<iterator_t<T>, sentinel_t<T>>;
\end{codeblock}

\rSec2[range.input]{Input ranges}

\pnum
The \tcode{InputRange} concept specifies requirements of
a \tcode{Range} type for which \tcode{begin} returns a type
that satisfies \tcode{InputIterator}~(\ref{range.iterators.input}).

\begin{codeblock}
template <class T>
concept @\oldtxt{bool}@ InputRange =
  Range<T> && InputIterator<iterator_t<T>>;
\end{codeblock}

\rSec2[range.output]{Output ranges}

\pnum
The \tcode{OutputRange} concept specifies requirements of
a \tcode{Range} type for which \tcode{begin} returns a type that satisfies
\tcode{OutputIterator}~(\ref{range.iterators.output}).

\begin{codeblock}
template <class R, class T>
concept @\oldtxt{bool}@ OutputRange =
  Range<R> && OutputIterator<iterator_t<R>, T>;
\end{codeblock}

\rSec2[range.forward]{Forward ranges}

\pnum
The \tcode{ForwardRange} concept specifies requirements of an
\tcode{InputRange} type for which \tcode{begin} returns a type that satisfies
\tcode{ForwardIterator}~(\ref{range.iterators.forward}).

\begin{codeblock}
template <class T>
concept @\oldtxt{bool}@ ForwardRange =
  InputRange<T> && ForwardIterator<iterator_t<T>>;
\end{codeblock}

\rSec2[range.bidirectional]{Bidirectional ranges}

\pnum
The \tcode{BidirectionalRange} concept specifies requirements of a
\tcode{ForwardRange} type for which \tcode{begin} returns a type that satisfies
\tcode{BidirectionalIterator}~(\ref{range.iterators.bidirectional}).

\begin{codeblock}
template <class T>
concept @\oldtxt{bool}@ BidirectionalRange =
  ForwardRange<T> && BidirectionalIterator<iterator_t<T>>;
\end{codeblock}

\rSec2[range.random.access]{Random access ranges}

\pnum
The \tcode{RandomAccessRange} concept specifies requirements of a
\tcode{BidirectionalRange} type for which \tcode{begin} returns a type that satisfies
\tcode{RandomAccessIterator}~(\ref{range.iterators.random.access}).

\begin{codeblock}
template <class T>
concept @\oldtxt{bool}@ RandomAccessRange =
  BidirectionalRange<T> && RandomAccessIterator<iterator_t<T>>;
\end{codeblock}

\rSec1[dangling.wrappers]{Dangling wrapper}

\rSec2[range.dangling.wrap]{Class template \tcode{dangling}}

\pnum
\indexlibrary{\idxcode{dangling}}%
Class template \tcode{dangling} is a wrapper for an object that refers to another object whose
lifetime may have ended. It is used by algorithms that accept rvalue ranges and return iterators.

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  template <CopyConstructible T>
  class dangling {
  public:
    constexpr dangling() requires DefaultConstructible<T>;
    constexpr dangling(T t);
    constexpr T get_unsafe() const;
  private:
    T value; // \expos
  };

  template <Range R>
  using safe_iterator_t =
    conditional_t<is_lvalue_reference@\newtxt{_v}@<R>@\oldtxt{::value}@,
      iterator_t<R>,
      dangling<iterator_t<R>>>;
}}@\oldtxt{\}\}}@
\end{codeblock}

\rSec3[range.dangling.wrap.ops]{\tcode{dangling} operations}

\rSec4[range.dangling.wrap.op.const]{\tcode{dangling} constructors}

\indexlibrary{\idxcode{dangling}!\idxcode{dangling}}%
\begin{itemdecl}
constexpr dangling() requires DefaultConstructible<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{dangling}, value-initializing \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{dangling}!\idxcode{dangling}}%
\begin{itemdecl}
constexpr dangling(T t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{dangling}, initializing \tcode{value} with \tcode{t}.
\end{itemdescr}

\rSec4[range.dangling.wrap.op.get]{\tcode{dangling::get_unsafe}}

\indexlibrary{\idxcode{get_unsafe}!\idxcode{dangling}}%
\indexlibrary{\idxcode{dangling}!\idxcode{get_unsafe}}%
\begin{itemdecl}
constexpr T get_unsafe() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{value}.
\end{itemdescr}

\input{algorithms}
} % \color{addclr}
