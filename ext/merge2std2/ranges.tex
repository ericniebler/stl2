%!TEX root = P0896.tex

\ednote{Add a new clause between [iterators] and [algorithms] with the following content:}
{\color{addclr}
\rSec0[range]{Ranges library}

\rSec1[range.general]{General}

\pnum
This clause describes components for dealing with ranges of elements.

\pnum
The following subclauses describe
range and view requirements, and
components for
range primitives
as summarized in \tref{range.summary}.

\begin{libsumtab}{Ranges library summary}{tab:range.summary}
  \ref{range.access}       & Range access      & \tcode{<\oldtxt{experimental/ranges/}range\newtxt{s}>} \\
  \ref{range.primitives}   & Range primitives  & \\
  \ref{range.requirements} & Requirements      & \\
  \ref{range.utility}      & Range utilities   & \\
  \ref{range.adaptors}     & Range adaptors    & \\
\end{libsumtab}

\rSec1[range.decaycopy]{decay_copy}

\ednote{TODO: Replace the definition of [thread.decaycopy] with this definition.}

\pnum
Several places in this clause use the expression \tcode{\placeholdernc{DECAY_COPY}(x)},
which is expression-equivalent to:
\begin{codeblock}
  decay_t<decltype((x))>(x)
\end{codeblock}

\rSec1[range.synopsis]{Header \tcode{<ranges>} synopsis}

\indexlibrary{\idxhdr{ranges}}%
\begin{codeblock}
#include <initializer_list>
#include <@\oldtxt{experimental/ranges/}@iterator>

namespace std { @\oldtxt{namespace experimental \{}@
  namespace ranges {
    @\newtxt{inline}@ namespace @\newtxt{\unspec}@ {
      // \ref{range.access}, range access
      @\newtxt{inline}@ constexpr @\unspec@ begin = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ end = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ cbegin = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ cend = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ rbegin = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ rend = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ crbegin = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ crend = @\unspecnc@;

      // \ref{range.primitives}, range primitives
      @\newtxt{inline}@ constexpr @\unspec@ size = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ empty = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ data = @\unspecnc@;
      @\newtxt{inline}@ constexpr @\unspec@ cdata = @\unspecnc@;
    }

    template<class T>
    using iterator_t = decltype(ranges::begin(declval<T&>()));

    template<class T>
    using sentinel_t = decltype(ranges::end(declval<T&>()));

    template<class>
    @\newtxt{inline}@ constexpr bool disable_sized_range = false;

    template<class T>
    struct enable_view { };

    struct view_base { };

    @\oldtxt{// \ref{range.dangling}, dangling wrapper}@
    @\oldtxt{template<class T> class dangling;}@

    template<Range R>
    using safe_iterator_t = @\newtxt{decltype(ranges::begin(declval<R>()))} \oldtxt{\seebelownc}@;

    // \ref{range.requirements}, range requirements

    // \ref{range.range}, Range
    template<class T>
    concept @\oldtxt{bool}@ Range = @\seebelownc@;

    // \ref{range.sized}, SizedRange
    template<class T>
    concept @\oldtxt{bool}@ SizedRange = @\seebelownc@;

    // \ref{range.view}, View
    template<class T>
    concept @\oldtxt{bool}@ View = @\seebelownc@;

    // \ref{range.common}, \oldtxt{BoundedRange}\newtxt{CommonRange}
    template<class T>
    concept @\oldtxt{bool}@ @\oldtxt{BoundedRange}\newtxt{CommonRange}@ = @\seebelownc@;

    // \ref{range.input}, InputRange
    template<class T>
    concept @\oldtxt{bool}@ InputRange = @\seebelownc@;

    // \ref{range.output}, OutputRange
    template<class R, class T>
    concept @\oldtxt{bool}@ OutputRange = @\seebelownc@;

    // \ref{range.forward}, ForwardRange
    template<class T>
    concept @\oldtxt{bool}@ ForwardRange = @\seebelownc@;

    // \ref{range.bidirectional}, BidirectionalRange
    template<class T>
    concept @\oldtxt{bool}@ BidirectionalRange = @\seebelownc@;

    // \ref{range.random.access}, RandomAccessRange
    template<class T>
    concept @\oldtxt{bool}@ RandomAccessRange = @\seebelownc@;

    // \ref{range.contiguous}, ContiguousRange
    template<class T>
    concept ContiguousRange = @\seebelownc@;

    // \ref{range.viewable}
    template<class T>
    concept ViewableRange = @\seebelownc@;

    // \ref{range.view_interface}
    template<class D>
      requires is_class_v<D>
    class view_interface;

    // \ref{range.subrange}
    enum class subrange_kind : bool { unsized, sized };

    template<Iterator I, Sentinel<I> S = I, subrange_kind K = @\seebelownc@>
      requires K == subrange_kind::sized || !SizedSentinel<S, I>
    class subrange;

    // \ref{range.adaptors.all}
    namespace view { inline constexpr @\unspec@ all = @\unspecnc@; }

    template<ViewableRange R>
    using all_view = decltype(view::all(declval<R>()));

    // \ref{range.adaptors.filter_view}
    template<InputRange R, IndirectUnaryPredicate<iterator_t<R>> Pred>
      requires View<R>
    class filter_view;

    namespace view { inline constexpr @\unspec@ filter = @\unspecnc@; }

    // \ref{range.adaptors.transform_view}
    template<InputRange R, CopyConstructible F>
      requires View<R> && @\newtxt{is_object_v<F> \&\&}@ Invocable<F&, @\newtxt{iter_}@reference_t<iterator_t<R>>>
    class transform_view;

    namespace view { inline constexpr @\unspec@ transform = @\unspecnc@; }

    // \ref{range.adaptors.iota_view}
    template<WeaklyIncrementable I, Semiregular Bound = unreachable>
      requires @\placeholder{weakly-equality-comparable-with}@<I, Bound>
    class iota_view;

    namespace view { inline constexpr @\unspec@ iota = @\unspecnc@; }

    // \ref{range.adaptors.join_view}
    template<InputRange R>
      requires View<R> && InputRange<@\newtxt{iter_}@reference_t<iterator_t<R>>> &&
        (is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<R>>> ||
          View<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<R>>>)
    class join_view;

    namespace view { inline constexpr @\unspec@ join = @\unspecnc@; }

    // \ref{range.adaptors.empty_view}
    template<class T>
      requires is_object_v<T>
    class empty_view;

    namespace view {
      template<class T>
      inline constexpr empty_view<T> empty {};
    }

    // \ref{range.adaptors.single_view}
    template<CopyConstructible T>
      @\newtxt{requires is_object_v<T>}@
    class single_view;

    namespace view { inline constexpr @\unspec@ single = @\unspecnc@; }

    // \expos
    template<class R>
    concept @\placeholder{tiny-range}@ = @\seebelownc@;

    // \ref{range.adaptors.split_view}
    template<InputRange Rng, ForwardRange Pattern>
      requires View<Rng> && View<Pattern> &&
          IndirectlyComparable<iterator_t<Rng>, iterator_t<Pattern>@\newtxt{, ranges::equal_to<>}@> &&
          (ForwardRange<Rng> || @\placeholder{tiny-range}@<Pattern>)
    class split_view;

    namespace view { inline constexpr @\unspec@ split = @\unspecnc@; }

    // \ref{range.adaptors.counted}
    namespace view { inline constexpr @\unspec@ counted = @\unspecnc@; }

    // \ref{range.adaptors.common_view}
    template<View Rng>
      requires !CommonRange<Rng>
    class common_view;

    namespace view { inline constexpr @\unspec@ common = @\unspecnc@; }

    // \ref{range.adaptors.reverse_view}
    template<View Rng>
      requires BidirectionalRange<Rng>
    class reverse_view;

    namespace view { inline constexpr @\unspec@ reverse = @\unspecnc@; }
  }

  namespace view = ranges::view;

  template<class I, class S, ranges::subrange_kind K>
    struct tuple_size<ranges::subrange<I, S, K>>
      : integral_constant<size_t, 2> {};
  template<class I, class S, ranges::subrange_kind K>
    struct tuple_element<0, ranges::subrange<I, S, K>> {
      using type = I;
    };
  template<class I, class S, ranges::subrange_kind K>
    struct tuple_element<1, ranges::subrange<I, S, K>> {
      using type = S;
    };
}@\oldtxt{\}\}}@
\end{codeblock}

\rSec1[range.access]{Range access}

\ednote{This wording integrates the PR for
\href{https://github.com/ericniebler/stl2/issues/547}{stl2\#547}.}

\pnum
In addition to being available via inclusion of the
\tcode{<\oldtxt{experimental/ranges/}range\newtxt{s}>}
header, the customization point objects in \ref{range.access} are
available when \tcode{<\oldtxt{experimental/ranges/}iterator>} is included.

\rSec2[range.access.begin]{\tcode{begin}}
\pnum
The name \tcode{begin} denotes a customization point
 object\cxxiref{customization.point.object}. The expression
\tcode{ranges::begin(E)} for some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item
  {\color{oldclr}
  \tcode{ranges::begin(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \begin{note}
  This deprecated usage exists so that
  \tcode{ranges::begin(E)} behaves similarly to \tcode{std::begin(E)}
  as defined in ISO/IEC 14882 when \tcode{E} is an rvalue.
  \end{note}
  } %% \color{oldclr}

\item
  \oldtxt{Otherwise, }\tcode{(E) + 0} if \tcode{E} \oldtxt{has}\newtxt{is an lvalue of} array
  type\cxxiref{basic.compound}.

\item
  Otherwise, \newtxt{if \tcode{E} is an lvalue,} \tcode{\placeholdernc{DECAY_COPY}((E).begin())}
  if it is a valid expression and its type \tcode{I} \newtxt{models \tcode{Iterator}.}\oldtxt{meets the
  syntactic requirements of \tcode{Iterator<I>}. If
  \tcode{Iterator} is not satisfied, the program is ill-formed
  with no diagnostic required.}

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(begin(E))} if it is a valid expression and its type \tcode{I} \oldtxt{meets the
  syntactic requirements of \tcode{Iterator<I>}} \newtxt{models \tcode{Iterator}} with overload
  resolution performed in a context that includes the declarations:
  \begin{codeblock}
  @\newtxt{template<class T>}@ void begin(@\oldtxt{auto}\newtxt{T}@&@\newtxt{\&}@) = delete;
  @\newtxt{template<class T> void begin(initializer_list<T>\&\&) = delete;}@
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::begin}. \oldtxt{If \tcode{Iterator}
  is not satisfied, the program is ill-formed with no diagnostic
  required.}

\item
  Otherwise, \tcode{ranges::begin(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::begin(E)} is a valid expression, its
type \oldtxt{satisfies} \newtxt{models} \tcode{Iterator}.
\end{note}

\rSec2[range.access.end]{\tcode{end}}
\pnum
The name \tcode{end} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::end(E)} for some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item
  {\color{oldclr}
  \tcode{ranges::end(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \begin{note}
  This deprecated usage exists so that
  \tcode{ranges::end(E)} behaves similarly to \tcode{std::end(E)}
  as defined in ISO/IEC 14882 when \tcode{E} is an rvalue.
  \end{note}
  } %% \color{oldclr}

\item
  \oldtxt{Otherwise, }\tcode{(E) + extent\newtxt{_v}<T>\oldtxt{::value}} if
  \tcode{E} \oldtxt{has} \newtxt{is an lvalue of} array
  type\cxxiref{basic.compound} \tcode{T}.

\item
  Otherwise, \newtxt{if \tcode{E} is an lvalue,} \tcode{\placeholdernc{DECAY_COPY}((E).end())}
  if it is a valid expression and its type \tcode{S} \newtxt{models}
  \oldtxt{meets the syntactic requirements of}
  \tcode{Sentinel<\oldtxt{\brk{}S, }decltype(\brk{}ranges::\brk{}begin(E))>}. \oldtxt{If
  \tcode{Sentinel} is not satisfied, the program is ill-formed with
  no diagnostic required.}

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(end(E))} if it is a valid expression and
  its type \tcode{S} \oldtxt{meets the syntactic requirements of} \newtxt{models}
  \tcode{Sentinel<\oldtxt{\brk{}S, }decltype(\brk{}ranges::\brk{}begin(E))>} with overload
  resolution performed in a context that includes the declarations:
  \begin{codeblock}
  @\newtxt{template<class T>}@ void end(@\oldtxt{auto}\newtxt{T}@&@\newtxt{\&}@) = delete;
  @\newtxt{template<class T> void end(initializer_list<T>\&\&) = delete;}@
  \end{codeblock}
  and does not include
  a declaration of \tcode{ranges::end}. \oldtxt{If \tcode{Sentinel} is not
  satisfied, the program is ill-formed with no diagnostic required.}

\item
  Otherwise, \tcode{ranges::end(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::end(E)} is a valid expression, the
types of \tcode{ranges::end(E)} and \tcode{ranges::\brk{}begin(E)} satisfy
\tcode{Sentinel}.
\end{note}

\rSec2[range.access.cbegin]{\tcode{cbegin}}
\pnum
The name \tcode{cbegin} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::\brk{}cbegin(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::\brk{}begin(static_cast<const T\&>(E))} \newtxt{if \tcode{E} is an lvalue}.
\item \newtxt{Otherwise, }\tcode{\newtxt{ranges::\brk{}begin(static_cast<const T\&\&>(E))}}\newtxt{.}
\end{itemize}

{\color{oldclr}
\pnum
Use of \tcode{ranges::cbegin(E)} with rvalue \tcode{E} is deprecated.
\begin{note}
This deprecated usage exists so that \tcode{ranges::cbegin(E)}
behaves similarly to \tcode{std::cbegin(E)} \oldtxt{as defined in ISO/IEC 14882} when
\tcode{E} is an rvalue.
\end{note}
} %% \color{oldclr}

\pnum
\begin{note}
Whenever \tcode{ranges::cbegin(E)} is a valid expression, its
type \oldtxt{satisfies} \newtxt{models} \tcode{Iterator}.
\end{note}

\rSec2[range.access.cend]{\tcode{cend}}
\pnum
The name \tcode{cend} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::cend(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:

\begin{itemize}
\item \tcode{ranges::end(static_cast<const T\&>(E))}\newtxt{ if \tcode{E} is an lvalue}.
\item \newtxt{Otherwise, }\tcode{\newtxt{ranges::end(static_cast<const T\&\&>(E))}}\newtxt{.}
\end{itemize}

{\color{oldclr}
\pnum
Use of \tcode{ranges::cend(E)} with rvalue \tcode{E} is deprecated.
\begin{note}
This deprecated usage exists so that \tcode{ranges::\brk{}cend(E)}
behaves similarly to \tcode{std::cend(E)} as defined in ISO/IEC 14882 when
\tcode{E} is an rvalue.
\end{note}
} %% \color{oldclr}

\pnum
\begin{note}
Whenever \tcode{ranges::cend(E)} is a valid expression, the
types of \tcode{ranges::cend(E)} and \tcode{ranges::\brk{}cbegin(E)} satisfy
\tcode{Sentinel}.
\end{note}

\rSec2[range.access.rbegin]{\tcode{rbegin}}
\pnum
The name \tcode{rbegin} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::rbegin(E)} for some subexpression \tcode{E} is expression-equivalent
to:

\begin{itemize}
{\color{oldclr}
\item
  \tcode{ranges::rbegin(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \begin{note}
  This deprecated usage exists so that \tcode{ranges::rbegin(E)} behaves similarly
  to \tcode{std::rbegin(E)} as defined in ISO/IEC 14882 when \tcode{E} is an rvalue.
  \end{note}
} %% \color{oldclr}

\item
  \oldtxt{Otherwise} \newtxt{If \tcode{E} is an lvalue},
  \tcode{\placeholdernc{DECAY_COPY}((E).rbegin())} if it is a valid expression and its
  type \tcode{I} \newtxt{models \tcode{Iterator}} \oldtxt{meets the syntactic
  requirements of \tcode{Iterator<I>}. If \tcode{Iterator}
  is not satisfied, the program is ill-formed with no diagnostic
  required}.

{\color{newclr}
\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(rbegin(E))} if it is a valid expression
  and its type \tcode{I} models \tcode{Iterator} with overload resolution
  performed in a context that includes the declaration:
  \begin{codeblock}
  template<class T> void rbegin(T&&) = delete;
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::rbegin}.
} %% \color{newclr}

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::end(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges::\brk{}end(\brk{}E)} are valid expressions of the same
  type \tcode{I} which \newtxt{models} \oldtxt{meets the syntactic requirements of}
  \tcode{Bi\-direct\-ional\-Iterator\oldtxt{<I>}}\iref{iterator.concept.bidirectional}.

\item
  Otherwise, \tcode{ranges::rbegin(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::rbegin(E)} is a valid expression, its
type \oldtxt{satisfies} \newtxt{models} \tcode{Iterator}.
\end{note}

\rSec2[range.access.rend]{\tcode{rend}}
\pnum
The name \tcode{rend} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::rend(E)} for some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
{\color{oldclr}
\item
  \tcode{ranges::rend(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \begin{note}
  This deprecated usage exists so that
  \tcode{ranges::rend(E)} behaves similarly to \tcode{std::rend(E)}
  as defined in ISO/IEC 14882 when \tcode{E} is an rvalue.
  \end{note}
} %% \color{oldclr}

\item
  \oldtxt{Otherwise} \newtxt{If \tcode{E} is an lvalue},
  \tcode{\placeholdernc{DECAY_COPY}((E).rend())} if it is a valid expression and its
  type \tcode{S} \oldtxt{meets the syntactic requirements of} \newtxt{models}
  \tcode{Sentinel<\oldtxt{\brk{}S, }decltype(\brk{}ranges::\brk{}rbegin(E))>}.
  \oldtxt{If \tcode{Sentinel} is not satisfied, the program is ill-formed with
  no diagnostic required.}

{\color{newclr}
\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(rend(E))} if it is a valid expression and
  its type \tcode{S} models \tcode{Sentinel<\brk{}decltype(\brk{}ranges::rbegin(E))>} with
  overload resolution performed in a context that includes the declaration:
  \begin{codeblock}
  template<class T> void rend(T&&) = delete;
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::rend}.
} %% \color{newclr}

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::begin(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges::end(\brk{}E)} are valid expressions
  of the same type \tcode{I} which \oldtxt{meets the syntactic requirements of} \newtxt{models}
  \tcode{Bi\-dir\-ect\-ion\-al\-It\-er\-at\-or\oldtxt{<I>}}\iref{iterator.concept.bidirectional}.

\item
  Otherwise, \tcode{ranges::rend(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::rend(E)} is a valid expression, the
types of \tcode{ranges::\brk{}rend(E)} and \tcode{ranges::\brk{}rbegin(E)} satisfy
\tcode{Sentinel}.
\end{note}

\rSec2[range.access.crbegin]{\tcode{crbegin}}
\pnum
The name \tcode{crbegin} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::\brk{}crbegin(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::\brk{}rbegin(static_cast<const T\&>(E))} \newtxt{if \tcode{E} is an lvalue}.
{\color{newclr}
\item Otherwise, \tcode{ranges::rbegin(static_cast<const T\&\&>(E))}.
} %% \color{newclr}
\end{itemize}

{\color{oldclr}
\pnum
Use of \tcode{ranges::crbegin(E)} with rvalue \tcode{E} is deprecated.
\begin{note}
This deprecated usage exists so that \tcode{ranges::crbegin(E)}
behaves similarly to \tcode{std::crbegin(E)} as defined in ISO/IEC 14882 when
\tcode{E} is an rvalue.
\end{note}
} %% \color{oldclr}

\pnum
\begin{note}
Whenever \tcode{ranges::crbegin(E)} is a valid expression, its
type \oldtxt{satisfies} \newtxt{models} \tcode{Iterator}.
\end{note}

\rSec2[range.access.crend]{\tcode{crend}}
\pnum
The name \tcode{crend} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::crend(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::rend(static_cast<const T\&>(E))} \newtxt{if \tcode{E} is an lvalue}.

{\color{newclr}
\item Otherwise, \tcode{ranges::rend(static_cast<const T\&\&>(E))}.
} %% \color{newclr}
\end{itemize}

{\color{oldclr}
\pnum
Use of \tcode{ranges::crend(E)} with rvalue \tcode{E} is deprecated.
\begin{note}
This deprecated usage exists so that \tcode{ranges::crend(E)}
behaves similarly to \tcode{std::crend(E)} as defined in ISO/IEC 14882 when
\tcode{E} is an rvalue.
\end{note}
} %% \color{oldclr}

\pnum
\begin{note}
Whenever \tcode{ranges::crend(E)} is a valid expression, the
types of \tcode{ranges::crend(E)} and \tcode{ranges::\brk{}crbegin(\brk{}E)} satisfy
\tcode{Sentinel}.
\end{note}

\rSec1[range.primitives]{Range primitives}

\pnum
In addition to being available via inclusion of the
\tcode{<\oldtxt{experimental/ranges/}range\newtxt{s}>}
header, the customization point objects in \ref{range.primitives} are
available when \tcode{<\oldtxt{experimental/ranges/}iterator>} is included.

\rSec2[range.primitives.size]{\tcode{size}}
\pnum
The name \tcode{size} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::size(E)} for some subexpression \tcode{E} with type
\tcode{T} is expression-equivalent to:

\begin{itemize}
\item
  \tcode{\placeholdernc{DECAY_COPY}(extent\newtxt{_v}<T>\oldtxt{::value})} if \tcode{T} is an array
  type\cxxiref{basic.compound}.

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(\oldtxt{static_cast<const T\&>(}E\oldtxt{)}.size())}
  if it is a valid expression and its type \tcode{I} \oldtxt{satisfies}
  \newtxt{models} \tcode{Integral\oldtxt{<I>}} and
  \tcode{disable_\-sized_\-range<\newtxt{remove_cvref_t<}T\newtxt{>}>}\iref{range.sized} is
  \tcode{false}.

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(size(\oldtxt{static_cast<const T\&>(}E\oldtxt{)}))}
  if it is a valid expression and its type \tcode{I} \oldtxt{satisfies}
  \newtxt{models} \tcode{Integral\oldtxt{<I>}} with overload resolution
  performed in a context that includes the declaration:
  \begin{codeblock}
  @\newtxt{template<class T>}@ void size(@\oldtxt{const}@ @\oldtxt{auto}\newtxt{T}@&@\newtxt{\&}@) = delete;
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::size}, and
  \tcode{disable_\-sized_\-range<\newtxt{remove_cvref_t<}T\newtxt{>}>} is \tcode{false}.

\item
  Otherwise,
  \tcode{\placeholdernc{DECAY_COPY}(ranges::\oldtxt{c}end(E) - ranges::\oldtxt{c}begin(E))}, except that \tcode{E}
  is only evaluated once, if it is a valid expression and the types \tcode{I} and \tcode{S} of
  \tcode{ranges::\oldtxt{c}begin(E)} and \tcode{ranges::\oldtxt{c}end(\brk{}E)} \oldtxt{meet the
  syntactic requirements of} \newtxt{model}
  \tcode{SizedSentinel<S, I>}\iref{iterator.concept.sizedsentinel} and
  \tcode{Forward\-Iter\-at\-or<I>}. \oldtxt{If \tcode{SizedSentinel} and
  \tcode{Forward\-Iter\-at\-or} are not satisfied, the program is ill-formed with no
  diagnostic required.}

\item
  Otherwise, \tcode{ranges::size(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::size(E)} is a valid expression, its
type \oldtxt{satisfies} \newtxt{models} \libconcept{Integral}.
\end{note}

\rSec2[range.primitives.empty]{\tcode{empty}}
\pnum
The name \tcode{empty} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::empty(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  \tcode{bool((E).empty())} if it is a valid expression.

\item
  Otherwise, \tcode{ranges::size(E) == 0} if it is a valid expression.

\item
  Otherwise, \tcode{bool(ranges::begin(E) == ranges::end(E))},
  except that \tcode{E} is only evaluated once, if it is a valid expression and the type of
  \tcode{ranges::begin(E)} \oldtxt{satisfies} \newtxt{models} \tcode{ForwardIterator}.

\item
  Otherwise, \tcode{ranges::empty(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::empty(E)} is a valid expression, it
has type \tcode{bool}.
\end{note}

\rSec2[range.primitives.data]{\tcode{data}}
\pnum
The name \tcode{data} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::data(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
{\color{oldclr}
\item
  \tcode{ranges::data(static_cast<const T\&>(E))} if \tcode{E} is an rvalue of
  type \tcode{T}. This usage is deprecated.
  \begin{note}
  This deprecated usage exists so that \tcode{ranges::data(E)} behaves
  similarly to \tcode{std::data(E)} as defined in the \Cpp Working
  Paper when \tcode{E} is an rvalue.
  \end{note}
} %% \color{oldclr}

\item
  \oldtxt{Otherwise} \newtxt{If \tcode{E} is an lvalue},
  \tcode{\placeholdernc{DECAY_COPY}((E).data())} if it is a valid expression of pointer to object type.

\item
  Otherwise, \tcode{ranges::begin(E)} if it is a valid expression of pointer to object type.

\item
  Otherwise, if \tcode{ranges::begin(E)} is a valid expression whose type models
  \tcode{ContiguousIterator},
  \begin{codeblock}
  ranges::begin(E) == ranges::end(E) ? nullptr : addressof(*ranges::begin(E))
  \end{codeblock}
  except that \tcode{E} is evaluated only once.

\item
  Otherwise, \tcode{ranges::data(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::data(E)} is a valid expression, it
has pointer to object type.
\end{note}

\rSec2[range.primitives.cdata]{\tcode{cdata}}
\pnum
The name \tcode{cdata} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::cdata(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::data(static_cast<const T\&>(E))} \newtxt{if \tcode{E} is an lvalue}.

{\color{newclr}
\item Otherwise, \tcode{ranges::data(static_cast<const T\&\&>(E))}.
} %% \color{newclr}
\end{itemize}

{\color{oldclr}
\pnum
Use of \tcode{ranges::cdata(E)} with rvalue \tcode{E} is deprecated.
\begin{note}
This deprecated usage exists so that \tcode{ranges::cdata(E)}
has behavior consistent with \tcode{ranges::data(E)} when \tcode{E} is
an rvalue.
\end{note}
} %% \color{oldclr}

\pnum
\begin{note}
Whenever \tcode{ranges::cdata(E)} is a valid expression, it
has pointer to object type.
\end{note}

\rSec1[range.requirements]{Range requirements}

\rSec2[range.requirements.general]{General}

\pnum
Ranges are an abstraction of containers that allow a \Cpp program to
operate on elements of data structures uniformly. In their simplest form, a
range object is one on which one can call \tcode{begin} and
\tcode{end} to get an iterator\iref{iterator.concept.iterator} and a
sentinel\iref{iterator.concept.sentinel}. To be able to construct
template algorithms and range adaptors that work correctly and efficiently on
different types of sequences, the library formalizes not just the interfaces but
also the semantics and complexity assumptions of ranges.

\pnum
This document defines three fundamental categories of ranges
based on the syntax and semantics supported by each: \term{range},
\term{sized range} and \term{view}, as shown in
\tref{range.relations}.

\begin{floattable}{Relations among range categories}{tab:range.relations}
  {lll}
  \topline
  \textbf{Sized Range}  &               &                   \\
                        & $\searrow$    &                   \\
                        &               &  \textbf{Range}   \\
                        & $\nearrow$    &                   \\
  \textbf{View}         &               &                   \\
\end{floattable}

\pnum
The \libconcept{Range} concept requires only that \tcode{begin} and \tcode{end}
return an iterator and a sentinel. The \tcode{SizedRange} concept refines \libconcept{Range}
with the requirement that the number of elements in the range can be determined
in constant time using the \tcode{size} function. The \tcode{View} concept
specifies requirements on a \libconcept{Range} type
with constant-time copy and assign operations.

\pnum
In addition to the three fundamental range categories, this document defines
a number of convenience refinements of \libconcept{Range} that group together requirements
that appear often in the concepts and algorithms.
\term{\oldtxt{Bounded ranges}\newtxt{Common ranges}} are ranges for which
\tcode{begin} and \tcode{end} return objects of the
same type. \term{Random access ranges} are ranges for which
\tcode{begin} returns a type that \oldtxt{satisfies} \newtxt{models}
\tcode{RandomAccessIterator}\iref{iterator.concept.random.access}. The range
categories \term{bidirectional ranges},
\term{forward ranges},
\term{input ranges}, and
\term{output ranges} are defined similarly.

\rSec2[range.range]{Ranges}

\pnum
The \libconcept{Range} concept defines the requirements of a type that allows
iteration over its elements by providing a \tcode{begin} iterator and an
\tcode{end} sentinel.
\begin{note}
Most algorithms requiring this concept simply forward to an
\tcode{Iterator}-based algorithm by calling \tcode{begin} and \tcode{end}.
\end{note}

\indexlibrary{\idxcode{Range}}%
\begin{itemdecl}
template<class T>
concept @\oldtxt{bool Range} \newtxt{\placeholder{range-impl}}@ = @\newtxt{// \expos}@
  requires(T&& t) {
    ranges::begin(@\newtxt{std::forward<T>(}@t@\newtxt{)}@); // not necessarily equality-preserving (see below)
    ranges::end(@\newtxt{std::forward<T>(}@t@\newtxt{)}@);
  };

@\newtxt{template<class T>}@
@\newtxt{concept Range = \placeholdernc{range-impl}<T\&>;}@

@\newtxt{template<class T>}@
@\newtxt{concept \placeholder{forwarding-range} = // \expos}@
  @\newtxt{Range<T> \&\& \placeholder{range-impl}<T>;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
Given an \oldtxt{lvalue \tcode{t} of type
}\tcode{\oldtxt{remove_reference_t<T>}}\oldtxt{, \tcode{Range<T>} is satisfied}
\newtxt{expression \tcode{E} such that \tcode{decltype((E))} is \tcode{T},
\tcode{T} models \tcode{\placeholdernc{range-impl}}} only if

\begin{itemize}
\item \range{\newtxt{ranges::}begin(\oldtxt{t}\newtxt{E})}%
{\newtxt{ranges::}end(\oldtxt{t}\newtxt{E})} denotes a range.

\item Both
\tcode{\newtxt{ranges::}begin(\oldtxt{t}\newtxt{E})}
and
\tcode{\newtxt{ranges::}end(\oldtxt{t}\newtxt{E})}
are amortized constant time and non-modifying.
\begin{note}
\tcode{\newtxt{ranges::}begin(\oldtxt{t}\newtxt{E})}
and
\tcode{\newtxt{ranges::}end(\oldtxt{t}\newtxt{E})}
do not require implicit expression
variations\cxxiref{concepts.equality}.
\end{note}

\item If \tcode{\oldtxt{iterator_t<T>}}
\newtxt{the type of \tcode{ranges::begin(E)}}
\oldtxt{satisfies} \newtxt{models} \tcode{ForwardIterator},
\tcode{\newtxt{ranges::}begin(\oldtxt{t}\newtxt{E})}
is equality-preserving.
\end{itemize}

{\color{newclr}
\pnum
Given an expression \tcode{E} such that \tcode{decltype((E))} is \tcode{T},
\tcode{T} models \tcode{\placeholdernc{forwarding-range}} only if
\begin{itemize}
\item The expressions \tcode{ranges::begin(E)} and \tcode{ranges::begin(static_cast<T\&>(E))}
are expression-equivalent.

\item The expressions \tcode{ranges::end(E)} and \tcode{ranges::end(static_cast<T\&>(E))}
are expression-equivalent.
\end{itemize}
} %% \color{newclr}
\end{itemdescr}

\pnum
\begin{note}
Equality preservation of both \tcode{\newtxt{ranges::}begin} and
\tcode{\newtxt{ranges::}end} enables passing a \libconcept{Range} whose iterator
type \oldtxt{satisfies} \newtxt{models} \tcode{ForwardIterator} to multiple
algorithms and making multiple passes over the range by repeated calls to
\tcode{\newtxt{ranges::}begin} and \tcode{\newtxt{ranges::}end}.
Since \tcode{\newtxt{ranges::}begin} is not required to be equality-preserving
when the return type does not satisfy \tcode{ForwardIterator}, repeated calls
might not return equal values or might not be well-defined;
\tcode{\newtxt{ranges::}begin} should be called at most once for such a range.
\end{note}

\rSec2[range.sized]{Sized ranges}

\pnum
The \tcode{SizedRange} concept specifies the requirements
of a \libconcept{Range} type that knows its size in constant time with the
\tcode{size} function.

\indexlibrary{\idxcode{SizedRange}}%
\begin{itemdecl}
template<class T>
concept @\oldtxt{bool}@ SizedRange =
  Range<T> &&
  !disable_sized_range<remove_cv@\oldtxt{_t<remove_}@ref@\oldtxt{erence}@_t<T>@\oldtxt{>}@> &&
  requires(T& t) {
    { ranges::size(t) } -> ConvertibleTo<@\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<T>>>;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{SizedRange<T>} is satisfied only if:

\begin{itemize}
\item \tcode{ranges::size(t)} is \bigoh{1}, does not modify \tcode{t}, and is equal
to \tcode{ranges::distance(t)}.

\item If \tcode{iterator_t<T>} \oldtxt{satisfies} \newtxt{models} \tcode{ForwardIterator},
\tcode{size(t)} is well-defined regardless of the evaluation of
\tcode{begin(t)}.
\begin{note}
\tcode{size(t)} is otherwise not required be
well-defined after evaluating \tcode{begin(t)}. For a \tcode{SizedRange}
whose iterator type does not model \tcode{ForwardIterator}, for
example, \tcode{size(t)} might only be well-defined if evaluated before
the first call to \tcode{begin(t)}.
\end{note}
\end{itemize}

\pnum
\begin{note}
The \tcode{disable_sized_range} predicate provides a mechanism to enable use
of range types with the library that meet the syntactic requirements but do
not in fact satisfy \tcode{SizedRange}. A program that instantiates a library template
that requires a \libconcept{Range} with such a range type \tcode{R} is ill-formed with no
diagnostic required unless
\tcode{disable_sized_range<remove_cv\oldtxt{_t<remove_}ref\oldtxt{erence}_t<R>\oldtxt{>}>} evaluates
to \tcode{true}\cxxiref{structure.requirements}.
\end{note}
\end{itemdescr}

\rSec2[range.view]{Views}

\pnum
The \tcode{View} concept specifies the requirements of a
\libconcept{Range} type that has constant time copy, move and assignment operators; that
is, the cost of these operations is not proportional to the number of elements in
the \tcode{View}.

\pnum
\begin{example}
Examples of \tcode{View}s are:

\begin{itemize}
\item A \libconcept{Range} type that wraps a pair of iterators.

\item A \libconcept{Range} type that holds its elements by \tcode{shared_ptr}
and shares ownership with all its copies.

\item A \libconcept{Range} type that generates its elements on demand.
\end{itemize}

A container\iref{containers} is not a \libconcept{View} since copying the
container copies the elements, which cannot be done in constant time.
\end{example}

\indexlibrary{\idxcode{View}}%
\begin{itemdecl}
template<class T>
@\newtxt{inline}@ constexpr bool @\placeholder{view-predicate}@ // \expos
  = @\seebelownc@;

template<class T>
concept @\oldtxt{bool}@ View =
  Range<T> &&
  Semiregular<T> &&
  @\placeholder{view-predicate}@<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Since the difference between \libconcept{Range} and \tcode{View} is largely semantic, the
two are differentiated with the help of the \tcode{enable_view}
trait. Users may specialize \tcode{enable_view}
to derive from \tcode{true_type} or \tcode{false_type}.

\pnum
For a type \tcode{T}, the value of \tcode{\placeholder{view-predicate}<T>} shall be:
\begin{itemize}

\item If \newtxt{the \grammarterm{qualified-id}} \tcode{enable_view<T>\newtxt{::type}}
  \oldtxt{has a member type \tcode{type}} \newtxt{is valid and denotes a
  type\cxxiref{temp.deduct}}, \tcode{enable_view<T>::type::value};
\item Otherwise, if \tcode{\newtxt{DerivedFrom<}T\newtxt{, view_base>}} is
  \newtxt{\tcode{true}} \oldtxt{derived from \tcode{view_base}}, \tcode{true};
\item Otherwise, if \tcode{T} is an \oldtxt{instantiation} \newtxt{specialization}
  of class template
  \tcode{initializer_list}\cxxiref{support.initlist},
  \tcode{set}\cxxiref{set},
  \tcode{multiset}\cxxiref{multiset},
  \tcode{unordered_set}\cxxiref{unord.set}, or
  \tcode{unordered_multiset}\cxxiref{unord.multiset}, \tcode{false};
\item Otherwise, if both \tcode{T} and \tcode{const T} satisfy \libconcept{Range} and
  \tcode{\newtxt{iter_}reference_t<iterator_t<T>{>}} is not the same type as
  \tcode{\newtxt{iter_}reference_t<iterator_t<const T>{>}},
  \tcode{false};
  \begin{note}
  Deep \tcode{const}-ness implies element ownership, whereas shallow \tcode{const}-ness
  implies reference semantics.
  \end{note}
\item Otherwise, \tcode{true}.
\end{itemize}
\end{itemdescr}

\rSec2[range.common]{Common ranges}

\ednote{We've renamed ``\libconcept{BoundedRange}'' to ``\libconcept{CommonRange}''. The authors believe
this is a better name than ``\libconcept{ClassicRange}'', which LEWG weakly preferred. The reason is
that the iterator and sentinel of a Common range have the same type in \textit{common}.
A non-Common range can be turned into a Common range with the help of \tcode{view::common}.}

\pnum
The \oldtxt{\tcode{BoundedRange}}\newtxt{\tcode{CommonRange}} concept specifies requirements
of a \libconcept{Range} type for which \tcode{begin} and \tcode{end} return objects of
the same type.
\begin{note}
The standard containers\cxxiref{containers}
satisfy \oldtxt{\tcode{BoundedRange}}\newtxt{\tcode{CommonRange}}.
\end{note}

\indexlibrary{\idxcode{CommonRange}}%
\begin{itemdecl}
template<class T>
concept @\oldtxt{bool}@ @\oldtxt{BoundedRange}\newtxt{CommonRange}@ =
  Range<T> && Same<iterator_t<T>, sentinel_t<T>>;
\end{itemdecl}

\rSec2[range.input]{Input ranges}

\pnum
The \tcode{InputRange} concept specifies requirements of
a \libconcept{Range} type for which \tcode{begin} returns a type
that \oldtxt{satisfies} \newtxt{models} \tcode{InputIterator}\iref{iterator.concept.input}.

\indexlibrary{\idxcode{InputRange}}%
\begin{itemdecl}
template<class T>
concept @\oldtxt{bool}@ InputRange =
  Range<T> && InputIterator<iterator_t<T>>;
\end{itemdecl}

\rSec2[range.output]{Output ranges}

\pnum
The \tcode{OutputRange} concept specifies requirements of
a \libconcept{Range} type for which \tcode{begin} returns a type that \oldtxt{satisfies} \newtxt{models}
\tcode{OutputIterator}\iref{iterator.concept.output}.

\indexlibrary{\idxcode{OutputRange}}%
\begin{itemdecl}
template<class R, class T>
concept @\oldtxt{bool}@ OutputRange =
  Range<R> && OutputIterator<iterator_t<R>, T>;
\end{itemdecl}

\rSec2[range.forward]{Forward ranges}

\pnum
The \tcode{ForwardRange} concept specifies requirements of an
\tcode{InputRange} type for which \tcode{begin} returns a type that \oldtxt{satisfies} \newtxt{models}
\tcode{ForwardIterator}\iref{iterator.concept.forward}.

\indexlibrary{\idxcode{ForwardRange}}%
\begin{itemdecl}
template<class T>
concept @\oldtxt{bool}@ ForwardRange =
  InputRange<T> && ForwardIterator<iterator_t<T>>;
\end{itemdecl}

\rSec2[range.bidirectional]{Bidirectional ranges}

\pnum
The \tcode{BidirectionalRange} concept specifies requirements of a
\tcode{ForwardRange} type for which \tcode{begin} returns a type that \oldtxt{satisfies} \newtxt{models}
\tcode{BidirectionalIterator}\iref{iterator.concept.bidirectional}.

\indexlibrary{\idxcode{BidirectionalRange}}%
\begin{itemdecl}
template<class T>
concept @\oldtxt{bool}@ BidirectionalRange =
  ForwardRange<T> && BidirectionalIterator<iterator_t<T>>;
\end{itemdecl}

\rSec2[range.random.access]{Random access ranges}

\pnum
The \tcode{RandomAccessRange} concept specifies requirements of a
\tcode{BidirectionalRange} type for which \tcode{begin} returns a type that \oldtxt{satisfies} \newtxt{models}
\tcode{RandomAccessIterator}\iref{iterator.concept.random.access}.

\indexlibrary{\idxcode{RandomAccessRange}}%
\begin{itemdecl}
template<class T>
concept @\oldtxt{bool}@ RandomAccessRange =
  BidirectionalRange<T> && RandomAccessIterator<iterator_t<T>>;
\end{itemdecl}

\rSec2[range.contiguous]{Contiguous ranges}

\pnum
The \tcode{ContiguousRange} concept specifies requirements of a
\tcode{RandomAccessRange} type for which \tcode{begin} returns a type that \oldtxt{satisfies} \newtxt{models}
\tcode{ContiguousIterator}\iref{iterator.concept.contiguous}.

\indexlibrary{\idxcode{ContiguousRange}}%
\begin{itemdecl}
template<class T>
concept ContiguousRange =
  RandomAccessRange<T> && ContiguousIterator<iterator_t<T>> &&
  requires(T& t) {
    ranges::data(t);
    requires Same<decltype(ranges::data(t)), add_pointer_t<@\newtxt{iter_}@reference_t<iterator_t<T>>>>;
  };
\end{itemdecl}

\rSec2[range.viewable]{Viewable ranges}
\pnum
The \libconcept{ViewableRange} concept specifies the requirements of a
\libconcept{Range} type that can be converted to a \libconcept{View} safely.

\indexlibrary{\idxcode{ViewableRange}}%
\begin{itemdecl}
template<class T>
concept ViewableRange =
  Range<T> && (@\oldtxt{is_lvalue_reference_v<T>}\newtxt{\placeholder{forwarding-range}<T>}@ || View<decay_t<T>>); @\oldtxt{// \seebelow}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{There need be no subsumption relationship between
}\tcode{\oldtxt{\libconcept{ViewableRange}<T>}}\oldtxt{
and
}\tcode{\oldtxt{is_lvalue_reference_v<T>}}\oldtxt{.}
\end{itemdescr}

\rSec1[range.utility]{Range utilities}

\pnum
The components in this section are general utilities for representing and
manipulating ranges.

{\color{oldclr}
\rSec2[range.dangling]{Class template \tcode{dangling}}

\pnum
\indexlibrary{\idxcode{\oldtxt{dangling}}}%
Class template \tcode{dangling} is a wrapper for an object that refers to another object whose
lifetime may have ended. It is used by algorithms that accept rvalue ranges and return iterators.

\begin{codeblock}
namespace std { namespace experimental { namespace ranges { inline namespace v1 {
  template<CopyConstructible T>
  class dangling {
  public:
    constexpr dangling() requires DefaultConstructible<T>;
    constexpr dangling(T t);
    constexpr T get_unsafe() const;
  private:
    T value; // \expos
  };

  template<Range R>
  using safe_iterator_t =
    conditional_t<is_lvalue_reference<R>::value,
      iterator_t<R>,
      dangling<iterator_t<R>>>;
}}}}
\end{codeblock}

\rSec3[range.dangling.ops]{\tcode{dangling} operations}

\indexlibrary{\idxcode{dangling}!\idxcode{dangling}}%
\begin{itemdecl}
constexpr dangling() requires DefaultConstructible<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{dangling}, value-initializing \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{dangling}!\idxcode{dangling}}%
\begin{itemdecl}
constexpr dangling(T t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs a \tcode{dangling}, initializing \tcode{value} with \tcode{t}.
\end{itemdescr}

\indexlibrary{\idxcode{unsafe_get}!\idxcode{dangling}}%
\indexlibrary{\idxcode{dangling}!\idxcode{unsafe_get}}%
\begin{itemdecl}
constexpr T get_unsafe() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{value}.
\end{itemdescr}
} %% \color{oldclr}


\rSec2[range.view_interface]{View interface}

\pnum
The class template \tcode{view_interface} is a helper for defining
\tcode{View}-like types that offer a container-like interface. It is
parameterized with the type that inherits from it.

\indexlibrary{\idxcode{view_interface}}%
\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<Range R>
  struct @\placeholder{range-common-iterator-impl}@ { // \expos
    using type = common_iterator<iterator_t<R>, sentinel_t<R>>;
  };
  template<CommonRange R>
  struct @\placeholdernc{range-common-iterator-impl}@<R> \{ // \expos
    using type = iterator_t<R>;
  };
  template<Range R>
    using @\placeholder{range-common-iterator}@ = // \expos
      typename @\placeholdernc{range-common-iterator-impl}@<R>::type;

  template<class D>
    requires is_class_v<D>
  class view_interface : public view_base {
  private:
    constexpr D& derived() noexcept { // \expos
      return static_cast<D&>(*this);
    }
    constexpr const D& derived() const noexcept { // \expos
      return static_cast<const D&>(*this);
    }
  public:
    constexpr bool empty() const requires ForwardRange<const D>;
    constexpr explicit operator bool() const
      requires requires { ranges::empty(derived()); };

    @\newtxt{constexpr auto data()}@
      @\newtxt{requires ContiguousIterator<iterator_t<D>>;}@
    constexpr auto data() const
      @\newtxt{requires Range<const D> \&\& ContiguousIterator<iterator_t<const D>>;}@
      @\oldtxt{requires RandomAccessRange<const D> \&\& is_pointer_v<iterator_t<const D>>;}@

    constexpr auto size() const requires ForwardRange<const D> &&
      SizedSentinel<sentinel_t<const D>, iterator_t<const D>>;

    constexpr decltype(auto) front() requires ForwardRange<D>;
    constexpr decltype(auto) front() const requires ForwardRange<const D>;

    constexpr decltype(auto) back()
      requires BidirectionalRange<D> && CommonRange<D>;
    constexpr decltype(auto) back() const
      requires BidirectionalRange<const D> && CommonRange<const D>;

    template<RandomAccessRange R = D>
      constexpr decltype(auto) operator[](@\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> n);
    template<RandomAccessRange R = const D>
      constexpr decltype(auto) operator[](@\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> n) const;

    @\oldtxt{template<RandomAccessRange R = D>}@
        @\oldtxt{requires SizedRange<R>}@
      @\oldtxt{constexpr decltype(auto) at(ifference_type_t<iterator_t<R>> n);}@
    @\oldtxt{template<RandomAccessRange R = const D>}@
        @\oldtxt{requires SizedRange<R>}@
      @\oldtxt{constexpr decltype(auto) at(ifference_type_t<iterator_t<R>> n) const;}@

    template<ForwardRange C>
        requires !View<C> &&
          ConvertibleTo<@\newtxt{iter_}@reference_t<iterator_t<const D>>,
            @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<C>>> &&
          Constructible<C, @\placeholder{range-common-iterator}@<const D>,
            @\placeholder{range-common-iterator}@<const D>>
      operator C() const;
  };
}@\oldtxt{\}}@
\end{codeblock}

\pnum
The template parameter for \tcode{view_interface} may be an incomplete type.

\rSec3[range.view_interface.accessors]{\tcode{view_interface} accessors}

\indexlibrary{\idxcode{empty}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr bool empty() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(derived()) == ranges::end(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{operator bool}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr explicit operator bool() const
  requires requires { ranges::empty(derived()); };
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !ranges::empty(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{data}!\idxcode{view_interface}}%
\begin{itemdecl}
@\newtxt{constexpr auto data()}@
  @\newtxt{requires ContiguousIterator<iterator_t<D>>;}@
constexpr auto data() const
  @\newtxt{requires Range<const D> \&\& ContiguousIterator<iterator_t<const D>>;}@
  @\oldtxt{requires RandomAccessRange<const D> \&\& is_pointer_v<iterator_t<const D>>;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr auto size() const requires ForwardRange<const D> &&
  SizedSentinel<sentinel_t<const D>, iterator_t<const D>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::end(derived()) - ranges::begin(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{front}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr decltype(auto) front() requires ForwardRange<D>;
constexpr decltype(auto) front() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\tcode{!empty()}.

\pnum
\effects Equivalent to: \tcode{return *ranges::begin(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{back}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr decltype(auto) back()
  requires BidirectionalRange<D> && CommonRange<D>;
constexpr decltype(auto) back() const
  requires BidirectionalRange<const D> && CommonRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\tcode{!empty()}.

\pnum
\effects Equivalent to: \tcode{return *\newtxt{ranges::}prev(ranges::end(derived()));}
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{view_interface}}%
\begin{itemdecl}
template<RandomAccessRange R = D>
constexpr decltype(auto) operator[](@\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> n);
template<RandomAccessRange R = const D>
constexpr decltype(auto) operator[](@\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires \tcode{ranges::begin(derived()) + n} is well-formed.}

\pnum
\effects Equivalent to: \tcode{return ranges::begin(derived())[n];}
\end{itemdescr}

\indexlibrary{\idxcode{at}!\idxcode{view_interface}}%
\begin{itemdecl}
@\oldtxt{template<RandomAccessRange R = D>}@
  @\oldtxt{requires SizedRange<R>}@
@\oldtxt{constexpr decltype(auto) at(difference_type_t<iterator_t<R>> n);}@
@\oldtxt{template<RandomAccessRange R = const D>}@
  @\oldtxt{requires SizedRange<R>}@
@\oldtxt{constexpr decltype(auto) at(difference_type_t<iterator_t<R>> n) const;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\effects Equivalent to: \tcode{return derived()[n];}.}

\pnum
\oldtxt{\throws \tcode{out_of_range} if \tcode{n < 0 || n >= ranges::size(derived())}.}
\end{itemdescr}

\indexlibrary{\idxcode{at}!\idxcode{view_interface}}%
\begin{itemdecl}
template<ForwardRange C>
  requires !View<C> &&
    ConvertibleTo<@\newtxt{iter_}@reference_t<iterator_t<const D>>,
      @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<C>>> &&
    Constructible<C, @\placeholder{range-common-iterator}@<const D>,
      @\placeholder{range-common-iterator}@<const D>>
operator C() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
using I = @\placeholder{range-common-iterator}@<R>;
return C(I{ranges::begin(derived())}, I{ranges::end(derived())});
\end{codeblock}
\end{itemdescr}


\rSec2[range.subranges]{Sub-ranges}

\pnum
The \tcode{subrange} class template bundles together an
iterator and a sentinel into a single object that \oldtxt{satisfies} \newtxt{models} the
\libconcept{View} concept. Additionally, it \oldtxt{satisfies} \newtxt{models} the
\libconcept{SizedRange} concept when the final template parameter is
\tcode{subrange_kind::sized}.

\rSec3[range.subrange]{\tcode{subrange}}

\indexlibrary{\idxcode{subrange}}%
\begin{codeblock}
namespace std { namespace ranges {
    template<class T>
    concept @\placeholder{pair-like}@ = // \expos
      requires(T t) {
        { tuple_size<T>::value } -> Integral;
        requires tuple_size<T>::value == 2;
        typename tuple_element_t<0, T>;
        typename tuple_element_t<1, T>;
        { get<0>(t) } -> const tuple_element_t<0, T>&;
        { get<1>(t) } -> const tuple_element_t<1, T>&;
      };

    template<class T, class U, class V>
    concept @\placeholder{pair-like-convertible-to}@ = // \expos
      !Range<T> && @\placeholder{pair-like}@<decay_t<T>> &&
      requires(T&& t) {
        { get<0>(std::forward<T>(t)) } -> ConvertibleTo<U>;
        { get<1>(std::forward<T>(t)) } -> ConvertibleTo<V>;
      };

    template<class T, class U, class V>
    concept @\placeholder{pair-like-convertible-from}@ = // \expos
      !Range<T> && Same<T, decay_t<T>> && @\placeholder{pair-like}@<T> &&
      Constructible<T, U, V>;

    template<class T>
    concept @\placeholder{iterator-sentinel-pair}@ = // \expos
      !Range<T> && Same<T, decay_t<T>> && @\placeholder{pair-like}@<T> &&
      Sentinel<tuple_element_t<1, T>, tuple_element_t<0, T>>;

    template<class T, class U>
    concept @\placeholder{not-same-as}@ = // \expos
      !Same<remove_cvref_t<T>, remove_cvref_t<U>>;

    template<Iterator I, Sentinel<I> S = I, subrange_kind K =
        @\oldtxt{\seebelow}\newtxt{SizedSentinel<S, I> ? subrange_kind::sized : subrange_kind::unsized>}@>
      requires K == subrange_kind::sized || !SizedSentinel<S, I>
    class subrange : public view_interface<subrange<I, S, K>> {
    private:
      static constexpr bool StoreSize =  // \expos
        K == subrange_kind::sized && !SizedSentinel<S, I>;
      I begin_ {}; // \expos
      S end_ {};   // \expos
      @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> size_ = 0; // \expos; only present when \tcode{StoreSize} is \tcode{true}
    public:
      using iterator = I;
      using sentinel = S;

      subrange() = default;

      constexpr subrange(I i, S s) requires !StoreSize;

      constexpr subrange(I i, S s, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n)
        requires K == subrange_kind::sized;

      @\oldtxt{template<ConvertibleTo<I> X, ConvertibleTo<S> Y, subrange_kind Z>}@
      @\oldtxt{constexpr subrange(subrange<X, Y, Z> r)}@
        @\oldtxt{requires !StoreSize || Z == subrange_kind::sized;}@

      @\oldtxt{template<ConvertibleTo<I> X, ConvertibleTo<S> Y, subrange_kind Z>}@
      @\oldtxt{constexpr subrange(subrange<X, Y, Z> r, difference_type_t<I> n)}@
        @\oldtxt{requires K == subrange_kind::sized;}@

      @\newtxt{template<\placeholdernc{not-same-as}<subrange> R>}@
        @\newtxt{requires \placeholdernc{forwarding-range}<R> \&\&}@
          @\newtxt{ConvertibleTo<iterator_t<R>, I> \&\& ConvertibleTo<sentinel_t<R>, S>}@
      @\newtxt{constexpr subrange(R\&\& r) requires !StoreSize || SizedRange<R>;}@

      @\newtxt{template<\placeholdernc{forwarding-range} R>}@
        @\newtxt{requires ConvertibleTo<iterator_t<R>, I> \&\& ConvertibleTo<sentinel_t<R>, S>}@
      @\newtxt{constexpr subrange(R\&\& r, iter_difference_t<I> n)}@
        @\newtxt{requires K == subrange_kind::sized;}@

      template<@\placeholdernc{not-same-as}@<subrange> PairLike>
        requires @\placeholdernc{pair-like-convertible-to}@<PairLike, I, S>
      constexpr subrange(PairLike&& r) requires !StoreSize;

      template<@\placeholdernc{pair-like-convertible-to}@<I, S> PairLike>
      constexpr subrange(PairLike&& r, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n)
        requires K == subrange_kind::sized;

      @\oldtxt{template<\placeholdernc{not-name-as}<subrange> R>}@
        @\oldtxt{requires Range<R> \&\& ConvertibleTo<iterator_t<R>, I> \&\& ConvertibleTo<sentinel_t<R>, S>}@
      @\oldtxt{constexpr subrange(R\& r) requires !StoreSize || SizedRange<R>;}@

      template<@\placeholdernc{not-same-as}@<subrange> PairLike>
        requires @\placeholdernc{pair-like-convertible-from}@<PairLike, const I&, const S&>
      constexpr operator PairLike() const;

      constexpr I begin() const;
      constexpr S end() const;

      constexpr bool empty() const;
      constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> size() const
        requires K == subrange_kind::sized;

      [[nodiscard]] constexpr subrange next(@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n = 1) const;
      [[nodiscard]] constexpr subrange prev(@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n = 1) const
        requires BidirectionalIterator<I>;
      constexpr subrange& advance(@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);

      @\newtxt{friend constexpr I begin(subrange r) \{ return r.begin(); \}}@
      @\newtxt{friend constexpr S end(subrange r) \{ return r.end(); \}}@
    };

    template<Iterator I, Sentinel<I> S>
    subrange(I, S, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>) ->
      subrange<I, S, subrange_kind::sized>;

    template<@\placeholder{iterator-sentinel-pair}@ P>
    subrange(P) -> subrange<tuple_element_t<0, P>, tuple_element_t<1, P>>;

    template<@\placeholder{iterator-sentinel-pair}@ P>
    subrange(P, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<tuple_element_t<0, P>>) ->
      subrange<tuple_element_t<0, P>, tuple_element_t<1, P>, subrange_kind::sized>;

    @\oldtxt{template<Iterator I, Sentinel<I> S, subrange_kind K>}@
    @\oldtxt{subrange(subrange<I, S, K>, difference_type_t<I>) ->}@
      @\oldtxt{subrange<I, S, subrange_kind::sized>;}@

    @\oldtxt{template<Range R>}@
    @\oldtxt{subrange(R\&) -> subrange<iterator_t<R>, sentinel_t<R>>;}@

    @\oldtxt{template<SizedRange R>}@
    @\oldtxt{subrange(R\&) -> subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;}@

    @\ednote{The following two deduction guides conflict per [temp.deduct.guide]/3;}@
    @\ednote{CWG will probably fix the problem.}@
    @\newtxt{template<\placeholder{forwarding-range} R>}@
    @\newtxt{subrange(R\&\&) -> subrange<iterator_t<R>, sentinel_t<R>{>};}@

    @\newtxt{template<\placeholder{forwarding-range} R>}@
      @\newtxt{requires SizedRange<R>}@
    @\newtxt{subrange(R\&\&) -> subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;}@

    @\newtxt{template<\placeholder{forwarding-range} R>}@
    @\newtxt{subrange(R\&\&, iter_difference_t<iterator_t<R>{>}) ->}@
      @\newtxt{subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;}@

    template<size_t N, class I, class S, subrange_kind K>
      requires N < 2
    constexpr auto get(const subrange<I, S, K>& r);

    @\newtxt{template<\placeholder{forwarding-range} R>}@
      @\newtxt{using safe_subrange_t = subrange<iterator_t<R>>;}@
  }

  @\newtxt{using ranges::get;}@
}
\end{codeblock}

{\color{oldclr}
\pnum
The default value for \tcode{subrange}'s third (non-type) template parameter is:
\begin{itemize}
\item If \tcode{\libconcept{SizedSentinel}<S, I>} is satisfied, \tcode{subrange_kind::sized}.
\item Otherwise, \tcode{subrange_kind::unsized}.
\end{itemize}
} %% \color{oldclr}

\rSec4[range.subrange.ctor]{\tcode{subrange} constructors}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr subrange(I i, S s) requires !StoreSize;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{begin_} with \tcode{i} and \tcode{end_} with
\tcode{s}.
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr subrange(I i, S s, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n)
  requires K == subrange_kind::sized;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\tcode{n == \newtxt{ranges::}distance(i, s)}.

\pnum
\effects Initializes \tcode{begin_} with \tcode{i}, \tcode{end_} with
\tcode{s}. If \tcode{StoreSize} is \tcode{true}, initializes \tcode{size_} with
\tcode{n}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<ConvertibleTo<I> X, ConvertibleTo<S> Y, subrange_kind Z>
constexpr subrange(subrange<X, Y, Z> r)
  requires !StoreSize || Z == subrange_kind::sized;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true},
\tcode{subrange\{r.begin(), r.end(), r.size()\}}.
\item Otherwise, \tcode{subrange\{r.begin(), r.end()\}}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<ConvertibleTo<I> X, ConvertibleTo<S> Y, subrange_kind Z>
constexpr subrange(subrange<X, Y, Z> r, difference_type_t<I> n)
  requires K == subrange_kind::sized;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{subrange\{r.begin(), r.end(), n\}}.
\end{itemdescr}
} %% \color{oldclr}

{\color{newclr}
\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{not-same-as}@<subrange> R>
  requires @\placeholdernc{forwarding-range}@<R> &&
    ConvertibleTo<iterator_t<R>, I> && ConvertibleTo<sentinel_t<R>, S>
constexpr subrange(R&& r) requires !StoreSize || SizedRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true},
\tcode{subrange\{ranges::begin(r), ranges::end(r), ranges::size(r)\}}.
\item Otherwise, \tcode{subrange\{ranges::begin(r), ranges::end(r)\}}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholder{forwarding-range}@ R>
  requires ConvertibleTo<iterator_t<R>, I> && ConvertibleTo<sentinel_t<R>, S>
constexpr subrange(R&& r, difference_type_t<I> n)
  requires K == subrange_kind::sized;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{subrange\{ranges::begin(r), ranges::end(r), n\}}.
\end{itemdescr}
} %% \color{newclr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{not-same-as}@<subrange> PairLike>
  requires @\placeholdernc{pair-like-convertible-to}@<PairLike, I, S>
constexpr subrange(PairLike&& r) requires !StoreSize;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
subrange{get<0>(std::forward<PairLike>(r)), get<1>(std::forward<PairLike>(r))}
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{pair-like-convertible-to}@<I, S> PairLike>
constexpr subrange(PairLike&& r, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n)
  requires K == subrange_kind::sized;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
subrange{get<0>(std::forward<PairLike>(r)), get<1>(std::forward<PairLike>(r)), n}
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{not-name-as}@<subrange> R>
  requires Range<R> && ConvertibleTo<iterator_t<R>, I> && ConvertibleTo<sentinel_t<R>, S>
constexpr subrange(R& r) requires !StoreSize || SizedRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true},
\tcode{subrange\{ranges::begin(r), ranges::end(r), distance(r)\}}.
\item Otherwise,
\tcode{subrange\{ranges::begin(r), ranges::end(r)\}}.
\end{itemize}
\end{itemdescr}
} %% \color{oldclr}

\rSec4[range.subrange.ops]{\tcode{subrange} operators}

\indexlibrary{\idxcode{operator \placeholder{PairLike}}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{not-same-as}@<subrange> PairLike>
  requires @\placeholdernc{pair-like-convertible-from}@<PairLike, const I&, const S&>
constexpr operator PairLike() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return PairLike(begin_, end_);}
\end{itemdescr}

\rSec4[range.subrange.accessors]{\tcode{subrange} accessors}

\indexlibrary{\idxcode{begin}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr I begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return begin_;}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr S end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return end_;}
\end{itemdescr}

\indexlibrary{\idxcode{empty}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr bool empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return begin_ == end_;}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> size() const
  requires K == subrange_kind::sized;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{if constexpr(StoreSize) return size_; else return end_ - begin_;}
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true}, \tcode{return size_;}.
\item Otherwise, \tcode{return end_ - begin_;}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{next}!\idxcode{subrange}}%
\begin{itemdecl}
[[nodiscard]] constexpr subrange next(@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n = 1) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
tmp.advance(n);
return tmp;
\end{codeblock}

\pnum
\begin{note}
If \tcode{\libconcept{ForwardIterator}<I>} is not satisfied, \tcode{next}
may invalidate \tcode{*this}.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{prev}!\idxcode{subrange}}%
\begin{itemdecl}
[[nodiscard]] constexpr subrange prev(@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n = 1) const
  requires BidirectionalIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
tmp.advance(-n);
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{advance}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr subrange& advance(@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true},
\begin{codeblock}
size_ -= n - ranges::advance(begin_, n, end_);
return *this;
\end{codeblock}
\item Otherwise,
\begin{codeblock}
ranges::advance(begin_, n, end_);
return *this;
\end{codeblock}
\end{itemize}
\end{itemdescr}

\rSec4[range.subrange.nonmember]{\tcode{subrange} non-member functions}

\indexlibrary{\idxcode{get}!\idxcode{subrange}}%
\begin{itemdecl}
template<size_t N, class I, class S, subrange_kind K>
  requires N < 2
constexpr auto get(const subrange<I, S, K>& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
if constexpr (N == 0)
  return r.begin();
else
  return r.end();
\end{codeblock}
\end{itemdescr}

\rSec1[range.adaptors]{Range adaptors}

\pnum
This section defines \term{range adaptors}, which are utilities that transform a
\libconcept{Range} into a \libconcept{View} with custom behaviors. These
adaptors can be chained to create pipelines of range transformations that
evaluate lazily as the resulting view is iterated.

\pnum
Range adaptors are declared in namespace \tcode{std::ranges::view}.

\pnum
The bitwise or operator is overloaded for the purpose of creating adaptor chain
pipelines. The adaptors also support function call syntax with equivalent
semantics.

\pnum
\begin{example}
\begin{codeblock}
vector<int> ints{0,1,2,3,4,5};
auto even = [](int i){ return 0 == i % 2; };
auto square = [](int i) { return i * i; };
for (int i : ints | view::filter(even) | view::transform(square)) {
  cout << i << ' '; // prints: 0 4 16
}
@\newtxt{assert(ranges::equal(ints | view::filter(even), view::filter(ints, even)));}@
\end{codeblock}
\end{example}

\rSec2[range.adaptor.object]{Range adaptor objects}

\pnum
A \term{range adaptor closure object} is a unary function object that accepts
a \libconcept{ViewableRange} as an argument and returns a \libconcept{View}. For
a range adaptor closure object \tcode{C} and an expression \tcode{R} such that
\tcode{decltype((R))} \oldtxt{satisfies} \newtxt{models} \libconcept{ViewableRange}, the following
expressions are equivalent and return a \libconcept{View}:

\begin{codeblock}
C(R)
R | C
\end{codeblock}

Given an additional range adaptor closure object \tcode{D},
the expression \tcode{C | D} is well-formed and produces another range adaptor
closure object such that the following two expressions are equivalent:

\begin{codeblock}
R | C | D
R | (C | D)
\end{codeblock}

\pnum
A \term{range adaptor object} is a
customization point object\cxxiref{customization.point.object}
that accepts a \libconcept{ViewableRange} as its first argument and returns a
\libconcept{View}.

\pnum
If the adaptor accepts only one argument, then it is a range adaptor closure
object.

\pnum
If the adaptor accepts more than one argument, then the following expressions
are equivalent:

\begin{codeblock}
@\placeholdernc{adaptor}@(rng, args...)
@\placeholdernc{adaptor}@(args...)(rng)
rng | @\placeholdernc{adaptor}@(args...)
\end{codeblock}

In this case, \tcode{\placeholdernc{adaptor}(args...)} is a  range adaptor
closure object.

\rSec2[range.adaptor.semiregular_wrapper]{Semiregular wrapper}

\pnum
Many of the types in this section are specified in terms of an exposition-only
helper called \tcode{\placeholder{semiregular}<T>}. This type behaves exactly
like \tcode{optional<T>} with the following exceptions:

\begin{itemize}
\item \tcode{\placeholder{semiregular}<T>} constrains its argument
with \tcode{\libconcept{CopyConstructible}<T> \newtxt{\&\& is_object_v<T>}}.

\item If \tcode{T} models \libconcept{DefaultConstructible}, the default
constructor of \tcode{\placeholder{semiregular}<T>} is equivalent to:
\begin{codeblock}
constexpr @\placeholder{semiregular}@()
  noexcept(is_nothrow_default_constructible@\newtxt{_v}@<T>@\oldtxt{::value})
  : @\placeholder{semiregular}@{in_place}
{ }
\end{codeblock}

\item If \oldtxt{the syntactic requirements of}
\tcode{\libconcept{Assignable}<T\&, const T\&>} \newtxt{is} \oldtxt{are} not
satisfied, the copy assignment operator is equivalent to:
\begin{codeblock}
@\oldtxt{constexpr}@ @\placeholder{semiregular}@& operator=(const @\placeholder{semiregular}@& that)
  noexcept(is_nothrow_copy_constructible@\newtxt{_v}@<T>@\oldtxt{::value}@)
{
  if (that) emplace(*that);
  else reset();
  return *this;
}
\end{codeblock}

\item If \oldtxt{the syntactic requirements of}
\tcode{\libconcept{Assignable}<T\&, T>} \newtxt{is} \oldtxt{are} not satisfied,
the move assignment operator is equivalent to:
\begin{codeblock}
@\oldtxt{constexpr}@ @\placeholder{semiregular}@& operator=(@\placeholder{semiregular}@&& that)
  noexcept(is_nothrow_move_constructible@\newtxt{_v}@<T>@\oldtxt{::value}@)
{
  if (that) emplace(std::move(*that));
  else reset();
  return *this;
}
\end{codeblock}
\end{itemize}

\rSec2[range.adaptor.helpers]{Helper concepts}

\pnum
Many of the types in this \oldtxt{section} \newtxt{subclause} are specified in
terms of \oldtxt{an} \newtxt{the following} exposition-only \newtxt{concepts:}
\oldtxt{Boolean variable template called }
\tcode{\oldtxt{\placeholder{simple-view}<T>}}\oldtxt{, defined as follows:}

\begin{codeblock}
template<class R>
concept @\oldtxt{\placeholdernc{\xname{simple-view}}} \newtxt{\placeholder{simple-view}}@ =
  View<R> && View<const R> &&
  Same<iterator_t<R>, iterator_t<const R>> &&
  Same<sentinel_t<R>, sentinel_t<const R>>;

@\oldtxt{template<class R>}@
  @\oldtxt{constexpr bool \placeholder{simple-view} = false;}@

@\oldtxt{template<\placeholder{\xname{simple-view}} R>}@
  @\oldtxt{constexpr bool \placeholder{simple-view}<R> = true;}@

@\newtxt{template<InputIterator I>}@
@\newtxt{concept \placeholder{has-arrow} = is_pointer_v<I> || requires(I i) \{ i.operator->(); \};}@
\end{codeblock}

\rSec2[range.adaptors.all]{\tcode{view::all}}

\pnum
\oldtxt{The purpose of} \tcode{view::all} \oldtxt{is to} return\newtxt{s} a
\libconcept{View} that includes all elements of \oldtxt{the} \newtxt{its}
\libconcept{Range} \newtxt{argument} \oldtxt{passed in}.

\pnum
The name \tcode{view::all} denotes a range adaptor
object\iref{range.adaptor.object}. The expression \tcode{view::all(E)} for
some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item \tcode{\placeholdernc{DECAY_COPY}(E)} if the decayed type of \tcode{E}
\oldtxt{satisfies the concept} \newtxt{models} \libconcept{View}.

\item \newtxt{Otherwise, \tcode{\placeholder{ref-view}\{E\}} if that
expression is well-formed, where \tcode{\placeholder{ref-view}}
is the exposition-only \libconcept{View} specified below.}

\item \newtxt{Otherwise,} \tcode{subrange\{E\}} if \newtxt{that expression is
well-formed.} \oldtxt{\tcode{E} is an lvalue and has a type that satisfies
concept \libconcept{Range}.}

\item Otherwise, \tcode{view::all(E)} is ill-formed.
\end{itemize}

\begin{note}
Whenever \tcode{view::all(E)} is a valid expression, it is a prvalue
whose type \oldtxt{satisfies} \newtxt{models} \libconcept{View}.
\end{note}

{\color{newclr}
\rSec3[range.view.ref]{\placeholder{ref-view}}

\begin{codeblock}
namespace std::ranges {
  template<Range Rng>
    requires std::is_object_v<Rng> && !View<Rng>
  class @\placeholder{ref_view}@ : public view_interface<@\placeholder{ref_view}@<Rng>> {
  private:
    Rng* rng_ = nullptr; // \expos
  public:
    constexpr @\placeholdernc{ref_view}@() noexcept = default;
    constexpr @\placeholdernc{ref_view}@(Rng& rng) noexcept;

    constexpr Rng& base() const;

    constexpr iterator_t<Rng> begin() const
      noexcept(noexcept(ranges::begin(*rng_)));
    constexpr sentinel_t<Rng> end() const
      noexcept(noexcept(ranges::end(*rng_)));

    constexpr bool empty() const
      noexcept(noexcept(ranges::empty(*rng_)))
      requires requires { ranges::empty(*rng_); };

    constexpr auto size() const
      noexcept(noexcept(ranges::size(*rng_)))
      requires SizedRange<Rng>;

    constexpr auto data() const
      noexcept(noexcept(ranges::data(*rng_)))
      requires ContiguousRange<Rng>;

    friend constexpr iterator_t<Rng> begin(@\placeholder{ref_view}@&& r)
      noexcept(noexcept(r.begin()));
    friend constexpr sentinel_t<Rng> end(@\placeholder{ref_view}@&& r)
      noexcept(noexcept(r.end()));
  };
}
\end{codeblock}

\rSec4[range.view.ref.ops]{\placeholder{ref-view} operations}

\indexlibrary{\idxcode{\placeholder{ref-view}}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr @\placeholdernc{ref_view}@(Rng& rng) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{rng_} with \tcode{addressof(rng)}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr Rng& base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return *rng_;}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr iterator_t<Rng> begin() const
  noexcept(noexcept(ranges::begin(*rng_)));
friend constexpr iterator_t<Rng> begin(@\placeholder{ref_view}@&& r)
  noexcept(noexcept(r.begin()));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(*rng_);}
or \tcode{return r.begin();}, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr sentinel_t<Rng> end() const
  noexcept(noexcept(ranges::end(*rng_)));
friend constexpr sentinel_t<Rng> end(@\placeholder{ref_view}@&& r)
  noexcept(noexcept(r.end()));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::end(*rng_);}
or \tcode{return r.end();}, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{empty}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr bool empty() const
  noexcept(noexcept(ranges::empty(*rng_)))
  requires requires { ranges::empty(*rng_); };
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::empty(*rng_);}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr auto size() const
  noexcept(noexcept(ranges::size(*rng_)))
  requires SizedRange<Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::size(*rng_);}
\end{itemdescr}

\indexlibrary{\idxcode{data}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr auto data() const
  noexcept(noexcept(ranges::data(*rng_)))
  requires ContiguousRange<Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::data(*rng_);}
\end{itemdescr}
} %% \color{newclr}

\rSec2[range.adaptors.filter_view]{Class template \tcode{filter_view}}

\pnum
\oldtxt{The purpose of} \tcode{filter_view} \oldtxt{is to} present\newtxt{s} a
\oldtxt{view}\newtxt{\libconcept{View}} of an underlying sequence without the
elements that fail to satisfy a predicate.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4, 5, 6 };
filter_view evens{is, [](int i) { return 0 == i % 2; }};
for (int i : evens)
  cout << i << ' '; // prints: 0 2 4 6
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<InputRange R, IndirectUnaryPredicate<iterator_t<R>> Pred>
    requires View<R> @\newtxt{\&\& is_object_v<Pred>}@
  class filter_view : public view_interface<filter_view<R, Pred>> {
  private:
    R base_ {};                              // \expos
    @\placeholder{semiregular}@<Pred> pred_;                 // \expos

    class iterator;                          // \expos
    class sentinel;                          // \expos

  public:
    filter_view() = default;
    constexpr filter_view(R base, Pred pred);
    template<InputRange O>
      requires ViewableRange<O> && Constructible<R, all_view<O>>
    constexpr filter_view(O&& o, Pred pred);

    constexpr R base() const;

    constexpr iterator begin();
    constexpr sentinel end();
    constexpr iterator end() requires CommonRange<R>;
  };

  template<@\oldtxt{InputRange}\newtxt{class}@ R, @\oldtxt{CopyConstructible}\newtxt{class}@ Pred>
    @\oldtxt{requires IndirectUnaryPredicate<Pred, iterator_t<R>> \&\& ViewableRange<R>}@
  filter_view(R&&, Pred) -> filter_view<all_view<R>, Pred>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.filter_view.ops]{\tcode{filter_view} operations}
\rSec4[range.adaptors.filter_view.ctor]{\tcode{filter_view} constructors}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr filter_view(R base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and initializes
\tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
template<InputRange O>
  requires ViewableRange<O> && Constructible<R, all_view<O>>
constexpr filter_view(O&& o, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}
and initializes \tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\rSec4[range.adaptors.filter_view.conv]{\tcode{filter_view} conversion}

\indexlibrary{\idxcode{base}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} base_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.filter_view.begin]{\tcode{filter_view} range begin}

\indexlibrary{\idxcode{begin}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr iterator begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\effects Equivalent to:} \newtxt{\returns}
\tcode{return \{*this, ranges::find_if(base_, ref(*pred_))\};}

\pnum
\remarks In order to provide the amortized constant time complexity required by
the \libconcept{Range} concept, this function caches the result within the
\tcode{filter_view} for use on subsequent calls.
\end{itemdescr}

\rSec4[range.adaptors.filter_view.end]{\tcode{filter_view} range end}

\indexlibrary{\idxcode{end}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr sentinel end();
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} sentinel\{*this\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\begin{itemdecl}
constexpr iterator end() requires CommonRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} iterator\{*this, ranges::end(base_)\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec3[range.adaptors.filter_view.iterator]{Class template \tcode{filter_view::iterator}}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view}}%
\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class R, class Pred>
  class filter_view<R, Pred>::iterator {
  private:
    iterator_t<R> current_ {};           // \expos
    filter_view* parent_ = nullptr;      // \expos
  public:
    using iterator_category = @\seebelownc@;
    @\newtxt{using iterator_concept  = \seebelownc;}@
    using value_type        = @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<R>>;
    using difference_type   = @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>>;

    iterator() = default;
    constexpr iterator(filter_view& parent, iterator_t<R> current);

    constexpr iterator_t<R> base() const;
    constexpr @\newtxt{iter_}@reference_t<iterator_t<R>> operator*() const;
    @\newtxt{constexpr iterator_t<R> operator->() const}@
      @\newtxt{requires \placeholder{has-arrow}<iterator_t<R>>}@;

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires ForwardRange<R>;

    constexpr iterator& operator--() requires BidirectionalRange<R>;
    constexpr iterator operator--(int) requires BidirectionalRange<R>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<R>>;
    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<R>>;

    friend constexpr @\newtxt{iter_}@rvalue_reference_t<iterator_t<R>> iter_move(const iterator& i)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(i.current_))}@);
    friend constexpr void iter_swap(const iterator& x, const iterator& y)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.current_, y.current_))}@)
      requires IndirectlySwappable<iterator_t<R>>;
  };
}@\oldtxt{\}}@
\end{codeblock}

\pnum
\oldtxt{The type }\tcode{\oldtxt{filter_view<R>::}iterator::iterator_category}
is defined as follows:
\begin{itemize}
\item \newtxt{Let \tcode{C} denote the type
}\tcode{\newtxt{iterator_traits<iterator_t<R>>::iterator_category}}\newtxt{.}

\item If \oldtxt{\tcode{R} satisfies \tcode{BidirectionalRange<R>}}
\newtxt{\tcode{C} models }\tcode{\newtxt{DerivedFrom<bidirectional_iterator_tag>}},
then \tcode{iterator_category} \newtxt{denotes} \oldtxt{is an alias for}
\tcode{\oldtxt{ranges::}bidirectional_iterator_tag}.

\item \newtxt{Otherwise,} if \oldtxt{\tcode{R} \oldtxt{satisfies}
\tcode{ForwardRange<R>}}
\newtxt{\tcode{C} models }\tcode{\newtxt{DerivedFrom<forward_iterator_tag>}},
then \tcode{iterator_category} \newtxt{denotes} \oldtxt{is an alias for}
\tcode{\oldtxt{ranges::}forward_iterator_tag}.

\item Otherwise, \tcode{iterator_category} \newtxt{denotes}
\oldtxt{is an alias for} \tcode{\oldtxt{ranges::}input_iterator_tag}.
\end{itemize}

{\color{newclr}
\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{R} models \libconcept{BidirectionalRange}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{R} models \libconcept{ForwardRange}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}
} %% \color{newclr}

\rSec4[range.adaptors.filter_view.iterator.ops]{\tcode{filter_view::iterator} operations}
\rSec5[range.adaptors.filter_view.iterator.ctor]{\tcode{filter_view::iterator} constructors}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator(filter_view& parent, iterator_t<R> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{current} and \tcode{parent_}
with \tcode{\oldtxt{\&}\newtxt{addressof(}parent\newtxt{)}}.
\end{itemdescr}

\rSec5[range.adaptors.filter_view.iterator.conv]{\tcode{filter_view::iterator} conversion}

\indexlibrary{\idxcode{base}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator_t<R> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec5[range.adaptors.filter_view.iterator.star]{\tcode{filter_view::iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr @\newtxt{iter_}@reference_t<iterator_t<R>> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} *current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

{\color{newclr}
\rSec5[range.adaptors.filter_view.iterator.arrow]{\tcode{filter_view::iterator::operator->}}

\indexlibrary{\idxcode{operator->}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator_t<R> operator->() const
  requires @\placeholder{has-arrow}@<iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return current_;}
\end{itemdescr}
} %% \color{newclr}

\rSec5[range.adaptors.filter_view.iterator.inc]{\tcode{filter_view::iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ = @\newtxt{ranges::}@find_if(++current_, ranges::end(parent_->base_), ref(*parent_->pred_));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{\oldtxt{(void)}++*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator operator++(int) requires ForwardRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.filter_view.iterator.dec]{\tcode{filter_view::iterator::operator\dcr}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator--() requires BidirectionalRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
do
  --current_;
while (invoke(*parent_->pred_, *current_));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator operator--(int) requires BidirectionalRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.filter_view.iterator.comp]{\tcode{filter_view::iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.current_ == y.current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.filter_view.iterator.nonmember]{\tcode{filter_view::iterator} non-member functions}

\indexlibrary{\idxcode{iter_move}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr @\newtxt{iter_}@rvalue_reference_t<iterator_t<R>> iter_move(const iterator& i)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(i.current_))}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} ranges::iter_move(i.current_)\newtxt{;}}\oldtxt{.}

\pnum
\oldtxt{\remarks The expression in \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_move(i.current_))}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr void iter_swap(const iterator& x, const iterator& y)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.current_, y.current_))}@)
  requires IndirectlySwappable<iterator_t<R>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(x.current_, y.current_)}.

\pnum
\oldtxt{\remarks The expression in \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_swap(x.current_, y.current_))}@
\end{codeblock}
\end{itemdescr}

\rSec3[range.adaptors.filter_view.sentinel]{Class template \tcode{filter_view::sentinel}}

\indexlibrary{\idxcode{sentinel}!\idxcode{filter_view}}%
\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class R, class Pred>
  class filter_view<R, Pred>::sentinel {
  private:
    sentinel_t<R> end_ {}; // \expos
  public:
    sentinel() = default;
    explicit constexpr sentinel(filter_view& parent);

    constexpr sentinel_t<R> base() const;

    friend constexpr bool operator==(const iterator& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator& y);
    friend constexpr bool operator!=(const iterator& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator& y);
  };
}@\oldtxt{\}}@
\end{codeblock}

\rSec4[range.adaptors.filter_view.sentinel.ctor]{\tcode{filter_view::sentinel} constructors}

\indexlibrary{\idxcode{sentinel}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
explicit constexpr sentinel(filter_view& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{ranges::end(parent)}.
\end{itemdescr}

\rSec4[range.adaptors.filter_view.sentinel.conv]{\tcode{filter_view::sentinel} conversion}

\indexlibrary{\idxcode{base}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
constexpr sentinel_t<R> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.filter_view.sentinel.comp]{\tcode{filter_view::sentinel} comparison}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.current_ == y.end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y == x\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(y == x)\newtxt{;}}\oldtxt{.}
\end{itemdescr}


\rSec2[range.adaptors.filter]{\tcode{view::filter}}

\pnum
The name \tcode{view::filter} denotes a range adaptor
object\iref{range.adaptor.object}. \oldtxt{Let \tcode{E} and \tcode{P} be expressions
such that types \tcode{T} and \tcode{U} are \tcode{decltype((E))} and
\tcode{decltype((P))} respectively. Then} The expression
\tcode{view::filter(E, P)} \newtxt{for subexpressions \tcode{E} and \tcode{P}}
is expression-equivalent to \tcode{filter_view\{E, P\}}\newtxt{.} \oldtxt{if
}\tcode{\oldtxt{InputRange<T> \&\& IndirectUnaryPredicate<decay_t<U>, iterator_t<T>{>}}}\oldtxt{
is satisfied. Otherwise, \tcode{view::filter(E, P)} is ill-formed.}


\rSec2[range.adaptors.transform_view]{Class template \tcode{transform_view}}

\pnum
\oldtxt{The purpose of} \tcode{transform_view} \oldtxt{is to} present\newtxt{s}
a \oldtxt{view}\newtxt{\libconcept{View}} of an underlying sequence after
applying a transformation function to each element.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4 };
transform_view squares{is, [](int i) { return i * i; }};
for (int i : squares)
  cout << i << ' '; // prints: 0 1 4 9 16
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<InputRange R, CopyConstructible F>
    requires View<R> && @\newtxt{is_object_v<F> \&\&}@ Invocable<F&, @\newtxt{iter_}@reference_t<iterator_t<R>>>
  class transform_view : public view_interface<transform_view<R, F>> {
  private:
    R base_ {};          // \expos
    @\placeholder{semiregular}@<F> fun_; // \expos
    template<bool Const>
      struct iterator;   // \expos
    template<bool Const>
      struct sentinel;   // \expos
  public:
    transform_view() = default;
    constexpr transform_view(R base, F fun);
    template<InputRange O>
      requires ViewableRange<O> && Constructible<R, all_view<O>>
    constexpr transform_view(O&& o, F fun);

    constexpr R base() const;

    constexpr auto begin();
    constexpr auto begin() const requires Range<const R> &&
      Invocable<const F&, @\newtxt{iter_}@reference_t<iterator_t<const R>>>;

    constexpr auto end();
    constexpr auto end() const requires Range<const R> &&
      Invocable<const F&, @\newtxt{iter_}@reference_t<iterator_t<const R>>>;
    constexpr auto end() requires CommonRange<R>;
    constexpr auto end() const requires CommonRange<const R> &&
      Invocable<const F&, @\newtxt{iter_}@reference_t<iterator_t<const R>>>;

    constexpr auto size() requires SizedRange<R>;
    constexpr auto size() const requires SizedRange<const R>;
  };

  template<class R, class F>
  transform_view(R&& r, F fun) -> transform_view<all_view<R>, F>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.transform_view.ops]{\tcode{transform_view} operations}
\rSec4[range.adaptors.transform_view.ctor]{\tcode{transform_view} constructors}

\indexlibrary{\idxcode{transform_view}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr transform_view(R base, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and initializes
\tcode{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\indexlibrary{\idxcode{transform_view}!\idxcode{transform_view}}%
\begin{itemdecl}
template<InputRange O>
  requires ViewableRange<O> && Constructible<R, all_view<O>>
constexpr transform_view(O&& o, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}
and initializes \tcode{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\rSec4[range.adaptors.transform_view.conv]{\tcode{transform_view} conversion}

\indexlibrary{\idxcode{base}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} base_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.transform_view.begin]{\tcode{transform_view} range begin}

\indexlibrary{\idxcode{begin}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr auto begin();
constexpr auto begin() const requires Range<const R> &&
  Invocable<const F&, @\newtxt{iter_}@reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return iterator<false>{*this, ranges::begin(base_)};
\end{codeblock}
  and
\begin{codeblock}
return iterator<true>{*this, ranges::begin(base_)};
\end{codeblock}
for the first and second overload, respectively.
\end{itemdescr}

\rSec4[range.adaptors.transform_view.end]{\tcode{transform_view} range end}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr auto end();
constexpr auto end() const requires Range<const R> &&
  Invocable<const F&, @\newtxt{iter_}@reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return sentinel<false>{ranges::end(base_)};
\end{codeblock}
  and
\begin{codeblock}
return sentinel<true>{ranges::end(base_)};
\end{codeblock}
for the first and second overload, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr auto end() requires CommonRange<R>;
constexpr auto end() const requires CommonRange<const R> &&
  Invocable<const F&, @\newtxt{iter_}@reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return iterator<false>{*this, ranges::end(base_)};
\end{codeblock}
  and
\begin{codeblock}
return iterator<true>{*this, ranges::end(base_)};
\end{codeblock}
for the first and second overload, respectively.
\end{itemdescr}

\rSec4[range.adaptors.transform_view.size]{\tcode{transform_view} range size}

\indexlibrary{\idxcode{size}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr auto size() requires SizedRange<R>;
constexpr auto size() const requires SizedRange<const R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} ranges::size(base_)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec3[range.adaptors.transform_view.iterator]{Class template \tcode{transform_view::iterator}}

\pnum
\oldtxt{\tcode{transform_view<R, F>::iterator} is an exposition-only type.}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class R, class F>
  template<bool Const>
  class transform_view<R, F>::iterator { // \expos
  private:
    using Parent =                 // \expos
      conditional_t<Const, const transform_view, transform_view>;
    using Base   = conditional_t<  // \expos
    iterator_t<Base> current_ {};  // \expos
    Parent* parent_ = nullptr;     // \expos
  public:
    using iterator_category = @\newtxt{\seebelownc;}@
      @\oldtxt{iterator_category_t<iterator_t<Base>>;}@
    @\newtxt{using iterator_concept  = \seebelownc;}@
    using value_type        =
      @\newtxt{remove_cvref_t<invoke_result_t<F\&, iter_reference_t<iterator_t<Base>>>>;}@
      @\oldtxt{remove_const_t<remove_reference_t<invoke_result_t<F\&, reference_t<iterator_t<Base>>>>>;}@
    using difference_type   = @\newtxt{iter_difference_t}\oldtxt{difference_type_t}@<iterator_t<Base>>;

    iterator() = default;
    constexpr iterator(Parent& parent, iterator_t<Base> current);
    constexpr iterator(iterator<!Const> i)
      requires Const && ConvertibleTo<iterator_t<R>, iterator_t<Base>>;

    constexpr iterator_t<Base> base() const;
    constexpr decltype(auto) operator*() const;

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires ForwardRange<Base>;

    constexpr iterator& operator--() requires BidirectionalRange<Base>;
    constexpr iterator operator--(int) requires BidirectionalRange<Base>;

    constexpr iterator& operator+=(difference_type n)
      requires RandomAccessRange<Base>;
    constexpr iterator& operator-=(difference_type n)
      requires RandomAccessRange<Base>;
    constexpr decltype(auto) operator[](difference_type n) const
      requires RandomAccessRange<Base>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<Base>>;
    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<Base>>;

    friend constexpr bool operator<(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;
    friend constexpr bool operator>(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;
    friend constexpr bool operator<=(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;
    friend constexpr bool operator>=(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;

    friend constexpr iterator operator+(iterator i, difference_type n)
      requires RandomAccessRange<Base>;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires RandomAccessRange<Base>;

    friend constexpr iterator operator-(iterator i, difference_type n)
      requires RandomAccessRange<Base>;
    friend constexpr difference_type operator-(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;

    friend constexpr decltype(auto) iter_move(const iterator& i)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(invoke(*i.parent_->fun_, *i.current_))}@);
    friend constexpr void iter_swap(const iterator& x, const iterator& y)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.current_, y.current_))}@)
      requires IndirectlySwappable<iterator_t<Base>>;
  };
}@\oldtxt{\}}@
\end{codeblock}

{\color{newclr}
\pnum
Let \tcode{C} denote the type
\tcode{iterator_traits<iterator_t<Base>>::iterator_category}. If \tcode{C}
models \tcode{\libconcept{DerivedFrom}<contiguous_iterator_tag>}, then
\tcode{iterator_category} denotes \tcode{random_access_iterator_tag}; otherwise,
\tcode{iterator_category} denotes \tcode{C}.

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{R} models \libconcept{RandomAccessRange}, then
\tcode{iterator_concept} denotes \tcode{random_access_iterator_tag}.

\item Otherwise, if \tcode{R} models \libconcept{BidirectionalRange}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{R} models \libconcept{ForwardRange}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}
} %% \color{newclr}

\rSec4[range.adaptors.transform_view.iterator.ops]{\tcode{transform_view::iterator} operations}
\rSec5[range.adaptors.transform_view.iterator.ctor]{\tcode{transform_view::iterator} constructors}

\indexlibrary{\idxcode{iterator}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator(Parent& parent, iterator_t<Base> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{current} and
initializes \tcode{parent_} with \tcode{\oldtxt{\&}\newtxt{addressof(}parent\newtxt{)}}.
\end{itemdescr}

\indexlibrary{\idxcode{iterator}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
constexpr iterator(iterator<!Const> i)
  requires Const && ConvertibleTo<iterator_t<R>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{i.parent_} and \tcode{current_}
with \tcode{i.current_}.
\end{itemdescr}

\rSec5[range.adaptors.transform_view.iterator.conv]{\tcode{transform_view::iterator} conversion}

\indexlibrary{\idxcode{base}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec5[range.adaptors.transform_view.iterator.star]{\tcode{transform_view::iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr decltype(auto) operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} invoke(*parent_->fun_, *current_)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec5[range.adaptors.transform_view.iterator.inc]{\tcode{transform_view::iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
++current_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
++current_;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator operator++(int) requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.transform_view.iterator.dec]{\tcode{transform_view::iterator::operator\dcr}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator--() requires BidirectionalRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
--current_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator operator--(int) requires BidirectionalRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.transform_view.iterator.adv]{\tcode{transform_view::iterator} advance}

\indexlibrary{\idxcode{operator+=}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator+=(difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ += n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator-=(difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ -= n;
return *this;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.transform_view.iterator.idx]{\tcode{transform_view::iterator} index}

\indexlibrary{\idxcode{operator[]}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr decltype(auto) operator[](difference_type n) const
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return invoke(*parent_->fun_, current_[n]);}
\end{itemdescr}

\rSec4[range.adaptors.transform_view.iterator.comp]{\tcode{transform_view::iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.current_ == y.current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator<(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.current_ < y.current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator>(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y < x\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator<=(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(y < x)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator>=(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x < y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.transform_view.iterator.nonmember]{\tcode{transform_view::iterator} non-member functions}

\indexlibrary{\idxcode{operator+}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator+(iterator i, difference_type n)
  requires RandomAccessRange<Base>;
friend constexpr iterator operator+(difference_type n, iterator i)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} iterator\{*i.parent_, i.current_ + n\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr iterator operator-(iterator i, difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} iterator\{*i.parent_, i.current_ - n\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr difference_type operator-(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.current_ - y.current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{iter_move}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr decltype(auto) iter_move(const iterator& i)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(invoke(*i.parent_->fun_, *i.current_))}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If the expression \tcode{*i} is an lvalue\oldtxt{, then}:
\tcode{\newtxt{return} std::move(*i)\newtxt{;}}
\item Otherwise: \tcode{\newtxt{return} *i\newtxt{;}}
\end{itemize}

\pnum
\oldtxt{\remarks The expression in the \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(invoke(*i.parent_->fun_, *i.current_))}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr void iter_swap(const iterator& x, const iterator& y)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.current_, y.current_))}@)
  requires IndirectlySwappable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(x.current_, y.current_)}.

\pnum
\oldtxt{\remarks The expression in the \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_swap(x.current_, y.current_))}@
\end{codeblock}
\end{itemdescr}


\rSec3[range.adaptors.transform_view.sentinel]{Class template \tcode{transform_view::sentinel}}

\pnum
\oldtxt{\tcode{transform_view<R, F>::sentinel} is an exposition-only type.}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class R, class F>
  template<bool Const>
  class transform_view<R, F>::sentinel { // \expos
  private:
    using Parent =                                 // \expos
      conditional_t<Const, const transform_view, transform_view>;
    using Base = conditional_t<Const, const R, R>; // \expos
    sentinel_t<Base> end_ {};                      // \expos
  public:
    sentinel() = default;
    explicit constexpr sentinel(sentinel_t<Base> end);
    constexpr sentinel(sentinel<!Const> i)
      requires Const && ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>;

    constexpr sentinel_t<Base> base() const;

    friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
    friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);

    friend constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<Base>>
      operator-(const iterator<Const>& x, const sentinel& y)
        requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
    friend constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<Base>>
      operator-(const sentinel& y, const iterator<Const>& x)
        requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
  };
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.transform_view.sentinel.ctor]{\tcode{transform_view::sentinel constructors}}

\indexlibrary{\idxcode{sentinel}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
explicit constexpr sentinel(sentinel_t<Base> end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{end}.
\end{itemdescr}

\indexlibrary{\idxcode{sentinel}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
constexpr sentinel(sentinel<!Const> i)
  requires Const && ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{i.end_}.
\end{itemdescr}

\rSec3[range.adaptors.transform_view.sentinel.conv]{\tcode{transform_view::sentinel conversion}}

\indexlibrary{\idxcode{base}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
constexpr sentinel_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec3[range.adaptors.transform_view.sentinel.comp]{\tcode{transform_view::sentinel comparison}}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.current_ == y.end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y == x\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(y == x)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec3[range.adaptors.transform_view.sentinel.nonmember]{\tcode{transform_view::sentinel} non-member functions}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<Base>>
operator-(const iterator<Const>& x, const sentinel& y)
  requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.current_ - y.end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<Base>>
operator-(const sentinel& y, const iterator<Const>& x)
  requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.end_ - y.current_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec2[range.adaptors.transform]{\tcode{view::transform}}

\pnum
The name \tcode{view::transform} denotes a range adaptor
object\iref{range.adaptor.object}. \oldtxt{Let \tcode{E} and \tcode{F} be expressions such
that types \tcode{T} and \tcode{U} are \tcode{decltype((E))} and \tcode{decltype((F))}
respectively. Then} The expression \tcode{view::transform(E, F)} \newtxt{for
subexpressions \tcode{E} and \tcode{F}} is expression-equivalent to
\tcode{transform_view\{E, F\}}\newtxt{.} \oldtxt{if
}\tcode{\oldtxt{InputRange<T> \&\& CopyConstructible<decay_t<U>{>} \&\&
Invocable<decay_t<U>\&, reference_t<iterator_t<T>>>}}\oldtxt{is satisfied.}
\oldtxt{Otherwise, \tcode{view::transform(E, F)} is ill-formed.}


\rSec2[range.adaptors.iota_view]{Class template \tcode{iota_view}}

\pnum
\oldtxt{The purpose of} \tcode{iota_view} \oldtxt{is to} generate\newtxt{s} a
sequence of elements by repeatedly incrementing an initial value.

\pnum
\begin{example}
\begin{codeblock}
@\oldtxt{iota_view indices\{1, 10\};}@
for (int i : @\newtxt{iota_view\{1, 10\}}@ @\oldtxt{indices}@)
  cout << i << ' '; // prints: 1 2 3 4 5 6 7 8 9
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class I>
  concept @\placeholder{Decrementable}@ = // \expos
    @\seebelownc@;
  template<class I>
  concept @\placeholder{Advanceable}@ = // \expos
    @\seebelownc@;

  template<WeaklyIncrementable I, @\oldtxt{class}\newtxt{Semiregular}@ Bound = unreachable>
    requires @\placeholdernc{weakly-equality-comparable-with}@<I, Bound>
  class iota_view : public view_interface<iota_view<I, Bound>> {
  private:
    I value_ {};     // \expos
    Bound bound_ {}; // \expos
    struct iterator; @\newtxt{// \expos}@
    struct sentinel; @\newtxt{// \expos}@
  public:
    iota_view() = default;
    constexpr explicit iota_view(I value);
    constexpr iota_view(I value, Bound bound); // \seebelow

    constexpr iterator begin() const;
    constexpr sentinel end() const;
    constexpr iterator end() const requires Same<I, Bound>;

    constexpr auto size() const requires @\seebelownc@;
  };

  @\oldtxt{template<WeaklyIncrementable I>}@
  @\oldtxt{explicit iota_view(I) -> iota_view<I>;}@

  template<@\oldtxt{WeaklyIncrementable}\newtxt{class}@ I, @\oldtxt{Semiregular}\newtxt{class}@ Bound>
    requires
      (!Integral<I> || !Integral<Bound> || is_signed_v<I> == is_signed_v<Bound>)
  iota_view(I, Bound) -> iota_view<I, Bound>;
}@\oldtxt{\}}@
\end{codeblock}

\pnum
The exposition-only \tcode{\placeholder{Decrementable}} concept is equivalent to:
\begin{itemdecl}
template<class I>
concept @\placeholder{Decrementable}@ =
  Incrementable<I> && requires(I i) {
    { --i } -> Same<I>&;
    i--; requires Same<I, decltype(i--)>;
  };
\end{itemdecl}

\begin{itemdescr}
\pnum
When an object is in the domain of both pre- and post-decrement,
the object is said to be \term{Decrementable}.

\pnum
Let \tcode{a} and \tcode{b} be incrementable and decrementable objects of type
\tcode{I}. \newtxt{\tcode{I} models}
\tcode{\placeholdernc{Decrementable}\oldtxt{<I>}} \oldtxt{is satisfied} only if
\begin{itemize}
\item \tcode{addressof(--a) == addressof(a)}.
\item If \tcode{bool(a == b)} then \tcode{bool(a-- == b)}.
\item If \tcode{bool(a == b)} then \tcode{bool((a--, a) == --b)}.
\item If \tcode{bool(a == b)} then \tcode{bool(--(++a) == b)} and
\tcode{bool(++(--a) == b)}.
\end{itemize}
\end{itemdescr}

\pnum
The exposition-only \tcode{\placeholder{Advanceable}} concept is equivalent to:
\begin{itemdecl}
template<class I>
concept @\placeholder{Advanceable}@ =
  @\placeholdernc{Decrementable}@<I> && StrictTotallyOrdered<I> &&
  requires { typename @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>; } &&
  requires(I i, const I j, const @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n) {
    { i += n } -> Same<I>&;
    { i -= n } -> Same<I>&;
    j + n; requires Same<I, decltype(j + n)>;
    n + j; requires Same<I, decltype(n + j)>;
    j - n; requires Same<I, decltype(j - n)>;
    j - j; requires Same<@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>, decltype(j - j)>;
  };
\end{itemdecl}

Let \tcode{a} and \tcode{b} be objects of type \tcode{I} such that \tcode{b} is
reachable from \tcode{a}. Let $M$ be the smallest number of applications
of \tcode{++a} necessary to make \tcode{bool(a == b)} be \tcode{true}. Let
\tcode{n}, \tcode{zero}, and \tcode{one} be objects of type
\tcode{\newtxt{iter_}difference\oldtxt{_type}_t<I>}
initialized with $M$, \tcode{0}, and \tcode{1}, respectively. Then if
$M$ is representable by \tcode{\newtxt{iter_}difference\oldtxt{_type}_t<I>},
\newtxt{\tcode{I} models}
\tcode{\placeholdernc{Advanceable}\oldtxt{<I>}}\oldtxt{ is satisfied} only if:
\begin{itemize}
\item \tcode{(a += n)} is equal to \tcode{b}.
\item \tcode{addressof(a += n)} is equal to \tcode{addressof(a)}.
\item \tcode{(a + n)} is equal to \tcode{(a += n)}.
\item For any two positive integers \tcode{x} and \tcode{y}, if
\tcode{a + (x + y)} is valid, then \tcode{a + (x + y)} is equal to
\tcode{(a + x) + y}.
\item \tcode{a + zero} is equal to \tcode{a}.
\item If \tcode{(a + (n - one))} is valid, then \tcode{a + n} is equal to
\tcode{++(a + (n - one))}.
\item \tcode{(b += -n)} is equal to \tcode{a}.
\item \tcode{(b -= n)} is equal to \tcode{a}.
\item \tcode{addressof(b -= n)} is equal to \tcode{addressof(b)}.
\item \tcode{(b - n)} is equal to \tcode{(b -= n)}.
\item \tcode{b - a} is equal to \tcode{n}.
\item \tcode{a - b} is equal to \tcode{-n}.
\item \tcode{a <= b}.
\end{itemize}

\rSec3[range.adaptors.iota_view.ops]{\tcode{iota_view} operations}
\rSec4[range.adaptors.iota_view.ctor]{\tcode{iota_view} constructors}

\indexlibrary{\idxcode{iota_view}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr explicit iota_view(I value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\newtxt{\tcode{Bound} denotes \tcode{unreachable} or }
\tcode{Bound\{\}} is reachable from \tcode{value}.

\pnum
\effects Initializes \tcode{value_} with \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{iota_view}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr iota_view(I value, Bound bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires} \newtxt{\expects}
\newtxt{\tcode{Bound} denotes \tcode{unreachable} or }
\tcode{bound} is reachable from \tcode{value}.

\pnum
\effects Initializes \tcode{value_} with \tcode{value} and \tcode{bound_} with
\tcode{bound}.

\pnum
\remarks This constructor does not contribute a function template to the overload
set used when resolving a placeholder for a deduced class
type\cxxiref{over.match.class.deduct}.
\end{itemdescr}

\rSec4[range.adaptors.iota_view.begin]{\tcode{iota_view} range begin}

\indexlibrary{\idxcode{begin}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr iterator begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} iterator\{value_\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.iota_view.end]{\tcode{iota_view} range end}

\indexlibrary{\idxcode{end}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr sentinel end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} sentinel\{bound_\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr iterator end() const requires Same<I, Bound>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} iterator\{bound_\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.iota_view.size]{\tcode{iota_view} range size}

\indexlibrary{\idxcode{size}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr auto size() const requires @\oldtxt{\seebelow}@
  @\newtxt{(Same<I, Bound> \&\& \placeholdernc{Advanceable}<I>) ||}@
  @\newtxt{(Integral<I> \&\& Integral<Bound>) ||}@
  @\newtxt{SizedSentinel<Bound, I>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} bound_ - value_\newtxt{;}}

\pnum
\oldtxt{\remarks The expression in the \tcode{requires} clause is equivalent to:}
\begin{codeblock}
@\oldtxt{(Same<I, Bound> \&\& \placeholdernc{Advanceable}<I>) ||}@
@\oldtxt{(Integral<I> \&\& Integral<Bound>) ||}@
@\oldtxt{SizedSentinel<Bound, I>}@
\end{codeblock}
\end{itemdescr}

\rSec3[range.adaptors.iota_view.iterator]{Class \tcode{iota_view::iterator}}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class I, class Bound>
  struct iota_view<I, Bound>::iterator {
  private:
    I value_ {}; // \expos
  public:
    using iterator_category = @\seebelownc@;
    using value_type = I;
    using difference_type = @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>;

    iterator() = default;
    explicit constexpr iterator(I value);

    constexpr I operator*() const noexcept(is_nothrow_copy_constructible_v<I>);

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires Incrementable<I>;

    constexpr iterator& operator--() requires @\placeholdernc{Decrementable}@<I>;
    constexpr iterator operator--(int) requires @\placeholdernc{Decrementable}@<I>;

    constexpr iterator& operator+=(difference_type n)
      requires @\placeholdernc{Advanceable}@<I>;
    constexpr iterator& operator-=(difference_type n)
      requires @\placeholdernc{Advanceable}@<I>;
    constexpr I operator[](difference_type n) const
      requires @\placeholdernc{Advanceable}@<I>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires EqualityComparable<I>;
    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires EqualityComparable<I>;

    friend constexpr bool operator<(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<I>;
    friend constexpr bool operator>(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<I>;
    friend constexpr bool operator<=(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<I>;
    friend constexpr bool operator>=(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<I>;

    friend constexpr iterator operator+(iterator i, difference_type n)
      requires @\placeholdernc{Advanceable}@<I>;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires @\placeholdernc{Advanceable}@<I>;

    friend constexpr iterator operator-(iterator i, difference_type n)
      requires @\placeholdernc{Advanceable}@<I>;
    friend constexpr difference_type operator-(const iterator& x, const iterator& y)
      requires @\placeholdernc{Advanceable}@<I>;
  };
}@\oldtxt{\}}@
\end{codeblock}

\pnum
\tcode{\oldtxt{iota_view<I, Bound>::}iterator::iterator_category} is defined as follows:
\begin{itemize}
\item If \tcode{I} \oldtxt{satisfies} \newtxt{models} \tcode{\placeholder{Advanceable}}, then
\tcode{iterator_category} is \tcode{\oldtxt{ranges::}random_access_iterator_tag}.
\item Otherwise, if \tcode{I} \oldtxt{satisfies} \newtxt{models} \tcode{\placeholder{Decrementable}}, then
\tcode{iterator_category} is \tcode{\oldtxt{ranges::}bidirectional_iterator_tag}.
\item Otherwise, if \tcode{I} \oldtxt{satisfies} \newtxt{models} \tcode{Incrementable}, then
\tcode{iterator_category} is \tcode{\oldtxt{ranges::}forward_iterator_tag}.
\item Otherwise, \tcode{iterator_category} is \tcode{\oldtxt{ranges::}input_iterator_tag}.
\end{itemize}

\pnum
\begin{note}
Overloads for \tcode{iter_move} and \tcode{iter_swap} are omitted
intentionally.
\end{note}

\rSec4[range.adaptors.iota_view.iterator.ops]{\tcode{iota_view::iterator} operations}
\rSec5[range.adaptors.iota_view.iterator.ctor]{\tcode{iota_view::iterator} constructors}

\indexlibrary{\idxcode{iterator}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
explicit constexpr iterator(I value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} with \tcode{value}.
\end{itemdescr}

\rSec5[range.adaptors.iota_view.iterator.star]{\tcode{iota_view::iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr I operator*() const noexcept(is_nothrow_copy_constructible_v<I>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} value_\newtxt{;}}\oldtxt{.}

\pnum
\begin{note}
The \tcode{noexcept} clause is needed by the default \tcode{iter_move}
implementation.
\end{note}
\end{itemdescr}

\rSec5[range.adaptors.iota_view.iterator.inc]{\tcode{iota_view::iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
++value_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{++*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator operator++(int) requires Incrementable<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.iota_view.iterator.dec]{\tcode{iota_view::iterator::operator--}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator--() requires @\placeholdernc{Decrementable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
--value_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator operator--(int) requires @\placeholdernc{Decrementable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.iota_view.iterator.adv]{\tcode{iota_view::iterator} advance}

\indexlibrary{\idxcode{operator+=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator+=(difference_type n)
  requires @\placeholdernc{Advanceable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
value_ += n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator-=(difference_type n)
  requires @\placeholdernc{Advanceable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
value_ -= n;
return *this;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.iota_view.iterator.idx]{\tcode{iota_view::iterator} index}

\indexlibrary{\idxcode{operator[]}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr I operator[](difference_type n) const
  requires @\placeholdernc{Advanceable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} value_ + n\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.iota_view.iterator.cmp]{\tcode{iota_view::iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires EqualityComparable<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.value_ == y.value_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires EqualityComparable<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator<(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.value_ < y.value_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator>(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y < x\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator<=(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(y < x)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator>=(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x < y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.iota_view.iterator.nonmember]{\tcode{iota_view::iterator} non-member functions}

\indexlibrary{\idxcode{operator+}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator+(iterator i, difference_type n)
  requires @\placeholdernc{Advanceable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} iterator\{*i + n\}\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator+(difference_type n, iterator i)
  requires @\placeholdernc{Advanceable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} i + n\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator-(iterator i, difference_type n)
  requires @\placeholdernc{Advanceable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} i + -n\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr difference_type operator-(const iterator& x, const iterator& y)
  requires @\placeholdernc{Advanceable}@<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} *x - *y\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec3[range.adaptors.iota_view.sentinel]{Class \tcode{iota_view::sentinel}}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class I, class Bound>
  struct iota_view<I, Bound>::sentinel {
  private:
    Bound bound_ {}; // \expos
  public:
    sentinel() = default;
    constexpr explicit sentinel(Bound bound);

    friend constexpr bool operator==(const iterator& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator& y);
    friend constexpr bool operator!=(const iterator& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator& y);
  };
}@\oldtxt{\}}@
\end{codeblock}

\rSec4[range.adaptors.iota_view.sentinel.ctor]{\tcode{iota_view::sentinel} constructors}

\indexlibrary{\idxcode{sentinel}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
constexpr explicit sentinel(Bound bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{bound_} with \tcode{bound}.
\end{itemdescr}

\rSec4[range.adaptors.iota_view.sentinel.cmp]{\tcode{iota_view::sentinel} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.value_ == y.bound_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y == x\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(y == x)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec2[range.adaptors.iota]{\tcode{view::iota}}

\pnum
The name \tcode{view::iota} denotes a customization point
object\cxxiref{customization.point.object}.
\oldtxt{Let \tcode{E} and \tcode{F} be expressions such that their
cv-unqualified types are \tcode{I} and \tcode{J} respectively. Then}
The expression\newtxt{s} \tcode{view::iota(E)} \newtxt{and
}\tcode{\newtxt{view::iota(E, F)}}\newtxt{ for some subexpressions
\tcode{E} and \tcode{F} are} \oldtxt{is} expression-equivalent to
\tcode{iota_view\{E\}} \newtxt{and }\tcode{\newtxt{iota_view\{E, F\}}}\newtxt{,
respectively.}
\oldtxt{if \tcode{WeaklyIncrementable<I>} is satisfied. Otherwise,
\tcode{view::iota(E)} is ill-formed.}

{\color{oldclr}
\pnum
The expression \tcode{view::iota(E, F)} is expression-equivalent to:

\begin{itemize}
\item \tcode{iota_view\{E, F\}} if the following set of constraints
is satisfied:
\begin{itemize}
\item \begin{codeblock}
WeaklyIncrementable<I> && Semiregular<J> &&
@\xname{WeaklyEqualityComparableWith}@<I, J> &&
(!Integral<I> || !Integral<Bound> || std::is_signed_v<I> == std::is_signed_v<Bound>)
\end{codeblock}
\end{itemize}
\item Otherwise, \tcode{view::iota(E, F)} is ill-formed.
\end{itemize}
} %% \color{oldclr}

\rSec2[range.adaptors.take_view]{Class template \tcode{take_view}}

\pnum
\oldtxt{The purpose of} \tcode{take_view} \oldtxt{is to} produce\newtxt{s} a
\oldtxt{range}\newtxt{\libconcept{View}} of the first $N$ elements from another
\oldtxt{range}\newtxt{\libconcept{View}}.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{0,1,2,3,4,5,6,7,8,9};
take_view few{is, 5};
for (int i : few)
  cout << i << ' '; // prints: 0 1 2 3 4
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<InputRange R>
    requires View<R>
  class take_view : public view_interface<take_view<R>> {
  private:
    R base_ {};                                      // \expos
    @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> count_ {}; // \expos
    template<bool Const>
      struct sentinel;                               // \expos
  public:
    take_view() = default;
    constexpr take_view(R base, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> count);
    template<InputRange O>
      requires ViewableRange<O> && Constructible<R, all_view<O>>
    constexpr take_view(O&& o, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> count);

    constexpr R base() const;

    constexpr auto begin();
    constexpr auto begin() const requires Range<const R>;
    constexpr auto begin() requires RandomAccessRange<R> && SizedRange<R>;
    constexpr auto begin() const
      requires RandomAccessRange<const R> && SizedRange<const R>;

    constexpr auto end();
    constexpr auto end() const requires Range<const R>;
    constexpr auto end() requires RandomAccessRange<R> && SizedRange<R>;
    constexpr auto end() const
      requires RandomAccessRange<const R> && SizedRange<const R>;

    constexpr auto size() requires SizedRange<R>;
    constexpr auto size() const requires SizedRange<const R>;
  };

  template<@\oldtxt{InputRange}\newtxt{class}@ R>
  take_view(R&& base, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> n)
    -> take_view<all_view<R>>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.take_view.ops]{\tcode{take_view} operations}
\rSec4[range.adaptors.take_view.ctor]{\tcode{take_view} constructors}

\indexlibrary{\idxcode{take_view}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr take_view(R base, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and initializes
\tcode{count_} with \tcode{count}.
\end{itemdescr}

\indexlibrary{\idxcode{take_view}!\idxcode{take_view}}%
\begin{itemdecl}
template<InputRange O>
  requires ViewableRange<O> && Constructible<R, all_view<O>>
constexpr take_view(O&& o, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}
and initializes \tcode{count_} with \tcode{count}.
\end{itemdescr}

\rSec4[range.adaptors.take_view.conv]{\tcode{take_view} conversion}

\indexlibrary{\idxcode{base}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr R base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} base_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.take_view.begin]{\tcode{take_view} range begin}

\indexlibrary{\idxcode{begin}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto begin();
constexpr auto begin() const requires Range<const R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return \oldtxt{make_}counted_iterator\oldtxt{(}\newtxt{\{}ranges::begin(base_), count_\newtxt{\}}\oldtxt{)};}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto begin() requires RandomAccessRange<R> && SizedRange<R>;
constexpr auto begin() const
  requires RandomAccessRange<const R> && SizedRange<const R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(base_);}
\end{itemdescr}

\rSec4[range.adaptors.take_view.end]{\tcode{take_view} range end}

\indexlibrary{\idxcode{end}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto end();
constexpr auto end() const requires Range<const R>;
\end{itemdecl}

\begin{itemdescr}
\ednote{LWG: Why not constrain the non-\tcode{const} overload with
\tcode{!\placeholder{simple-view<R>}}
and return something like
\tcode{constexpr bool i_am_const = is_const_v<remove_reference_t<decltype(*this)>>;
sentinel<i_am_const>\{ranges::end(base_)\}}?
(Similarly for the other occurrences elsewhere.)}

\pnum
\effects Equivalent to:
\tcode{\newtxt{return }sentinel<\oldtxt{\placeholder{simple-view}<R>}\newtxt{$C$}>\{ranges::end(base_)\}\newtxt{;}} \\
\oldtxt{and }\tcode{\oldtxt{sentinel<true>\{ranges::end(base_)\}}}
\newtxt{where $C$ is }\tcode{\newtxt{\placeholder{simple-view}<R>}}\newtxt{ or
\tcode{true}} for the first and second overload, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto end() requires RandomAccessRange<R> && SizedRange<R>;
constexpr auto end() const
  requires RandomAccessRange<const R> && SizedRange<const R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(base_) + size();}
\end{itemdescr}

\rSec4[range.adaptors.take_view.size]{\tcode{take_view} range size}

\indexlibrary{\idxcode{size}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto size() requires SizedRange<R>;
constexpr auto size() const requires SizedRange<const R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{\oldtxt{ranges::size(base_) < count_ ? ranges::size(base_) : count_}}\oldtxt{, except with
only one call to }\tcode{\oldtxt{ranges::size(base_)}}\oldtxt{.}
\begin{codeblock}
@\newtxt{auto n = ranges::size(base_);}@
@\newtxt{return min(n, static_cast<decltype(n)>(count_));}@
\end{codeblock}
\end{itemdescr}

\rSec3[range.adaptors.take_view.sentinel]{Class template \tcode{take_view::sentinel}}

\pnum
\oldtxt{\tcode{take_view<R>::sentinel} is an exposition-only type.}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class R>
  template<bool Const>
  class take_view<R>::sentinel { // \expos
  private:
    using Parent =                                 // \expos
      conditional_t<Const, const take_view, take_view>;
    using Base = conditional_t<Const, const R, R>; // \expos
    sentinel_t<Base> end_ {};                      // \expos
    using CI = counted_iterator<iterator_t<Base>>; // \expos
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t<Base> end);
    constexpr sentinel(sentinel<!Const> s)
      requires Const && ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>;

    constexpr sentinel_t<Base> base() const;

    friend constexpr bool operator==(const sentinel& x, const CI& y)
      @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
    friend constexpr bool operator==(const CI& x, const sentinel& y)
      @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
    friend constexpr bool operator!=(const sentinel& x, const CI& y)
      @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
    friend constexpr bool operator!=(const CI& x, const sentinel& y)
      @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
  };
}@\oldtxt{\}}@
\end{codeblock}

\rSec4[range.adaptors.take_view.sentinel.ops]{\tcode{take_view::sentinel} operations}
\rSec5[range.adaptors.take_view.sentinel.ctor]{\tcode{take_view::sentinel} constructors}

\indexlibrary{\idxcode{sentinel}!\idxcode{take_view::sentinel}}
\begin{itemdecl}
constexpr explicit sentinel(sentinel_t<Base> end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{end}.
\end{itemdescr}

\indexlibrary{\idxcode{sentinel}!\idxcode{take_view::sentinel}}%
\begin{itemdecl}
constexpr sentinel(sentinel<!Const> s)
  requires Const && ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{s.end_}.
\end{itemdescr}

\rSec5[range.adaptors.take_view.sentinel.conv]{\tcode{take_view::sentinel} conversion}

\indexlibrary{\idxcode{base}!\idxcode{take_view::sentinel}}
\begin{itemdecl}
constexpr sentinel_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.take_view.sentinel.comp]{\tcode{take_view::sentinel} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{take_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const CI& y)
  @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y.count() == 0 || y.base() == x.end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\begin{itemdecl}
friend constexpr bool operator==(const CI& x, const sentinel& y)
  @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y == x\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{take_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const CI& y)
  @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\begin{itemdecl}
friend constexpr bool operator!=(const CI& x, const sentinel& y)
  @\oldtxt{requires EqualityComparable<iterator_t<Base>>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(y == x)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec2[range.adaptors.take]{\tcode{view::take}}

\pnum
The name \tcode{view::take} denotes a range adaptor
object\iref{range.adaptor.object}. \oldtxt{Let \tcode{E} and \tcode{F} be
expressions such that type \tcode{T} is \tcode{decltype((E))}. Then} The
expression \tcode{view::take(E, F)} \newtxt{for some subexpressions \tcode{E}
and \tcode{F}} is expression-equivalent to \tcode{take_view\{E, F\}}\newtxt{.}
\oldtxt{if \tcode{InputRange<T>} is satisfied and if \tcode{F}
is implicitly convertible to }\tcode{\oldtxt{difference_type_t<iterator_t<T>>}
}\oldtxt{. Otherwise, \tcode{view::take(E, F)} is ill-formed.}


\rSec2[range.adaptors.join_view]{Class template \tcode{join_view}}

\pnum
\oldtxt{The purpose of} \tcode{join_view} \oldtxt{is to} flatten\newtxt{s} a
\oldtxt{range}\newtxt{\libconcept{View}} of ranges into a
\oldtxt{range}\newtxt{\libconcept{View}}.

\pnum
\begin{example}
\begin{codeblock}
vector<string> ss{"hello", " ", "world", "!"};
join_view greeting{ss};
for (char ch : greeting)
  cout << ch; // prints: hello world!
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<InputRange R>
    requires View<R> && InputRange<@\newtxt{iter_}@reference_t<iterator_t<R>>> &&
      (is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<R>>> ||
      View<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<R>>>)
  class join_view : public view_interface<join_view<R>> {
  private:
    using InnerRng =              // \expos
      @\newtxt{iter_}@reference_t<iterator_t<R>>;
    template<bool Const>
      struct iterator;            // \expos
    template<bool Const>
      struct sentinel;            // \expos

    R base_ {};                   // \expos
    all_view<InnerRng> inner_ {}; // \expos, only present when \tcode{!is_reference_v<InnerRng>}
  public:
    join_view() = default;
    constexpr explicit join_view(R base);

    @\ednote{LWG: Should this constructor be conditionally explicit?}@
    template<InputRange O>
        requires ViewableRange<O> && Constructible<R, all_view<O>>
      constexpr explicit join_view(O&& o);

    constexpr auto begin();

    constexpr auto begin() const requires InputRange<const R> &&
      is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<const R>>>;

    constexpr auto end();

    constexpr auto end() const requires InputRange<const R> &&
      is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<const R>>>;

    constexpr auto end() requires ForwardRange<R> &&
      is_reference_v<InnerRng> && ForwardRange<InnerRng> &&
      CommonRange<R> && CommonRange<InnerRng>;

    constexpr auto end() const requires ForwardRange<const R> &&
      is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<const R>>> &&
      ForwardRange<@\newtxt{iter_}@reference_t<iterator_t<const R>>> &&
      CommonRange<const R> && CommonRange<@\newtxt{iter_}@reference_t<iterator_t<const R>>>;
  };

  template<@\oldtxt{InputRange}\newtxt{class}@ R>
    @\oldtxt{requires InputRange<iter_reference_t<iterator_t<R>>> \&\&}@
      @\oldtxt{(is_reference_v<reference_t<iterator_t<R>>> ||}@
      @\oldtxt{View<value_type_t<iterator_t<R>>>)}@
    explicit join_view(R&&) -> join_view<all_view<R>>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.join_view.ops]{\tcode{join_view} operations}
\rSec4[range.adaptors.join_view.ctor]{\tcode{join_view} constructors}

\indexlibrary{\idxcode{join_view}!\idxcode{join_view}}%
\begin{itemdecl}
explicit constexpr join_view(R base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrary{\idxcode{join_view}!\idxcode{join_view}}%
\begin{itemdecl}
template<InputRange O>
  requires ViewableRange<O> && Constructible<R, all_view<O>>
constexpr explicit join_view(O&& o);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}.
\end{itemdescr}

\rSec4[range.adaptors.join_view.begin]{\tcode{join_view} range begin}

\indexlibrary{\idxcode{begin}!\idxcode{join_view}}%
\begin{itemdecl}
constexpr auto begin();
constexpr auto begin() const requires InputRange<const R> &&
  is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return iterator<\oldtxt{\placeholder{simple-view}<R>}\newtxt{$C$}>\{*this, ranges::begin(base_)\};} \\
\oldtxt{and }\tcode{\oldtxt{return iterator<true>\{*this, ranges::begin(base_)\};}}
\newtxt{where $C$ is \tcode{\placeholder{simple-view}<R>} or \tcode{true}}
for the first and second overloads, respectively.
\end{itemdescr}

\rSec4[range.adaptors.join_view.end]{\tcode{join_view} range end}

\indexlibrary{\idxcode{end}!\idxcode{join_view}}%
\begin{itemdecl}
constexpr auto end();
constexpr auto end() const requires InputRange<const R> &&
  is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return sentinel<\oldtxt{\placeholder{simple-view}<R>}\newtxt{$C$}>\{*this\};} \\
\oldtxt{and }\tcode{\oldtxt{return sentinel<true>\{*this\};}}
\newtxt{where $C$ is \tcode{\placeholder{simple-view}<R>} or \tcode{true}}
for the first and second overload, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{join_view}}%
\begin{itemdecl}
constexpr auto end() requires ForwardRange<R> &&
  is_reference_v<InnerRng> && ForwardRange<InnerRng> &&
  CommonRange<R> && CommonRange<InnerRng>;
constexpr auto end() const requires ForwardRange<const R> &&
  is_reference_v<@\newtxt{iter_}@reference_t<iterator_t<const R>>> &&
  ForwardRange<@\newtxt{iter_}@reference_t<iterator_t<const R>>> &&
  CommonRange<const R> && CommonRange<@\newtxt{iter_}@reference_t<iterator_t<const R>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return iterator<\oldtxt{\placeholder{simple-view}<R>}\newtxt{$C$}>\{*this, ranges::end(base_)\};} \\
\oldtxt{and }\tcode{\oldtxt{return iterator<true>\{*this, ranges::end(base_)\};}}
\newtxt{where $C$ is \tcode{\placeholder{simple-view}<R>} or \tcode{true}}
for the first and second overloads, respectively.
\end{itemdescr}

\rSec3[range.adaptors.join_view.iterator]{Class template \tcode{join_view::iterator}}

\pnum
\oldtxt{\tcode{join_view::iterator} is an exposition-only type.}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
template<class R>
  template<bool Const>
  struct join_view<R>::iterator { // \expos
  private:
    using Parent =                                            // \expos
      conditional_t<Const, const join_view, join_view>;
    using Base   = conditional_t<Const, const R, R>;          // \expos

    @\newtxt{static constexpr bool ref_is_glvalue =                    // \expos}@
      @\newtxt{is_reference_v<iter_reference_t<iterator_t<Base>>>;}@

    iterator_t<Base> outer_ {};                               @\newtxt{// \expos}@
    iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>> inner_ {}; @\newtxt{// \expos}@
    Parent* parent_ {};                                       @\newtxt{// \expos}@

    constexpr void satisfy();                                 @\newtxt{// \expos}@
  public:
    using iterator_category = @\seebelownc@;
    @\newtxt{using iterator_concept  = \seebelownc;}@
    using value_type = @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>;
    using difference_type = @\seebelownc@;

    iterator() = default;
    constexpr iterator(Parent& parent, iterator_t<R> outer);
    constexpr iterator(iterator<!Const> i) requires Const &&
      ConvertibleTo<iterator_t<R>, iterator_t<Base>> &&
      ConvertibleTo<iterator_t<InnerRng>,
        iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>;

    constexpr decltype(auto) operator*() const;
    @\newtxt{constexpr iterator_t<Base> operator->() const}@
      @\newtxt{requires \placeholder{has-arrow}<iterator_t<Base>>;}@

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
      requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
        @\newtxt{ref_is_glvalue \&\&}@ ForwardRange<Base> &&
        ForwardRange<@\newtxt{iter_}@reference_t<iterator_t<Base>>>;

    constexpr iterator& operator--();
      requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
        @\newtxt{ref_is_glvalue \&\&}@ BidirectionalRange<Base> &&
        BidirectionalRange<@\newtxt{iter_}@reference_t<iterator_t<Base>>>;

    constexpr iterator operator--(int)
      requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
        @\newtxt{ref_is_glvalue \&\&}@ BidirectionalRange<Base> &&
        BidirectionalRange<@\newtxt{iter_}@reference_t<iterator_t<Base>>>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
        @\newtxt{ref_is_glvalue \&\&}@ EqualityComparable<iterator_t<Base>> &&
        EqualityComparable<iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>;

    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
        @\newtxt{ref_is_glvalue \&\&}@ EqualityComparable<iterator_t<Base>> &&
        EqualityComparable<iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>;

    friend constexpr decltype(auto) iter_move(const iterator& i)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(i.inner_))}@);

    friend constexpr void iter_swap(const iterator& x, const iterator& y)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.inner_, y.inner_))}@);
  };
}@\oldtxt{\}}@
\end{codeblock}

\pnum
\tcode{\oldtxt{join_view<R>::}iterator::iterator_category} is defined as follows:
\begin{itemize}
{\color{newclr}
\item
Let \placeholder{OUTERC} denote
\tcode{iterator_traits<iterator_t<Base>>::iterator_category}, and
let \placeholder{INNERC} denote
\tcode{iterator_traits<iterator_t<iter_reference_t<iterator_t<Base>>>>::iterator_category}.

\item If \tcode{ref_is_glvalue} is \tcode{true},
  \begin{itemize}
  \item If \placeholder{OUTERC} and \placeholder{INNERC} each model
  \tcode{DerivedFrom<bidirectional_iterator_tag>}, \tcode{iterator_category}
  denotes \tcode{bidirectional_iterator_tag}.

  \item Otherwise, if \placeholder{OUTERC} and \placeholder{INNERC} each model
  \tcode{DerivedFrom<forward_iterator_tag>}, \tcode{iterator_category}
  denotes \tcode{forward_iterator_tag}.
  \end{itemize}
} %% \color{newclr}

{\color{oldclr}
\item If \tcode{Base} satisfies \tcode{BidirectionalRange}, and if
\tcode{is_reference_v<reference_t<iterator_t<Base>>>} is \tcode{true}, and if
\tcode{reference_t<iterator_t<Base>>} satisfies \tcode{BidirectionalRange}, then
\tcode{iterator_category} is \tcode{ranges::bidirectional_iterator_tag}.

\item Otherwise, if \tcode{Base} satisfies \tcode{ForwardRange}, and if
\tcode{is_reference_v<reference_t<iterator_t<Base>>>} is \tcode{true}, and if
\tcode{reference_t<iterator_t<Base>>} satisfies \tcode{ForwardRange}, then
\tcode{iterator_category} is \tcode{ranges::forward_iterator_tag}.
} %% \color{oldclr}

\item Otherwise, \tcode{iterator_category} \oldtxt{is} \newtxt{denotes}
\tcode{\oldtxt{ranges::}input_iterator_tag}.
\end{itemize}

{\color{newclr}
\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{ref_is_glvalue} is \tcode{true},

  \begin{itemize}
  \item If \tcode{Base} and \tcode{iter_reference_t<iterator_t<Base>>} each model
  \libconcept{BidirectionalRange}, then \tcode{iterator_concept} denotes
  \tcode{bidirectional_iterator_tag}.

  \item Otherwise, if \tcode{Base} and \tcode{iter_reference_t<iterator_t<Base>>}
  each model \libconcept{ForwardRange}, then \tcode{iterator_concept} denotes
  \tcode{forward_iterator_tag}.
  \end{itemize}

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}
} %% \color{newclr}

\pnum
\tcode{\oldtxt{join_view<R>::}iterator::difference_type} \oldtxt{is an alias for}
\newtxt{denotes the type}:
\begin{codeblock}
common_type_t<
  @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<Base>>,
  @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>>
\end{codeblock}

\rSec4[range.adaptors.join_view.iterator.ops]{\tcode{join_view::iterator} operations}

\rSec5[range.adaptors.join_view.iterator.satisfy]{\tcode{satisfy}}
{\color{newclr}
\pnum
\tcode{join_view} iterators use the \tcode{satisfy} function to skip over empty
inner ranges.

\begin{itemdecl}
constexpr void satisfy(); // \expos
\end{itemdecl}
} %% \color{newclr}

\begin{itemdescr}
\pnum
\newtxt{\effects} \oldtxt{The \tcode{join_view<R>::iterator::satisfy} function is} Equivalent to:
\begin{codeblock}
@\newtxt{auto update_inner = [this](reference_t<iterator_t<Base>> x) -> decltype(auto) \{}@
  @\newtxt{if constexpr (ref_is_glvalue) // \tcode{x} is a reference}@
    @\newtxt{return (x); // \tcode{(x)} is an lvalue}@
  @\newtxt{else}@
    @\newtxt{return (parent_->inner_ = view::all(x));}@
@\newtxt{\};}@

for (; outer_ != ranges::end(parent_->base_); ++outer_) {
  auto&@\oldtxt{\&}@ inner = @\newtxt{update_inner(*outer_)}\oldtxt{\placeholder{inner-range-update}}@;
  inner_ = ranges::begin(inner);
  if (inner_ != ranges::end(inner))
    return;
}
if constexpr (@\newtxt{ref_is_glvalue}\oldtxt{is_reference_v<reference_t<iterator_t<Base>>>}@)
  inner_ = iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>{};
\end{codeblock}

{\color{oldclr}
where \tcode{\placeholder{inner-range-update}} is equivalent to:
\begin{itemize}
\item If \tcode{is_reference_v<reference_t<iterator_t<Base>>>} is \tcode{true},
\tcode{*outer_}.

\item Otherwise,
\begin{codeblock}
[this](auto&& x) -> decltype(auto) {
  return (parent_->inner_ = view::all(x));
}(*outer_)
\end{codeblock}
\end{itemize}
} %% \color{oldclr}
\end{itemdescr}

\rSec5[range.adaptors.join_view.iterator.ctor]{\tcode{join_view::iterator} constructors}

\indexlibrary{\idxcode{iterator}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator(Parent& parent, iterator_t<R> outer)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{outer_} with \tcode{outer} and initializes
\tcode{parent_} with \tcode{\oldtxt{\&}\newtxt{addressof(}parent\newtxt{)}}; then calls \tcode{satisfy()}.
\end{itemdescr}

\indexlibrary{\idxcode{iterator}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator(iterator<!Const> i) requires Const &&
  ConvertibleTo<iterator_t<R>, iterator_t<Base>> &&
  ConvertibleTo<iterator_t<InnerRng>,
      iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{outer_} with \tcode{i.outer_}, initializes
\tcode{inner_} with \tcode{i.inner_}, and initializes \tcode{parent_} with
\tcode{i.parent_}.
\end{itemdescr}

\rSec5[range.adaptors.join_view.iterator.star]{\tcode{join_view::iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr decltype(auto) operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} *inner_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

{\color{newclr}
\rSec5[range.adaptors.join_view.iterator.arrow]{\tcode{join_view::iterator::operator->}}

\indexlibrary{\idxcode{operator->}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator_t<Base> operator->() const
  requires @\placeholder{has-arrow}@<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{return inner_;}
\end{itemdescr}
} %% \color{newclr}

\rSec5[range.adaptors.join_view.iterator.inc]{\tcode{join_view::iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
if (++inner_ == ranges::end(@\placeholdernc{inner-range}@)) {
  ++outer_;
  satisfy();
}
return *this;
\end{codeblock}

where \tcode{\placeholder{inner-range}} is equivalent to:
\begin{itemize}
\item If \tcode{\oldtxt{is_reference_v<reference_t<iterator_t<Base>>>}\newtxt{ref_is_glvalue}} is \tcode{true}, \tcode{*outer_}.
\item Otherwise, \tcode{parent_->inner_}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{\oldtxt{(void)}++*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator operator++(int)
  requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
    @\newtxt{ref_is_glvalue \&\&}@ ForwardRange<Base> &&
    ForwardRange<@\newtxt{iter_}@reference_t<iterator_t<Base>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec5[range.adaptors.join_view.iterator.dec]{\tcode{join_view::iterator::operator\dcr}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator--();
  requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
    @\newtxt{ref_is_glvalue \&\&}@ BidirectionalRange<Base> &&
    BidirectionalRange<@\newtxt{iter_}@reference_t<iterator_t<Base>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
if (outer_ == ranges::end(parent_->base_))
  inner_ = ranges::end(*--outer_);
while (inner_ == ranges::begin(*outer_))
  inner_ = ranges::end(*--outer_);
--inner_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator operator--(int)
  requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
    @\newtxt{ref_is_glvalue \&\&}@ BidirectionalRange<Base> &&
    BidirectionalRange<@\newtxt{iter_}@reference_t<iterator_t<Base>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[range.adaptors.join_view.iterator.comp]{\tcode{join_view::iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
    @\newtxt{ref_is_glvalue \&\&}@ EqualityComparable<iterator_t<Base>> &&
    EqualityComparable<iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.outer_ == y.outer_ \&\& x.inner_ == y.inner_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires @\oldtxt{is_reference_v<reference_t<iterator_t<Base>>> \&\&}@
    @\newtxt{ref_is_glvalue \&\&}@ EqualityComparable<iterator_t<Base>> &&
    EqualityComparable<iterator_t<@\newtxt{iter_}@reference_t<iterator_t<Base>>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec4[range.adaptors.join_view.iterator.nonmember]{\tcode{join_view::iterator} non-member functions}

\indexlibrary{\idxcode{iter_move}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr decltype(auto) iter_move(const iterator& i)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(i.inner_))}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} ranges::iter_move(i.inner_)\newtxt{;}}\oldtxt{.}

\pnum
\oldtxt{\remarks The expression in the \tcode{noexcept} clause is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_move(i.inner_))}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr void iter_swap(const iterator& x, const iterator& y)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.inner_, y.inner_))}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} ranges::iter_swap(x.inner_, y.inner_)\newtxt{;}}\oldtxt{.}

\pnum
\oldtxt{\remarks The expression in the \tcode{noexcept} clause is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_swap(x.inner_, y.inner_))}@
\end{codeblock}
\end{itemdescr}

\rSec3[range.adaptors.join_view.sentinel]{Class template \tcode{join_view::sentinel}}

\pnum
\oldtxt{\tcode{join_view::sentinel} is an exposition-only type.}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class R>
  template<bool Const>
  struct join_view<R>::sentinel { @\newtxt{// \expos}@
  private:
    using Parent =                                   // \expos
      conditional_t<Const, const join_view, join_view>;
    using Base   = conditional_t<Const, const R, R>; // \expos
    sentinel_t<Base> end_ {};                        // \expos
  public:
    sentinel() = default;

    constexpr explicit sentinel(Parent& parent);
    constexpr sentinel(sentinel<!Const> s) requires Const &&
        ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>;

    friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
    friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);
  };
}@\oldtxt{\}}@
\end{codeblock}

\rSec4[range.adaptors.join_view.sentinel.ops]{\tcode{join_view::sentinel} operations}

\indexlibrary{\idxcode{sentinel}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
constexpr explicit sentinel(Parent& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{ranges::end(parent.base_)}.
\end{itemdescr}

\indexlibrary{\idxcode{sentinel}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
constexpr sentinel(sentinel<!Const> s) requires Const &&
  ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{s.end_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} x.outer_ == y.end_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} y == x\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(x == y)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to: }\tcode{\newtxt{return} !(y == x)\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec2[range.adaptors.join]{\tcode{view::join}}

\pnum
The name \tcode{view::join} denotes a range adaptor
object\iref{range.adaptor.object}. \oldtxt{Let \tcode{E} be an expression such
that type \tcode{T} is \tcode{decltype((E))}. Then} The expression
\tcode{view::join(E)} \newtxt{for some subexpression \tcode{E}} is
expression-equivalent to \tcode{join_view\{E\}}\newtxt{.}
{\color{oldclr}
if the following is satisfied:
\begin{codeblock}
InputRange<T> &&
InputRange<reference_t<iterator_t<T>>> &&
(is_reference_v<reference_t<iterator_t<T>>> ||
 View<value_type_t<iterator_t<T>>)
\end{codeblock}
Otherwise, \tcode{view::join(E)} is ill-formed.
} %% \color{oldclr}

\rSec2[range.adaptors.empty_view]{Class template \tcode{empty_view}}

\pnum
\oldtxt{The purpose of} \tcode{empty_view} \oldtxt{is to} produce\newtxt{s}
\oldtxt{an empty range} \newtxt{a \libconcept{View}} of \newtxt{no} elements of
a particular type.

\pnum
\begin{example}
\begin{codeblock}
empty_view<int> e;
static_assert(ranges::empty(e));
static_assert(0 == e.size());
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class T>
    requires is_object_v<T>
  class empty_view : public view_interface<empty_view<T>> {
  public:
    constexpr static T* begin() noexcept@\oldtxt{;} \newtxt{\{ return nullptr; \}}@
    constexpr static T* end() noexcept@\oldtxt{;} \newtxt{\{ return nullptr; \}}@
    constexpr static ptrdiff_t size() noexcept@\oldtxt{;} \newtxt{\{ return 0; \}}@
    constexpr static T* data() noexcept@\oldtxt{;} \newtxt{\{ return nullptr; \}}@

    @\newtxt{constexpr static bool empty() noexcept \{ return true; \}}@

    @\newtxt{friend constexpr T* begin(empty_view) noexcept \{ return nullptr; \}}@
    @\newtxt{friend constexpr T* end(empty_view) noexcept \{ return nullptr; \}}@
  };
}@\oldtxt{\}}@
\end{codeblock}

\rSec2[range.adaptors.single_view]{Class template \tcode{single_view}}

\pnum
\oldtxt{The purpose of} \tcode{single_view} \oldtxt{is to} produce\newtxt{s} a
\oldtxt{range}\newtxt{\libconcept{View}} that contains exactly one element of a
specified value.

\pnum
\begin{example}
\begin{codeblock}
single_view s{4};
for (int i : s)
  cout << i; // prints 4
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<CopyConstructible T>
    @\newtxt{requires is_object_v<T>}@
  class single_view : public view_interface<single_view<T>> {
  private:
    @\placeholder{semiregular}@<T> value_; // \expos
  public:
    single_view() = default;
    constexpr explicit single_view(const T& t);
    constexpr explicit single_view(T&& t);
    template<class... Args>
      requires Constructible<T, Args...>
    constexpr single_view(in_place_t, Args&&... args);

    @\newtxt{constexpr const T* begin() noexcept;}@
    constexpr const T* begin() const noexcept;
    @\newtxt{constexpr const T* end() noexcept;}@
    constexpr const T* end() const noexcept;
    constexpr static ptrdiff_t size() noexcept;
    @\newtxt{constexpr const T* data() noexcept;}@
    constexpr const T* data() const noexcept;
  };

  template<class T>
    @\oldtxt{requires CopyConstructible<decay_t<T>>}@
  explicit single_view(T&&) -> single_view<decay_t<T>>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.single_view.ops]{\tcode{single_view} operations}

\indexlibrary{\idxcode{single_view}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr explicit single_view(const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} with \tcode{t}.
\end{itemdescr}

\indexlibrary{\idxcode{single_view}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr explicit single_view(T&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} with \tcode{std::move(t)}.
\end{itemdescr}

\indexlibrary{\idxcode{single_view}!\idxcode{single_view}}%
\begin{itemdecl}
template<class... Args>
constexpr single_view(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} as if by
\tcode{value_\{in_place, std::forward<Args>(args)...\}}.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{single_view}}%
\begin{itemdecl}
@\newtxt{constexpr const T* begin() noexcept;}@
constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires \tcode{bool(value_)}}

\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:}
\tcode{\newtxt{return} value_.operator->()\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{single_view}}%
\begin{itemdecl}
@\newtxt{constexpr const T* end() noexcept;}@
constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires \tcode{bool(value_)}}

\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:}
\tcode{\newtxt{return} value_.operator->() + 1\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr static ptrdiff_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires \tcode{bool(value_)}}

\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} 1\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{data}!\idxcode{single_view}}%
\begin{itemdecl}
@\newtxt{constexpr const T* data() noexcept;}@
constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires \tcode{bool(value_)}}

\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} begin()\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\rSec2[range.adaptors.single]{\tcode{view::single}}

\pnum
The name \tcode{view::single} denotes a customization point
object\cxxiref{customization.point.object}. \oldtxt{Let \tcode{E} be an
expression such that its cv-unqualified type is \tcode{I}. Then} The expression
\tcode{view::single(E)} \newtxt{for some subexpression \tcode{E}} is
expression-equivalent to \tcode{single_view\{E\}}\newtxt{.} \oldtxt{if
\tcode{CopyConstructible<I>} is satisfied. Otherwise, \tcode{view::single(E)} is
ill-formed.}


\rSec2[range.adaptors.split_view]{Class template \tcode{split_view}}

\pnum
The \tcode{split_view} takes a \oldtxt{range} \newtxt{\libconcept{View}} and a
delimiter, and splits the \oldtxt{range} \newtxt{\libconcept{View}} into
subranges on the delimiter. The delimiter can be a single element or a
\oldtxt{range} \newtxt{\libconcept{View}} of elements.

\pnum
\begin{example}
\begin{codeblock}
string str{"the quick brown fox"};
split_view sentence{str, ' '};
for (auto word : sentence) {
  for (char ch : word)
    cout << ch;
  cout << " *";
}
// The above prints: the *quick *brown *fox *
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class R>
  concept @\placeholder{tiny-range}@ = // \expos
    SizedRange<R> && @\oldtxt{requires \{}@
      @\oldtxt{requires}@ remove_reference_t<R>::size() <= 1;
    @\oldtxt{\};}@

  template<InputRange Rng, ForwardRange Pattern>
    requires View<Rng> && View<Pattern> &&
      IndirectlyComparable<iterator_t<Rng>, iterator_t<Pattern>@\newtxt{, ranges::equal_to<>}@> &&
      (ForwardRange<Rng> || @\placeholdernc{tiny-range}@<Pattern>)
  class split_view @\newtxt{: public view_interface<split_view<Rng, Pattern>>}@ {
  private:
    Rng base_ {};                               // \expos
    Pattern pattern_ {};                        // \expos
    iterator_t<Rng> current_ {};                // \expos, only present if \tcode{!ForwardRange<Rng>}
    @\newtxt{bool zero_ = false;}@                         @\newtxt{// \expos, only present if \tcode{!ForwardRange<Rng>}}@
    template<bool Const> struct outer_iterator; // \expos
    @\oldtxt{template<bool Const> struct outer_sentinel; // \expos}@
    template<bool Const> struct inner_iterator; // \expos
    @\oldtxt{template<bool Const> struct inner_sentinel; // \expos}@
  public:
    split_view() = default;
    constexpr split_view(Rng base, Pattern pattern);

    template<InputRange O, ForwardRange P>
      requires @\oldtxt{ViewableRange<O> \&\& ViewableRange<P> \&\&}@
        Constructible<Rng, all_view<O>> &&
        Constructible<Pattern, all_view<P>>
    constexpr split_view(O&& o, P&& p);

    template<InputRange O>
      requires @\oldtxt{ViewableRange<O> \&\&}@
        Constructible<Rng, all_view<O>> &&
        Constructible<Pattern, single_view<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<O>>>>
    constexpr split_view(O&& o, @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<O>> e);

    constexpr auto begin();
    constexpr auto begin() requires ForwardRange<Rng>;
    constexpr auto begin() const
      requires @\newtxt{ForwardRange<Rng> \&\&}@ ForwardRange<const Rng>;

    constexpr auto end() @\newtxt{const;}@
    @\oldtxt{constexpr auto end() const}@
      @\oldtxt{requires ForwardRange<const Rng>;}@

    constexpr auto end()
      requires ForwardRange<Rng> && CommonRange<Rng>;
    constexpr auto end() const
      requires @\newtxt{ForwardRange<Rng> \&\&}@ ForwardRange<const Rng> && CommonRange<const Rng>;
  };

  template<@\oldtxt{InputRange}\newtxt{class}@ O, @\oldtxt{ForwardRange}\newtxt{class}@ P>
    @\oldtxt{requires ViewableRange<O> \&\& ViewableRange<P> \&\&}@
      @\oldtxt{IndirectlyComparable<iterator_t<O>, iterator_t<P>> \&\&}@
      @\oldtxt{(ForwardRange<O> || \placeholdernc{tiny-range}<P>)}@
  split_view(O&&, P&&) -> split_view<all_view<O>, all_view<P>>;

  template<InputRange O>
    @\oldtxt{requires ViewableRange<O> \&\&}@
      @\oldtxt{IndirectlyComparable<iterator_t<Rng>, const value_type_t<iterator_t<Rng>>*> \&\&}@
      @\oldtxt{CopyConstructible<value_type_t<iterator_t<O>>>}@
  split_view(O&&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<O>>)
    -> split_view<all_view<O>, single_view<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<O>>>>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.split_view.ops]{\tcode{split_view} operations}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr split_view(Rng base, Pattern pattern);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}, and
\oldtxt{initializes} \tcode{pattern_} with \tcode{std::move(pattern)}.
\end{itemdescr}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
template<InputRange O, ForwardRange P>
  requires @\oldtxt{ViewableRange<O> \&\& ViewableRange<P> \&\&}@
    Constructible<Rng, all_view<O>> &&
    Constructible<Pattern, all_view<P>>
constexpr split_view(O&& o, P&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
{\color{newclr}
Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))} and
\tcode{pattern_} with \tcode{view::all(std\brk{}::forward<P>(p))}.
} %% \color{newclr}

\oldtxt{Delegates to:
}\tcode{\oldtxt{split_view\{view::all(std::forward<O>(o)), view::all(std::\brk{}forward<P>(p))\}}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
template<InputRange O>
  requires @\oldtxt{ViewableRange<O> \&\&}@
    Constructible<Rng, all_view<O>> &&
    Constructible<Pattern, single_view<@\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<O>>>>
constexpr split_view(O&& o, @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<O>> e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
{\color{newclr}
Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))} and
\tcode{pattern_} with \tcode{single_view\{\brk{}std::move(e)\}}.
} %% \color{newclr}

\oldtxt{Delegates to
}\tcode{\oldtxt{split_view\{view::all(std::forward<O>(o)), single_view\{std::\brk{}move(e)\}\}}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ = ranges::begin(base_);
return @\newtxt{outer_}@iterator@\newtxt{<\placeholder{simple-view}<R>>}@{*this};
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto begin() requires ForwardRange<Rng>;
constexpr auto begin() const
  requires @\newtxt{ForwardRange<Rng> \&\&}@ ForwardRange<@\newtxt{const}@ Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return outer_iterator<\oldtxt{\placeholder{simple-view}<R>}\newtxt{$C$}>\{*this, ranges::begin(base_)\};} \\
\oldtxt{and }\tcode{\oldtxt{return outer_iterator<true>\{*this, ranges::begin(base_)\};}}
\newtxt{where $C$ is \tcode{\placeholder{simple-view}<R>} or \tcode{true}
for the first and second overloads, respectively.}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto end() @\newtxt{const;}@
@\oldtxt{constexpr auto end() const}@
  @\oldtxt{requires ForwardRange<Rng>;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{\newtxt{return default_sentinel\{\};}}

\oldtxt{\tcode{return outer_sentinel<\placeholder{simple-view}<R>>\{*this\};}
and \tcode{return outer_sentinel<true>\{*this\};}
for the first and second overloads, respectively.}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto end()
  requires ForwardRange<Rng> && CommonRange<Rng>;
constexpr auto end() const
  requires @\newtxt{ForwardRange<Rng> \&\&}@ ForwardRange<@\newtxt{const}@ Rng> && CommonRange<@\newtxt{const}@ Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return outer_iterator<\oldtxt{\placeholder{simple-view}<R>}\newtxt{$C$}>\{*this, ranges::end(base_)\};} \\
\oldtxt{and }\tcode{\oldtxt{return outer_iterator<true>\{*this, ranges::end(base_)\};}}
\newtxt{where $C$ is \tcode{\placeholder{simple-view}<R>} or \tcode{true}
for the first and second overloads, respectively.}
\end{itemdescr}

\rSec3[range.adaptors.split_view.outer_iterator]{Class template \tcode{split_view::outer_iterator}}

\pnum
\begin{note}
\tcode{\oldtxt{split_view::outer_iterator}}\oldtxt{ is an exposition-only type.}
\end{note}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class Rng, class Pattern>
  template<bool Const>
  struct split_view<Rng, Pattern>::outer_iterator { @\newtxt{// \expos}@
  private:
    using Parent =                @\newtxt{// \expos}@
      conditional_t<Const, const split_view, split_view>;
    using Base   =                @\newtxt{// \expos}@
      conditional_t<Const, const Rng, Rng>;
    iterator_t<Base> current_ {}; // \expos, present only if \tcode{Rng} models \libconcept{ForwardRange}
    Parent* parent_ = nullptr;    // \expos
  public:
    using iterator_category = @\newtxt{input_iterator_tag} \oldtxt{\seebelownc}@;
    @\newtxt{using iterator_concept  =}@
      @\newtxt{conditional_t<ForwardRange<Base>, forward_iterator_tag, input_iterator_tag>;}@
    using difference_type   = @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<Base>>;
    struct value_type;

    outer_iterator() = default;
    constexpr explicit outer_iterator(Parent& parent)
      @\newtxt{requires !ForwardRange<Base>}@;
    constexpr outer_iterator(Parent& parent, iterator_t<Base> current)
      requires ForwardRange<Base>;
    constexpr outer_iterator(outer_iterator<!Const> i) requires Const &&
      ConvertibleTo<iterator_t<Rng>, iterator_t<@\newtxt{const Rng} \oldtxt{Base}@>>;

    constexpr value_type operator*() const;

    constexpr outer_iterator& operator++();
    constexpr @\newtxt{decltype(auto)} \oldtxt{void}@ operator++(int);
    @\oldtxt{constexpr outer_iterator operator++(int) requires ForwardRange<Base>;}@

    friend constexpr bool operator==(const outer_iterator& x, const outer_iterator& y)
      requires ForwardRange<Base>;
    friend constexpr bool operator!=(const outer_iterator& x, const outer_iterator& y)
      requires ForwardRange<Base>;

    @\newtxt{friend constexpr bool operator==(const outer_iterator\& x, default_sentinel);}@
    @\newtxt{friend constexpr bool operator==(default_sentinel, const outer_iterator\& x);}@
    @\newtxt{friend constexpr bool operator!=(const outer_iterator\& x, default_sentinel y);}@
    @\newtxt{friend constexpr bool operator!=(default_sentinel y, const outer_iterator\& x);}@
  };
}@\oldtxt{\}}@
\end{codeblock}

{\color{oldclr}
\pnum
\tcode{split_view<Rng, Pattern>::outer_iterator::iterator_category} is defined
as follows:
\begin{itemize}
\item If \tcode{outer_iterator::Base} satisfies \libconcept{ForwardRange},
then \tcode{iterator_category} is \tcode{ranges::forward_iterator_tag}.

\item Otherwise, \tcode{iterator_category} is \tcode{ranges::input_iterator_tag}.
\end{itemize}
} %% \color{oldclr}

{\color{newclr}
\pnum
Many of the following specifications refer to the notional member
\tcode{\placeholder{current}} of \tcode{outer_iterator}.
\tcode{\placeholder{current}} is equivalent to \tcode{current_} if \tcode{Rng}
models \libconcept{ForwardRange}, and \tcode{parent_->current_} otherwise.
} %% \color{newclr}

\rSec3[range.adaptors.split_view.outer_iterator.ops]{\tcode{split_view::outer_iterator} operations}
\rSec4[range.adaptors.split_view.outer_iterator.ctor]{\tcode{split_view::outer_iterator} constructors}

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr explicit outer_iterator(Parent& parent)
  @\newtxt{requires !ForwardRange<Base>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{\oldtxt{\&}\newtxt{addressof(}parent\newtxt{)}}.
\end{itemdescr}

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator(Parent& parent, iterator_t<Base> current)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{\oldtxt{\&}\newtxt{addressof(}parent\newtxt{)}}
and \tcode{current_} with \tcode{current}.
\end{itemdescr}

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator(outer_iterator<!Const> i) requires Const &&
  ConvertibleTo<iterator_t<Rng>, iterator_t<@\newtxt{const Rng} \oldtxt{Base}@>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{i.parent_} and \tcode{current_} with \tcode{i.current_}.
\end{itemdescr}

\rSec4[range.adaptors.split_view.outer_iterator.star]{\tcode{split_view::outer_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr value_type operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} value_type\{*this\}\newtxt{;}}
\end{itemdescr}

\rSec4[range.adaptors.split_view.outer_iterator.inc]{\tcode{split_view::outer_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
const auto end = ranges::end(parent_->base_);
if (@\placeholder{current}@ == end) return *this;
const auto [pbegin, pend] = subrange{parent_->pattern_};
do {
  @\newtxt{const}@ auto [b, p] = @\newtxt{ranges::}@mismatch(@\placeholdernc{current}@, end, pbegin, pend);
  if (p == pend) @\oldtxt{continue;}@ @\newtxt{\{}@
    // The pattern matches; skip it:
    @\newtxt{\placeholder{current} = b;}@
    @\newtxt{if (pbegin == pend) \{}@
      @\newtxt{if constexpr (ForwardRange<Base>) ++\placeholdernc{current};}@
      @\newtxt{else \{}@
        @\newtxt{if (!parent_->zero_) ++\placeholdernc{current};}@
        @\newtxt{parent_->zero_ = false;}@
      @\newtxt{\}}@
    @\newtxt{\}}@
    @\oldtxt{\placeholder{current} = \placeholdernc{bump}(b, pbegin, pend, end);}@
    break;
  @\newtxt{\}}@
} while (++@\placeholder{current}@ != end);
return *this;
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
Where \tcode{\placeholder{current}} is equivalent to:
\begin{itemize}
\item If \tcode{Rng} satisfies \libconcept{ForwardRange}, \tcode{current_}.

\item Otherwise, \tcode{parent_->current_}.
\end{itemize}

and \tcode{\placeholdernc{bump}(b, x, y, e)} is equivalent to:
\begin{itemize}
\item If \tcode{Rng} satisfies \libconcept{ForwardRange},
\tcode{next(b, (int)(x == y), e)}.

\item Otherwise, \tcode{b}.
\end{itemize}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr @\newtxt{decltype(auto)} \oldtxt{void}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
{\color{newclr}
If \tcode{Base} models \libconcept{ForwardRange}, equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
Otherwise,
} %% \color{newclr}
equivalent to \tcode{\oldtxt{(void)}++*this}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator++}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator operator++(int) requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}
} %% \color{oldclr}

\rSec4[range.adaptors.split_view.outer_iterator.nonmember]{\tcode{split_view::outer_iterator} non-member functions}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_iterator& x, const outer_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ == y.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const outer_iterator& x, const outer_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

{\color{newclr}
\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_iterator& x, default_sentinel);
friend constexpr bool operator==(default_sentinel, const outer_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\placeholder{current} == ranges::end(x.parent_->base_);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const outer_iterator& x, default_sentinel y);
friend constexpr bool operator!=(default_sentinel y, const outer_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}
} %% \color{newclr}

\rSec3[range.adaptors.split_view.outer_iterator.value_type]{Class \tcode{split_view::outer_iterator::value_type}}

\pnum
\begin{note}
\tcode{\oldtxt{split_view::outer_iterator::value_type}}\oldtxt{ is an exposition-only type.}
\end{note}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class Rng, class Pattern>
  template<bool Const>
  struct split_view<Rng, Pattern>::outer_iterator<Const>::value_type {
  private:
    outer_iterator i_ {}; // \expos
  public:
    value_type() = default;
    constexpr explicit value_type(outer_iterator i);

    constexpr @\newtxt{inner_iterator<Const>} \oldtxt{auto}@ begin() const;
    constexpr @\newtxt{default_sentinel} \oldtxt{auto}@ end() const;
  };
}@\oldtxt{\}}@
\end{codeblock}

\rSec4[range.adaptors.split_view.outer_iterator.value_type.ops]{\tcode{split_view::outer_iterator::value_type} operations}

\indexlibrary{\idxcode{value_type}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr explicit value_type(outer_iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{i_} with \tcode{i}.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr @\newtxt{inner_iterator<Const>} \oldtxt{auto}@ begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return inner_iterator<Const>\{i_\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr @\newtxt{default_sentinel} \oldtxt{auto}@ end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return \newtxt{\{\};} \oldtxt{inner_sentinel<Const>\{\};}}
\end{itemdescr}

{\color{oldclr}
\rSec3[range.adaptors.split_view.outer_sentinel]{Class template \tcode{split_view::outer_sentinel}}

\pnum
\begin{note}
\tcode{split_view::outer_sentinel} is an exposition-only type.
\end{note}

\begin{codeblock}
namespace std { namespace ranges {
  template<class Rng, class Pattern>
  template<bool Const>
  struct split_view<Rng, Pattern>::outer_sentinel {
  private:
    using Parent =                                       // \expos
      conditional_t<Const, const split_view, split_view>;
    using Base   = conditional_t<Const, const Rng, Rng>; // \expos
    sentinel_t<Base> end_;                               // \expos
  public:
    outer_sentinel() = default;
    constexpr explicit outer_sentinel(Parent& parent);

    friend constexpr bool operator==(const outer_iterator<Const>& x, const outer_sentinel& y);
    friend constexpr bool operator==(const outer_sentinel& x, const outer_iterator<Const>& y);
    friend constexpr bool operator!=(const outer_iterator<Const>& x, const outer_sentinel& y);
    friend constexpr bool operator!=(const outer_sentinel& x, const outer_iterator<Const>& y);
  };
}}
\end{codeblock}

\rSec4[range.adaptors.split_view.outer_sentinel.ops]{\tcode{split_view::outer_sentinel} operations}

\indexlibrary{\idxcode{outer_sentinel}!\idxcode{split_view::outer_sentinel}}%
\begin{itemdecl}
constexpr explicit outer_sentinel(Parent& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{ranges::end(parent.base_)}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_iterator<Const>& x, const outer_sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return @\placeholdernc{current}@(x) == y.end_;
\end{codeblock}

Where \tcode{\placeholdernc{current}(x)} is equivalent to:
\begin{itemize}
\item If \tcode{Rng} satisfies \tcode{ForwardRange}, \tcode{x.current_}.
\item Otherwise, \tcode{x.parent_->current_}.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_sentinel& x, const outer_iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y == x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::outer_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const outer_iterator<Const>& x, const outer_sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::outer_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const outer_sentinel& x, const outer_iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y == x);}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.adaptors.split_view.inner_iterator]{Class template \tcode{split_view::inner_iterator}}

\pnum
\begin{note}
\tcode{\oldtxt{split_view::inner_iterator}}\oldtxt{ is an exposition-only type.}
\end{note}

{\color{oldclr}
\pnum
In the definition of \tcode{split_view<Rng, Pattern>::inner_iterator} below,
\tcode{\placeholdernc{current}(i)} is equivalent to:
\begin{itemize}
\item If \tcode{Rng} satisfies \tcode{ForwardRange}, \tcode{i.current_}.

\item Otherwise, \tcode{i.parent_->current_}.
\end{itemize}
} %% \color{oldclr}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class Rng, class Pattern>
  template<bool Const>
  struct split_view<Rng, Pattern>::inner_iterator { @\newtxt{// \expos}@
  private:
    using Base =
      conditional_t<Const, const Rng, Rng>; @\newtxt{// \expos}@
    outer_iterator<Const> i_ {};            @\newtxt{// \expos}@
    bool zero_ = false;                     @\newtxt{// \expos, present only if \tcode{Rng} models \libconcept{ForwardRange}}@
  public:
    using iterator_category = @\newtxt{\seebelownc;}@
      @\oldtxt{iterator_category_t<outer_iterator<Const>>;}@
    @\newtxt{using iterator_concept =}@
      @\newtxt{typename outer_iterator<Const>::iterator_concept;}@
    using difference_type = @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<Base>>;
    using value_type = @\newtxt{iter_}@value@\oldtxt{_type}@_t<iterator_t<Base>>;

    inner_iterator() = default;
    constexpr explicit inner_iterator(outer_iterator<Const> i);

    constexpr decltype(auto) operator*() const;

    constexpr inner_iterator& operator++();
    constexpr @\newtxt{decltype(auto)} \oldtxt{void}@ operator++(int);
    @\oldtxt{constexpr inner_iterator operator++(int) requires ForwardRange<Base>;}@

    friend constexpr bool operator==(const inner_iterator& x, const inner_iterator& y)
      requires ForwardRange<Base>;
    friend constexpr bool operator!=(const inner_iterator& x, const inner_iterator& y)
      requires ForwardRange<Base>;

    @\newtxt{friend constexpr bool operator==(const inner_iterator\& x, default_sentinel);}@
    @\newtxt{friend constexpr bool operator==(default_sentinel, const inner_iterator\& x);}@
    @\newtxt{friend constexpr bool operator!=(const inner_iterator\& x, default_sentinel y);}@
    @\newtxt{friend constexpr bool operator!=(default_sentinel y, const inner_iterator\& x);}@

    friend constexpr decltype(auto) iter_move(const inner_iterator& i)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(i.i_.\placeholdernc{current}))}@);
    friend constexpr void iter_swap(const inner_iterator& x, const inner_iterator& y)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.i_.\placeholdernc{current}, y.i_.\placeholdernc{current}))}@)
      requires IndirectlySwappable<iterator_t<Base>>;
  };
}@\oldtxt{\}}@
\end{codeblock}

{\color{newclr}
\pnum
The \grammarterm{typedef-name} \tcode{iterator_category} denotes
\tcode{forward_iterator_tag} if
\tcode{iterator_traits<iterator_t<Base>>::iterator_category} models
\tcode{DerivedFrom<forward_iterator_tag>}, and \tcode{input_iterator_tag}
otherwise.

\pnum
Many of the following specifications refer to the notional member
\tcode{\placeholder{zero}} of \tcode{inner_iterator}.
\tcode{\placeholder{zero}} is equivalent to \tcode{zero_} if \tcode{Rng}
models \libconcept{ForwardRange}, and \tcode{parent_->zero_} otherwise.
} %% \color{newclr}

\rSec4[range.adaptors.split_view.inner_iterator.ctor]{\tcode{split_view::inner_iterator} constructors}

\indexlibrary{\idxcode{inner_iterator}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr explicit inner_iterator(outer_iterator<Const> i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{i_} with \tcode{i}.
\end{itemdescr}

\rSec4[range.adaptors.split_view.inner_iterator.star]{\tcode{split_view::inner_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr decltype(auto) operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\effects Equivalent to: }\tcode{\newtxt{return *i_.\placeholdernc{current};}}

\oldtxt{\returns \tcode{*\placeholdernc{current}(i_)}.}
\end{itemdescr}

\rSec4[range.adaptors.split_view.inner_iterator.inc]{\tcode{split_view::inner_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr @\newtxt{inner_iterator\&}@ @\oldtxt{decltype(auto)}@ operator++() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
@\oldtxt{++\placeholdernc{current}(i_);}@
@\newtxt{++i_.\placeholdernc{current};}@
@\placeholdernc{zero}\oldtxt{_}@ = true;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr @\newtxt{decltype(auto)} \oldtxt{void}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
{\color{newclr}
If \tcode{Rng} models \libconcept{ForwardRange}, equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
Otherwise,
} %% \color{newclr}
equivalent to \tcode{\oldtxt{(void)}++*this}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator++}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr inner_iterator operator++(int) requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}
} %% \color{oldclr}

\rSec4[range.adaptors.split_view.inner_iterator.comp]{\tcode{split_view::inner_iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const inner_iterator& x, const inner_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.i_.current_ == y.i_.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const inner_iterator& x, const inner_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

{\color{newclr}
\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const inner_iterator& x, default_sentinel);
friend constexpr bool operator==(default_sentinel, const inner_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto cur = x.i_.@\placeholdernc{current}@;
auto end = ranges::end(x.i_.parent_->base_);
if (cur == end) return true;
auto [pcur, pend] = subrange{x.i_.parent_->pattern_};
if (pcur == pend) return x.@\placeholdernc{zero}@;
do {
  if (*cur != *pcur) return false;
  if (++pcur == pend) return true;
} while (++cur != end);
return false;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const inner_iterator& x, default_sentinel y);
friend constexpr bool operator!=(default_sentinel y, const inner_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}
} %% \color{newclr}

\rSec4[range.adaptors.split_view.inner_iterator.nonmember]{\tcode{split_view::inner_iterator} non-member functions}

\indexlibrary{\idxcode{iter_move}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr decltype(auto) iter_move(const inner_iterator& i)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(i.i_.\placeholdernc{current}))}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\effects }\tcode{\newtxt{ranges::iter_move(i.i_.\placeholdernc{current})}}\newtxt{.}

\oldtxt{\returns }\tcode{\oldtxt{ranges::iter_move(\placeholdernc{current}(i.i_))}}\oldtxt{.}

\pnum
\oldtxt{\remarks The expression in the \tcode{noexcept} clause is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_move(\placeholdernc{current}(i.i_)))}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr void iter_swap(const inner_iterator& x, const inner_iterator& y)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.i_.\placeholdernc{current}, y.i_.\placeholdernc{current}))}@)
  requires IndirectlySwappable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(\placeholdernc{current}(x.i_), \placeholdernc{current}(y.i_))}.

\pnum
\oldtxt{\remarks The expression in the \tcode{noexcept} clause is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_swap(\placeholdernc{current}(x.i_), \placeholdernc{current}(y.i_)))}@
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
\rSec3[range.adaptors.split_view.inner_sentinel]{Class template \tcode{split_view::inner_sentinel}}

\pnum
\begin{note}
\tcode{split_view::inner_sentinel} is an exposition-only type.
\end{note}

\begin{codeblock}
namespace std { namespace ranges {
  template<class Rng, class Pattern>
  template<bool Const>
  struct split_view<Rng, Pattern>::inner_sentinel {
    friend constexpr bool operator==(const inner_iterator<Const>& x, inner_sentinel);
    friend constexpr bool operator==(inner_sentinel x, const inner_iterator<Const>& y);
    friend constexpr bool operator!=(const inner_iterator<Const>& x, inner_sentinel y);
    friend constexpr bool operator!=(inner_sentinel x, const inner_iterator<Const>& y);
  };
}}
\end{codeblock}

\rSec4[range.adaptors.split_view.inner_sentinel.comp]{\tcode{split_view::inner_sentinel} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const inner_iterator<Const>& x, inner_sentinel)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto cur = x.i_.@\placeholdernc{current}@();
auto end = ranges::end(x.i_.parent_->base_);
if (cur == end) return true;
auto [pcur, pend] = subrange{x.i_.parent_->pattern_};
if (pcur == pend) return x.zero_;
do {
  if (*cur != *pcur) return false;
  if (++pcur == pend) return true;
} while (++cur != end);
return false;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(inner_sentinel x, const inner_iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y == x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::inner_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const inner_iterator<Const>& x, inner_sentinel y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::inner_sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(inner_sentinel x, const inner_iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y == x);}
\end{itemdescr}
} %% \color{oldclr}

\rSec2[range.adaptors.split]{\tcode{view::split}}

\pnum
The name \tcode{view::split} denotes a range adaptor
object\iref{range.adaptor.object}.
\oldtxt{Let \tcode{E} and \tcode{F} be expressions such that their types are
\tcode{T} and \tcode{U} respectively. Then} The expression
\tcode{view::split(E, F)} \newtxt{for some subexpressions \tcode{E} and
\tcode{F}} is expression-equivalent to \tcode{split_view\{E, F\}}\newtxt{.}
\oldtxt{if either of the following sets of requirements is satisfied:}
{\color{oldclr}
\begin{itemize}
\item \begin{codeblock}
InputRange<T> && ForwardRange<U> &&
ViewableRange<T> && ViewableRange<U> &&
IndirectlyComparable<iterator_t<T>, iterator_t<U>> &&
(ForwardRange<T> || @\placeholdernc{tiny-range}@<U>)
\end{codeblock}

\item \begin{codeblock}
InputRange<T> && ViewableRange<T> &&
IndirectlyComparable<iterator_t<T>, const value_type_t<iterator_t<T>>*> &&
CopyConstructible<value_type_t<iterator_t<T>>> &&
ConvertibleTo<U, value_type_t<iterator_t<T>>>
\end{codeblock}
\end{itemize}
Otherwise, \tcode{view::split(E, F)} is ill-formed.
} %% \color{oldclr}


\rSec2[range.adaptors.counted]{\tcode{view::counted}}

\pnum
The name \tcode{view::counted} denotes a customization point
object\cxxiref{customization.point.object}.
Let \tcode{E} and \tcode{F} be expressions such that their decayed types are \tcode{T}
and \tcode{U} respectively. Then the expression \tcode{view::counted(E, F)} is
expression-equivalent to:

\begin{itemize}
{\color{newclr}
\item If \tcode{T} models \libconcept{Iterator} and \tcode{U} models
\libconcept{ConvertibleTo<iter_difference_t<T>>},
} %% \color{newclr}
  \begin{itemize}
  \item \tcode{subrange\{E, E + F\}} if \tcode{T} \newtxt{models
  \libconcept{ContiguousIterator}.} \oldtxt{is a pointer to an object type, and
  if \tcode{U} is implicitly convertible to \tcode{ptrdiff_t}.}

  \item Otherwise, \tcode{subrange\{counted_iterator(E,
  static_cast<\newtxt{iter_}difference\oldtxt{_type}_t<T>>(F)),
  default_sentinel\{\}\}}\newtxt{.} \oldtxt{if }\tcode{\oldtxt{Iterator<T> \&\&
  ConvertibleTo<U, difference_type_t<T>{}>}}\oldtxt{ is satisfied.}
\end{itemize}

\item Otherwise, \tcode{view::counted(E, F)} is ill-formed.
\end{itemize}

\rSec2[range.adaptors.common_view]{Class template \tcode{common_view}}

\pnum
\oldtxt{The} \tcode{common_view} takes a \newtxt{\libconcept{View}}
\oldtxt{range} which has different types for its iterator and sentinel and turns
it into an equivalent \newtxt{\libconcept{View}} \oldtxt{range} where the
iterator and sentinel have the same type.

\pnum
\begin{note}
\tcode{common_view} is useful for calling legacy algorithms that expect
a range's iterator and sentinel types to be the same.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
// Legacy algorithm:
template<class ForwardIterator>
size_t count(ForwardIterator first, ForwardIterator last);

template<ForwardRange R>
void my_algo(R&& r) {
  auto&& common = common_view{r};
  auto cnt = count(common.begin(), common.end());
  // ...
}
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<View Rng>
    requires !CommonRange<Rng>
  class common_view : public view_interface<common_view<Rng>> {
  private:
    Rng base_ {}; // \expos
  public:
    common_view() = default;

    explicit constexpr common_view(Rng rng);

    template<ViewableRange O>
      requires !CommonRange<O> && Constructible<Rng, all_view<O>>
    explicit constexpr common_view(O&& o);

    constexpr Rng base() const;

    constexpr auto size() const requires SizedRange<const Rng>;

    constexpr auto begin();
    constexpr auto begin() const requires Range<const Rng>;

    constexpr auto begin()
      requires RandomAccessRange<Rng> && SizedRange<Rng>;
    constexpr auto begin() const
      requires RandomAccessRange<const Rng> && SizedRange<const Rng>;

    constexpr auto end();
    constexpr auto end() const requires Range<const Rng>;

    constexpr auto end()
      requires RandomAccessRange<Rng> && SizedRange<Rng>;
    constexpr auto end() const
      requires RandomAccessRange<const Rng> && SizedRange<Rng>;
  };

  template<@\oldtxt{ViewableRange}\newtxt{class}@ O>
    @\oldtxt{requires !CommonRange<O>}@
  common_view(O&&) -> common_view<all_view<O>>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.common_view.ops]{\tcode{common_view} operations}

\indexlibrary{\idxcode{common_view}!\idxcode{common_view}}%
\begin{itemdecl}
explicit constexpr common_view(Rng base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrary{\idxcode{common_view}!\idxcode{common_view}}%
\begin{itemdecl}
template<ViewableRange O>
  requires !CommonRange<O> && Constructible<Rng, all_view<O>>
explicit constexpr common_view(O&& o);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr Rng base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} base_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto size() const requires SizedRange<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::size(base_);}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto begin();
constexpr auto begin() const requires Range<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{Let \tcode{R} be \tcode{Rng} or \tcode{const Rng} for the first and
second overloads, respectively.}

\pnum
\effects Equivalent to:
\begin{codeblock}
return common_iterator<iterator_t<R@\oldtxt{ng}@>, sentinel_t<R@\oldtxt{ng}@>>(ranges::begin(base_));
\end{codeblock}
\oldtxt{and}
\begin{codeblock}
@\oldtxt{return common_iterator<iterator_t<const Rng>, sentinel_t<const Rng>>(ranges::begin(base_));}@
\end{codeblock}
\oldtxt{for the first and second overloads, respectively.}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto begin()
  requires RandomAccessRange<Rng> && SizedRange<Rng>;
constexpr auto begin() const
  requires RandomAccessRange<const Rng> && SizedRange<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(base_);}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto end();
constexpr auto end() const requires Range<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{Let \tcode{R} be \tcode{Rng} or \tcode{const Rng} for the first and
second overloads, respectively.}

\pnum
\effects Equivalent to:
\begin{codeblock}
return common_iterator<iterator_t<R@\oldtxt{ng}@>, sentinel_t<R@\oldtxt{ng}@>>(ranges::end(base_));
\end{codeblock}
\oldtxt{and}
\begin{codeblock}
@\oldtxt{return common_iterator<iterator_t<const Rng>, sentinel_t<const Rng>>(ranges::end(base_));}@
\end{codeblock}
\oldtxt{for the first and second overloads, respectively.}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto end()
  requires RandomAccessRange<Rng> && SizedRange<Rng>;
constexpr auto end() const
  requires RandomAccessRange<const Rng> && SizedRange<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(base_) + ranges::size(base_);}
\end{itemdescr}

\rSec2[range.adaptors.common]{\tcode{view::common}}

\pnum
The name \tcode{view::common} denotes a range adaptor
object\iref{range.adaptor.object}. \oldtxt{Let \tcode{E} be an expression such
that \tcode{U} is \tcode{decltype((E))}.} Then the expression
\tcode{view::common(E)} is expression-equivalent to:

\begin{itemize}
\item If \oldtxt{\tcode{ViewableRange<U> \&\&}} \newtxt{\tcode{decltype((E))}
models} \libconcept{CommonRange}\tcode{\oldtxt{<U>}}\oldtxt{ is satisfied,}
\tcode{view::all(E)}\newtxt{, if that is a well-formed expression}.

\item Otherwise, \oldtxt{if \tcode{ViewableRange<U>} is satisfied,}
\tcode{common_view\{E\}}\newtxt{, if that is a well-formed expression}.

\item Otherwise, \tcode{view::common(E)} is ill-formed.
\end{itemize}


\rSec2[range.adaptors.reverse_view]{Class template \tcode{reverse_view}}

\pnum
\oldtxt{The} \tcode{reverse_view} takes a bidirectional \libconcept{View}
\oldtxt{range} and produces another \libconcept{View} \oldtxt{range} that
iterates the same elements in reverse order.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is {0,1,2,3,4};
reverse_view rv {is};
for (int i : rv)
  cout << i << ' '; // prints: 4 3 2 1 0
\end{codeblock}
\end{example}

\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<View Rng>
    requires BidirectionalRange<Rng>
  class reverse_view : public view_interface<reverse_view<Rng>> {
  private:
    Rng base_ {}; // \expos
  public:
    reverse_view() = default;

    explicit constexpr reverse_view(Rng rng);

    template<ViewableRange O>
      requires BidirectionalRange<O> && Constructible<Rng, all_view<O>>
    explicit constexpr reverse_view(O&& o);

    constexpr Rng base() const;

    constexpr auto begin();
    constexpr auto begin() requires CommonRange<Rng>;
    constexpr auto begin() const requires CommonRange<const Rng>;

    constexpr auto end();
    constexpr auto end() const requires CommonRange<const Rng>;

    constexpr auto size() const requires SizedRange<const Rng>;
  };

  template<@\oldtxt{ViewableRange}\newtxt{class}@ O>
    @\oldtxt{requires BidirectionalRange<O>}@
  reverse_view(O&&) -> reverse_view<all_view<O>>;
}@\oldtxt{\}}@
\end{codeblock}

\rSec3[range.adaptors.reverse_view.ops]{\tcode{reverse_view} operations}

\indexlibrary{\idxcode{reverse_view}!\idxcode{reverse_view}}%
\begin{itemdecl}
explicit constexpr reverse_view(Rng base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrary{\idxcode{reverse_view}!\idxcode{reverse_view}}%
\begin{itemdecl}
template<ViewableRange O>
  requires BidirectionalRange<O> && Constructible<Rng, all_view<O>>
explicit constexpr reverse_view(O&& o);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<O>(o))}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr Rng base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns} \newtxt{\effects Equivalent to:} \tcode{\newtxt{return} base_\newtxt{;}}\oldtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr auto begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return reverse_iterator{ranges::next(ranges::begin(base_), ranges::end(base_))};
\end{codeblock}

\pnum
\remarks In order to provide the amortized constant time complexity required by
the \libconcept{Range} concept, this function caches the result within the
\tcode{reverse_view} for use on subsequent calls.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr auto begin() requires CommonRange<Rng>;
constexpr auto begin() const requires CommonRange<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return reverse_iterator\{ranges::end(base_)\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr auto end() requires CommonRange<Rng>;
constexpr auto end() const requires CommonRange<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return reverse_iterator\{ranges::begin(base_)\};}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr auto size() const requires SizedRange<const Rng>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::size(base_);}
\end{itemdescr}

\rSec2[range.adaptors.reverse]{\tcode{view::reverse}}

\pnum
The name \tcode{view::reverse} denotes a range adaptor
object\iref{range.adaptor.object}. \oldtxt{Let \tcode{E} be an expression such
that \tcode{U} is \tcode{decltype((E))}. Then} The expression
\tcode{view::reverse(E)} \newtxt{for some subexpression \tcode{E}} is
expression-equivalent to \oldtxt{If \tcode{ViewableRange<U> \&\&
BidirectionalRange<U>} is satisfied,} \tcode{reverse_view\{E\}}.
\oldtxt{Otherwise, \tcode{view::reverse(E)} is ill-formed.}
} %% \color{addclr}
