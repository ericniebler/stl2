%!TEX root = P0896.tex

\ednote{Add a new clause between [iterators] and [algorithms] with the following content:}
\begin{addedblock}
\rSec0[range]{Ranges library}

\rSec1[range.general]{General}

\pnum
This clause describes components for dealing with ranges of elements.

\pnum
The following subclauses describe
range and view requirements, and
components for
range primitives
as summarized in \tref{range.summary}.

\begin{libsumtab}{Ranges library summary}{tab:range.summary}
  \ref{range.access}       & Range access      & \tcode{<ranges>} \\
  \ref{range.primitives}   & Range primitives  & \\
  \ref{range.requirements} & Requirements      & \\
  \ref{range.utility}      & Range utilities   & \\
  \ref{range.adaptors}     & Range adaptors    & \\
\end{libsumtab}

\pnum
Several places in this clause use the expression \tcode{\placeholdernc{DECAY_COPY}(x)}
\newtxt{with semantics as defined in \ref{thread.decaycopy}.}
\oldtxt{which is expression-equivalent to:}
\begin{codeblock}
@\oldtxt{decay_t<decltype((x))>(x)}@
\end{codeblock}


\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\indexlibrary{\idxhdr{ranges}}%
\begin{codeblock}
#include <initializer_list>
#include <iterator>

namespace std@\newtxt{::ranges}@ {
  @\oldtxt{namespace ranges \{}@
  inline namespace @\unspec@ {
    // \ref{range.access}, range access
    inline constexpr @\unspec@ begin = @\unspecnc@;
    inline constexpr @\unspec@ end = @\unspecnc@;
    inline constexpr @\unspec@ cbegin = @\unspecnc@;
    inline constexpr @\unspec@ cend = @\unspecnc@;
    inline constexpr @\unspec@ rbegin = @\unspecnc@;
    inline constexpr @\unspec@ rend = @\unspecnc@;
    inline constexpr @\unspec@ crbegin = @\unspecnc@;
    inline constexpr @\unspec@ crend = @\unspecnc@;

    // \ref{range.primitives}, range primitives
    inline constexpr @\unspec@ size = @\unspecnc@;
    inline constexpr @\unspec@ empty = @\unspecnc@;
    inline constexpr @\unspec@ data = @\unspecnc@;
    inline constexpr @\unspec@ cdata = @\unspecnc@;
  }

  // \ref{range.range}, Range
  template<class T>
    using iterator_t = decltype(ranges::begin(declval<T&>()));

  template<class T>
    using sentinel_t = decltype(ranges::end(declval<T&>()));

  template<@\oldtxt{Range}\newtxt{\placeholder{fowarding-range}}@ R>
    using safe_iterator_t = @\oldtxt{decltype(ranges::begin(declval<R>()))}\newtxt{iterator_t<R>}@;

  template<class T>
    concept Range = @\seebelownc@;

  // \ref{range.sized}, SizedRange
  template<class>
    inline constexpr bool disable_sized_range = false;

  template<class T>
    concept SizedRange = @\seebelownc@;

  // \ref{range.view}, View
  template<class T>
  @\oldtxt{struct enable_view \{ \};}@
  @\newtxt{inline constexpr bool enable_view = \seebelownc;}@

  struct view_base { };

  template<class T>
    concept View = @\seebelownc@;

  // \ref{range.refinements}, \oldtxt{OutputRange} \newtxt{common range refinements}
  template<class R, class T>
    concept OutputRange = @\seebelownc@;

  @\oldtxt{// \ref{range.refinements}, InputRange}@
  template<class T>
    concept InputRange = @\seebelownc@;

  @\oldtxt{// \ref{range.refinements}, ForwardRange}@
  template<class T>
    concept ForwardRange = @\seebelownc@;

  @\oldtxt{// \ref{range.refinements}, BidirectionalRange}@
  template<class T>
    concept BidirectionalRange = @\seebelownc@;

  @\oldtxt{// \ref{range.refinements}, RandomAccessRange}@
  template<class T>
    concept RandomAccessRange = @\seebelownc@;

  @\oldtxt{// \ref{range.refinements}, ContiguousRange}@
  template<class T>
    concept ContiguousRange = @\seebelownc@;

  @\oldtxt{// \ref{range.refinements}, CommonRange}@
  template<class T>
    concept CommonRange = @\seebelownc@;

  @\oldtxt{// \ref{range.refinements}}@
  template<class T>
    concept ViewableRange = @\seebelownc@;

  // \ref{range.view_interface}\newtxt{, class template }\tcode{\newtxt{view_interface}}
  template<class D>
    requires is_class_v<D>
  class view_interface;

  // \ref{range.subrange}\newtxt{, sub-ranges}
  enum class subrange_kind : bool { unsized, sized };

  template<Iterator I, Sentinel<I> S = I, subrange_kind K = @\seebelownc@>
    requires @\newtxt{(}@K == subrange_kind::sized || !SizedSentinel<S, I>@\newtxt{)}@
  class subrange;

  @\newtxt{template<\placeholder{forwarding-range} R>}@
    @\newtxt{using safe_subrange_t = subrange<iterator_t<R>>;}@

  // \ref{range.all}\newtxt{, all view}
  namespace view { inline constexpr @\unspec@ all = @\unspecnc@; }

  template<ViewableRange R>
    using all_view = decltype(view::all(declval<R>()));

  // \ref{range.filter}\newtxt{, filter view}
  template<InputRange V, IndirectUnaryPredicate<iterator_t<V>> Pred>
    requires View<V>
  class filter_view;

  namespace view { inline constexpr @\unspec@ filter = @\unspecnc@; }

  // \ref{range.transform}\newtxt{, transform view}
  template<InputRange V, CopyConstructible F>
    requires View<V> && is_object_v<F> && @\newtxt{Regular}@Invocable<F&, iter_reference_t<iterator_t<V>>>
  class transform_view;

  namespace view { inline constexpr @\unspec@ transform = @\unspecnc@; }

  // \ref{range.iota}\newtxt{, iota view}
  template<WeaklyIncrementable W, Semiregular Bound = unreachable>
    requires @\placeholder{weakly-equality-comparable-with}@<W, Bound>
  class iota_view;

  namespace view { inline constexpr @\unspec@ iota = @\unspecnc@; }

  // \ref{range.take}\newtxt{, take view}
  template<View> class take_view;

  namespace view { inline constexpr @\unspec@ take = @\unspecnc@; }

  // \ref{range.join}\newtxt{, join view}
  template<InputRange V>
    requires View<V> && InputRange<iter_reference_t<iterator_t<V>>> &&
        (is_reference_v<iter_reference_t<iterator_t<V>>> ||
         View<iter_value_t<iterator_t<V>>>)
  class join_view;

  namespace view { inline constexpr @\unspec@ join = @\unspecnc@; }

  // \ref{range.empty}\newtxt{, range factory \tcode{view::empty}}
  template<class T>
    requires is_object_v<T>
  class empty_view;

  namespace view {
    template<class T>
      inline constexpr empty_view<T> empty {};
  }

  // \ref{range.single}\newtxt{, range factory \tcode{view::single}}
  template<CopyConstructible T>
    requires is_object_v<T>
  class single_view;

  namespace view { inline constexpr @\unspec@ single = @\unspecnc@; }

  // \ref{range.split}\newtxt{, split view}
  template<class R>
    concept @\placeholder{tiny-range}@ = @\seebelownc@; // \expos

  template<InputRange V, ForwardRange Pattern>
    requires View<V> && View<Pattern> &&
        IndirectlyComparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to<>> &&
        (ForwardRange<V> || @\placeholder{tiny-range}@<Pattern>)
  class split_view;

  namespace view { inline constexpr @\unspec@ split = @\unspecnc@; }

  // \ref{range.counted}\newtxt{, counted view}
  namespace view { inline constexpr @\unspec@ counted = @\unspecnc@; }

  // \ref{range.common}\newtxt{, common view}
  template<View V>
    requires @\newtxt{(}@!CommonRange<V>@\newtxt{)}@
  class common_view;

  namespace view { inline constexpr @\unspec@ common = @\unspecnc@; }

  // \ref{range.reverse}\newtxt{, reverse view}
  template<View V>
    requires BidirectionalRange<V>
  class reverse_view;

  namespace view { inline constexpr @\unspec@ reverse = @\unspecnc@; }
}

@\newtxt{namespace std \{}@
  namespace view = ranges::view;

  template<class I, class S, ranges::subrange_kind K>
  struct tuple_size<ranges::subrange<I, S, K>>
    : integral_constant<size_t, 2> {};
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<0, ranges::subrange<I, S, K>> {
    using type = I;
  };
  template<class I, class S, ranges::subrange_kind K>
  struct tuple_element<1, ranges::subrange<I, S, K>> {
    using type = S;
  };
}
\end{codeblock}

\rSec1[range.access]{Range access}

\ednote{This wording integrates the PR for
\href{https://github.com/ericniebler/stl2/issues/547}{stl2\#547}.}

\pnum
In addition to being available via inclusion of the \tcode{<ranges>}
header, the customization point objects in \ref{range.access} are
available when \tcode{<iterator>} is included.

\rSec2[range.access.begin]{\tcode{ranges::begin}}
\pnum
The name \tcode{\newtxt{ranges::}begin} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::begin(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  \tcode{(E) + 0} if \tcode{E} is an lvalue of array type\cxxiref{basic.compound}.

\item
  Otherwise, if \tcode{E} is an lvalue,
  \tcode{\placeholdernc{DECAY_COPY}((E).begin())}
  if it is a valid expression and its type \tcode{I} models \tcode{Iterator}.

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(begin(E))} if it is a
  valid expression and its type \tcode{I} models \tcode{Iterator} with overload
  resolution performed in a context that includes the declarations:
  \begin{codeblock}
  template<class T> void begin(T&&) = delete;
  template<class T> void begin(initializer_list<T>&&) = delete;
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::begin}.

\item
  Otherwise, \tcode{ranges::begin(E)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::begin(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::begin(E)} is a valid expression, its type models
\tcode{Iterator}.
\end{note}

\rSec2[range.access.end]{\tcode{ranges::end}}
\pnum
The name \tcode{\newtxt{ranges::}end} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::end(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  \tcode{(E) + extent_v<T>} if \tcode{E} is an lvalue of array
  type\cxxiref{basic.compound} \tcode{T}.

\item
  Otherwise, if \tcode{E} is an lvalue,
  \tcode{\placeholdernc{DECAY_COPY}((E).end())}
  if it is a valid expression and its type \tcode{S} models
  \tcode{Sentinel<decltype(\brk{}ranges::\brk{}begin(E))>}.

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(end(E))} if it is a valid
  expression and its type \tcode{S} models
  \tcode{Sentinel<decltype(\brk{}ranges::\brk{}begin(E))>} with overload
  resolution performed in a context that includes the declarations:
  \begin{codeblock}
  template<class T> void end(T&&) = delete;
  template<class T> void end(initializer_list<T>&&) = delete;
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::end}.

\item
  Otherwise, \tcode{ranges::end(E)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::end(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::end(E)} is a valid expression, the
types \newtxt{\tcode{S} and \tcode{I}} of \tcode{ranges::end(E)} and \tcode{ranges::begin(E)} model
\libconcept{Sentinel\newtxt{<S, I>}}.
\end{note}

\rSec2[range.access.cbegin]{\tcode{ranges::cbegin}}
\pnum
The name \tcode{\newtxt{ranges::}cbegin} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::cbegin(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::begin(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.
\item Otherwise, \tcode{ranges::begin(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::cbegin(E)} is a valid expression, its type models
\tcode{Iterator}.
\end{note}

\rSec2[range.access.cend]{\tcode{ranges::cend}}
\pnum
The name \tcode{\newtxt{ranges::}cend} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::cend(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:

\begin{itemize}
\item \tcode{ranges::end(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.
\item Otherwise, \tcode{ranges::end(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::cend(E)} is a valid expression, the
types \newtxt{\tcode{S} and \tcode{I}} of \tcode{ranges::cend(E)} and \tcode{ranges::cbegin(E)} model
\libconcept{Sentinel\newtxt{<S, I>}}.
\end{note}

\rSec2[range.access.rbegin]{\tcode{ranges::rbegin}}
\pnum
The name \tcode{\newtxt{ranges::}rbegin} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::rbegin(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  If \tcode{E} is an lvalue, \tcode{\placeholdernc{DECAY_COPY}((E).rbegin())}
  if it is a valid expression and its type \tcode{I} models \tcode{Iterator}.

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(rbegin(E))} if it is a valid
  expression and its type \tcode{I} models \tcode{Iterator} with overload
  resolution performed in a context that includes the declaration:
  \begin{codeblock}
  template<class T> void rbegin(T&&) = delete;
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::rbegin}.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::end(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges::\brk{}end(\brk{}E)} are valid
  expressions of the same type \tcode{I} which models
  \libconcept{BidirectionalIterator}\iref{iterator.concept.bidirectional}.

\item
  Otherwise, \tcode{ranges::rbegin(E)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::rbegin(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::rbegin(E)} is a valid expression, its type models
\tcode{Iterator}.
\end{note}

\rSec2[range.access.rend]{\tcode{ranges::rend}}
\pnum
The name \tcode{\newtxt{ranges::}rend} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::rend(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  If \tcode{E} is an lvalue, \tcode{\placeholdernc{DECAY_COPY}((E).rend())}
  if it is a valid expression and its type \tcode{S} models
  \tcode{Sentinel<decltype(\brk{}ranges::\brk{}rbegin(E))>}.

\item
  Otherwise, \tcode{\placeholdernc{DECAY_COPY}(rend(E))} if it is a valid
  expression and its type \tcode{S} models
  \tcode{Sentinel<\brk{}decltype(\brk{}ranges::rbegin(E))>} with overload
  resolution performed in a context that includes the declaration:
  \begin{codeblock}
  template<class T> void rend(T&&) = delete;
  \end{codeblock}
  and does not include a declaration of \tcode{ranges::rend}.

\item
  Otherwise, \tcode{make_reverse_iterator(ranges::begin(E))} if both
  \tcode{ranges::begin(E)} and \tcode{ranges::end(\brk{}E)} are valid
  expressions of the same type \tcode{I} which models
  \tcode{BidirectionalIterator}\iref{iterator.concept.bidirectional}.

\item
  Otherwise, \tcode{ranges::rend(E)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::rend(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::rend(E)} is a valid expression, the
types \newtxt{\tcode{S} and \tcode{I}} of \tcode{ranges::rend(E)} and \tcode{ranges::rbegin(E)}
model \libconcept{Sentinel\newtxt{<S, I>}}.
\end{note}

\rSec2[range.access.crbegin]{\tcode{ranges::crbegin}}
\pnum
The name \tcode{\newtxt{ranges::}crbegin} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::\brk{}crbegin(E)} for some subexpression \tcode{E} of type
\tcode{T} is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::\brk{}rbegin(static_cast<const T\&>(E))} if \tcode{E} is
  an lvalue.
\item Otherwise, \tcode{ranges::rbegin(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::crbegin(E)} is a valid expression, its
type models \tcode{Iterator}.
\end{note}

\rSec2[range.access.crend]{\tcode{ranges::crend}}
\pnum
The name \tcode{\newtxt{ranges::}crend} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::crend(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::rend(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.

\item Otherwise, \tcode{ranges::rend(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::crend(E)} is a valid expression, the
types \newtxt{\tcode{S} and \tcode{I}} of \tcode{ranges::crend(E)} and \tcode{ranges::crbegin(E)}
model \libconcept{Sentinel\newtxt{<S, I>}}.
\end{note}

\rSec1[range.primitives]{Range primitives}

\pnum
In addition to being available via inclusion of the \tcode{<ranges>} header,
the customization point objects in \ref{range.primitives} are available
when \tcode{<iterator>} is included.

\rSec2[range.primitives.size]{\tcode{size}}
\pnum
The name \tcode{size} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::size(E)} for some subexpression \tcode{E} with type
\tcode{T} is expression-equivalent to:

\begin{itemize}
\item
  \tcode{\placeholdernc{DECAY_COPY}(extent_v<T>)} if \tcode{T} is an array
  type\cxxiref{basic.compound}.

\item
  \newtxt{Otherwise, if
  }\tcode{\newtxt{disable_sized_range<remove_cv_t<T>>}}\newtxt{\iref{range.sized}
  is \tcode{false}:}
  \begin{itemize}
  \item
    \oldtxt{Otherwise,} \tcode{\placeholdernc{DECAY_COPY}(E.size())}
    if it is a valid expression and its type \tcode{I} models
    \libconcept{Integral} \oldtxt{and
    }\tcode{\oldtxt{disable_sized_range<remove_cvref_t<T>>}}\oldtxt{\iref{range.sized}
    is \tcode{false}}.

  \item
    Otherwise, \tcode{\placeholdernc{DECAY_COPY}(size(E))}
    if it is a valid expression and its type \tcode{I} models
    \libconcept{Integral} with overload resolution
    performed in a context that includes the declaration:
    \begin{codeblock}
    template<class T> void size(T&&) = delete;
    \end{codeblock}
    and does not include a declaration of \tcode{ranges::size}\oldtxt{, and
    }\tcode{\oldtxt{disable_sized_range<remove_cvref_t<T>>}}\oldtxt{ is \tcode{false}}.
  \end{itemize}

\item
  Otherwise, \newtxt{\tcode{DIFF}, where \tcode{DIFF} is}
  \tcode{\placeholdernc{\oldtxt{DECAY_COPY}}(ranges::end(E) - ranges::begin(E))}
  except that \tcode{E} is only evaluated once, if \oldtxt{it} \newtxt{\tcode{DIFF}} is a valid expression and
  the types \tcode{I} and \tcode{S} of \tcode{ranges::begin(E)} and
  \tcode{ranges::end(\brk{}E)} model
  \tcode{SizedSentinel<S, I>}\iref{iterator.concept.sizedsentinel} and
  \tcode{ForwardIterator<I>}.

\item
  Otherwise, \tcode{ranges::size(E)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::size(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::size(E)} is a valid expression, its
type models \libconcept{Integral}.
\end{note}

\rSec2[range.primitives.empty]{\tcode{empty}}
\pnum
The name \tcode{empty} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::empty(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  \tcode{bool((E).empty())} if it is a valid expression.

\item
  Otherwise, \tcode{(ranges::size(E) == 0)} if it is a valid expression.

\item
  Otherwise, \newtxt{\tcode{EQ}, where \tcode{EQ} is}
  \tcode{bool(ranges::begin(E) == ranges::end(E))}
  except that \tcode{E} is only evaluated once, if \oldtxt{it}
  \newtxt{\tcode{EQ}} is a valid expression and the type of
  \tcode{ranges::begin(E)} models \libconcept{ForwardIterator}.

\item
  Otherwise, \tcode{ranges::empty(E)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::empty(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::empty(E)} is a valid expression,
it has type \tcode{bool}.
\end{note}

\rSec2[range.primitives.data]{\tcode{data}}
\pnum
The name \tcode{data} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::data(E)} for some subexpression \tcode{E} is
expression-equivalent to:

\begin{itemize}
\item
  If \tcode{E} is an lvalue, \tcode{\placeholdernc{DECAY_COPY}((E).data())}
  if it is a valid expression of pointer to object type.

\item
  \oldtxt{Otherwise, \tcode{ranges::begin(E)} if it is a valid expression
  of pointer to object type.}

\item
  Otherwise, if \tcode{ranges::begin(E)} is a valid expression whose type models
  \tcode{ContiguousIterator},
  \begin{codeblock}
  ranges::begin(E) == ranges::end(E) ? nullptr : addressof(*ranges::begin(E))
  \end{codeblock}
  except that \tcode{E} is evaluated only once.

\item
  Otherwise, \tcode{ranges::data(E)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{ranges::data(E)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::data(E)} is a valid expression, it
has pointer to object type.
\end{note}

\rSec2[range.primitives.cdata]{\tcode{cdata}}
\pnum
The name \tcode{cdata} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::cdata(E)} for some subexpression \tcode{E} of type \tcode{T}
is expression-equivalent to:
\begin{itemize}
\item \tcode{ranges::data(static_cast<const T\&>(E))} if \tcode{E} is an lvalue.

\item Otherwise, \tcode{ranges::data(static_cast<const T\&\&>(E))}.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::cdata(E)} is a valid expression, it
has pointer to object type.
\end{note}

\rSec1[range.requirements]{Range requirements}

\rSec2[range.requirements.general]{General}

\pnum
Ranges are an abstraction \oldtxt{of containers} that allow a \Cpp program to
operate on elements of data structures uniformly. \oldtxt{In their simplest form, a
range object is one on which one can call \tcode{begin} and
\tcode{end} to get an iterator\iref{iterator.concept.iterator} and a
sentinel\iref{iterator.concept.sentinel}. To be able to construct
template algorithms and range adaptors that work correctly and efficiently on
different types of sequences, the library formalizes not just the interfaces but
also the semantics and complexity assumptions of ranges.}
\newtxt{Calling \tcode{ranges::begin} on a range returns an object
whose type models \libconcept{Iterator}\iref{iterator.concept.iterator}.
Calling \tcode{ranges::end} on a range returns an object whose type \tcode{S},
together with the type \tcode{I} of the object returned by \tcode{ranges::begin},
models \libconcept{Sentinel<S, I>}.
The library formalizes the interfaces, semantics, and complexity of ranges to
enable algorithms and range adaptors that work efficiently on different types
of sequences.}

\pnum
\oldtxt{This document defines three fundamental categories of ranges
based on the syntax and semantics supported by each: \term{range},
\term{sized range} and \term{view}, as shown in
\tref{range.relations}.}

\begin{floattable}{\oldtxt{Relations among range categories}}{tab:range.relations}
  {lll}
  \topline
  \textbf{\oldtxt{SizedRange}}  &             &                 \\
                       & \oldtxt{$\searrow$}  &                 \\
                       &             & \textbf{\oldtxt{Range}}  \\
                       & \oldtxt{$\nearrow$}  &                 \\
  \textbf{\oldtxt{View}}        &             &                 \\
\end{floattable}

\pnum
The \libconcept{Range} concept requires only that
\tcode{\newtxt{ranges::}begin} and \tcode{\newtxt{ranges::}end}
return an iterator and a sentinel\newtxt{, respectively}.
The \libconcept{SizedRange} concept refines \libconcept{Range} with
the requirement that the number of elements in the range can be determined
in constant time using the \tcode{\newtxt{ranges::}size} function.
The \tcode{View} concept specifies requirements on a \libconcept{Range} type
with constant-time copy and assign operations.

\pnum
\oldtxt{In addition to the three fundamental range categories, this document
defines a number of convenience refinements of \libconcept{Range} that
group together requirements that appear often}
\newtxt{Several refinements of \libconcept{Range} group requirements that
arise frequently} in \oldtxt{the} concepts and algorithms.
Common ranges are ranges for which
\tcode{\newtxt{ranges::}begin} and \tcode{\newtxt{ranges::}end}
return objects of the same type.
Random access ranges are ranges for which \tcode{\newtxt{ranges::}begin}
returns a type that models
\libconcept{RandomAccessIterator}\iref{iterator.concept.random.access}.
(\newtxt{Contiguous,} Bidirectional \oldtxt{ranges}, forward \oldtxt{ranges},
input \oldtxt{ranges}, and output ranges are defined similarly.)
\newtxt{Viewable ranges can be converted to views and stored safely.}

\rSec2[range.range]{Ranges}

\pnum
The \libconcept{Range} concept defines the requirements of a type that allows
iteration over its elements by providing an \oldtxt{\tcode{begin}} iterator and
an \oldtxt{\tcode{end}} sentinel \newtxt{that denote the elements of the range}.
{\color{oldclr}
\begin{note}
\oldtxt{Most algorithms requiring this concept simply forward to an
\libconcept{Iterator}-based algorithm by calling \tcode{begin} and \tcode{end}.}
\end{note}
} %% \color{oldclr}

\indexlibrary{\idxcode{Range}}%
\begin{itemdecl}
template<class T>
  concept @\placeholder{range-impl}@ = // \expos
    requires(T&& t) {
      ranges::begin(std::forward<T>(t)); // \oldtxt{not necessarily} \newtxt{sometimes} equality-preserving (see below)
      ranges::end(std::forward<T>(t));
    };

template<class T>
  concept Range = @\placeholdernc{range-impl}@<T&>;

template<class T>
  concept @\placeholder{forwarding-range}@ = // \expos
    Range<T> && @\placeholder{range-impl}@<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{The required expressions
\tcode{ranges::begin(std::forward<T>(t))}
and
\tcode{ranges::end(std::forward<T>(t))}
of the \tcode{\placeholder{range-impl}} concept
do not require implicit expression variations\cxxiref{concepts.equality}.}

\pnum
Given an expression \tcode{E} such that \tcode{decltype((E))} is \tcode{T},
\tcode{T} models \tcode{\placeholder{range-impl}} only if

\begin{itemize}
\item \range{ranges::begin(E)}{ranges::end(E)}
  denotes a range\iref{iterator.requirements.general},

\item both
\tcode{ranges::begin(E)}
and
\tcode{ranges::end(E)}
are amortized constant time and non-modifying, and

\item if the type of \tcode{ranges::begin(E)} models
\libconcept{ForwardIterator}, \tcode{ranges::begin(E)} is equality-preserving.
\end{itemize}

\pnum
\begin{note}
Equality preservation of both \tcode{ranges::begin} and
\tcode{ranges::end} enables passing a \libconcept{Range} whose iterator
type models \libconcept{ForwardIterator} to multiple
algorithms and making multiple passes over the range by repeated calls to
\tcode{ranges::begin} and \tcode{ranges::end}.
Since \tcode{ranges::begin} is not required to be equality-preserving
when the return type does not model \libconcept{ForwardIterator}, repeated calls
might not return equal values or might not be well-defined;
\tcode{ranges::begin} should be called at most once for such a range.
\end{note}

\pnum
Given an expression \tcode{E} such that \tcode{decltype((E))} is \tcode{T}
\newtxt{and an lvalue \tcode{t} that denotes the same object as \tcode{E}},
\tcode{T} models \tcode{\placeholdernc{forwarding-range}} only if
\begin{itemize}
\item \oldtxt{The expressions} \tcode{ranges::begin(E)} and
  \tcode{ranges::begin(\oldtxt{static_cast<T\&>(E)} \newtxt{t})}
  are expression-equivalent, and
\item \oldtxt{The expressions} \tcode{ranges::end(E)} and
  \tcode{ranges::end(\oldtxt{static_cast<T\&>(E)} \newtxt{t})}
  are expression-equivalent, and
\item \newtxt{the validity of iterators obtained from the object denoted
  by \tcode{E} is not tied to the lifetime of that object.}
\end{itemize}

{\color{newclr}
\pnum
\begin{note}
Since the validity of iterators is not tied to the lifetime of a model of
\tcode{\placeholder{forwarding-range}}, a function can accept a model by value
and return iterators obtained from it without danger of dangling.
\end{note}

\pnum
\begin{example}
Specializations of class template \tcode{subrange}\iref{range.subrange}
model \tcode{\placeholder{forwarding-range}}. \tcode{subrange} provides
non-member rvalue overloads of \tcode{begin} and \tcode{end} with the same
semantics as its member lvalue overloads, and \tcode{subrange}'s iterators
- since they are ``borrowed'' from some other range -
do not have validity tied to the lifetime of a \tcode{subrange} object.
\end{example}
} %% \color{newclr}
\end{itemdescr}

\rSec2[range.sized]{Sized ranges}

\pnum
The \libconcept{SizedRange} concept specifies the requirements
of a \libconcept{Range} type that knows its size in constant time with the
\tcode{size} function.

\indexlibrary{\idxcode{SizedRange}}%
\begin{itemdecl}
template<class T>
  concept SizedRange =
    Range<T> &&
    !disable_sized_range<remove_cvref_t<T>> &&
    requires(T& t) {
      @\oldtxt{\{}@ ranges::size(t) @\oldtxt{\} -> ConvertibleTo<iter_difference_t<iterator_t<T>>>}@;
    };
\end{itemdecl}

\begin{itemdescr}
\pnum
Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{T}
models \libconcept{SizedRange} only if

\begin{itemize}
\item \tcode{ranges::size(t)} is \bigoh{1}, does not modify \tcode{t},
and is equal to \tcode{ranges::distance(t)}, and

\item if \tcode{iterator_t<T>} models \libconcept{ForwardIterator},
\tcode{\newtxt{ranges::}size(t)} is well-defined regardless of the evaluation of
\tcode{\newtxt{ranges::}begin(t)}.
\begin{note}
\tcode{\newtxt{ranges::}size(t)} is otherwise not required \newtxt{to} be
well-defined after evaluating \tcode{\newtxt{ranges::}begin(t)}.
For \newtxt{example, for} a \libconcept{SizedRange} whose iterator type does not
model \libconcept{ForwardIterator}, \oldtxt{for example,}
\tcode{\newtxt{ranges::}size(t)} might only be well-defined if evaluated before
the first call to \tcode{\newtxt{ranges::}begin(t)}.
\end{note}
\end{itemize}

\pnum
\begin{note}
\oldtxt{The} \tcode{disable_sized_range} \oldtxt{predicate provides a mechanism to} enable\newtxt{s} use
of range types with the library that \oldtxt{meet the syntactic requirements} \newtxt{satisfy} but do
not in fact model \libconcept{SizedRange}. \oldtxt{A program that instantiates a library template
that requires a \libconcept{Range} with such a range type \tcode{R} is ill-formed with no
diagnostic required unless
\tcode{disable_sized_range<remove_cvref_t<R>{}>} evaluates
to \tcode{true}\cxxiref{structure.requirements}}.
\end{note}
\end{itemdescr}

\rSec2[range.view]{Views}

\pnum
The \tcode{View} concept specifies the requirements of a \libconcept{Range} type
that has constant time copy, move, and assignment operators; that is, the cost of
these operations is not proportional to the number of elements in the
\tcode{View}.

\pnum
\begin{example}
Examples of \tcode{View}s are:

\begin{itemize}
\item A \libconcept{Range} type that wraps a pair of iterators.

\item A \libconcept{Range} type that holds its elements by \tcode{shared_ptr}
and shares ownership with all its copies.

\item A \libconcept{Range} type that generates its elements on demand.
\end{itemize}

\oldtxt{A} \newtxt{Most} containers\iref{containers} \oldtxt{is}
\newtxt{are} not \oldtxt{a} \libconcept{View}\newtxt{s} since copying the
container copies the elements, which cannot be done in constant time.
\end{example}

\indexlibrary{\idxcode{enable_view}}%
\indexlibrary{\idxcode{View}}%
\begin{itemdecl}
template<class T>
  inline constexpr bool @\newtxt{enable_view}@ @\oldtxt{\placeholder{view-predicate} // \expos}@
    = @\seebelownc@;

template<class T>
  concept View =
    Range<T> &&
    Semiregular<T> &&
    @\oldtxt{\placeholder{view-predicate}} \newtxt{enable_view}@<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Since the difference between \libconcept{Range} and \libconcept{View} is largely
semantic, the two are differentiated with the help of the \tcode{enable_view}
trait. \oldtxt{Users may specialize \tcode{enable_view} to derive from
\tcode{true_type} or \tcode{false_type}.}

\pnum
For a type \tcode{T}, the \newtxt{default} value of
\oldtxt{\tcode{\placeholder{view-predicate}<T>} shall be}
\tcode{\newtxt{enable_view<T>}}\newtxt{ is}:
\begin{itemize}

\item \oldtxt{If the \grammarterm{qualified-id} \tcode{enable_view<T>::type}
  is valid and denotes a type\cxxiref{temp.deduct},
  \tcode{enable_view<T>::type::value}.}
\item \oldtxt{Otherwise,} If \tcode{DerivedFrom<T, view_base>} is \tcode{true},
  \tcode{true}.
\item Otherwise, if \tcode{T} is a specialization of class template
  \tcode{initializer_list}\cxxiref{support.initlist},
  \tcode{set}\cxxiref{set},
  \tcode{multiset}\cxxiref{multiset},
  \tcode{unordered_set}\cxxiref{unord.set}, or
  \tcode{unordered_multiset}\cxxiref{unord.multiset}, \tcode{false}.
\item Otherwise, if both \tcode{T} and \tcode{const T} model \libconcept{Range} and
  \tcode{iter_reference_t<iterator_t<T>{>}} is not the same type as
  \tcode{iter_reference_t<iterator_t<const T>{>}},
  \tcode{false}.
  \begin{note}
  Deep \tcode{const}-ness implies element ownership,
  whereas shallow \tcode{const}-ness implies reference semantics.
  \end{note}
\item Otherwise, \tcode{true}.
\end{itemize}

\pnum
\newtxt{Pursuant to \cxxref{namespace.std}, users may specialize
}\tcode{\newtxt{enable_view}}\newtxt{ to override the default value.}
\end{itemdescr}

\rSec2[range.refinements]{Common range refinements}

\pnum
The \tcode{OutputRange} concept specifies requirements of a
\libconcept{Range} type for which \tcode{\newtxt{ranges::}begin} returns
a model of \tcode{OutputIterator}\iref{iterator.concept.output}.
\newtxt{\tcode{InputRange}, \tcode{ForwardRange}, \tcode{BidirectionalRange},
and \tcode{RandomAccessRange} are defined similarly.}


\indexlibrary{\idxcode{OutputRange}}%
\indexlibrary{\idxcode{InputRange}}%
\indexlibrary{\idxcode{ForwardRange}}%
\indexlibrary{\idxcode{BidirectionalRange}}%
\indexlibrary{\idxcode{RandomAccessRange}}%
\begin{itemdecl}
template<class R, class T>
  concept OutputRange =
    Range<R> && OutputIterator<iterator_t<R>, T>;

template<class T>
  concept InputRange =
    Range<T> && InputIterator<iterator_t<T>>;

template<class T>
  concept ForwardRange =
    InputRange<T> && ForwardIterator<iterator_t<T>>;

template<class T>
  concept BidirectionalRange =
    ForwardRange<T> && BidirectionalIterator<iterator_t<T>>;

template<class T>
  concept RandomAccessRange =
    BidirectionalRange<T> && RandomAccessIterator<iterator_t<T>>;
\end{itemdecl}

\pnum
\newtxt{\tcode{ContiguousRange} breaks this pattern by additionally requiring that
the \tcode{ranges::data} customization point\iref{range.primitives.data}
is usable with the range.}

\indexlibrary{\idxcode{ContiguousRange}}%
\begin{itemdecl}
template<class T>
  concept ContiguousRange =
    RandomAccessRange<T> && ContiguousIterator<iterator_t<T>> &&
    requires(T& t) {
      ranges::data(t);
      requires Same<decltype(ranges::data(t)), add_pointer_t<iter_reference_t<iterator_t<T>>>>;
    };
\end{itemdecl}

\pnum
The \tcode{CommonRange} concept specifies requirements of
a \libconcept{Range} type for which \tcode{\newtxt{ranges::}begin} and
\tcode{\newtxt{ranges::}end} return objects of the same type.
\begin{example}
The standard containers\cxxiref{containers} model \tcode{CommonRange}.
\end{example}

\indexlibrary{\idxcode{CommonRange}}%
\begin{itemdecl}
template<class T>
  concept CommonRange =
    Range<T> && Same<iterator_t<T>, sentinel_t<T>>;
\end{itemdecl}

\pnum
The \libconcept{ViewableRange} concept specifies the requirements of a
\libconcept{Range} type that can be converted to a \libconcept{View} safely.

\indexlibrary{\idxcode{ViewableRange}}%
\begin{itemdecl}
template<class T>
  concept ViewableRange =
    Range<T> && (@\placeholder{forwarding-range}@<T> || View<decay_t<T>>);
\end{itemdecl}

\rSec1[range.utility]{Range utilities}

\pnum
The components in this subclause are general utilities for representing and
manipulating ranges.

\rSec2[range.utility.helpers]{Helper concepts}

\pnum
Many of the types in this subclause are specified in terms of
the following exposition-only concepts:

\begin{codeblock}
template<class R>
  concept @\placeholder{simple-view}@ =
    View<R> && Range<const R> &&
    Same<iterator_t<R>, iterator_t<const R>> &&
    Same<sentinel_t<R>, sentinel_t<const R>>;

template<InputIterator I>
  concept @\placeholder{has-arrow}@ =
    is_pointer_v<I> || requires(I i) { i.operator->(); };

template<class T, class U>
  concept @\placeholder{not-same-as}@ =
    !Same<remove_cvref_t<T>, remove_cvref_t<U>>;
\end{codeblock}

\rSec2[range.view_interface]{View interface}

\pnum
The class template \tcode{view_interface} is a helper for defining
\tcode{View}-like types that offer a container-like interface. It is
parameterized with the type that inherits from it.

\indexlibrary{\idxcode{view_interface}}%
\begin{codeblock}
namespace std::ranges {
  template<Range R>
  struct @\placeholder{range-common-iterator-impl}@ { // \expos
    using type = common_iterator<iterator_t<R>, sentinel_t<R>>;
  };
  template<CommonRange R>
  struct @\placeholdernc{range-common-iterator-impl}@<R> { // \expos
    using type = iterator_t<R>;
  };
  template<Range R>
    using @\placeholder{range-common-iterator}@ = // \expos
      typename @\placeholdernc{range-common-iterator-impl}@<R>::type;

  template<class D>
    requires is_class_v<D> @\newtxt{\&\& Same<D, remove_cv_t<D>>}@
  class view_interface : public view_base {
  private:
    constexpr D& derived() noexcept { // \expos
      return static_cast<D&>(*this);
    }
    constexpr const D& derived() const noexcept { // \expos
      return static_cast<const D&>(*this);
    }
  public:
    constexpr bool empty() const requires ForwardRange<const D> @\newtxt{\{}@
      @\newtxt{return ranges::begin(derived()) == ranges::end(derived())}@;
    @\newtxt{\}}@

    constexpr explicit operator bool() const
      requires requires { ranges::empty(derived()); } @\newtxt{\{}@
      @\newtxt{return !ranges::empty(derived())}@;
    @\newtxt{\}}@

    constexpr auto data()
      requires ContiguousIterator<iterator_t<D>> @\newtxt{\{}@
      @\newtxt{return ranges::empty(derived()) ? nullptr : addressof(*ranges::begin(derived()))}@;
    @\newtxt{\}}@
    constexpr auto data() const
      requires Range<const D> && ContiguousIterator<iterator_t<const D>> @\newtxt{\{}@
      @\newtxt{return ranges::empty(derived()) ? nullptr : addressof(*ranges::begin(derived()))}@;
    @\newtxt{\}}@

    constexpr auto size() const requires ForwardRange<const D> &&
      SizedSentinel<sentinel_t<const D>, iterator_t<const D>> @\newtxt{\{}@
      @\newtxt{return ranges::end(derived()) - ranges::begin(derived())}@;
    @\newtxt{\}}@

    constexpr decltype(auto) front() requires ForwardRange<D> @\newtxt{\{}@
      @\newtxt{// \expects \tcode{!empty()}.}@
      @\newtxt{return *ranges::begin(derived())}@;
    @\newtxt{\}}@
    constexpr decltype(auto) front() const requires ForwardRange<const D> @\newtxt{\{}@
      @\newtxt{// \expects \tcode{!empty()}.}@
      @\newtxt{return *ranges::begin(derived())}@;
    @\newtxt{\}}@

    constexpr decltype(auto) back()
      requires BidirectionalRange<D> && CommonRange<D> @\newtxt{\{}@
      @\newtxt{// \expects \tcode{!empty()}.}@
      @\newtxt{return *ranges::prev(ranges::end(derived()))}@;
    @\newtxt{\}}@
    constexpr decltype(auto) back() const
      requires BidirectionalRange<const D> && CommonRange<const D> @\newtxt{\{}@
      @\newtxt{// \expects \tcode{!empty()}.}@
      @\newtxt{return *ranges::prev(ranges::end(derived()))}@;
    @\newtxt{\}}@

    template<RandomAccessRange R = D>
      constexpr decltype(auto) operator[](iter_difference_t<iterator_t<R>> n) @\newtxt{\{}@
      @\newtxt{return ranges::begin(derived())[n]}@;
    @\newtxt{\}}@
    template<RandomAccessRange R = const D>
      constexpr decltype(auto) operator[](iter_difference_t<iterator_t<R>> n) const @\newtxt{\{}@
      @\newtxt{return ranges::begin(derived())[n]}@;
    @\newtxt{\}}@

    @\oldtxt{template<ForwardRange C>}@
      @\oldtxt{requires !View<C> \&\&}@
          @\oldtxt{ConvertibleTo<iter_reference_t<iterator_t<const D>>,}@
            @\oldtxt{iter_value_t<iterator_t<C>>> \&\&}@
          @\oldtxt{Constructible<C, \placeholder{range-common-iterator}<const D>,}@
            @\oldtxt{\placeholder{range-common-iterator}<const D>>}@
      @\oldtxt{operator C() const;}@
  };
}
\end{codeblock}

\pnum
The template parameter \tcode{D} for \tcode{view_interface} may be an
incomplete type. \newtxt{Before any member of the resulting specialization of
}\tcode{\newtxt{view_interface}}\newtxt{ other than special member functions
is referenced, \tcode{D} shall be complete,
publicly and unambiguously derived from
}\tcode{\newtxt{view_interface<D>}}\newtxt{,
and model the \libconcept{View} concept.}

{\color{oldclr}
\rSec3[range.view_interface.accessors]{\tcode{view_interface} accessors}

\indexlibrary{\idxcode{empty}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr bool empty() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return ranges::begin(derived()) == ranges::end(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{operator bool}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr explicit operator bool() const
  requires requires { ranges::empty(derived()); };
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !ranges::empty(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{data}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr auto data()
  requires ContiguousIterator<iterator_t<D>>;
constexpr auto data() const
  requires Range<const D> && ContiguousIterator<iterator_t<const D>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return ranges::empty(derived()) ? nullptr : addressof(*ranges::begin(derived()));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr auto size() const requires ForwardRange<const D> &&
  SizedSentinel<sentinel_t<const D>, iterator_t<const D>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return ranges::end(derived()) - ranges::begin(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{front}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr decltype(auto) front() requires ForwardRange<D>;
constexpr decltype(auto) front() const requires ForwardRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects \tcode{!empty()}.

\pnum
\effects Equivalent to: \tcode{return *ranges::begin(derived());}
\end{itemdescr}

\indexlibrary{\idxcode{back}!\idxcode{view_interface}}%
\begin{itemdecl}
constexpr decltype(auto) back()
  requires BidirectionalRange<D> && CommonRange<D>;
constexpr decltype(auto) back() const
  requires BidirectionalRange<const D> && CommonRange<const D>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects \tcode{!empty()}.

\pnum
\effects Equivalent to: \tcode{return *ranges::prev(ranges::end(derived()));}
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{view_interface}}%
\begin{itemdecl}
template<RandomAccessRange R = D>
  constexpr decltype(auto) operator[](iter_difference_t<iterator_t<R>> n);
template<RandomAccessRange R = const D>
  constexpr decltype(auto) operator[](iter_difference_t<iterator_t<R>> n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(derived())[n];}
\end{itemdescr}

\indexlibrary{\idxcode{at}!\idxcode{view_interface}}%
\begin{itemdecl}
template<ForwardRange C>
  requires !View<C> &&
    ConvertibleTo<iter_reference_t<iterator_t<const D>>,
      iter_value_t<iterator_t<C>>> &&
    Constructible<C, @\placeholder{range-common-iterator}@<const D>,
      @\placeholder{range-common-iterator}@<const D>>
operator C() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
using I = @\placeholder{range-common-iterator}@<const D>;
return C(I{ranges::begin(derived())}, I{ranges::end(derived())});
\end{codeblock}
\end{itemdescr}
} %% \color{oldclr}


\rSec2[range.subrange]{Sub-ranges}

\pnum
The \tcode{subrange} class template bundles together an
iterator and a sentinel into a single object that models the
\libconcept{View} concept. Additionally, it models the
\libconcept{SizedRange} concept when the final template parameter is
\tcode{subrange_kind::sized}.

\indexlibrary{\idxcode{subrange}}%
\begin{codeblock}
namespace std@\newtxt{::ranges}@ { @\oldtxt{namespace ranges \{}@
  template<class T>
    concept @\placeholder{pair-like}@ = // \expos
      @\newtxt{!is_reference_v<T> \&\&}@ requires(T t) {
        @\newtxt{typename tuple_size<T>::type; // ensures tuple_size<T> is complete}@
        @\newtxt{requires DerivedFrom<tuple_size<T>, integral_constant<size_t, 2>>;}@
        @\oldtxt{\{ tuple_size<T>::value \} -> Integral;}@
        @\oldtxt{requires tuple_size<T>::value == 2;}@
        typename tuple_element_t<0, @\newtxt{remove_const_t<}@T@\newtxt{>}@>;
        typename tuple_element_t<1, @\newtxt{remove_const_t<}@T@\newtxt{>}@>;
        { get<0>(t) } -> const tuple_element_t<0, T>&;
        { get<1>(t) } -> const tuple_element_t<1, T>&;
      };

  template<class T, class U, class V>
    concept @\placeholder{pair-like-convertible-to}@ = // \expos
      !Range<T> && @\placeholder{pair-like}@<@\oldtxt{decay_t}\newtxt{remove_reference_t}@<T>> &&
      requires(T&& t) {
        @\oldtxt{\{}@ get<0>(std::forward<T>(t)) @\oldtxt{\} -> ConvertibleTo<U>}@;
        @\newtxt{requires ConvertibleTo<decltype(get<0>(std::forward<T>(t))), U>;}@
        @\oldtxt{\{}@ get<1>(std::forward<T>(t)) @\oldtxt{\} -> ConvertibleTo<V>}@;
        @\newtxt{requires ConvertibleTo<decltype(get<1>(std::forward<T>(t))), V>;}@
      };

  template<class T, class U, class V>
    concept @\placeholder{pair-like-convertible-from}@ = // \expos
      !Range<T> @\oldtxt{\&\& Same<T, decay_t<T>>}@ && @\placeholder{pair-like}@<T> && Constructible<T, U, V>;

  template<class T>
    concept @\placeholder{iterator-sentinel-pair}@ = // \expos
      !Range<T> @\oldtxt{\&\& Same<T, decay_t<T>>}@ && @\placeholder{pair-like}@<T> &&
      Sentinel<tuple_element_t<1, T>, tuple_element_t<0, T>>;

  template<Iterator I, Sentinel<I> S = I, subrange_kind K =
      SizedSentinel<S, I> ? subrange_kind::sized : subrange_kind::unsized>
    requires @\newtxt{(}@K == subrange_kind::sized || !SizedSentinel<S, I>@\newtxt{)}@
  class subrange : public view_interface<subrange<I, S, K>> {
  private:
    static constexpr bool StoreSize = // \expos
      K == subrange_kind::sized && !SizedSentinel<S, I>;
    I begin_ @\oldtxt{\{\}} \newtxt{= I()}@; // \expos
    S end_ @\oldtxt{\{\}} \newtxt{= S()}@;   // \expos
    iter_difference_t<I> size_ = 0; // \expos; only present when \tcode{StoreSize} is \tcode{true}
  public:
    @\oldtxt{using iterator = I;}@
    @\oldtxt{using sentinel = S;}@

    subrange() = default;

    constexpr subrange(I i, S s) requires @\newtxt{(}@!StoreSize@\newtxt{)}@;

    constexpr subrange(I i, S s, iter_difference_t<I> n)
      requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}@;

    template<@\placeholdernc{not-same-as}@<subrange> R>
      requires @\placeholdernc{forwarding-range}@<R> &&
        ConvertibleTo<iterator_t<R>, I> && ConvertibleTo<sentinel_t<R>, S>
    constexpr subrange(R&& r) requires @\newtxt{(}@!StoreSize@\newtxt{)}@ || SizedRange<R>;

    template<@\placeholdernc{forwarding-range}@ R>
      requires ConvertibleTo<iterator_t<R>, I> && ConvertibleTo<sentinel_t<R>, S>
    constexpr subrange(R&& r, iter_difference_t<I> n)
      requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}\oldtxt{;}@
        @\newtxt{: subrange\{ranges::begin(r), ranges::end(r), n\}}@
    @\newtxt{\{\}}@

    template<@\placeholdernc{not-same-as}@<subrange> PairLike>
      requires @\placeholdernc{pair-like-convertible-to}@<PairLike, I, S>
    constexpr subrange(PairLike&& r) requires @\newtxt{(}@!StoreSize@\newtxt{)}\oldtxt{;}@
      @\newtxt{: subrange\{std::get<0>(std::forward<PairLike>(r)),}@
                  @\newtxt{std::get<1>(std::forward<PairLike>(r))\}}@
    @\newtxt{\{\}}@

    template<@\placeholdernc{pair-like-convertible-to}@<I, S> PairLike>
    constexpr subrange(PairLike&& r, iter_difference_t<I> n)
      requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}\oldtxt{;}@
      @\newtxt{: subrange\{std::get<0>(std::forward<PairLike>(r)),}@
                  @\newtxt{std::get<1>(std::forward<PairLike>(r)), n\}}@
    @\newtxt{\{\}}@

    template<@\placeholdernc{not-same-as}@<subrange> PairLike>
      requires @\placeholdernc{pair-like-convertible-from}@<PairLike, const I&, const S&>
    constexpr operator PairLike() const;

    constexpr I begin() const;
    constexpr S end() const;

    constexpr bool empty() const;
    constexpr iter_difference_t<I> size() const
      requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}@;

    [[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) const;
    [[nodiscard]] constexpr subrange prev(iter_difference_t<I> n = 1) const
      requires BidirectionalIterator<I>;
    constexpr subrange& advance(iter_difference_t<I> n);

    friend constexpr I begin(subrange r) { return r.begin(); }
    friend constexpr S end(subrange r) { return r.end(); }
  };

  template<Iterator I, Sentinel<I> S>
    subrange(I, S, iter_difference_t<I>) -> subrange<I, S, subrange_kind::sized>;

  template<@\placeholder{iterator-sentinel-pair}@ P>
    subrange(P) -> subrange<tuple_element_t<0, P>, tuple_element_t<1, P>>;

  template<@\placeholder{iterator-sentinel-pair}@ P>
    subrange(P, iter_difference_t<tuple_element_t<0, P>>) ->
      subrange<tuple_element_t<0, P>, tuple_element_t<1, P>, subrange_kind::sized>;

  template<@\placeholder{forwarding-range}@ R>
    subrange(R&&) ->
      subrange<iterator_t<R>, sentinel_t<R>@\newtxt{,}@
               @\newtxt{(SizedRange<R> || SizedSentinel<sentinel_t<R>, iterator_t<R>>)}@
                 @\newtxt{? subrange_kind::sized : subrange_kind::unsized}@>;

  @\oldtxt{template<\placeholder{forwarding-range} R>}@
    @\oldtxt{requires SizedRange<R>}@
  @\oldtxt{subrange(R\&\&) -> subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;}@

  template<@\placeholder{forwarding-range}@ R>
    subrange(R&&, iter_difference_t<iterator_t<R>>) ->
      subrange<iterator_t<R>, sentinel_t<R>, subrange_kind::sized>;

  template<size_t N, class I, class S, subrange_kind K>
    requires @\newtxt{(}@N < 2@\newtxt{)}@
  constexpr auto get(const subrange<I, S, K>& r);

  @\oldtxt{template<\placeholder{forwarding-range} R>}@
    @\oldtxt{using safe_subrange_t = subrange<iterator_t<R>>;}@
}

@\newtxt{namespace std \{}@
  using ranges::get;
}
\end{codeblock}

\rSec3[range.subrange.ctor]{Constructors and conversions}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr subrange(I i, S s) requires @\newtxt{(}@!StoreSize@\newtxt{)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{begin_} with \tcode{i} and \tcode{end_} with
\tcode{s}.
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr subrange(I i, S s, iter_difference_t<I> n)
  requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects \tcode{n == ranges::distance(i, s)}.

\pnum
\effects Initializes \tcode{begin_} with \tcode{i} and \tcode{end_} with
\tcode{s}. If \tcode{StoreSize} is \tcode{true}, initializes \tcode{size_} with
\tcode{n}.

{\color{newclr}
\pnum
\begin{note}
Accepting the length of the range and storing it to later return  from
\tcode{size()} enables \tcode{subrange} to model \libconcept{SizedRange} even
when it stores an iterator and sentinel that do not model
\libconcept{SizedSentinel}.
\end{note}
} %% \color{newclr}
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{not-same-as}@<subrange> R>
  requires @\placeholdernc{forwarding-range}@<R> &&
    ConvertibleTo<iterator_t<R>, I> && ConvertibleTo<sentinel_t<R>, S>
constexpr subrange(R&& r) requires @\newtxt{(}@!StoreSize@\newtxt{)}@ || SizedRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true},
\tcode{subrange\{ranges::begin(r), ranges::end(r), ranges::size(r)\}}.
\item Otherwise, \tcode{subrange\{ranges::begin(r), ranges::end(r)\}}.
\end{itemize}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholder{forwarding-range}@ R>
  requires ConvertibleTo<iterator_t<R>, I> && ConvertibleTo<sentinel_t<R>, S>
constexpr subrange(R&& r, difference_type_t<I> n)
  requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{subrange\{ranges::begin(r), ranges::end(r), n\}}.
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{not-same-as}@<subrange> PairLike>
  requires @\placeholdernc{pair-like-convertible-to}@<PairLike, I, S>
constexpr subrange(PairLike&& r) requires @\newtxt{(}@!StoreSize@\newtxt{)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
subrange{get<0>(std::forward<PairLike>(r)), get<1>(std::forward<PairLike>(r))}
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{subrange}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{pair-like-convertible-to}@<I, S> PairLike>
constexpr subrange(PairLike&& r, iter_difference_t<I> n)
  requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
subrange{get<0>(std::forward<PairLike>(r)), get<1>(std::forward<PairLike>(r)), n}
\end{codeblock}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator \placeholder{PairLike}}!\idxcode{subrange}}%
\begin{itemdecl}
template<@\placeholdernc{not-same-as}@<subrange> PairLike>
  requires @\placeholdernc{pair-like-convertible-from}@<PairLike, const I&, const S&>
constexpr operator PairLike() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return PairLike(begin_, end_);}
\end{itemdescr}

\rSec3[range.subrange.access]{Accessors}

\indexlibrary{\idxcode{begin}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr I begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return begin_;}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr S end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return end_;}
\end{itemdescr}

\indexlibrary{\idxcode{empty}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr bool empty() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return begin_ == end_;}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr iter_difference_t<I> size() const
  requires @\newtxt{(}@K == subrange_kind::sized@\newtxt{)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true}, equivalent to: \tcode{return size_;}
\item Otherwise, equivalent to: \tcode{return end_ - begin_;}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{next}!\idxcode{subrange}}%
\begin{itemdecl}
[[nodiscard]] constexpr subrange next(iter_difference_t<I> n = 1) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
tmp.advance(n);
return tmp;
\end{codeblock}

\pnum
\begin{note}
If \tcode{I} does not model \libconcept{ForwardIterator}, \tcode{next}
may invalidate \tcode{*this}.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{prev}!\idxcode{subrange}}%
\begin{itemdecl}
[[nodiscard]] constexpr subrange prev(iter_difference_t<I> n = 1) const
  requires BidirectionalIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
tmp.advance(-n);
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{advance}!\idxcode{subrange}}%
\begin{itemdecl}
constexpr subrange& advance(iter_difference_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{itemize}
\item If \tcode{StoreSize} is \tcode{true},
\begin{codeblock}
size_ -= n - ranges::advance(begin_, n, end_);
return *this;
\end{codeblock}
\item Otherwise,
\begin{codeblock}
ranges::advance(begin_, n, end_);
return *this;
\end{codeblock}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{get}!\idxcode{subrange}}%
\begin{itemdecl}
template<size_t N, class I, class S, subrange_kind K>
  requires @\newtxt{(}@N < 2@\newtxt{)}@
constexpr auto get(const subrange<I, S, K>& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
if constexpr (N == 0)
  return r.begin();
else
  return r.end();
\end{codeblock}
\end{itemdescr}


\rSec1[range.adaptors]{Range adaptors}

\pnum
This subclause defines \term{range adaptors}, which are utilities that transform a
\libconcept{Range} into a \libconcept{View} with custom behaviors. These
adaptors can be chained to create pipelines of range transformations that
evaluate lazily as the resulting view is iterated.

\pnum
Range adaptors are declared in namespace \tcode{std::ranges::view}.

\pnum
The bitwise or operator is overloaded for the purpose of creating adaptor chain
pipelines. The adaptors also support function call syntax with equivalent
semantics.

\pnum
\begin{example}
\begin{codeblock}
vector<int> ints{0,1,2,3,4,5};
auto even = [](int i){ return 0 == i % 2; };
auto square = [](int i) { return i * i; };
for (int i : ints | view::filter(even) | view::transform(square)) {
  cout << i << ' '; // prints: 0 4 16
}
assert(ranges::equal(ints | view::filter(even), view::filter(ints, even)));
\end{codeblock}
\end{example}

\rSec2[range.adaptor.object]{Range adaptor objects}

\pnum
A \term{range adaptor closure object} is a unary function object that accepts
a \libconcept{ViewableRange} as an argument and returns a \libconcept{View}. For
a range adaptor closure object \tcode{C} and an expression \tcode{R} such that
\tcode{decltype((R))} models \libconcept{ViewableRange}, the following
expressions are equivalent and \oldtxt{return}\newtxt{yield} a \libconcept{View}:

\begin{codeblock}
C(R)
R | C
\end{codeblock}

Given an additional range adaptor closure object \tcode{D},
the expression \tcode{C | D} is well-formed and produces another range adaptor
closure object such that the following two expressions are equivalent:

\begin{codeblock}
R | C | D
R | (C | D)
\end{codeblock}

\pnum
A \term{range adaptor object} is a
customization point object\cxxiref{customization.point.object}
that accepts a \libconcept{ViewableRange} as its first argument and returns a
\libconcept{View}.

\pnum
If \oldtxt{the adaptor} \newtxt{a range adaptor object} accepts only one argument, then it is a range adaptor closure
object.

\pnum
If \oldtxt{the adaptor} \newtxt{a range adaptor object} accepts more than one arguments, then the following expressions
are equivalent:

\begin{codeblock}
@\placeholdernc{adaptor}@(range, args...)
@\placeholdernc{adaptor}@(args...)(range)
range | @\placeholdernc{adaptor}@(args...)
\end{codeblock}

In this case, \tcode{\placeholdernc{adaptor}(args...)} is a range adaptor
closure object.

\rSec2[range.semi.wrap]{Semiregular wrapper}

\pnum
Many of the types in this subclause are specified in terms of
an exposition-only \oldtxt{helper called}
\newtxt{class template} \tcode{\placeholder{semiregular}<T>}.
\oldtxt{This type} \newtxt{\tcode{\placeholder{semiregular}<T>}} behaves
exactly like \tcode{optional<T>} with the following
\oldtxt{exceptions} \newtxt{differences}:

\begin{itemize}
\item \tcode{\placeholder{semiregular}<T>} constrains its \oldtxt{argument}
\newtxt{type parameter \tcode{T}}
with \tcode{\libconcept{CopyConstructible}<T> \&\& is_object_v<T>}.

\item If \tcode{T} models \libconcept{DefaultConstructible}, the default
constructor of \tcode{\placeholder{semiregular}<T>} is equivalent to:
\begin{codeblock}
constexpr @\placeholder{semiregular}@()
  noexcept(is_nothrow_default_constructible_v<T>)
  : @\placeholder{semiregular}@{in_place}
{ }
\end{codeblock}

\item If \tcode{\libconcept{Assignable}<T\&, const T\&>} is not
satisfied, the copy assignment operator is equivalent to:
\begin{codeblock}
@\placeholder{semiregular}@& operator=(const @\placeholder{semiregular}@& that)
  noexcept(is_nothrow_copy_constructible_v<T>)
{
  if (that) emplace(*that);
  else reset();
  return *this;
}
\end{codeblock}

\item If \tcode{\libconcept{Assignable}<T\&, T>} is not satisfied,
the move assignment operator is equivalent to:
\begin{codeblock}
@\placeholder{semiregular}@& operator=(@\placeholder{semiregular}@&& that)
  noexcept(is_nothrow_move_constructible_v<T>)
{
  if (that) emplace(std::move(*that));
  else reset();
  return *this;
}
\end{codeblock}
\end{itemize}

\rSec2[range.all]{All view}

\pnum
\tcode{view::all} returns a \libconcept{View} that includes all elements of
its \libconcept{Range} argument.

\pnum
The name \tcode{view::all} denotes a range adaptor
object\iref{range.adaptor.object}. The expression \tcode{view::all(E)} for
some subexpression \tcode{E} is expression-equivalent to:

\begin{itemize}
\item \tcode{\placeholdernc{DECAY_COPY}(E)} if the decayed type of \tcode{E}
models \libconcept{View}.

\item Otherwise, \tcode{\placeholder{ref-view}\{E\}} if that
expression is well-formed, where \tcode{\placeholder{ref-view}}
is the exposition-only \libconcept{View} specified below.

\item Otherwise, \tcode{subrange\{E\}} \oldtxt{if that expression is well-formed}.

\item \oldtxt{Otherwise, \tcode{view::all(E)} is ill-formed.}
\end{itemize}

\begin{note}
\oldtxt{Whenever \tcode{view::all(E)} is a valid expression, it is a prvalue
whose type models \libconcept{View}.}
\end{note}

\rSec3[range.view.ref]{\placeholder{ref-view}}

\begin{codeblock}
namespace std::ranges {
  template<Range R>
    requires std::is_object_v<R>
  class @\placeholder{ref-view}@ : public view_interface<@\placeholder{ref-view}@<R>> {
  private:
    R* r_ = nullptr; // \expos
  public:
    constexpr @\placeholdernc{ref-view}@() noexcept = default;
    @\oldtxt{constexpr \placeholdernc{ref-view}(R\& r) noexcept;}@

    @\newtxt{template<\placeholder{not-same-as}<\placeholder{ref-view}> T>}@
      @\newtxt{requires \seebelow}@
    @\newtxt{constexpr \placeholder{ref-view}(T\&\& t) noexcept(is_nothrow_convertible_v<T, R\&>);}@

    constexpr R& base() const@\oldtxt{;}@
    @\newtxt{\{ return *r_; \}}@

    constexpr iterator_t<R> begin() const
      @\oldtxt{noexcept(noexcept(ranges::begin(*r_)));}@
    @\newtxt{\{ return ranges::begin(*r_); \}}@

    constexpr sentinel_t<R> end() const
      @\oldtxt{noexcept(noexcept(ranges::end(*r_)));}@
    @\newtxt{\{ return ranges::end(*r_); \}}@

    constexpr bool empty() const
      @\oldtxt{noexcept(noexcept(ranges::empty(*r_)))}@
      requires requires { ranges::empty(*r_); }@\oldtxt{;}@
    @\newtxt{\{ return ranges::empty(*r_); \}}@

    constexpr auto size() const
      @\oldtxt{noexcept(noexcept(ranges::size(*r_)))}@
      requires SizedRange<R>@\oldtxt{;}@
    @\newtxt{\{ return ranges::size(*r_); \}}@

    constexpr auto data() const
      @\oldtxt{noexcept(noexcept(ranges::data(*r_)))}@
      requires ContiguousRange<R>@\oldtxt{;}@
    @\newtxt{\{ return ranges::data(*r_); \}}@

    friend constexpr iterator_t<R> begin(@\placeholder{ref-view}\oldtxt{\&\&}@ r)
      @\oldtxt{noexcept(noexcept(r.begin()));}@
    @\newtxt{\{ return r.begin(); \}}@

    friend constexpr sentinel_t<R> end(@\placeholder{ref-view}\oldtxt{\&\&}@ r)
      @\oldtxt{noexcept(noexcept(r.end()));}@
    @\newtxt{\{ return r.end(); \}}@
  };
}
\end{codeblock}

\indexlibrary{\idxcode{\placeholder{ref-view}}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
@\oldtxt{constexpr \placeholdernc{ref-view}(R\& r) noexcept;}@
@\newtxt{template<\placeholder{not-same-as}<\placeholder{ref-view}> T>}@
  @\newtxt{requires \seebelow}@
@\newtxt{constexpr \placeholder{ref-view}(T\&\& t) noexcept(is_nothrow_convertible_v<T, R\&>);}@
\end{itemdecl}

\begin{itemdescr}
{\color{newclr}
\pnum
\remarks Let \tcode{\placeholder{FUN}} denote the exposition-only functions
\begin{codeblock}
void FUN(R&) noexcept;
void FUN(R&&) = delete;
\end{codeblock}
The expression in the \grammarterm{requires-clause} is equivalent to
\begin{codeblock}
requires { FUN(std::declval<T>()); }
\end{codeblock}
} %% \color{newclr}

\pnum
\effects Initializes \tcode{r_} with \tcode{addressof(\oldtxt{r}\newtxt{static_cast<R\&>(std::forward<T>(t))})}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{base}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr R& base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return *r_;}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr iterator_t<R> begin() const
  noexcept(noexcept(ranges::begin(*r_)));
friend constexpr iterator_t<R> begin(@\placeholder{ref-view}@&& r)
  noexcept(noexcept(r.begin()));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(*r_);}
or \tcode{return r.begin();}, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr sentinel_t<R> end() const
  noexcept(noexcept(ranges::end(*r_)));
friend constexpr sentinel_t<R> end(@\placeholder{ref-view}@&& r)
  noexcept(noexcept(r.end()));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::end(*r_);}
or \tcode{return r.end();}, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{empty}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr bool empty() const
  noexcept(noexcept(ranges::empty(*r_)))
  requires requires { ranges::empty(*r_); };
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::empty(*r_);}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr auto size() const
  noexcept(noexcept(ranges::size(*r_)))
  requires SizedRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::size(*r_);}
\end{itemdescr}

\indexlibrary{\idxcode{data}!\idxcode{\placeholder{ref-view}}}%
\begin{itemdecl}
constexpr auto data() const
  noexcept(noexcept(ranges::data(*r_)))
  requires ContiguousRange<R>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::data(*r_);}
\end{itemdescr}
} %% \color{oldclr}

\rSec2[range.filter]{Filter view}

\rSec3[range.filter.overview]{Overview}

\pnum
\tcode{filter_view} presents a \libconcept{View} of an underlying sequence
without the elements that fail to satisfy a predicate.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4, 5, 6 };
filter_view evens{is, [](int i) { return 0 == i % 2; }};
for (int i : evens)
  cout << i << ' '; // prints: 0 2 4 6
\end{codeblock}
\end{example}

\rSec3[range.filter.view]{Class template \tcode{filter_view}}

\begin{codeblock}
namespace std::ranges {
  template<InputRange V, IndirectUnaryPredicate<iterator_t<V>> Pred>
    requires View<V> && is_object_v<Pred>
  class filter_view : public view_interface<filter_view<V, Pred>> {
  private:
    V base_ @\oldtxt{\{\}} \newtxt{= V()}@;                              // \expos
    @\placeholder{semiregular}@<Pred> pred_;                 // \expos

    class iterator;                          // \expos
    class sentinel;                          // \expos

  public:
    filter_view() = default;
    constexpr filter_view(V base, Pred pred);
    template<InputRange R>
      requires ViewableRange<R> && Constructible<V, all_view<R>>
    constexpr filter_view(R&& r, Pred pred);

    constexpr V base() const;

    constexpr iterator begin();
    @\oldtxt{constexpr sentinel end();}@
    constexpr @\oldtxt{iterator}\newtxt{auto}@ end() @\oldtxt{requires CommonRange<V>;}\newtxt{\{}@
      @\newtxt{if constexpr (CommonRange<V>)}@
        @\newtxt{return iterator\{*this, ranges::end(base_)\};}@
      @\newtxt{else}@
        @\newtxt{return sentinel\{*this\};}@
    @\newtxt{\}}@
  };

  template<class R, class Pred>
    filter_view(R&&, Pred) -> filter_view<all_view<R>, Pred>;
}
\end{codeblock}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr filter_view(V base, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and initializes
\tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{filter_view}!\idxcode{filter_view}}%
\begin{itemdecl}
template<InputRange R>
  requires ViewableRange<R> && Constructible<V, all_view<R>>
constexpr filter_view(R&& r, Pred pred);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))}
and initializes \tcode{pred_} with \tcode{std::move(pred)}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr V base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return base_;}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr iterator begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\expects
}\tcode{\newtxt{pred_.has_value()}}\newtxt{.}

\pnum
\returns
\tcode{\{*this, ranges::find_if(base_, ref(*pred_))\}}.

\pnum
\remarks In order to provide the amortized constant time complexity required by
the \libconcept{Range} concept, this function caches the result within the
\tcode{filter_view} for use on subsequent calls.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{end}!\idxcode{filter_view}}%
\begin{itemdecl}
constexpr sentinel end();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return sentinel\{*this\};}
\end{itemdescr}

\begin{itemdecl}
constexpr iterator end() requires CommonRange<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return iterator\{*this, ranges::end(base_)\};}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.filter.iterator]{Class \tcode{filter_view::iterator}}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view}}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pred>
  class filter_view<V, Pred>::iterator {
  private:
    iterator_t<V> current_ @\oldtxt{\{\}} \newtxt{= iterator_t<V>()}@;           // \expos
    filter_view* parent_ = nullptr;      // \expos
  public:
    using iterator_concept  = @\seebelownc@;
    using iterator_category = @\seebelownc@;
    using value_type        = iter_value_t<iterator_t<V>>;
    using difference_type   = iter_difference_t<iterator_t<V>>;

    iterator() = default;
    constexpr iterator(filter_view& parent, iterator_t<V> current);

    constexpr iterator_t<V> base() const;
    constexpr iter_reference_t<iterator_t<V>> operator*() const;
    constexpr iterator_t<V> operator->() const
      requires @\placeholder{has-arrow}@<iterator_t<V>>;

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires ForwardRange<V>;

    constexpr iterator& operator--() requires BidirectionalRange<V>;
    constexpr iterator operator--(int) requires BidirectionalRange<V>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<V>>;
    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<V>>;

    friend constexpr iter_rvalue_reference_t<iterator_t<V>> iter_move(const iterator& i)
      noexcept(noexcept(ranges::iter_move(i.current_)));
    friend constexpr void iter_swap(const iterator& x, const iterator& y)
      noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
      requires IndirectlySwappable<iterator_t<V>>;
  };
}
\end{codeblock}

\pnum
\newtxt{Modification of the element a \tcode{filter_view::iterator} denotes is
permitted, but results in undefined behavior if the resulting value does not
satisfy the filter predicate.}

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{V} models \libconcept{BidirectionalRange}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{ForwardRange}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
\item Let \tcode{C} denote the type
\tcode{iterator_traits<iterator_t<V>>::iterator_category}.

\item If \tcode{C} models \tcode{DerivedFrom<bidirectional_iterator_tag>},
then \tcode{iterator_category} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if  \tcode{C} models \tcode{DerivedFrom<forward_iterator_tag>},
then \tcode{iterator_category} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_category} denotes \tcode{input_iterator_tag}.
\end{itemize}

\indexlibrary{\idxcode{iterator}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator(filter_view& parent, iterator_t<V> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{current} and
\tcode{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator_t<V> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iter_reference_t<iterator_t<V>> operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return *current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator->}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator_t<V> operator->() const
  requires @\placeholder{has-arrow}@<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ = ranges::find_if(++current_, ranges::end(parent_->base_), ref(*parent_->pred_));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{++*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator operator++(int) requires ForwardRange<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator--() requires BidirectionalRange<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
do
  --current_;
while (@\newtxt{!}@invoke(*parent_->pred_, *current_));
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
constexpr iterator operator--(int) requires BidirectionalRange<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ == y.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{iter_move}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr iter_rvalue_reference_t<iterator_t<V>> iter_move(const iterator& i)
  noexcept(noexcept(ranges::iter_move(i.current_)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(i.current_);}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{filter_view::iterator}}%
\begin{itemdecl}
friend constexpr void iter_swap(const iterator& x, const iterator& y)
  noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
  requires IndirectlySwappable<iterator_t<V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(x.current_, y.current_)}.
\end{itemdescr}

\rSec3[range.filter.sentinel]{Class \tcode{filter_view::sentinel}}

\indexlibrary{\idxcode{sentinel}!\idxcode{filter_view}}%
\begin{codeblock}
namespace std::ranges {
  template<class V, class Pred>
  class filter_view<V, Pred>::sentinel {
  private:
    sentinel_t<V> end_ @\oldtxt{\{\}} \newtxt{= sentinel_t<V>()}@; // \expos
  public:
    sentinel() = default;
    explicit constexpr sentinel(filter_view& parent);

    constexpr sentinel_t<V> base() const;

    friend constexpr bool operator==(const iterator& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator& y);
    friend constexpr bool operator!=(const iterator& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator& y);
  };
}
\end{codeblock}

\indexlibrary{\idxcode{sentinel}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
explicit constexpr sentinel(filter_view& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{ranges::end(parent)}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
constexpr sentinel_t<V> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ == y.end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y == x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{filter_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y == x);}
\end{itemdescr}

\rSec3[range.filter.adaptor]{\tcode{view::filter}}

\pnum
The name \tcode{view::filter} denotes a
range adaptor object\iref{range.adaptor.object}.
The expression \tcode{view::filter(E, P)} for subexpressions
\tcode{E} and \tcode{P} is expression-equivalent to \tcode{filter_view\{E, P\}}.


\rSec2[range.transform]{Transform view}

\rSec3[range.transform.overview]{Overview}

\pnum
\tcode{transform_view} presents
a \libconcept{View} of an underlying sequence after
applying a transformation function to each element.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{ 0, 1, 2, 3, 4 };
transform_view squares{is, [](int i) { return i * i; }};
for (int i : squares)
  cout << i << ' '; // prints: 0 1 4 9 16
\end{codeblock}
\end{example}

\rSec3[range.transform.view]{Class template \tcode{transform_view}}

\begin{codeblock}
namespace std::ranges {
  template<InputRange V, CopyConstructible F>
    requires View<V> && is_object_v<F> && @\newtxt{Regular}@Invocable<F&, iter_reference_t<iterator_t<V>>>
  class transform_view : public view_interface<transform_view<V, F>> {
  private:
    template<bool> struct iterator;   // \expos
    template<bool> struct sentinel;   // \expos

    V base_ @\oldtxt{\{\}} \newtxt{= V()}@;                       // \expos
    @\placeholder{semiregular}@<F> fun_;              // \expos

  public:
    transform_view() = default;
    constexpr transform_view(V base, F fun);
    template<InputRange R>
      requires ViewableRange<R> && Constructible<V, all_view<R>>
    constexpr transform_view(R&& r, F fun);

    constexpr V base() const;

    constexpr @\oldtxt{auto}\newtxt{iterator<false>}@ begin();
    constexpr @\oldtxt{auto}\newtxt{iterator<true>}@ begin() const requires Range<const V> &&
      @\newtxt{Regular}@Invocable<const F&, iter_reference_t<iterator_t<const V>>>;

    constexpr @\oldtxt{auto}\newtxt{sentinel<false>}@ end();
    constexpr @\oldtxt{auto}\newtxt{iterator<false>}@ end() requires CommonRange<V>;
    constexpr @\oldtxt{auto}\newtxt{sentinel<true>}@ end() const requires Range<const V> &&
      @\newtxt{Regular}@Invocable<const F&, iter_reference_t<iterator_t<const V>>>;
    constexpr @\oldtxt{auto}\newtxt{iterator<true>}@ end() const requires CommonRange<const V> &&
      @\newtxt{Regular}@Invocable<const F&, iter_reference_t<iterator_t<const V>>>;

    constexpr auto size() requires SizedRange<V>@\oldtxt{;}@
    @\newtxt{\{ return ranges::size(base_); \}}@
    constexpr auto size() const requires SizedRange<const V>@\oldtxt{;}@
    @\newtxt{\{ return ranges::size(base_); \}}@
  };

  template<class R, class F>
    transform_view(R&& r, F fun) -> transform_view<all_view<R>, F>;
}
\end{codeblock}

\indexlibrary{\idxcode{transform_view}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr transform_view(V base, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and
\tcode{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\indexlibrary{\idxcode{transform_view}!\idxcode{transform_view}}%
\begin{itemdecl}
template<InputRange R>
  requires ViewableRange<R> && Constructible<V, all_view<R>>
constexpr transform_view(R&& r, F fun);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))}
and \tcode{fun_} with \tcode{std::move(fun)}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr V base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return base_;}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{iterator<false>}@ begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return iterator<false>{*this, ranges::begin(base_)};
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{iterator<true>}@ begin() const requires Range<const V> &&
  @\newtxt{Regular}@Invocable<const F&, iter_reference_t<iterator_t<const V>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return iterator<true>{*this, ranges::begin(base_)};
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{sentinel<false>}@ end();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return sentinel<false>{ranges::end(base_)};
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{iterator<false>}@ end() requires CommonRange<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return iterator<false>{*this, ranges::end(base_)};
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{sentinel<true>}@ end() const requires Range<const V> &&
  @\newtxt{Regular}@Invocable<const F&, iter_reference_t<iterator_t<const V>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return sentinel<true>{ranges::end(base_)};
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{iterator<true>}@ end() const requires CommonRange<const V> &&
  @\newtxt{Regular}@Invocable<const F&, iter_reference_t<iterator_t<const V>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
return iterator<true>{*this, ranges::end(base_)};
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{size}!\idxcode{transform_view}}%
\begin{itemdecl}
constexpr auto size() requires SizedRange<V>;
constexpr auto size() const requires SizedRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::size(base_);}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.transform.iterator]{Class template \tcode{transform_view::iterator}}

\begin{codeblock}
namespace std::ranges {
  template<class V, class F>
  template<bool Const>
  class transform_view<V, F>::iterator { // \expos
  private:
    using Parent =                 // \expos
      conditional_t<Const, const transform_view, transform_view>;
    using Base   =                 // \expos
      conditional_t<Const, const V, V>;
    iterator_t<Base> current_ @\oldtxt{\{\}} \newtxt{= iterator_t<Base>()}@;  // \expos
    Parent* parent_ = nullptr;     // \expos
  public:
    using iterator_concept  = @\seebelownc@;
    using iterator_category = @\seebelownc@;
    using value_type        =
      remove_cvref_t<invoke_result_t<F&, iter_reference_t<iterator_t<Base>>>>;
    using difference_type   = iter_difference_t<iterator_t<Base>>;

    iterator() = default;
    constexpr iterator(Parent& parent, iterator_t<Base> current);
    constexpr iterator(iterator<!Const> i)
      requires Const && ConvertibleTo<iterator_t<V>, iterator_t<Base>>;

    constexpr iterator_t<Base> base() const;
    constexpr decltype(auto) operator*() const@\oldtxt{;}@
    @\newtxt{\{ return invoke(*parent_->fun_, *current_); \}}@

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires ForwardRange<Base>;

    constexpr iterator& operator--() requires BidirectionalRange<Base>;
    constexpr iterator operator--(int) requires BidirectionalRange<Base>;

    constexpr iterator& operator+=(difference_type n)
      requires RandomAccessRange<Base>;
    constexpr iterator& operator-=(difference_type n)
      requires RandomAccessRange<Base>;
    constexpr decltype(auto) operator[](difference_type n) const
      requires RandomAccessRange<Base>@\oldtxt{;}@
    @\newtxt{\{ return invoke(*parent_->fun_, current_[n]); \}}@

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<Base>>;
    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires EqualityComparable<iterator_t<Base>>;

    friend constexpr bool operator<(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;
    friend constexpr bool operator>(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;
    friend constexpr bool operator<=(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;
    friend constexpr bool operator>=(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;

    friend constexpr iterator operator+(iterator i, difference_type n)
      requires RandomAccessRange<Base>;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires RandomAccessRange<Base>;

    friend constexpr iterator operator-(iterator i, difference_type n)
      requires RandomAccessRange<Base>;
    friend constexpr difference_type operator-(const iterator& x, const iterator& y)
      requires RandomAccessRange<Base>;

    friend constexpr decltype(auto) iter_move(const iterator& i)
      noexcept(noexcept(invoke(*i.parent_->fun_, *i.current_)))@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (is_lvalue_reference(decltype(*i)))}@
        @\newtxt{return std::move(*i);}@
      @\newtxt{else}@
        @\newtxt{return *i;}@
    @\newtxt{\}}@

    friend constexpr void iter_swap(const iterator& x, const iterator& y)
      noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
        requires IndirectlySwappable<iterator_t<Base>>;
  };
}
\end{codeblock}

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{V} models \libconcept{RandomAccessRange}, then
\tcode{iterator_concept} denotes \tcode{random_access_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{BidirectionalRange}, then
\tcode{iterator_concept} denotes \tcode{bidirectional_iterator_tag}.

\item Otherwise, if \tcode{V} models \libconcept{ForwardRange}, then
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag}.

\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
Let \tcode{C} denote the type
\tcode{iterator_traits<iterator_t<Base>>::iterator_category}. If \tcode{C}
models \tcode{\libconcept{DerivedFrom}<contiguous_iterator_tag>}, then
\tcode{iterator_category} denotes \tcode{random_access_iterator_tag}; otherwise,
\tcode{iterator_category} denotes \tcode{C}.

\indexlibrary{\idxcode{iterator}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator(Parent& parent, iterator_t<Base> current);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{current} and
\tcode{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrary{\idxcode{iterator}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
constexpr iterator(iterator<!Const> i)
  requires Const && ConvertibleTo<iterator_t<V>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{current_} with \tcode{\newtxt{std::move(}i.current_\newtxt{)}} and
\tcode{parent_} with \tcode{i.parent_}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return current_;}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator*}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr decltype(auto) operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return invoke(*parent_->fun_, *current_);}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
++current_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{++current_}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator operator++(int) requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator--() requires BidirectionalRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
--current_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator operator--(int) requires BidirectionalRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator+=}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator+=(difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ += n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
constexpr iterator& operator-=(difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
current_ -= n;
return *this;
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator[]}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
constexpr decltype(auto) operator[](difference_type n) const
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return invoke(*parent_->fun_, current_[n]);}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ == y.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires EqualityComparable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator<(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ < y.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator>(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y < x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator<=(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y < x);}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr bool operator>=(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x < y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator+(iterator i, difference_type n)
  requires RandomAccessRange<Base>;
friend constexpr iterator operator+(difference_type n, iterator i)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return iterator\{*i.parent_, i.current_ + n\};}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr iterator operator-(iterator i, difference_type n)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return iterator\{*i.parent_, i.current_ - n\};}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{transform_view::iterator}}%
\begin{itemdecl}
friend constexpr difference_type operator-(const iterator& x, const iterator& y)
  requires RandomAccessRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ - y.current_;}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{iter_move}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr decltype(auto) iter_move(const iterator& i)
  noexcept(noexcept(invoke(*i.parent_->fun_, *i.current_)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\begin{itemize}
\item If the expression \tcode{*i} is an lvalue,
  equivalent to: \tcode{return std::move(*i);}
\item Otherwise, equivalent to: \tcode{return *i;}
\end{itemize}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{transform_view::iterator}}
\begin{itemdecl}
friend constexpr void iter_swap(const iterator& x, const iterator& y)
  noexcept(noexcept(ranges::iter_swap(x.current_, y.current_)))
    requires IndirectlySwappable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(x.current_, y.current_)}.
\end{itemdescr}


\rSec3[range.transform.sentinel]{Class template \tcode{transform_view::sentinel}}

\begin{codeblock}
namespace std::ranges {
  template<class V, class F>
  template<bool Const>
  class transform_view<V, F>::sentinel { // \expos
  private:
    using Parent =                                 // \expos
      conditional_t<Const, const transform_view, transform_view>;
    using Base = conditional_t<Const, const V, V>; // \expos
    sentinel_t<Base> end_ @\oldtxt{\{\}} \newtxt{= sentinel_t<Base>()}@;                      // \expos
  public:
    sentinel() = default;
    explicit constexpr sentinel(sentinel_t<Base> end);
    constexpr sentinel(sentinel<!Const> i)
      requires Const && ConvertibleTo<sentinel_t<V>, sentinel_t<Base>>;

    constexpr sentinel_t<Base> base() const;

    friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
    friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);

    friend constexpr iter_difference_t<iterator_t<Base>>
      operator-(const iterator<Const>& x, const sentinel& y)
        requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
    friend constexpr iter_difference_t<iterator_t<Base>>
      operator-(const sentinel& y, const iterator<Const>& x)
        requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{sentinel}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
explicit constexpr sentinel(sentinel_t<Base> end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{end}.
\end{itemdescr}

\indexlibrary{\idxcode{sentinel}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
constexpr sentinel(sentinel<!Const> i)
  requires Const && ConvertibleTo<sentinel_t<V>, sentinel_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{\newtxt{std::move(}i.end_\newtxt{)}}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
constexpr sentinel_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ == y.end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{transform_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y == x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y == x);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr iter_difference_t<iterator_t<Base>>
  operator-(const iterator<Const>& x, const sentinel& y)
    requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ - y.end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{transform_view::sentinel}}%
\begin{itemdecl}
friend constexpr iter_difference_t<iterator_t<Base>>
  operator-(const sentinel& y, const iterator<Const>& x)
    requires SizedSentinel<sentinel_t<Base>, iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.end_ - y.current_;}
\end{itemdescr}

\rSec3[range.transform.adaptor]{\tcode{view::transform}}

\pnum
The name \tcode{view::transform} denotes a
range adaptor object\iref{range.adaptor.object}. The expression
\tcode{view::transform(E, F)} for subexpressions \tcode{E} and \tcode{F} is
expression-equivalent to \tcode{transform_view\{E, F\}}.


\rSec2[range.iota]{Iota view}

\rSec3[range.iota.overview]{Overview}

\pnum
\tcode{iota_view} generates a
sequence of elements by repeatedly incrementing an initial value.

\pnum
\begin{example}
\begin{codeblock}
for (int i : iota_view{1, 10})
  cout << i << ' '; // prints: 1 2 3 4 5 6 7 8 9
\end{codeblock}
\end{example}

\rSec3[range.iota.view]{Class template \tcode{iota_view}}

\begin{codeblock}
namespace std::ranges {
  template<class I>
    concept @\placeholder{Decrementable}@ = // \expos
      @\seebelownc@;
  template<class I>
    concept @\placeholder{Advanceable}@ = // \expos
      @\seebelownc@;

  template<WeaklyIncrementable W, Semiregular Bound = unreachable>
    requires @\placeholdernc{weakly-equality-comparable-with}@<W, Bound>
  class iota_view : public view_interface<iota_view<W, Bound>> {
  private:
    struct iterator; // \expos
    struct sentinel; // \expos
    W value_ @\oldtxt{\{\}} \newtxt{= W()}@;     // \expos
    Bound bound_ @\oldtxt{\{\}} \newtxt{= Bound()}@; // \expos
  public:
    iota_view() = default;
    constexpr explicit iota_view(W value);
    constexpr iota_view(W value, Bound bound); // \seebelow

    constexpr iterator begin() const;
    constexpr sentinel end() const;
    constexpr iterator end() const requires Same<W, Bound>;

    constexpr auto size() const
      requires @\newtxt{(Same<W, Bound> \&\& \placeholdernc{Advanceable}<W>) ||}@
               @\newtxt{(Integral<W> \&\& Integral<Bound>) ||}@
               @\newtxt{SizedSentinel<Bound, W>}@ @\oldtxt{\seebelow;}@
    @\newtxt{\{ return bound_ - value_; \}}@
  };

  template<class W, class Bound>
    requires
      (!Integral<W> || !Integral<Bound> || is_signed_v<W> == is_signed_v<Bound>)
  iota_view(W, Bound) -> iota_view<W, Bound>;
}
\end{codeblock}

\pnum
The exposition-only \tcode{\placeholder{Decrementable}} concept is equivalent to:
\begin{itemdecl}
template<class I>
  concept @\placeholder{Decrementable}@ =
    Incrementable<I> && requires(I i) {
      { --i } -> Same<I>&;
      i--; requires Same<I, decltype(i--)>;
    };
\end{itemdecl}

\begin{itemdescr}
\pnum
When an object is in the domain of both pre- and post-decrement,
the object is said to be \term{decrementable}.

\pnum
Let \tcode{a} and \tcode{b} be incrementable and decrementable objects of type
\tcode{I}. \tcode{I} models \tcode{\placeholdernc{Decrementable}} only if
\begin{itemize}
\item \tcode{addressof(--a) == addressof(a)}.
\item If \tcode{bool(a == b)} then \tcode{bool(a-- == b)}.
\item If \tcode{bool(a == b)} then \tcode{bool((\newtxt{(void)}a--, a) == --b)}.
\item If \tcode{bool(a == b)} then \tcode{bool(--(++a) == b)} and
\tcode{bool(++(--a) == b)}.
\end{itemize}
\end{itemdescr}

\pnum
The exposition-only \tcode{\placeholder{Advanceable}} concept is equivalent to:
\begin{itemdecl}
template<class I>
  concept @\placeholder{Advanceable}@ =
    @\placeholdernc{Decrementable}@<I> && StrictTotallyOrdered<I> &&
    @\oldtxt{requires { typename iter_difference_t<I>; } \&\&}@
    requires(I i, const I j, const iter_difference_t<I> n) {
      { i += n } -> Same<I>&;
      { i -= n } -> Same<I>&;
      j + n; requires Same<I, decltype(j + n)>;
      n + j; requires Same<I, decltype(n + j)>;
      j - n; requires Same<I, decltype(j - n)>;
      j - j; requires Same<iter_difference_t<I>, decltype(j - j)>;
    };
\end{itemdecl}

Let \tcode{a} and \tcode{b} be objects of type \tcode{I} such that
\tcode{b} is reachable from \tcode{a}
\newtxt{after \tcode{n} applications of \tcode{++a},
for some value \tcode{n} of type }\tcode{\newtxt{iter_difference_t<I>}}\newtxt{,
and let \tcode{D} be }\tcode{\newtxt{iter_difference_t<I>}}.
\oldtxt{Let $M$ be the smallest number of applications
of \tcode{++a} necessary to make \tcode{bool(a == b)} be \tcode{true}. Let
\tcode{n}, \tcode{zero}, and \tcode{one} be objects of type
\tcode{iter_difference_t<I>}
initialized with $M$, \tcode{0}, and \tcode{1}, respectively. Then if
$M$ is representable by \tcode{iter_difference_t<I>},}
\tcode{I} models \tcode{\placeholdernc{Advanceable}} only if
\begin{itemize}
\item \tcode{(a += n)} is equal to \tcode{b}.
\item \tcode{addressof(a += n)} is equal to \tcode{addressof(a)}.
\item \tcode{(a + n)} is equal to \tcode{(a += n)}.
\item For any two positive \oldtxt{integers} \newtxt{values}
  \tcode{x} and \tcode{y} \newtxt{of type \tcode{D}},
  if \tcode{(a + \newtxt{D}(x + y)} is valid, then
  \tcode{(a + \newtxt{D}(x + y))} is equal to \tcode{((a + x) + y)}.
\item \tcode{(a + \newtxt{D(0)}\oldtxt{zero})} is equal to \tcode{a}.
\item If \tcode{(a + \newtxt{D}(n - \oldtxt{one}\newtxt{1}))} is valid, then
  \tcode{(a + n)} is equal to \tcode{++(a + \newtxt{D}(n - \oldtxt{one}\newtxt{1}))}.
\item \tcode{(b += -n)} is equal to \tcode{a}.
\item \tcode{(b -= n)} is equal to \tcode{a}.
\item \tcode{addressof(b -= n)} is equal to \tcode{addressof(b)}.
\item \tcode{(b - n)} is equal to \tcode{(b -= n)}.
\item \tcode{(b - a)} is equal to \tcode{n}.
\item \tcode{(a - b)} is equal to \tcode{-n}.
\item \tcode{\newtxt{bool}(a <= b)} \newtxt{is \tcode{true}}.
\end{itemize}

\indexlibrary{\idxcode{iota_view}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr explicit iota_view(W value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{Bound} denotes \tcode{unreachable} or
\tcode{Bound\oldtxt{\{\}}\newtxt{()}} is reachable from \tcode{value}.

\pnum
\effects Initializes \tcode{value_} with \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{iota_view}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr iota_view(W value, Bound bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{Bound} denotes \tcode{unreachable} or
\tcode{bound} is reachable from \tcode{value}.

\pnum
\effects Initializes \tcode{value_} with \tcode{value} and
\tcode{bound_} with \tcode{bound}.

\pnum
\remarks This constructor does not contribute a function template to the overload
set used when resolving a placeholder for a deduced class
type\cxxiref{over.match.class.deduct}.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr iterator begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return iterator\{value_\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr sentinel end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return sentinel\{bound_\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr iterator end() const requires Same<W, Bound>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return iterator\{bound_\};}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{size}!\idxcode{iota_view}}%
\begin{itemdecl}
constexpr auto size() const requires
  (Same<W, Bound> && @\placeholdernc{Advanceable}@<W>) ||
  (Integral<W> && Integral<Bound>) ||
  SizedSentinel<Bound, W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return bound_ - value_;}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.iota.iterator]{Class \tcode{iota_view::iterator}}

\begin{codeblock}
namespace std::ranges {
  template<class W, class Bound>
  struct iota_view<W, Bound>::iterator {
  private:
    W value_ @\oldtxt{\{\}} \newtxt{= W()}@; // \expos
  public:
    using iterator_category = @\seebelownc@;
    using value_type = W;
    using difference_type = iter_difference_t<W>;

    iterator() = default;
    explicit constexpr iterator(W value);

    constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v<W>);

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int) requires Incrementable<W>;

    constexpr iterator& operator--() requires @\placeholdernc{Decrementable}@<W>;
    constexpr iterator operator--(int) requires @\placeholdernc{Decrementable}@<W>;

    constexpr iterator& operator+=(difference_type n)
      requires @\placeholdernc{Advanceable}@<W>;
    constexpr iterator& operator-=(difference_type n)
      requires @\placeholdernc{Advanceable}@<W>;
    constexpr W operator[](difference_type n) const
      requires @\placeholdernc{Advanceable}@<W>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires EqualityComparable<W>;
    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires EqualityComparable<W>;

    friend constexpr bool operator<(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<W>;
    friend constexpr bool operator>(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<W>;
    friend constexpr bool operator<=(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<W>;
    friend constexpr bool operator>=(const iterator& x, const iterator& y)
      requires StrictTotallyOrdered<W>;

    friend constexpr iterator operator+(iterator i, difference_type n)
      requires @\placeholdernc{Advanceable}@<W>;
    friend constexpr iterator operator+(difference_type n, iterator i)
      requires @\placeholdernc{Advanceable}@<W>;

    friend constexpr iterator operator-(iterator i, difference_type n)
      requires @\placeholdernc{Advanceable}@<W>;
    friend constexpr difference_type operator-(const iterator& x, const iterator& y)
      requires @\placeholdernc{Advanceable}@<W>;
  };
}
\end{codeblock}

\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
\item If \tcode{W} models \tcode{\placeholder{Advanceable}}, then
\tcode{iterator_category} is \tcode{random_access_iterator_tag}.
\item Otherwise, if \tcode{W} models \tcode{\placeholder{Decrementable}}, then
\tcode{iterator_category} is \tcode{bidirectional_iterator_tag}.
\item Otherwise, if \tcode{W} models \libconcept{Incrementable}, then
\tcode{iterator_category} is \tcode{forward_iterator_tag}.
\item Otherwise, \tcode{iterator_category} is \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\begin{note}
Overloads for \tcode{iter_move} and \tcode{iter_swap} are omitted intentionally.
\end{note}

\indexlibrary{\idxcode{iterator}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
explicit constexpr iterator(W value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} with \tcode{value}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr W operator*() const noexcept(is_nothrow_copy_constructible_v<W>);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return value_;}

\pnum
\begin{note}
The \tcode{noexcept} clause is needed by the default \tcode{iter_move}
implementation.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
++value_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{++*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator operator++(int) requires Incrementable<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator--() requires @\placeholdernc{Decrementable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
--value_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator operator--(int) requires @\placeholdernc{Decrementable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator+=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator+=(difference_type n)
  requires @\placeholdernc{Advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
value_ += n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator-=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator-=(difference_type n)
  requires @\placeholdernc{Advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
value_ -= n;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator[]}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
constexpr W operator[](difference_type n) const
  requires @\placeholdernc{Advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return value_ + n;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires EqualityComparable<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.value_ == y.value_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires EqualityComparable<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator<}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator<(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.value_ < y.value_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator>(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y < x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator<=(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y < x);}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator>=(const iterator& x, const iterator& y)
  requires StrictTotallyOrdered<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x < y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator+(iterator i, difference_type n)
  requires @\placeholdernc{Advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return iterator\{\oldtxt{*}i\newtxt{.value_} + n\};}
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator+(difference_type n, iterator i)
  requires @\placeholdernc{Advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return i + n;}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr iterator operator-(iterator i, difference_type n)
  requires @\placeholdernc{Advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return i + -n;}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{iota_view::iterator}}
\begin{itemdecl}
friend constexpr difference_type operator-(const iterator& x, const iterator& y)
  requires @\placeholdernc{Advanceable}@<W>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return \oldtxt{*}x\newtxt{.value_} - \oldtxt{*}y\newtxt{.value_};}
\end{itemdescr}

\rSec3[range.iota.sentinel]{Class \tcode{iota_view::sentinel}}

\begin{codeblock}
namespace std::ranges {
  template<class W, class Bound>
  struct iota_view<W, Bound>::sentinel {
  private:
    Bound bound_ @\oldtxt{\{\}} \newtxt{= Bound()}@; // \expos
  public:
    sentinel() = default;
    constexpr explicit sentinel(Bound bound);

    friend constexpr bool operator==(const iterator& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator& y);
    friend constexpr bool operator!=(const iterator& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator& y);
  };
}
\end{codeblock}

\indexlibrary{\idxcode{sentinel}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
constexpr explicit sentinel(Bound bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{bound_} with \tcode{bound}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.value_ == y.bound_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y == x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{iota_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y == x);}
\end{itemdescr}

\rSec3[range.iota.adaptor]{\tcode{view::iota}}

\pnum
The name \tcode{view::iota} denotes a
customization point object\cxxiref{customization.point.object}.
\newtxt{For subexpressions \tcode{E} and \tcode{F},}
the expressions \tcode{view::iota(E)} and \tcode{view::iota(E, F)}
\oldtxt{for some subexpressions \tcode{E} and \tcode{F}} are expression-equivalent to
\tcode{iota_view\{E\}} and \tcode{iota_view\{E, F\}}, respectively.


\rSec2[range.take]{Take view}

\rSec3[range.take.overview]{Overview}

\pnum
\tcode{take_view} produces a \libconcept{View} of \oldtxt{the first} \newtxt{at most} $N$ elements
from another \libconcept{View}.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is{0,1,2,3,4,5,6,7,8,9};
take_view few{is, 5};
for (int i : few)
  cout << i << ' '; // prints: 0 1 2 3 4
\end{codeblock}
\end{example}

\rSec3[range.take.view]{Class template \tcode{take_view}}

\begin{codeblock}
namespace std::ranges {
  template<View V>
  class take_view : public view_interface<take_view<V>> {
  private:
    V base_ @\oldtxt{\{\}} \newtxt{= V()}@;                                  // \expos
    iter_difference_t<iterator_t<V>> count_ = 0; // \expos
    template<bool> struct sentinel;              // \expos
  public:
    take_view() = default;
    constexpr take_view(V base, iter_difference_t<iterator_t<V>> count);
    template<ViewableRange R>
      requires Constructible<V, all_view<R>>
    constexpr take_view(R&& r, iter_difference_t<iterator_t<V>> count);

    constexpr V base() const;

    constexpr auto begin() requires @\newtxt{(}@!@\placeholder{simple-view}@<V>@\newtxt{)}@@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (SizedRange<V>) \{}@
        @\newtxt{if constexpr (RandomAccessRange<V>)}@
          @\newtxt{return ranges::begin(base_);}@
        @\newtxt{else}@
          @\newtxt{return counted_iterator\{ranges::begin(base_), size()\};}@
      @\newtxt{\} else}@
        @\newtxt{return counted_iterator\{ranges::begin(base_), count_\};}@
    @\newtxt{\}}@

    constexpr auto begin() const requires Range<const V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (SizedRange<const V>) \{}@
        @\newtxt{if constexpr (RandomAccessRange<const V>)}@
          @\newtxt{return ranges::begin(base_);}@
        @\newtxt{else}@
          @\newtxt{return counted_iterator\{ranges::begin(base_), size()\};}@
      @\newtxt{\} else}@
        @\newtxt{return counted_iterator\{ranges::begin(base_), count_\};}@
    @\newtxt{\}}@

    constexpr auto end() requires @\newtxt{(}@!@\placeholder{simple-view}@<V>@\newtxt{)}@@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (SizedRange<V>) \{}@
        @\newtxt{if constexpr (RandomAccessRange<V>)}@
          @\newtxt{return ranges::begin(base_) + size();}@
        @\newtxt{else}@
          @\newtxt{return default_sentinel\{\};}@
      @\newtxt{\} else}@
        @\newtxt{return sentinel<false>\{ranges::end(base_)\};}@
    @\newtxt{\}}@

    constexpr auto end() const requires Range<const V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (SizedRange<const V>) \{}@
        @\newtxt{if constexpr (RandomAccessRange<const V>)}@
          @\newtxt{return ranges::begin(base_) + size();}@
        @\newtxt{else}@
          @\newtxt{return default_sentinel\{\};}@
      @\newtxt{\} else}@
        @\newtxt{return sentinel<true>\{ranges::end(base_)\};}@
    @\newtxt{\}}@

    constexpr auto size() requires SizedRange<V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{auto n = ranges::size(base_);}@
      @\newtxt{return ranges::min(n, static_cast<decltype(n)>(count_));}@
    @\newtxt{\}}@

    constexpr auto size() const requires SizedRange<const V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{auto n = ranges::size(base_);}@
      @\newtxt{return ranges::min(n, static_cast<decltype(n)>(count_));}@
    @\newtxt{\}}@
  };

  template<Range R>
    take_view(R&& base, iter_difference_t<iterator_t<R>> n)
      -> take_view<all_view<R>>;
}
\end{codeblock}

\indexlibrary{\idxcode{take_view}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr take_view(V base, iter_difference_t<iterator_t<V>> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)} and
\tcode{count_} with \tcode{count}.
\end{itemdescr}

\indexlibrary{\idxcode{take_view}!\idxcode{take_view}}%
\begin{itemdecl}
template<ViewableRange R>
  requires Constructible<V, all_view<R>>
constexpr take_view(R&& r, iter_difference_t<iterator_t<V>> count);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))}
and \tcode{count_} with \tcode{count}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr V base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return base_;}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{begin}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto begin() requires @\newtxt{(}@!@\placeholder{simple-view}@<V>@\newtxt{)}@;
constexpr auto begin() const requires Range<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{T} be \tcode{V} for the first overload and \tcode{const V} for the
second.

\pnum
\effects
\begin{itemize}
\item If \tcode{T} models both \libconcept{SizedRange} and
  \libconcept{RandomAccessRange}, equivalent to:
  \tcode{return ranges::begin(base_);}
\item Otherwise, if \tcode{T} models \libconcept{SizedRange}, equivalent to:
  \tcode{return counted_iterator\{ranges::begin(base_), size()\};}
\item Otherwise, equivalent to:
  \tcode{return counted_iterator\{ranges::begin(base_), count_\};}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto end() requires @\newtxt{(}@!@\placeholder{simple-view}@<V>@\newtxt{)}@;
constexpr auto end() const requires Range<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{T} be \tcode{V} for the first overload and \tcode{const V} for the
second.

\pnum
\effects
\begin{itemize}
\item If \tcode{T} models both \libconcept{SizedRange} and
  \libconcept{RandomAccessRange}, equivalent to:
  \tcode{return ranges::begin(base_) + size();}
\item Otherwise, if \tcode{T} models \libconcept{SizedRange}, equivalent to:
  \tcode{return default_sentinel\{\};}
\item Otherwise, equivalent to:
  \tcode{return sentinel<is_const_v<T>>\{ranges::end(base_)\};}
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{take_view}}%
\begin{itemdecl}
constexpr auto size() requires SizedRange<V>;
constexpr auto size() const requires SizedRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto n = ranges::size(base_);
return ranges::min(n, static_cast<decltype(n)>(count_));
\end{codeblock}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.take.sentinel]{Class template \tcode{take_view::sentinel}}

\begin{codeblock}
namespace std::ranges {
  template<class V>
  template<bool Const>
  class take_view<V>::sentinel { // \expos
  private:
    using Base = conditional_t<Const, const V, V>; // \expos
    using CI = counted_iterator<iterator_t<Base>>; // \expos
    sentinel_t<Base> end_ @\oldtxt{\{\}} \newtxt{= sentinel_t<Base>()}@;                      // \expos
  public:
    sentinel() = default;
    constexpr explicit sentinel(sentinel_t<Base> end);
    constexpr sentinel(sentinel<!Const> s)
      requires Const && ConvertibleTo<sentinel_t<V>, sentinel_t<Base>>;

    constexpr sentinel_t<Base> base() const;

    friend constexpr bool operator==(const sentinel& x, const CI& y);
    friend constexpr bool operator==(const CI& y, const sentinel& x);
    friend constexpr bool operator!=(const sentinel& x, const CI& y);
    friend constexpr bool operator!=(const CI& y, const sentinel& x);
  };
}
\end{codeblock}

\indexlibrary{\idxcode{sentinel}!\idxcode{take_view::sentinel}}
\begin{itemdecl}
constexpr explicit sentinel(sentinel_t<Base> end);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{end}.
\end{itemdescr}

\indexlibrary{\idxcode{sentinel}!\idxcode{take_view::sentinel}}%
\begin{itemdecl}
constexpr sentinel(sentinel<!Const> s)
  requires Const && ConvertibleTo<sentinel_t<V>, sentinel_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{\newtxt{std::move(}s.end_\newtxt{)}}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{take_view::sentinel}}
\begin{itemdecl}
constexpr sentinel_t<Base> base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{take_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const CI& y);
friend constexpr bool operator==(const CI& y, const sentinel& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return y.count() == 0 || y.base() == x.end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{take_view::sentinel}}%
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const CI& y);
friend constexpr bool operator!=(const CI& y, const sentinel& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\rSec3[range.take.adaptor]{\tcode{view::take}}

\pnum
The name \tcode{view::take} denotes a
range adaptor object\iref{range.adaptor.object}. The expression
\tcode{view::take(E, F)} for some subexpressions \tcode{E} and \tcode{F} is
expression-equivalent to \tcode{take_view\{E, F\}}.


\rSec2[range.join]{Join view}

\rSec3[range.join.overview]{Overview}

\pnum
\tcode{join_view} flattens a \libconcept{View} of ranges into a
\libconcept{View}.

\pnum
\begin{example}
\begin{codeblock}
vector<string> ss{"hello", " ", "world", "!"};
join_view greeting{ss};
for (char ch : greeting)
  cout << ch; // prints: hello world!
\end{codeblock}
\end{example}

\rSec3[range.join.view]{Class template \tcode{join_view}}

\begin{codeblock}
namespace std::ranges {
  template<InputRange V>
    requires View<V> && InputRange<iter_reference_t<iterator_t<V>>> &&
      (is_reference_v<iter_reference_t<iterator_t<V>>> ||
      View<iter_value_t<iterator_t<V>>>)
  class join_view : public view_interface<join_view<V>> {
  private:
    using InnerRng =              // \expos
      iter_reference_t<iterator_t<V>>;
    template<bool Const>
      struct iterator;            // \expos
    template<bool Const>
      struct sentinel;            // \expos

    V base_ @\oldtxt{\{\}} \newtxt{= V()}@;                   // \expos
    all_view<InnerRng> inner_ @\oldtxt{\{\}} \newtxt{= all_view<InnerRng>()}@; // \expos, only present when \tcode{!is_reference_v<InnerRng>}
  public:
    join_view() = default;
    constexpr explicit join_view(V base);

    template<InputRange R>
      requires ViewableRange<R> && Constructible<V, all_view<R>>
    constexpr explicit join_view(R&& r);

    constexpr auto begin()@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{return iterator<\placeholder{simple-view}<V>>\{*this, ranges::begin(base_)\};}@
    @\newtxt{\}}@

    constexpr auto begin() const requires InputRange<const V> &&
      is_reference_v<iter_reference_t<iterator_t<const V>>>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{return iterator<true>\{*this, ranges::begin(base_)\};}@
    @\newtxt{\}}@

    constexpr auto end()@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (ForwardRange<V> \&\&}@
                    @\newtxt{is_reference_v<InnerRng> \&\& ForwardRange<InnerRng> \&\&}@
                    @\newtxt{CommonRange<V> \&\& CommonRange<InnerRng>)}@
        @\newtxt{return iterator<\placeholder{simple-view}<V>>\{*this, ranges::end(base_)\};}@
      @\newtxt{else}@
        @\newtxt{return sentinel<\placeholder{simple-view}<V>>\{*this\};}@
    @\newtxt{\}}@

    constexpr auto end() const requires InputRange<const V> &&
      is_reference_v<iter_reference_t<iterator_t<const V>>>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (ForwardRange<const V> \&\&}@
                    @\newtxt{is_reference_v<iter_reference_t<iterator_t<const V>>> \&\&}@
                    @\newtxt{ForwardRange<iter_reference_t<iterator_t<const V>>> \&\&}@
                    @\newtxt{CommonRange<const V> \&\&}@
                    @\newtxt{CommonRange<iter_reference_t<iterator_t<const V>>>)}@
        @\newtxt{return iterator<true>\{*this, ranges::end(base_)\};}@
      @\newtxt{else}@
        @\newtxt{return sentinel<true>\{*this\};}@
    @\newtxt{\}}@

    @\oldtxt{constexpr auto end() requires ForwardRange<V> \&\&}@
      @\oldtxt{is_reference_v<InnerRng> \&\& ForwardRange<InnerRng> \&\&}@
      @\oldtxt{CommonRange<V> \&\& CommonRange<InnerRng>;}@

    @\oldtxt{constexpr auto end() const requires ForwardRange<const V> \&\&}@
      @\oldtxt{is_reference_v<iter_reference_t<iterator_t<const V>>> \&\&}@
      @\oldtxt{ForwardRange<iter_reference_t<iterator_t<const V>>> \&\&}@
      @\oldtxt{CommonRange<const V> \&\& CommonRange<iter_reference_t<iterator_t<const V>>>;}@
  };

  template<class R>
    explicit join_view(R&&) -> join_view<all_view<R>>;
}
\end{codeblock}

\indexlibrary{\idxcode{join_view}!\idxcode{join_view}}%
\begin{itemdecl}
explicit constexpr join_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrary{\idxcode{join_view}!\idxcode{join_view}}%
\begin{itemdecl}
template<InputRange R>
  requires ViewableRange<R> && Constructible<V, all_view<R>>
constexpr explicit join_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{begin}!\idxcode{join_view}}%
\begin{itemdecl}
constexpr auto begin();
constexpr auto begin() const requires InputRange<const V> &&
  is_reference_v<iter_reference_t<iterator_t<const V>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return iterator<$C$>\{*this, ranges::begin(base_)\};} \\
where $C$ is \tcode{\placeholder{simple-view}<V>} or \tcode{true}
for the first and second overloads, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{join_view}}%
\begin{itemdecl}
constexpr auto end();
constexpr auto end() const requires InputRange<const V> &&
  is_reference_v<iter_reference_t<iterator_t<const V>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return sentinel<$C$>\{*this\};} \\
where $C$ is \tcode{\placeholder{simple-view}<V>} or \tcode{true}
for the first and second overload, respectively.
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{join_view}}%
\begin{itemdecl}
constexpr auto end() requires ForwardRange<V> &&
  is_reference_v<InnerRng> && ForwardRange<InnerRng> &&
  CommonRange<V> && CommonRange<InnerRng>;
constexpr auto end() const requires ForwardRange<const V> &&
  is_reference_v<iter_reference_t<iterator_t<const V>>> &&
  ForwardRange<iter_reference_t<iterator_t<const V>>> &&
  CommonRange<const V> && CommonRange<iter_reference_t<iterator_t<const V>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return iterator<$C$>\{*this, ranges::end(base_)\};} \\
where $C$ is \tcode{\placeholder{simple-view}<V>} or \tcode{true}
for the first and second overloads, respectively.
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.join.iterator]{Class template \tcode{join_view::iterator}}

\pnum
\begin{codeblock}
namespace std::ranges {
template<class V>
  template<bool Const>
  struct join_view<V>::iterator { // \expos
  private:
    using Parent =                                            // \expos
      conditional_t<Const, const join_view, join_view>;
    using Base   = conditional_t<Const, const V, V>;          // \expos

    static constexpr bool ref_is_glvalue =                    // \expos
      is_reference_v<iter_reference_t<iterator_t<Base>>>;

    iterator_t<Base> outer_ @\oldtxt{\{\}} \newtxt{= iterator_t<Base>()}@;          // \expos
    iterator_t<iter_reference_t<iterator_t<Base>>> inner_ @\oldtxt{\{\}} \newtxt{=}@
      @\newtxt{iterator_t<iter_reference_t<iterator_t<Base>>>()}@;       // \expos
    Parent* parent_ = nullptr;                                // \expos

    constexpr void satisfy();                                 // \expos
  public:
    using iterator_concept  = @\seebelownc@;
    using iterator_category = @\seebelownc@;
    using value_type        =
      iter_value_t<iterator_t<iter_reference_t<iterator_t<Base>>>>;
    using difference_type   = @\seebelownc@;

    iterator() = default;
    constexpr iterator(Parent& parent, iterator_t<V> outer);
    constexpr iterator(iterator<!Const> i) requires Const &&
      ConvertibleTo<iterator_t<V>, iterator_t<Base>> &&
      ConvertibleTo<iterator_t<InnerRng>,
        iterator_t<iter_reference_t<iterator_t<Base>>>>;

    constexpr decltype(auto) operator*() const@\oldtxt{;}@
    @\newtxt{\{ return *inner_; \}}@

    constexpr iterator_t<Base> operator->() const
      requires @\placeholder{has-arrow}@<iterator_t<Base>>;

    constexpr iterator& operator++();
    constexpr void operator++(int);
    constexpr iterator operator++(int)
      requires ref_is_glvalue && ForwardRange<Base> &&
        ForwardRange<iter_reference_t<iterator_t<Base>>>;

    constexpr iterator& operator--();
      requires ref_is_glvalue && BidirectionalRange<Base> &&
        BidirectionalRange<iter_reference_t<iterator_t<Base>>>;

    constexpr iterator operator--(int)
      requires ref_is_glvalue && BidirectionalRange<Base> &&
        BidirectionalRange<iter_reference_t<iterator_t<Base>>>;

    friend constexpr bool operator==(const iterator& x, const iterator& y)
      requires ref_is_glvalue && EqualityComparable<iterator_t<Base>> &&
        EqualityComparable<iterator_t<iter_reference_t<iterator_t<Base>>>>;

    friend constexpr bool operator!=(const iterator& x, const iterator& y)
      requires ref_is_glvalue && EqualityComparable<iterator_t<Base>> &&
        EqualityComparable<iterator_t<iter_reference_t<iterator_t<Base>>>>;

    friend constexpr decltype(auto) iter_move(const iterator& i)
      noexcept(noexcept(ranges::iter_move(i.inner_)))@\oldtxt{;}@
    @\newtxt{\{ return ranges::iter_move(i.inner_); \}}@

    friend constexpr void iter_swap(const iterator& x, const iterator& y)
      noexcept(noexcept(ranges::iter_swap(x.inner_, y.inner_)));
  };
}
\end{codeblock}

\pnum
\tcode{iterator::iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{ref_is_glvalue} is \tcode{true},
  \begin{itemize}
  \item If \tcode{Base} and \tcode{iter_reference_t<iterator_t<Base>>} each model
    \libconcept{BidirectionalRange}, then \tcode{iterator_concept} denotes
    \tcode{bidirectional_iterator_tag}.
  \item Otherwise, if \tcode{Base} and \tcode{iter_reference_t<iterator_t<Base>>}
    each model \libconcept{ForwardRange}, then \tcode{iterator_concept} denotes
    \tcode{forward_iterator_tag}.
  \end{itemize}
\item Otherwise, \tcode{iterator_concept} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\tcode{iterator::iterator_category} is defined as follows:
\begin{itemize}
\item Let \placeholder{OUTERC} denote
  \tcode{iterator_traits<iterator_t<Base>>::iterator_category}, and
  let \placeholder{INNERC} denote
  \tcode{iterator_traits<iterator_t<iter_reference_t<iterator_t<Base>>>>::iterator_category}.
\item If \tcode{ref_is_glvalue} is \tcode{true},
  \begin{itemize}
  \item If \placeholder{OUTERC} and \placeholder{INNERC} each model
    \tcode{DerivedFrom<bidirectional_iterator_tag>}, \tcode{iterator_category}
    denotes \tcode{bidirectional_iterator_tag}.
  \item Otherwise, if \placeholder{OUTERC} and \placeholder{INNERC} each model
    \tcode{DerivedFrom<forward_iterator_tag>}, \tcode{iterator_category}
    denotes \tcode{forward_iterator_tag}.
  \end{itemize}
\item Otherwise, \tcode{iterator_category} denotes \tcode{input_iterator_tag}.
\end{itemize}

\pnum
\tcode{iterator::difference_type} denotes the type:
\begin{codeblock}
common_type_t<
  iter_difference_t<iterator_t<Base>>,
  iter_difference_t<iterator_t<iter_reference_t<iterator_t<Base>>>>>
\end{codeblock}

\pnum
\tcode{join_view} iterators use the \tcode{satisfy} function to skip over
empty inner ranges.

\begin{itemdecl}
constexpr void satisfy(); // \expos
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto update_inner = [this](reference_t<iterator_t<Base>> x) -> decltype(auto) {
  if constexpr (ref_is_glvalue) // \tcode{x} is a reference
    return (x); // \tcode{(x)} is an lvalue
  else
    return (parent_->inner_ = view::all(x));
};

for (; outer_ != ranges::end(parent_->base_); ++outer_) {
  auto& inner = update_inner(*outer_);
  inner_ = ranges::begin(inner);
  if (inner_ != ranges::end(inner))
    return;
}
if constexpr (ref_is_glvalue)
  inner_ = iterator_t<iter_reference_t<iterator_t<Base>>>@\oldtxt{\{\}}\newtxt{()}@;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{iterator}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator(Parent& parent, iterator_t<V> outer)
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{outer_} with \tcode{outer} and
\tcode{parent_} with \tcode{addressof(parent)}; then calls \tcode{satisfy()}.
\end{itemdescr}

\indexlibrary{\idxcode{iterator}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator(iterator<!Const> i) requires Const &&
  ConvertibleTo<iterator_t<V>, iterator_t<Base>> &&
  ConvertibleTo<iterator_t<InnerRng>,
      iterator_t<iter_reference_t<iterator_t<Base>>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{outer_} with \tcode{\newtxt{std::move(}i.outer_\newtxt{)}},
\tcode{inner_} with \tcode{\newtxt{std::move(}i.inner_\newtxt{)}}, and
\tcode{parent_} with \tcode{i.parent_}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator*}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr decltype(auto) operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return *inner_;}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator->}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator_t<Base> operator->() const
  requires @\placeholder{has-arrow}@<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{return inner_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{\placeholder{inner-range}} be:
\begin{itemize}
\item If \tcode{ref_is_glvalue} is \tcode{true}, \tcode{*outer_}.
\item Otherwise, \tcode{parent_->inner_}.
\end{itemize}

\pnum
\effects Equivalent to:
\begin{codeblock}
@\newtxt{auto\&\& inner_rng = \placeholdernc{inner-range};}@
if (++inner_ == ranges::end(@\oldtxt{\placeholdernc{inner-range}}\newtxt{inner_rng}@)) {
  ++outer_;
  satisfy();
}
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{++*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator operator++(int)
  requires ref_is_glvalue && ForwardRange<Base> &&
    ForwardRange<iter_reference_t<iterator_t<Base>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator& operator--();
  requires ref_is_glvalue && BidirectionalRange<Base> &&
    BidirectionalRange<iter_reference_t<iterator_t<Base>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
if (outer_ == ranges::end(parent_->base_))
  inner_ = ranges::end(*--outer_);
while (inner_ == ranges::begin(*outer_))
  inner_ = ranges::end(*--outer_);
--inner_;
return *this;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{join_view::iterator}}
\begin{itemdecl}
constexpr iterator operator--(int)
  requires ref_is_glvalue && BidirectionalRange<Base> &&
    BidirectionalRange<iter_reference_t<iterator_t<Base>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator& x, const iterator& y)
  requires ref_is_glvalue && EqualityComparable<iterator_t<Base>> &&
    EqualityComparable<iterator_t<iter_reference_t<iterator_t<Base>>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return x.outer_ == y.outer_ \&\& x.inner_ == y.inner_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator& x, const iterator& y)
  requires ref_is_glvalue && EqualityComparable<iterator_t<Base>> &&
    EqualityComparable<iterator_t<iter_reference_t<iterator_t<Base>>>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{iter_move}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr decltype(auto) iter_move(const iterator& i)
  noexcept(noexcept(ranges::iter_move(i.inner_)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(i.inner_);}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{join_view::iterator}}
\begin{itemdecl}
friend constexpr void iter_swap(const iterator& x, const iterator& y)
  noexcept(noexcept(ranges::iter_swap(x.inner_, y.inner_)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_swap(x.inner_, y.inner_);}
\end{itemdescr}

\rSec3[range.join.sentinel]{Class template \tcode{join_view::sentinel}}

\begin{codeblock}
namespace std::ranges {
  template<class V>
  template<bool Const>
  struct join_view<V>::sentinel { // \expos
  private:
    using Parent =                                   // \expos
      conditional_t<Const, const join_view, join_view>;
    using Base   = conditional_t<Const, const V, V>; // \expos
    sentinel_t<Base> end_ @\oldtxt{\{\}} \newtxt{= sentinel_t<Base>()}@;                        // \expos
  public:
    sentinel() = default;

    constexpr explicit sentinel(Parent& parent);
    constexpr sentinel(sentinel<!Const> s) requires Const &&
        ConvertibleTo<sentinel_t<V>, sentinel_t<Base>>;

    friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
    friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
    friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);
  };
}
\end{codeblock}

\indexlibrary{\idxcode{sentinel}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
constexpr explicit sentinel(Parent& parent);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{ranges::end(parent.base_)}.
\end{itemdescr}

\indexlibrary{\idxcode{sentinel}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
constexpr sentinel(sentinel<!Const> s) requires Const &&
  ConvertibleTo<sentinel_t<V>, sentinel_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{end_} with \tcode{\newtxt{std::move(}s.end_\newtxt{)}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.outer_ == y.end_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator==(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return y == x;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const iterator<Const>& x, const sentinel& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{join_view::sentinel}}
\begin{itemdecl}
friend constexpr bool operator!=(const sentinel& x, const iterator<Const>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(y == x);}
\end{itemdescr}

\rSec3[range.join.adaptor]{\tcode{view::join}}

\pnum
The name \tcode{view::join} denotes a
range adaptor object\iref{range.adaptor.object}. The expression
\tcode{view::join(E)} for some subexpression \tcode{E} is expression-equivalent
to \tcode{join_view\{E\}}.


\rSec2[range.empty]{Empty view}

\rSec3[range.empty.overview]{Overview}

\pnum
\tcode{empty_view} produces a \libconcept{View} of no elements of
a particular type.

\pnum
\begin{example}
\begin{codeblock}
empty_view<int> e;
static_assert(ranges::empty(e));
static_assert(0 == e.size());
\end{codeblock}
\end{example}

\rSec3[range.empty.view]{Class template \tcode{empty_view}}

\begin{codeblock}
namespace std::ranges {
  template<class T>
    requires is_object_v<T>
  class empty_view : public view_interface<empty_view<T>> {
  public:
    constexpr static T* begin() noexcept { return nullptr; }
    constexpr static T* end() noexcept { return nullptr; }
    constexpr static T* data() noexcept { return nullptr; }
    constexpr static ptrdiff_t size() noexcept { return 0; }
    constexpr static bool empty() noexcept { return true; }

    friend constexpr T* begin(empty_view) noexcept { return nullptr; }
    friend constexpr T* end(empty_view) noexcept { return nullptr; }
  };
}
\end{codeblock}


\rSec2[range.single]{Single view}

\rSec3[range.single.overview]{Overview}

\pnum
\tcode{single_view} produces a \libconcept{View} that contains
exactly one element of a specified value.

\pnum
\begin{example}
\begin{codeblock}
single_view s{4};
for (int i : s)
  cout << i; // prints 4
\end{codeblock}
\end{example}

\rSec3[range.single.view]{Class template \tcode{single_view}}

\begin{codeblock}
namespace std::ranges {
  template<CopyConstructible T>
    requires is_object_v<T>
  class single_view : public view_interface<single_view<T>> {
  private:
    @\placeholder{semiregular}@<T> value_; // \expos
  public:
    single_view() = default;
    constexpr explicit single_view(const T& t);
    constexpr explicit single_view(T&& t);
    template<class... Args>
      requires Constructible<T, Args...>
    constexpr single_view(in_place_t, Args&&... args);

    constexpr T* begin() noexcept;
    constexpr const T* begin() const noexcept;
    constexpr T* end() noexcept;
    constexpr const T* end() const noexcept;
    constexpr static ptrdiff_t size() noexcept;
    constexpr T* data() noexcept;
    constexpr const T* data() const noexcept;
  };

  @\oldtxt{template<class T>}@
    @\oldtxt{explicit single_view(T\&\&) -> single_view<decay_t<T>>;}@
}
\end{codeblock}

\indexlibrary{\idxcode{single_view}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr explicit single_view(const T& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} with \tcode{t}.
\end{itemdescr}

\indexlibrary{\idxcode{single_view}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr explicit single_view(T&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} with \tcode{std::move(t)}.
\end{itemdescr}

\indexlibrary{\idxcode{single_view}!\idxcode{single_view}}%
\begin{itemdecl}
template<class... Args>
constexpr single_view(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{value_} as if by
\tcode{value_\{in_place, std::forward<Args>(args)...\}}.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr T* begin() noexcept;
constexpr const T* begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return data();}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr T* end() noexcept;
constexpr const T* end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return data() + 1;}
\end{itemdescr}

\indexlibrary{\idxcode{size}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr static ptrdiff_t size() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return 1;}
\end{itemdescr}

\indexlibrary{\idxcode{data}!\idxcode{single_view}}%
\begin{itemdecl}
constexpr T* data() noexcept;
constexpr const T* data() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return value_.operator->();}
\end{itemdescr}

\rSec3[range.single.adaptor]{\tcode{view::single}}

\pnum
The name \tcode{view::single} denotes a
customization point object\cxxiref{customization.point.object}. The expression
\tcode{view::single(E)} for some subexpression \tcode{E} is
expression-equivalent to \tcode{single_view\{E\}}.


\rSec2[range.split]{Split view}

\rSec3[range.split.overview]{Overview}

\pnum
\tcode{split_view} takes a \libconcept{View} and a delimiter, and splits
the \libconcept{View} into subranges on the delimiter. The delimiter can be
a single element or a \libconcept{View} of elements.

\pnum
\begin{example}
\begin{codeblock}
string str{"the quick brown fox"};
split_view sentence{str, ' '};
for (auto word : sentence) {
  for (char ch : word)
    cout << ch;
  cout << " *";
}
// The above prints: the *quick *brown *fox *
\end{codeblock}
\end{example}

\rSec3[range.split.view]{Class template \tcode{split_view}}

\begin{codeblock}
namespace std::ranges {
  template<class R>
  concept @\placeholder{tiny-range}@ = // \expos
    SizedRange<R> && (remove_reference_t<R>::size() <= 1);

  template<InputRange V, ForwardRange Pattern>
    requires View<V> && View<Pattern> &&
      IndirectlyComparable<iterator_t<V>, iterator_t<Pattern>, ranges::equal_to<>> &&
      (ForwardRange<V> || @\placeholdernc{tiny-range}@<Pattern>)
  class split_view : public view_interface<split_view<V, Pattern>> {
  private:
    V base_ @\oldtxt{\{\}} \newtxt{= V()}@;                                 // \expos
    Pattern pattern_ @\oldtxt{\{\}} \newtxt{= Pattern()}@;                        // \expos
    iterator_t<V> current_ @\oldtxt{\{\}} \newtxt{= iterator_t<V>()}@;                  // \expos, only present if \tcode{!ForwardRange<V>}
    template<bool Const> struct outer_iterator; // \expos
    template<bool Const> struct inner_iterator; // \expos
  public:
    split_view() = default;
    constexpr split_view(V base, Pattern pattern);

    template<InputRange R, ForwardRange P>
      requires
        Constructible<V, all_view<R>> &&
        Constructible<Pattern, all_view<P>>
    constexpr split_view(R&& r, P&& p);

    template<InputRange R>
      requires
        Constructible<V, all_view<R>> &&
        Constructible<Pattern, single_view<iter_value_t<iterator_t<R>>>>
    constexpr split_view(R&& r, iter_value_t<iterator_t<R>> e);

    constexpr auto begin()@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (ForwardRange<V>)}@
        @\newtxt{return outer_iterator<\placeholder{simple-view}<V>>\{*this, ranges::begin(base_)\};}@
      @\newtxt{else \{}@
        @\newtxt{current_ = ranges::begin(base_);}@
        @\newtxt{return outer_iterator<false>\{*this\};}@
      @\newtxt{\}}@
    @\newtxt{\}}@

    constexpr auto begin() const
      requires ForwardRange<V> && ForwardRange<const V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{return outer_iterator<true>\{*this, ranges::begin(base_)\};}@
    @\newtxt{\}}@

    constexpr auto end()
      requires ForwardRange<V> && CommonRange<V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{return outer_iterator<\placeholder{simple-view}<V>>\{*this, ranges::end(base_)\};}@
    @\newtxt{\}}@

    constexpr auto end() const@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (ForwardRange<V> \&\& ForwardRange<const V> \&\& CommonRange<const V>)}@
        @\newtxt{return outer_iterator<true>\{*this, ranges::end(base_)\};}@
      @\newtxt{else}@
        @\newtxt{return default_sentinel\{\};}@
    @\newtxt{\}}@

  };

  template<class R, class P>
    split_view(R&&, P&&) -> split_view<all_view<R>, all_view<P>>;

  template<InputRange R>
    split_view(R&&, iter_value_t<iterator_t<R>>)
      -> split_view<all_view<R>, single_view<iter_value_t<iterator_t<R>>>>;
}
\end{codeblock}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr split_view(V base, Pattern pattern);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}, and
\tcode{pattern_} with \tcode{std::move(pattern)}.
\end{itemdescr}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
template<InputRange R, ForwardRange P>
  requires
    Constructible<V, all_view<R>> &&
    Constructible<Pattern, all_view<P>>
constexpr split_view(R&& r, P&& p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))} and
\tcode{pattern_} with \tcode{view::all(std\brk{}::forward<P>(p))}.
\end{itemdescr}

\indexlibrary{\idxcode{split_view}!\idxcode{split_view}}%
\begin{itemdecl}
template<InputRange R>
  requires
    Constructible<V, all_view<R>> &&
    Constructible<Pattern, single_view<iter_value_t<iterator_t<R>>>>
constexpr split_view(R&& r, iter_value_t<iterator_t<R>> e);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))} and
\tcode{pattern_} with \tcode{single_view\{\brk{}std::move(e)\}}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{begin}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{V} models \libconcept{ForwardRange}, equivalent to:
\begin{codeblock}
return outer_iterator<@\placeholder{simple-view}@<V>>{*this, ranges::begin(base_)};
\end{codeblock}
Otherwise, equivalent to:
\begin{codeblock}
current_ = ranges::begin(base_);
return outer_iterator<false>{*this};
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto begin() const
  requires ForwardRange<V> && ForwardRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return outer_iterator<true>\{*this, ranges::begin(base_)\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto end()
  requires ForwardRange<V> && CommonRange<V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return outer_iterator<\placeholder{simple-view}<V>>\{*this, ranges::end(base_)\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{split_view}}%
\begin{itemdecl}
constexpr auto end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{V} models
\tcode{ForwardRange<V> \&\& ForwardRange<const V> \&\& CommonRange<const V>},
equivalent to:
\tcode{return outer_iterator<true>\{*this, ranges::end(base_)\};}
Otherwise, equivalent to: \tcode{return default_sentinel\{\};}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.split.outer]{Class template \tcode{split_view::outer_iterator}}

\begin{codeblock}
namespace std::ranges {
  template<class V, class Pattern>
  template<bool Const>
  struct split_view<V, Pattern>::outer_iterator { // \expos
  private:
    using Parent =                // \expos
      conditional_t<Const, const split_view, split_view>;
    using Base   =                // \expos
      conditional_t<Const, const V, V>;
    Parent* parent_ = nullptr;    // \expos
    iterator_t<Base> current_ @\oldtxt{\{\}} \newtxt{= iterator_t<Base>()}@; // \expos, present only if \tcode{V} models \libconcept{ForwardRange}
  public:
    using iterator_concept  =
      conditional_t<ForwardRange<Base>, forward_iterator_tag, input_iterator_tag>;
    using iterator_category = input_iterator_tag;
    struct value_type;
    using difference_type   = iter_difference_t<iterator_t<Base>>;

    outer_iterator() = default;
    constexpr explicit outer_iterator(Parent& parent)
      requires @\newtxt{(}@!ForwardRange<Base>@\newtxt{)}@;
    constexpr outer_iterator(Parent& parent, iterator_t<Base> current)
      requires ForwardRange<Base>;
    constexpr outer_iterator(outer_iterator<!Const> i) requires Const &&
      ConvertibleTo<iterator_t<V>, iterator_t<const V>>;

    constexpr value_type operator*() const;

    constexpr outer_iterator& operator++();
    constexpr decltype(auto) operator++(int)@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (ForwardRange<Base>) \{}@
        @\newtxt{auto tmp = *this;}@
        @\newtxt{++*this;}@
        @\newtxt{return tmp;}@
      @\newtxt{\} else}@
        @\newtxt{++*this;}@
    @\newtxt{\}}@

    friend constexpr bool operator==(const outer_iterator& x, const outer_iterator& y)
      requires ForwardRange<Base>;
    friend constexpr bool operator!=(const outer_iterator& x, const outer_iterator& y)
      requires ForwardRange<Base>;

    friend constexpr bool operator==(const outer_iterator& x, default_sentinel);
    friend constexpr bool operator==(default_sentinel, const outer_iterator& x);
    friend constexpr bool operator!=(const outer_iterator& x, default_sentinel y);
    friend constexpr bool operator!=(default_sentinel y, const outer_iterator& x);
  };
}
\end{codeblock}

\pnum
Many of the following specifications refer to the notional member
\tcode{\placeholder{current}} of \tcode{outer_iterator}.
\tcode{\placeholder{current}} is equivalent to \tcode{current_} if \tcode{V}
models \libconcept{ForwardRange}, and \tcode{parent_->current_} otherwise.

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr explicit outer_iterator(Parent& parent)
  requires @\newtxt{(}@!ForwardRange<Base>@\newtxt{)}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{addressof(parent)}.
\end{itemdescr}

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator(Parent& parent, iterator_t<Base> current)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{addressof(parent)}
and \tcode{current_} with \tcode{current}.
\end{itemdescr}

\indexlibrary{\idxcode{outer_iterator}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator(outer_iterator<!Const> i) requires Const &&
  ConvertibleTo<iterator_t<V>, iterator_t<const V>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{parent_} with \tcode{i.parent_} and
\tcode{current_} with \tcode{\newtxt{std::move(}i.current_\newtxt{)}}.
\end{itemdescr}

\indexlibrary{\idxcode{operator*}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr value_type operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return value_type\{*this\};}
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr outer_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
const auto end = ranges::end(parent_->base_);
if (@\placeholder{current}@ == end) return *this;
const auto [pbegin, pend] = subrange{parent_->pattern_};
if (pbegin == pend) ++@\placeholdernc{current}@;
else {
  do {
    const auto [b, p] = ranges::mismatch(@\placeholdernc{current}@, end, pbegin, pend);
    if (p == pend) {
      @\placeholder{current}@ = b; // The pattern matched; skip it
      break;
    }
  } while (++@\placeholder{current}@ != end);
}
return *this;
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator++}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
constexpr decltype(auto) operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{Base} models \libconcept{ForwardRange}, equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
Otherwise, equivalent to \tcode{++*this}.
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_iterator& x, const outer_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.current_ == y.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const outer_iterator& x, const outer_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const outer_iterator& x, default_sentinel);
friend constexpr bool operator==(default_sentinel, const outer_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return x.\placeholder{current} == ranges::end(x.parent_->base_);}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::outer_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const outer_iterator& x, default_sentinel y);
friend constexpr bool operator!=(default_sentinel y, const outer_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\rSec3[range.split.outer.value_type]{Class \tcode{split_view::outer_iterator::value_type}}

\begin{codeblock}
namespace std::ranges {
  template<class V, class Pattern>
  template<bool Const>
  struct split_view<V, Pattern>::outer_iterator<Const>::value_type {
  private:
    outer_iterator i_ @\oldtxt{\{\}} \newtxt{= outer_iterator()}@; // \expos
  public:
    value_type() = default;
    constexpr explicit value_type(outer_iterator i);

    constexpr inner_iterator<Const> begin() const;
    constexpr default_sentinel end() const;
  };
}
\end{codeblock}

\indexlibrary{\idxcode{value_type}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr explicit value_type(outer_iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{i_} with \tcode{i}.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr inner_iterator<Const> begin() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return inner_iterator<Const>\{i_\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{split_view::outer_iterator::value_type}}%
\begin{itemdecl}
constexpr default_sentinel end() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return \{\};}
\end{itemdescr}

\rSec3[range.split.inner]{Class template \tcode{split_view::inner_iterator}}

\begin{codeblock}
namespace std::ranges {
  template<class V, class Pattern>
  template<bool Const>
  struct split_view<V, Pattern>::inner_iterator { // \expos
  private:
    using Base =
      conditional_t<Const, const V, V>; // \expos
    outer_iterator<Const> i_ @\oldtxt{\{\}} \newtxt{= outer_iterator<Const>()}@;        // \expos
    bool zero_ = false;                 // \expos
  public:
    using iterator_concept  = typename outer_iterator<Const>::iterator_concept;
    using iterator_category = @\seebelownc@;
    using value_type        = iter_value_t<iterator_t<Base>>;
    using difference_type   = iter_difference_t<iterator_t<Base>>;

    inner_iterator() = default;
    constexpr explicit inner_iterator(outer_iterator<Const> i);

    constexpr decltype(auto) operator*() const@\oldtxt{;}@
    @\newtxt{\{ return *i_.\placeholdernc{current}; \}}@

    constexpr inner_iterator& operator++();
    constexpr decltype(auto) operator++(int)@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (ForwardRange<V>) \{}@
        @\newtxt{auto tmp = *this;}@
        @\newtxt{++*this;}@
        @\newtxt{return tmp;}@
      @\newtxt{\} else}@
        @\newtxt{++*this;}@
    @\newtxt{\}}@

    friend constexpr bool operator==(const inner_iterator& x, const inner_iterator& y)
      requires ForwardRange<Base>;
    friend constexpr bool operator!=(const inner_iterator& x, const inner_iterator& y)
      requires ForwardRange<Base>;

    friend constexpr bool operator==(const inner_iterator& x, default_sentinel);
    friend constexpr bool operator==(default_sentinel, const inner_iterator& x);
    friend constexpr bool operator!=(const inner_iterator& x, default_sentinel y);
    friend constexpr bool operator!=(default_sentinel y, const inner_iterator& x);

    friend constexpr decltype(auto) iter_move(const inner_iterator& i)
      noexcept(noexcept(ranges::iter_move(i.i_.@\placeholdernc{current}@)))@\oldtxt{;}@
    @\newtxt{\{ return ranges::iter_move(i.i_.\placeholdernc{current}); \}}@

    friend constexpr void iter_swap(const inner_iterator& x, const inner_iterator& y)
      noexcept(noexcept(ranges::iter_swap(x.i_.@\placeholdernc{current}, y.i_.\placeholdernc{current}@)))
        requires IndirectlySwappable<iterator_t<Base>>;
  };
}
\end{codeblock}

\pnum
The \grammarterm{typedef-name} \tcode{iterator_category} denotes
\tcode{forward_iterator_tag} if
\tcode{iterator_traits<iterator_t<Base>>::iterator_category} models
\tcode{DerivedFrom<forward_iterator_tag>}, and \tcode{input_iterator_tag}
otherwise.

\indexlibrary{\idxcode{inner_iterator}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr explicit inner_iterator(outer_iterator<Const> i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{i_} with \tcode{i}.
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator*}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr decltype(auto) operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return *i_.\placeholdernc{current};}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator++}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr inner_iterator& operator++() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
zero_ = true;
if constexpr (!ForwardRange<Base>) {
  if constexpr (Pattern::size() == 0) {
    return *this;
  }
}
++i_.@\placeholdernc{current}@;
return *this;
\end{codeblock}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{operator++}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
constexpr decltype(auto) operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{V} models \libconcept{ForwardRange}, equivalent to:
\begin{codeblock}
auto tmp = *this;
++*this;
return tmp;
\end{codeblock}
Otherwise, equivalent to \tcode{++*this}.
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const inner_iterator& x, const inner_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return x.i_.current_ == y.i_.current_;}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const inner_iterator& x, const inner_iterator& y)
  requires ForwardRange<Base>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator==(const inner_iterator& x, default_sentinel);
friend constexpr bool operator==(default_sentinel, const inner_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
auto cur = x.i_.@\placeholdernc{current}@;
auto end = ranges::end(x.i_.parent_->base_);
if (cur == end) return true;
auto [pcur, pend] = subrange{x.i_.parent_->pattern_};
if (pcur == pend) return x.zero_;
do {
  if (*cur != *pcur) return false;
  if (++pcur == pend) return true;
} while (++cur != end);
return false;
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{operator!=}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr bool operator!=(const inner_iterator& x, default_sentinel y);
friend constexpr bool operator!=(default_sentinel y, const inner_iterator& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return !(x == y);}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{iter_move}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr decltype(auto) iter_move(const inner_iterator& i)
  noexcept(noexcept(ranges::iter_move(i.i_.@\placeholdernc{current}@)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return ranges::iter_move(i.i_.\placeholdernc{current});}
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{split_view::inner_iterator}}%
\begin{itemdecl}
friend constexpr void iter_swap(const inner_iterator& x, const inner_iterator& y)
  noexcept(noexcept(ranges::iter_swap(x.i_.@\placeholdernc{current}, y.i_.\placeholdernc{current}@)))
    requires IndirectlySwappable<iterator_t<Base>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to
\tcode{ranges::iter_swap(\placeholdernc{current}(x.i_), \placeholdernc{current}(y.i_))}.
\end{itemdescr}

\rSec3[range.split.adaptor]{\tcode{view::split}}

\pnum
The name \tcode{view::split} denotes a
range adaptor object\iref{range.adaptor.object}. The expression
\tcode{view::split(E, F)} for some subexpressions \tcode{E} and \tcode{F} is
expression-equivalent to \tcode{split_view\{E, F\}}.


\rSec2[range.counted]{Counted view}

\pnum
The name \tcode{view::counted} denotes a
customization point object\cxxiref{customization.point.object}.
Let \tcode{E} and \tcode{F} be expressions such that their decayed types are
\tcode{T} and \tcode{U} respectively. Then the expression
\tcode{view::counted(E, F)} is expression-equivalent to:

\begin{itemize}
\item If \tcode{T} models \libconcept{Iterator} and
\tcode{U} models \libconcept{ConvertibleTo<iter_difference_t<T>>},
  \begin{itemize}
  \item \tcode{subrange\{E, E + F\}} if \tcode{T} models
    \libconcept{ContiguousIterator}.
  \item Otherwise,
    \tcode{subrange\{counted_iterator(E, static_cast<iter_difference_t<T>>(F)),
    default_sentinel\{\}\}}.
\end{itemize}

\item Otherwise, \tcode{view::counted(E, F)} is ill-formed.
  {\color{newclr}
  \begin{note}
  This case can result in substitution failure when \tcode{view::counted(E, F)}
  appears in the immediate context of a template instantiation.
  \end{note}
  } %% \color{newclr}
\end{itemize}


\rSec2[range.common]{Common view}

\rSec3[range.common.overview]{Overview}

\pnum
\tcode{common_view} takes a \libconcept{View} which has different types for
its iterator and sentinel and turns it into an equivalent \libconcept{View}
where the iterator and sentinel have the same type.

\pnum
\begin{note}
\tcode{common_view} is useful for calling legacy algorithms that expect
a range's iterator and sentinel types to be the same.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
// Legacy algorithm:
template<class ForwardIterator>
size_t count(ForwardIterator first, ForwardIterator last);

template<ForwardRange R>
void my_algo(R&& r) {
  auto&& common = common_view{r};
  auto cnt = count(common.begin(), common.end());
  // ...
}
\end{codeblock}
\end{example}

\rSec3[range.common.view]{Class template \tcode{common_view}}

\begin{codeblock}
namespace std::ranges {
  template<View V>
    requires @\newtxt{(}@!CommonRange<V>@\newtxt{)}@
  class common_view : public view_interface<common_view<V>> {
  private:
    V base_ @\oldtxt{\{\}} \newtxt{= V()}@; // \expos
  public:
    common_view() = default;

    explicit constexpr common_view(V r);

    template<ViewableRange R>
      requires @\newtxt{(}@!CommonRange<R>@\newtxt{)}@ && Constructible<V, all_view<R>>
    explicit constexpr common_view(R&& r);

    constexpr V base() const;

    constexpr auto size() const requires SizedRange<const V>@\oldtxt{;}@
    @\newtxt{\{ return ranges::size(base_); \}}@

    constexpr auto begin()@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (RandomAccessRange<V> \&\& SizedRange<V>)}@
        @\newtxt{return ranges::begin(base_);}@
      @\newtxt{else}@
        @\newtxt{return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::begin(base_));}@
    @\newtxt{\}}@

    constexpr auto begin() const requires Range<const V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (RandomAccessRange<const V> \&\& SizedRange<const V>)}@
        @\newtxt{return ranges::begin(base_);}@
      @\newtxt{else}@
        @\newtxt{return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::begin(base_));}@
    @\newtxt{\}}@

    @\newtxt{constexpr auto begin()}@
      @\newtxt{requires RandomAccessRange<V> \&\& SizedRange<V>;}@
    @\newtxt{constexpr auto begin() const}@
      @\newtxt{requires RandomAccessRange<const V> \&\& SizedRange<const V>;}@

    constexpr auto end()@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (RandomAccessRange<V> \&\& SizedRange<V>)}@
        @\newtxt{return ranges::begin(base_) + ranges::size(base_);}@
      @\newtxt{else}@
        @\newtxt{return common_iterator<iterator_t<V>, sentinel_t<V>>(ranges::end(base_));}@
    @\newtxt{\}}@

    constexpr auto end() const requires Range<const V>@\oldtxt{;}@
    @\newtxt{\{}@
      @\newtxt{if constexpr (RandomAccessRange<const V> \&\& SizedRange<const V>)}@
        @\newtxt{return ranges::begin(base_) + ranges::size(base_);}@
      @\newtxt{else}@
        @\newtxt{return common_iterator<iterator_t<const V>, sentinel_t<const V>>(ranges::end(base_));}@
    @\newtxt{\}}@

    @\oldtxt{constexpr auto end()}@
      @\oldtxt{requires RandomAccessRange<V> \&\& SizedRange<V>;}@
    @\oldtxt{constexpr auto end() const}@
      @\oldtxt{requires RandomAccessRange<const V> \&\& SizedRange<V>;}@
  };

  template<class R>
    common_view(R&&) -> common_view<all_view<R>>;
}
\end{codeblock}

\indexlibrary{\idxcode{common_view}!\idxcode{common_view}}%
\begin{itemdecl}
explicit constexpr common_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrary{\idxcode{common_view}!\idxcode{common_view}}%
\begin{itemdecl}
template<ViewableRange R>
  requires @\newtxt{(}@!CommonRange<R>@\newtxt{)}@ && Constructible<V, all_view<R>>
explicit constexpr common_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr V base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return base_;}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{size}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto size() const requires SizedRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::size(base_);}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto begin();
constexpr auto begin() const requires Range<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{T} be \tcode{V} or \tcode{const V} for the first and
second overloads, respectively.

\pnum
\effects Equivalent to:
\begin{codeblock}
return common_iterator<iterator_t<T>, sentinel_t<T>>(ranges::begin(base_));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto begin()
  requires RandomAccessRange<V> && SizedRange<V>;
constexpr auto begin() const
  requires RandomAccessRange<const V> && SizedRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(base_);}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto end();
constexpr auto end() const requires Range<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{T} be \tcode{V} or \tcode{const V} for the first and
second overloads, respectively.

\pnum
\effects Equivalent to:
\begin{codeblock}
return common_iterator<iterator_t<T>, sentinel_t<T>>(ranges::end(base_));
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{common_view}}%
\begin{itemdecl}
constexpr auto end()
  requires RandomAccessRange<V> && SizedRange<V>;
constexpr auto end() const
  requires RandomAccessRange<const V> && SizedRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::begin(base_) + ranges::size(base_);}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.common.adaptor]{\tcode{view::common}}

\pnum
The name \tcode{view::common} denotes a
range adaptor object\iref{range.adaptor.object}. The expression
\tcode{view::common(E)} is expression-equivalent to:

\begin{itemize}
\item If \tcode{decltype((E))} models \libconcept{CommonRange},
\tcode{view::all(E)}, if that is a well-formed expression.

\item Otherwise, \tcode{common_view\{E\}}\oldtxt{, if that is a well-formed expression}.

\item \oldtxt{Otherwise, \tcode{view::common(E)} is ill-formed.}
\end{itemize}


\rSec2[range.reverse]{Reverse view}

\rSec3[range.reverse.overview]{Overview}

\pnum
\tcode{reverse_view} takes a bidirectional \libconcept{View} and produces
another \libconcept{View} that iterates the same elements in reverse order.

\pnum
\begin{example}
\begin{codeblock}
vector<int> is {0,1,2,3,4};
reverse_view rv {is};
for (int i : rv)
  cout << i << ' '; // prints: 4 3 2 1 0
\end{codeblock}
\end{example}

\rSec3[range.reverse.view]{Class template \tcode{reverse_view}}

\indexlibrary{\idxcode{weiv_esrever}}%
\begin{codeblock}
namespace std::ranges {
  template<View V>
    requires BidirectionalRange<V>
  class reverse_view : public view_interface<reverse_view<V>> {
  private:
    V base_ @\oldtxt{\{\}} \newtxt{= V()}@; // \expos
  public:
    reverse_view() = default;

    explicit constexpr reverse_view(V r);

    template<ViewableRange R>
      requires BidirectionalRange<R> && Constructible<V, all_view<R>>
    explicit constexpr reverse_view(R&& r);

    constexpr V base() const;

    constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<V>>}@ begin();
    constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<V>>}@ begin() requires CommonRange<V>;
    constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<const V>>}@ begin() const
      requires CommonRange<const V>;

    constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<V>>}@ end();
    constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<const V>>}@ end() const
      requires CommonRange<const V>;

    constexpr auto size() const requires SizedRange<const V>@\oldtxt{;}@
    @\newtxt{\{ return ranges::size(base_); \}}@
  };

  template<class R>
    reverse_view(R&&) -> reverse_view<all_view<R>>;
}
\end{codeblock}

\indexlibrary{\idxcode{reverse_view}!\idxcode{reverse_view}}%
\begin{itemdecl}
explicit constexpr reverse_view(V base);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{std::move(base)}.
\end{itemdescr}

\indexlibrary{\idxcode{reverse_view}!\idxcode{reverse_view}}%
\begin{itemdecl}
template<ViewableRange R>
  requires BidirectionalRange<R> && Constructible<V, all_view<R>>
explicit constexpr reverse_view(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Initializes \tcode{base_} with \tcode{view::all(std::forward<R>(r))}.
\end{itemdescr}

\indexlibrary{\idxcode{base}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr V base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return base_;}
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<V>>}@ begin();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{reverse_iterator\{ranges::next(ranges::begin(base_), ranges::end(base_))\}}.

\pnum
\remarks In order to provide the amortized constant time complexity required by
the \libconcept{Range} concept, this function caches the result within the
\tcode{reverse_view} for use on subsequent calls.
\end{itemdescr}

\indexlibrary{\idxcode{begin}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<V>>}@ begin() requires CommonRange<V>;
constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<const V>>}@ begin() const
  requires CommonRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return reverse_iterator\{ranges::end(base_)\};}
\end{itemdescr}

\indexlibrary{\idxcode{end}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<V>>}@ end();
constexpr @\oldtxt{auto}\newtxt{reverse_iterator<iterator_t<const V>>}@ end() const
  requires CommonRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return reverse_iterator\{ranges::begin(base_)\};}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{size}!\idxcode{reverse_view}}%
\begin{itemdecl}
constexpr auto size() const requires SizedRange<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::size(base_);}
\end{itemdescr}
} %% \color{oldclr}

\rSec3[range.reverse.adaptor]{\tcode{view::reverse}}

\pnum
The name \tcode{view::reverse} denotes a
range adaptor object\iref{range.adaptor.object}. The expression
\tcode{view::reverse(E)} for some subexpression \tcode{E} is
expression-equivalent to \tcode{reverse_view\{E\}}.
\end{addedblock}
