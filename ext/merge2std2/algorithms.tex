%!TEX root = P0896.tex

\rSec0[algorithms]{Algorithms library}

\rSec1[algorithms.general]{General}

[...]

\rSec1[algorithm.syn]{Header \tcode{<algorithm>} synopsis}
\indexhdr{algorithm}%

\begin{codeblock}
#include <initializer_list>

namespace std {
  // \ref{alg.nonmodifying}, non-modifying sequence operations
  // \ref{alg.all_of}, all of
  template<class InputIterator, class Predicate>
    constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool all_of(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                ForwardIterator first, ForwardIterator last, Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr bool all_of(I first, S last, Pred pred, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool all_of(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.any_of}, any of
  template<class InputIterator, class Predicate>
    constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool any_of(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                ForwardIterator first, ForwardIterator last, Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr bool any_of(I first, S last, Pred pred, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool any_of(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.none_of}, none of
  template<class InputIterator, class Predicate>
    constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool none_of(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last, Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr bool none_of(I first, S last, Pred pred, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool none_of(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.foreach}, for each
  template<class InputIterator, class Function>
    constexpr Function for_each(InputIterator first, InputIterator last, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Function>
    void for_each(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator first, ForwardIterator last, Function f);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class F>
    struct for_each_result {
      I in;
      F fun;
    };

    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryInvocable<projected<I, Proj>> Fun>
      constexpr for_each_result<I, Fun>
        for_each(I first, S last, Fun f, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryInvocable<projected<iterator_t<R>, Proj>> Fun>
      constexpr for_each_result<safe_iterator_t<R>, Fun>
        for_each(R&& r, Fun f, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class Size, class Function>
    constexpr InputIterator for_each_n(InputIterator first, Size n, Function f);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Function>
    ForwardIterator for_each_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                               ForwardIterator first, Size n, Function f);

  // \ref{alg.find}, find
  template<class InputIterator, class T>
    constexpr InputIterator find(InputIterator first, InputIterator last,
                                 const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    ForwardIterator find(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                         ForwardIterator first, ForwardIterator last,
                         const T& value);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                    Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);
  template<class InputIterator, class Predicate>
    constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator find_if_not(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
        constexpr I find(I first, S last, const T& value, Proj proj = Proj{});
    template<InputRange R, class T, class Proj = identity>
      requires IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
      constexpr safe_iterator_t<R>
        find(R&& r, const T& value, Proj proj = Proj{});
    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr I find_if(I first, S last, Pred pred, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr safe_iterator_t<R>
        find_if(R&& r, Pred pred, Proj proj = Proj{});
    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr safe_iterator_t<R>
        find_if_not(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.find.end}, find end
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      find_end(ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_end(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2,
        class Pred = ranges::equal_to<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      constexpr subrange<I1>
        find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<ForwardRange R1, ForwardRange R2,
        class Pred = ranges::equal_to<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr safe_subrange_t<R1>
        find_end(R1&& r1, R2&& r2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.find.first.of}, find first
  template<class InputIterator, class ForwardIterator>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2);
  template<class InputIterator, class ForwardIterator, class BinaryPredicate>
    constexpr InputIterator
      find_first_of(InputIterator first1, InputIterator last1,
                    ForwardIterator first2, ForwardIterator last2,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2, class BinaryPredicate>
    ForwardIterator1
      find_first_of(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                    ForwardIterator1 first1, ForwardIterator1 last1,
                    ForwardIterator2 first2, ForwardIterator2 last2,
                    BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<projected<I1, Proj1>, projected<I2, Proj2>> Pred = ranges::equal_to<>>
      constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                                 Pred pred = Pred{},
                                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, ForwardRange R2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectRelation<projected<iterator_t<R1>, Proj1>,
          projected<iterator_t<R2>, Proj2>> Pred = ranges::equal_to<>>
      constexpr safe_iterator_t<R1>
        find_first_of(R1&& r1, R2&& r2,
                      Pred pred = Pred{},
                      Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.adjacent.find}, adjacent find
  template<class ForwardIterator>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator
      adjacent_find(ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator
      adjacent_find(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last,
                    BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectRelation<projected<I, Proj>> Pred = ranges::equal_to<>>
      constexpr I adjacent_find(I first, S last, Pred pred = Pred{},
                                Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectRelation<projected<iterator_t<R>, Proj>> Pred = ranges::equal_to<>>
      constexpr safe_iterator_t<R>
        adjacent_find(R&& r, Pred pred = Pred{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.count}, count
  template<class InputIterator, class T>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count(InputIterator first, InputIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    typename iterator_traits<ForwardIterator>::difference_type
      count(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
            ForwardIterator first, ForwardIterator last, const T& value);
  template<class InputIterator, class Predicate>
    constexpr typename iterator_traits<InputIterator>::difference_type
      count_if(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    typename iterator_traits<ForwardIterator>::difference_type
      count_if(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last, Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I, Sentinel<I> S, class T, class Proj = identity>
      requires IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
      constexpr iter_difference_t<I>
        count(I first, S last, const T& value, Proj proj = Proj{});
    template<InputRange R, class T, class Proj = identity>
      requires IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
      constexpr iter_difference_t<iterator_t<R>>
        count(R&& r, const T& value, Proj proj = Proj{});
    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr iter_difference_t<I>
        count_if(I first, S last, Pred pred, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr iter_difference_t<iterator_t<R>>
        count_if(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{mismatch}, mismatch
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr pair<InputIterator1, InputIterator2>
      mismatch(InputIterator1 first1, InputIterator1 last1,
               InputIterator2 first2, InputIterator2 last2,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    pair<ForwardIterator1, ForwardIterator2>
      mismatch(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2>
    struct mismatch_result {
      I1 in1;
      I2 in2;
    };

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<projected<I1, Proj1>, projected<I2, Proj2>> Pred = ranges::equal_to<>>
      constexpr mismatch_result<I1, I2>
        mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectRelation<projected<iterator_t<R1>, Proj1>,
          projected<iterator_t<R2>, Proj2>> Pred = ranges::equal_to<>>
      constexpr mismatch_result<safe_iterator_t<R1>, safe_iterator_t<R2>>
        mismatch(R1&& r1, R2&& r2, Pred pred = Pred{},
                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.equal}, equal
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, BinaryPredicate pred);
  template<class InputIterator1, class InputIterator2>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class BinaryPredicate>
    constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2, InputIterator2 last2,
                         BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool equal(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    bool equal(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator1 first1, ForwardIterator1 last1,
               ForwardIterator2 first2, ForwardIterator2 last2,
               BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Pred = ranges::equal_to<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred = Pred{},
                           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, class Pred = ranges::equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool equal(R1&& r1, R2&& r2, Pred pred = Pred{},
                           Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.is_permutation}, is permutation
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, BinaryPredicate pred);
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                                  ForwardIterator2 first2, ForwardIterator2 last2,
                                  BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Pred = ranges::equal_to<>, class Proj1 = identity,
        class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                    Pred pred = Pred{},
                                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr bool is_permutation(R1&& r1, R2&& r2, Pred pred = Pred{},
                                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.search}, search
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
    constexpr ForwardIterator1
      search(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator1
      search(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator1
      search(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
        Sentinel<I2> S2, class Pred = ranges::equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
      constexpr subrange<I1>
        search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
      constexpr safe_subrange_t<R1>
        search(R1&& r1, R2&& r2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator, class Size, class T>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ForwardIterator, class Size, class T, class BinaryPredicate>
    constexpr ForwardIterator
      search_n(ForwardIterator first, ForwardIterator last,
               Size count, const T& value,
               BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
    ForwardIterator
      search_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class T,
           class BinaryPredicate>
    ForwardIterator
      search_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
               ForwardIterator first, ForwardIterator last,
               Size count, const T& value,
               BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class T,
        class Pred = ranges::equal_to<>, class Proj = identity>
      requires IndirectlyComparable<I, const T*, Pred, Proj>
      constexpr subrange<I>
        search_n(I first, S last, iter_difference_t<I> count,
                 const T& value, Pred pred = Pred{}, Proj proj = Proj{});
    template<ForwardRange R, class T, class Pred = ranges::equal_to<>,
        class Proj = identity>
      requires IndirectlyComparable<iterator_t<R>, const T*, Pred, Proj>
      constexpr safe_subrange_t<R>
        search_n(R&& r, iter_difference_t<iterator_t<R>> count,
                 const T& value, Pred pred = Pred{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class ForwardIterator, class Searcher>
    constexpr ForwardIterator
      search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);

  // \ref{alg.modifying.operations}, mutating sequence operations
  // \ref{alg.copy}, copy
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                  OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2 copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    struct copy_result {
      I in;
      O out;
    };

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      constexpr copy_result<I, O>
        copy(I first, S last, O result);
    template<InputRange R, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<R>, O>
      constexpr copy_result<safe_iterator_t<R>, O>
        copy(R&& r, O result);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class Size, class OutputIterator>
    constexpr OutputIterator copy_n(InputIterator first, Size n,
                                    OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class Size,
           class ForwardIterator2>
    ForwardIterator2 copy_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                            ForwardIterator1 first, Size n,
                            ForwardIterator2 result);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using copy_n_result = copy_result<I, O>;

    template<InputIterator I, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      constexpr copy_n_result<I, O>
        copy_n(I first, iter_difference_t<I> n, O result);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2 copy_if(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                             ForwardIterator1 first, ForwardIterator1 last,
                             ForwardIterator2 result, Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using copy_if_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      constexpr copy_if_result<I, O>
        copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});
    template<InputRange R, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<R>, O>
      constexpr copy_if_result<safe_iterator_t<R>, O>
        copy_if(R&& r, O result, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2>
    using copy_backward_result = copy_result<I1, I2>;

    template<BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
      requires IndirectlyCopyable<I1, I2>
      constexpr copy_backward_result<I1, I2>
        copy_backward(I1 first, S1 last, I2 result);
    template<BidirectionalRange R, BidirectionalIterator I>
      requires IndirectlyCopyable<iterator_t<R>, I>
      constexpr copy_backward_result<safe_iterator_t<R>, I>
        copy_backward(R&& r, I result);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.move}, move
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator move(InputIterator first, InputIterator last,
                                  OutputIterator result);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using move_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyMovable<I, O>
      constexpr move_result<I, O>
        move(I first, S last, O result);
    template<InputRange R, WeaklyIncrementable O>
      requires IndirectlyMovable<iterator_t<R>, O>
      constexpr move_result<safe_iterator_t<R>, O>
        move(R&& r, O result);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ExecutionPolicy, class ForwardIterator1,
           class ForwardIterator2>
    ForwardIterator2 move(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                          ForwardIterator1 first, ForwardIterator1 last,
                          ForwardIterator2 result);
  template<class BidirectionalIterator1, class BidirectionalIterator2>
    constexpr BidirectionalIterator2
      move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                    BidirectionalIterator2 result);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2>
    using move_backward_result = copy_result<I1, I2>;

    template<BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
      requires IndirectlyMovable<I1, I2>
      constexpr move_backward_result<I1, I2>
        move_backward(I1 first, S1 last, I2 result);
    template<BidirectionalRange R, BidirectionalIterator I>
      requires IndirectlyMovable<iterator_t<R>, I>
      constexpr move_backward_result<safe_iterator_t<R>, I>
        move_backward(R&& r, I result);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.swap}, swap
  template<class ForwardIterator1, class ForwardIterator2>
    constexpr ForwardIterator2
      swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      swap_ranges(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2>
    using swap_ranges_result = mismatch_result<I1, I2>;

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2>
      requires IndirectlySwappable<I1, I2>
      constexpr swap_ranges_result<I1, I2>
        swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
    template<InputRange R1, InputRange R2>
      requires IndirectlySwappable<iterator_t<R1>, iterator_t<R2>>
      constexpr swap_ranges_result<safe_iterator_t<R1>, safe_iterator_t<R2>>
        swap_ranges(R1&& r1, R2&& r2);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator1, class ForwardIterator2>
    void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

  // \ref{alg.transform}, transform
  template<class InputIterator, class OutputIterator, class UnaryOperation>
    constexpr OutputIterator
      transform(InputIterator first@\added{1}@, InputIterator last@\added{1}@,
                OutputIterator result, UnaryOperation op);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class BinaryOperation>
    constexpr OutputIterator
      transform(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, OutputIterator result,
                BinaryOperation binary_op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class UnaryOperation>
    ForwardIterator2
      transform(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                ForwardIterator1 first@\added{1}@, ForwardIterator1 last@\added{1}@,
                ForwardIterator2 result, UnaryOperation op);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class BinaryOperation>
    ForwardIterator
      transform(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator result,
                BinaryOperation binary_op);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using unary_transform_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        CopyConstructible F, class Proj = identity>
      requires Writable<O, indirect_result_t<F&, projected<I, Proj>>>
      constexpr unary_transform_result<I, O>
        transform(I first1, S last1, O result, F op, Proj proj = Proj{});
    template<InputRange R, WeaklyIncrementable O, CopyConstructible F,
        class Proj = identity>
      requires Writable<O, indirect_result_t<F&, projected<iterator_t<R>, Proj>>>
      constexpr unary_transform_result<safe_iterator_t<R>, O>
        transform(R&& r, O result, F op, Proj proj = Proj{});

    template<class I1, class I2, class O>
    struct binary_transform_result {
      I1 in1;
      I2 in2;
      O  out;
    };

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
        class Proj2 = identity>
      requires Writable<O, indirect_result_t<F&, projected<I1, Proj1>,
        projected<I2, Proj2>>>
      constexpr binary_transform_result<I1, I2, O>
        transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, WeaklyIncrementable O,
        CopyConstructible F, class Proj1 = identity, class Proj2 = identity>
      requires Writable<O, indirect_result_t<F&,
        projected<iterator_t<R1>, Proj1>, projected<iterator_t<R2>, Proj2>>>
      constexpr binary_transform_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
        transform(R1&& r1, R2&& r2, O result,
                  F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.replace}, replace
  template<class ForwardIterator, class T>
    constexpr void replace(ForwardIterator first, ForwardIterator last,
                           const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void replace(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                 ForwardIterator first, ForwardIterator last,
                 const T& old_value, const T& new_value);
  template<class ForwardIterator, class Predicate, class T>
    constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                              Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate, class T>
    void replace_if(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                    ForwardIterator first, ForwardIterator last,
                    Predicate pred, const T& new_value);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I, Sentinel<I> S, class T1, class T2, class Proj = identity>
      requires Writable<I, const T2&> &&
        IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T1*>
      constexpr I
        replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = Proj{});
    template<InputRange R, class T1, class T2, class Proj = identity>
      requires Writable<iterator_t<R>, const T2&> &&
        IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T1*>
      constexpr safe_iterator_t<R>
        replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = Proj{});
    template<InputIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires Writable<I, const T&>
      constexpr I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = Proj{});
    template<InputRange R, class T, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires Writable<iterator_t<R>, const T&>
      constexpr safe_iterator_t<R>
        replace_if(R&& r, Pred pred, const T& new_value, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator replace_copy(InputIterator first, InputIterator last,
                                          OutputIterator result,
                                          const T& old_value, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
    ForwardIterator2 replace_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                  ForwardIterator1 first, ForwardIterator1 last,
                                  ForwardIterator2 result,
                                  const T& old_value, const T& new_value);
  template<class InputIterator, class OutputIterator, class Predicate, class T>
    constexpr OutputIterator replace_copy_if(InputIterator first, InputIterator last,
                                             OutputIterator result,
                                             Predicate pred, const T& new_value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate, class T>
    ForwardIterator2 replace_copy_if(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                     ForwardIterator1 first, ForwardIterator1 last,
                                     ForwardIterator2 result,
                                     Predicate pred, const T& new_value);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using replace_copy_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, class T1, class T2, OutputIterator<const T2&> O,
        class Proj = identity>
      requires IndirectlyCopyable<I, O> &&
        IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T1*>
      constexpr replace_copy_result<I, O>
        replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                     Proj proj = Proj{});
    template<InputRange R, class T1, class T2, OutputIterator<const T2&> O,
        class Proj = identity>
      requires IndirectlyCopyable<iterator_t<R>, O> &&
        IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T1*>
      constexpr replace_copy_result<safe_iterator_t<R>, O>
        replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                     Proj proj = Proj{});

    template<class I, class O>
    using replace_copy_if_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, class T, OutputIterator<const T&> O,
        class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      constexpr replace_copy_if_result<I, O>
        replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                        Proj proj = Proj{});
    template<InputRange R, class T, OutputIterator<const T&> O, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<R>, O>
      constexpr replace_copy_if_result<safe_iterator_t<R>, O>
        replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                        Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.fill}, fill
  template<class ForwardIterator, class T>
    constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    void fill(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
              ForwardIterator first, ForwardIterator last, const T& value);
  template<class OutputIterator, class Size, class T>
    constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value);
  template<class ExecutionPolicy, class ForwardIterator,
           class Size, class T>
    ForwardIterator fill_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                           ForwardIterator first, Size n, const T& value);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class T, OutputIterator<const T&> O, Sentinel<O> S>
      constexpr O fill(O first, S last, const T& value);
    template<class T, OutputRange<const T&> R>
      constexpr safe_iterator_t<R> fill(R&& r, const T& value);
    template<class T, OutputIterator<const T&> O>
      constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.generate}, generate
  template<class ForwardIterator, class Generator>
    constexpr void generate(ForwardIterator first, ForwardIterator last,
                            Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Generator>
    void generate(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator first, ForwardIterator last,
                  Generator gen);
  template<class OutputIterator, class Size, class Generator>
    constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
  template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
    ForwardIterator generate_n(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                               ForwardIterator first, Size n, Generator gen);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<Iterator O, Sentinel<O> S, CopyConstructible F>
        requires Invocable<F&> && Writable<O, invoke_result_t<F&>>
      constexpr O generate(O first, S last, F gen);
    template<class R, CopyConstructible F>
        requires Invocable<F&> && OutputRange<R, invoke_result_t<F&>>
      constexpr safe_iterator_t<R> generate(R&& r, F gen);
    template<Iterator O, CopyConstructible F>
        requires Invocable<F&> && Writable<O, invoke_result_t<F&>>
      constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.remove}, remove
  template<class ForwardIterator, class T>
    constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                     const T& value);
  template<class ExecutionPolicy, class ForwardIterator, class T>
    ForwardIterator remove(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last,
                           const T& value);
  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator remove_if(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                              ForwardIterator first, ForwardIterator last,
                              Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class T, class Proj = identity>
      requires @\oldtxt{Permutable<I> \&\&}@
        IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
      constexpr I remove(I first, S last, const T& value, Proj proj = Proj{});
    template<ForwardRange R, class T, class Proj = identity>
      requires Permutable<iterator_t<R>> &&
        IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
      constexpr safe_iterator_t<R>
        remove(R&& r, const T& value, Proj proj = Proj{});
    template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      @\oldtxt{requires Permutable<I>}@
      constexpr I remove_if(I first, S last, Pred pred, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires Permutable<iterator_t<R>>
      constexpr safe_iterator_t<R>
        remove_if(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class OutputIterator, class T>
    constexpr OutputIterator
      remove_copy(InputIterator first, InputIterator last,
                  OutputIterator result, const T& value);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class T>
    ForwardIterator2
      remove_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, const T& value);
  template<class InputIterator, class OutputIterator, class Predicate>
    constexpr OutputIterator
      remove_copy_if(InputIterator first, InputIterator last,
                     OutputIterator result, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Predicate>
    ForwardIterator2
      remove_copy_if(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     ForwardIterator1 first, ForwardIterator1 last,
                     ForwardIterator2 result, Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using remove_copy_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class T,
        class Proj = identity>
      requires IndirectlyCopyable<I, O> &&
        IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
      constexpr remove_copy_result<I, O>
        remove_copy(I first, S last, O result, const T& value, Proj proj = Proj{});
    template<InputRange R, WeaklyIncrementable O, class T, class Proj = identity>
      requires IndirectlyCopyable<iterator_t<R>, O> &&
        IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
      constexpr remove_copy_result<safe_iterator_t<R>, O>
        remove_copy(R&& r, O result, const T& value, Proj proj = Proj{});

    template<class I, class O>
    using remove_copy_if_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O>
      constexpr remove_copy_if_result<I, O>
        remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});
    template<InputRange R, WeaklyIncrementable O, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<R>, O>
      constexpr remove_copy_if_result<safe_iterator_t<R>, O>
        remove_copy_if(R&& r, O result, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.unique}, unique
  template<class ForwardIterator>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class BinaryPredicate>
    constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                     BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator unique(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
    ForwardIterator unique(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                           ForwardIterator first, ForwardIterator last,
                           BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class Proj = identity,
        IndirectRelation<projected<I, Proj>> C = ranges::equal_to<>>
      @\oldtxt{requires Permutable<I>}@
      constexpr I unique(I first, S last, C comp = C{}, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectRelation<projected<iterator_t<R>, Proj>> C = ranges::equal_to<>>
      requires Permutable<iterator_t<R>>
      constexpr safe_iterator_t<R>
        unique(R&& r, C comp = C{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class OutputIterator>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result);
  template<class InputIterator, class OutputIterator, class BinaryPredicate>
    constexpr OutputIterator
      unique_copy(InputIterator first, InputIterator last,
                  OutputIterator result, BinaryPredicate pred);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class BinaryPredicate>
    ForwardIterator2
      unique_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 last,
                  ForwardIterator2 result, BinaryPredicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using unique_copy_result = copy_result<I, O>;

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
        class Proj = identity, IndirectRelation<projected<I, Proj>> C = ranges::equal_to<>>
      requires IndirectlyCopyable<I, O> &&
        (ForwardIterator<I> ||
        (InputIterator<O> && Same<iter_value_t<I>, iter_value_t<O>>) ||
        IndirectlyCopyableStorable<I, O>)
      constexpr unique_copy_result<I, O>
        unique_copy(I first, S last, O result, C comp = C{}, Proj proj = Proj{});
    template<InputRange R, WeaklyIncrementable O, class Proj = identity,
        IndirectRelation<projected<iterator_t<R>, Proj>> C = ranges::equal_to<>>
      requires IndirectlyCopyable<iterator_t<R>, O> &&
        (ForwardIterator<iterator_t<R>> ||
        (InputIterator<O> && Same<iter_value_t<iterator_t<R>>, iter_value_t<O>>) ||
        IndirectlyCopyableStorable<iterator_t<R>, O>)
      constexpr unique_copy_result<safe_iterator_t<R>, O>
        unique_copy(R&& r, O result, C comp = C{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.reverse}, reverse
  template<class BidirectionalIterator>
    void reverse(BidirectionalIterator first, BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void reverse(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                 BidirectionalIterator first, BidirectionalIterator last);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<BidirectionalIterator I, Sentinel<I> S>
      requires Permutable<I>
      constexpr I reverse(I first, S last);
    template<BidirectionalRange R>
      requires Permutable<iterator_t<R>>
      constexpr safe_iterator_t<R> reverse(R&& r);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class BidirectionalIterator, class OutputIterator>
    constexpr OutputIterator
      reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                   OutputIterator result);
  template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
    ForwardIterator
      reverse_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                   BidirectionalIterator first, BidirectionalIterator last,
                   ForwardIterator result);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using reverse_copy_result = copy_result<I, O>;

    template<BidirectionalIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      constexpr reverse_copy_result<I, O>
        reverse_copy(I first, S last, O result);
    template<BidirectionalRange R, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<R>, O>
      constexpr reverse_copy_result<safe_iterator_t<R>, O>
        reverse_copy(R&& r, O result);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.rotate}, rotate
  template<class ForwardIterator>
    constexpr ForwardIterator rotate(ForwardIterator first,
                                     ForwardIterator middle,
                                     ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator rotate(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                           ForwardIterator first,
                           ForwardIterator middle,
                           ForwardIterator last);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S>
      @\oldtxt{requires Permutable<I>}@
      constexpr subrange<I> rotate(I first, I middle, S last);
    template<ForwardRange R>
      requires Permutable<iterator_t<R>>
      constexpr safe_subrange_t<R> rotate(R&& r, iterator_t<R> middle);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator, class OutputIterator>
    constexpr OutputIterator
      rotate_copy(ForwardIterator first, ForwardIterator middle,
                  ForwardIterator last, OutputIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    ForwardIterator2
      rotate_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator1 first, ForwardIterator1 middle,
                  ForwardIterator1 last, ForwardIterator2 result);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using rotate_copy_result = copy_result<I, O>;

    template<ForwardIterator I, Sentinel<I> S, WeaklyIncrementable O>
      requires IndirectlyCopyable<I, O>
      constexpr rotate_copy_result<I, O>
        rotate_copy(I first, I middle, S last, O result);
    template<ForwardRange R, WeaklyIncrementable O>
      requires IndirectlyCopyable<iterator_t<R>, O>
      constexpr rotate_copy_result<safe_iterator_t<R>, O>
        rotate_copy(R&& r, iterator_t<R> middle, O result);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.random.sample}, sample
  [...]

  // \ref{alg.random.shuffle}, shuffle
  template<class RandomAccessIterator, class UniformRandomBitGenerator>
    void shuffle(RandomAccessIterator first,
                 RandomAccessIterator last,
                 UniformRandomBitGenerator&& g);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Gen>
      requires Permutable<I> &&
        UniformRandomBitGenerator<remove_reference_t<Gen>> &&
        ConvertibleTo<invoke_result_t<Gen&>, iter_difference_t<I>>
      I shuffle(I first, S last, Gen&& g);
    template<RandomAccessRange R, class Gen>
      requires Permutable<iterator_t<R>> &&
        UniformRandomBitGenerator<remove_reference_t<Gen>> &&
        ConvertibleTo<invoke_result_t<Gen&>, iter_difference_t<iterator_t<R>>>
      safe_iterator_t<R>
        shuffle(R&& r, Gen&& g);
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.shift}, shift
  [...]

  // \ref{alg.sorting}, sorting and related operations
  // \ref{alg.sort}, sorting
  template<class RandomAccessIterator>
    constexpr void sort(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void sort(RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void sort(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
              RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void sort(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
              RandomAccessIterator first, RandomAccessIterator last,
              Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr I
        sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr safe_iterator_t<R>
        sort(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class RandomAccessIterator>
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void stable_sort(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void stable_sort(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I stable_sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      safe_iterator_t<R>
        stable_sort(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class RandomAccessIterator>
    constexpr void partial_sort(RandomAccessIterator first,
                                RandomAccessIterator middle,
                                RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void partial_sort(RandomAccessIterator first,
                                RandomAccessIterator middle,
                                RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void partial_sort(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void partial_sort(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                      RandomAccessIterator first,
                      RandomAccessIterator middle,
                      RandomAccessIterator last, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr I
        partial_sort(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr safe_iterator_t<R>
        partial_sort(R&& r, iterator_t<R> middle, Comp comp = Comp{},
                     Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class RandomAccessIterator>
    constexpr RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class InputIterator, class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator
      partial_sort_copy(InputIterator first, InputIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,  // see \cxxref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last);
  template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
           class Compare>
    RandomAccessIterator
      partial_sort_copy(ExecutionPolicy&& exec,  // see \cxxref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last,
                        RandomAccessIterator result_first,
                        RandomAccessIterator result_last,
                        Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I1, Sentinel<I1> S1, RandomAccessIterator I2, Sentinel<I2> S2,
        class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyCopyable<I1, I2> && Sortable<I2, Comp, Proj2> &&
          IndirectStrictWeakOrder<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
      constexpr I2
        partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                          Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, RandomAccessRange R2, class Comp = ranges::less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires IndirectlyCopyable<iterator_t<R1>, iterator_t<R2>> &&
          Sortable<iterator_t<R2>, Comp, Proj2> &&
          IndirectStrictWeakOrder<Comp, projected<iterator_t<R1>, Proj1>,
            projected<iterator_t<R2>, Proj2>>
      constexpr safe_iterator_t<R2>
        partial_sort_copy(R1&& r, R2&& result_r, Comp comp = Comp{},
                          Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                             Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    bool is_sorted(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                   ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    bool is_sorted(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                   ForwardIterator first, ForwardIterator last,
                   Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
      constexpr bool is_sorted(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr bool is_sorted(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator
      is_sorted_until(ForwardIterator first, ForwardIterator last,
                      Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                      ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator
      is_sorted_until(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                      ForwardIterator first, ForwardIterator last,
                      Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
      constexpr I is_sorted_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr safe_iterator_t<R>
        is_sorted_until(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.nth.element}, Nth element
  template<class RandomAccessIterator>
    constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                               RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                               RandomAccessIterator last, Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    void nth_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    void nth_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     RandomAccessIterator first, RandomAccessIterator nth,
                     RandomAccessIterator last, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr I
        nth_element(I first, I nth, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr safe_iterator_t<R>
        nth_element(R&& r, iterator_t<R> nth, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.binary.search}, binary search
  template<class ForwardIterator, class T>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator
      lower_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
      constexpr I lower_bound(I first, S last, const T& value, Comp comp = Comp{},
                              Proj proj = Proj{});
    template<ForwardRange R, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr safe_iterator_t<R>
        lower_bound(R&& r, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class ForwardIterator, class T>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr ForwardIterator
      upper_bound(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
      constexpr I upper_bound(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
    template<ForwardRange R, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr safe_iterator_t<R>
        upper_bound(R&& r, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class ForwardIterator, class T>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      equal_range(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
      constexpr subrange<I>
        equal_range(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
    template<ForwardRange R, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr safe_subrange_t<R>
        equal_range(R&& r, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class ForwardIterator, class T>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value);
  template<class ForwardIterator, class T, class Compare>
    constexpr bool
      binary_search(ForwardIterator first, ForwardIterator last,
                    const T& value, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
      constexpr bool binary_search(I first, S last, const T& value, Comp comp = Comp{},
                                   Proj proj = Proj{});
    template<ForwardRange R, class T, class Proj = identity,
        IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr bool binary_search(R&& r, const T& value, Comp comp = Comp{},
                                   Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.partitions}, partitions
  template<class InputIterator, class Predicate>
    constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    bool is_partitioned(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                        ForwardIterator first, ForwardIterator last, Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator partition(ForwardIterator first,
                                        ForwardIterator last,
                                        Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class Predicate>
    ForwardIterator partition(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                              ForwardIterator first,
                              ForwardIterator last,
                              Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      @\oldtxt{requires Permutable<I>}@
      constexpr I
        partition(I first, S last, Pred pred, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires Permutable<iterator_t<R>>
      constexpr safe_iterator_t<R>
        partition(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class BidirectionalIterator, class Predicate>
    BidirectionalIterator stable_partition(BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
  template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
    BidirectionalIterator stable_partition(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                           BidirectionalIterator first,
                                           BidirectionalIterator last,
                                           Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<BidirectionalIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires Permutable<I>
      I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});
    template<BidirectionalRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires Permutable<iterator_t<R>>
      safe_iterator_t<R> stable_partition(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class InputIterator, class OutputIterator1,
           class OutputIterator2, class Predicate>
    constexpr pair<OutputIterator1, OutputIterator2>
      partition_copy(InputIterator first, InputIterator last,
                     OutputIterator1 out_true, OutputIterator2 out_false,
                     Predicate pred);
  template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
           class ForwardIterator2, class Predicate>
    pair<ForwardIterator1, ForwardIterator2>
      partition_copy(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last,
                     ForwardIterator1 out_true, ForwardIterator2 out_false,
                     Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O1, class O2>
    struct partition_copy_result {
      I  in;
      O1 out1;
      O2 out2;
    };

    template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O1, WeaklyIncrementable O2,
        class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
      requires IndirectlyCopyable<I, O1> && IndirectlyCopyable<I, O2>
      constexpr partition_copy_result<I, O1, O2>
        partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                       Proj proj = Proj{});
    template<InputRange R, WeaklyIncrementable O1, WeaklyIncrementable O2,
        class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      requires IndirectlyCopyable<iterator_t<R>, O1> &&
        IndirectlyCopyable<iterator_t<R>, O2>
      constexpr partition_copy_result<safe_iterator_t<R>, O1, O2>
        partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator, class Predicate>
    constexpr ForwardIterator
      partition_point(ForwardIterator first, ForwardIterator last,
                      Predicate pred);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectUnaryPredicate<projected<I, Proj>> Pred>
      constexpr I partition_point(I first, S last, Pred pred, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
      constexpr safe_iterator_t<R>
        partition_point(R&& r, Pred pred, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.merge}, merge
  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator,
           class Compare>
    constexpr OutputIterator
      merge(InputIterator1 first1, InputIterator1 last1,
            InputIterator2 first2, InputIterator2 last2,
            OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      merge(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      merge(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
            ForwardIterator1 first1, ForwardIterator1 last1,
            ForwardIterator2 first2, ForwardIterator2 last2,
            ForwardIterator result, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2, class O>
    using merge_result = binary_transform_result<I1, I2, O>;

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity,
        class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr merge_result<I1, I2, O>
        merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, WeaklyIncrementable O, class Comp = ranges::less<>,
        class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr merge_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
        merge(R1&& r1, R2&& r2, O result,
              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class BidirectionalIterator>
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    void inplace_merge(BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);
  template<class ExecutionPolicy, class BidirectionalIterator>
    void inplace_merge(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last);
  template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
    void inplace_merge(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                       BidirectionalIterator first,
                       BidirectionalIterator middle,
                       BidirectionalIterator last, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<BidirectionalIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      I inplace_merge(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<BidirectionalRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      safe_iterator_t<R>
        inplace_merge(R&& r, iterator_t<R> middle, Comp comp = Comp{},
                      Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.set.operations}, set operations
  template<class InputIterator1, class InputIterator2>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool includes(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool includes(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectStrictWeakOrder<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less<>>
      constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = Comp{},
                              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R1>, Proj1>,
          projected<iterator_t<R2>, Proj2>> Comp = ranges::less<>>
      constexpr bool includes(R1&& r1, R2&& r2, Comp comp = Comp{},
                              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
                set_union(InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_union(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_union(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                ForwardIterator result, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2, class O>
    using set_union_result = binary_transform_result<I1, I2, O>;

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_union_result<I1, I2, O>
        set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = Comp{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, WeaklyIncrementable O,
        class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_union_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
        set_union(R1&& r1, R2&& r2, O result, Comp comp = Comp{},
                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_intersection(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_intersection(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                       ForwardIterator1 first1, ForwardIterator1 last1,
                       ForwardIterator2 first2, ForwardIterator2 last2,
                       ForwardIterator result, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2, class O>
    using set_intersection_result = binary_transform_result<I1, I2, O>;

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_intersection_result<I1, I2, O>
        set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, WeaklyIncrementable O,
        class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_intersection_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
        set_intersection(R1&& r1, R2&& r2, O result,
                         Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_difference(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_difference(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I, class O>
    using set_difference_result = copy_result<I, O>;

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_difference_result<I1, O>
        set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, WeaklyIncrementable O,
        class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_difference_result<safe_iterator_t<R1>, O>
        set_difference(R1&& r1, R2&& r2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class InputIterator1, class InputIterator2, class OutputIterator>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result);
  template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
    constexpr OutputIterator
      set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class ForwardIterator, class Compare>
    ForwardIterator
      set_symmetric_difference(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                               ForwardIterator1 first1, ForwardIterator1 last1,
                               ForwardIterator2 first2, ForwardIterator2 last2,
                               ForwardIterator result, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class I1, class I2, class O>
    using set_symmetric_difference_result = binary_transform_result<I1, I2, O>;

    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
      constexpr set_symmetric_difference_result<I1, I2, O>
        set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp = Comp{}, Proj1 proj1 = Proj1{},
                                 Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, WeaklyIncrementable O,
        class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
      requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
      constexpr set_symmetric_difference_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
        set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = Comp{},
                                 Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.heap.operations}, heap operations
  template<class RandomAccessIterator>
    constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr I
        push_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr safe_iterator_t<R>
        push_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class RandomAccessIterator>
    constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                            Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr I
        pop_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr safe_iterator_t<R>
        pop_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class RandomAccessIterator>
    constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr I
        make_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr safe_iterator_t<R>
        make_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class RandomAccessIterator>
    constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                             Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr I
        sort_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr safe_iterator_t<R>
        sort_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class RandomAccessIterator>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    bool is_heap(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                 RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    bool is_heap(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                 RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
      constexpr bool is_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr bool is_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class RandomAccessIterator>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
  template<class RandomAccessIterator, class Compare>
    constexpr RandomAccessIterator
      is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);
  template<class ExecutionPolicy, class RandomAccessIterator>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                    RandomAccessIterator first, RandomAccessIterator last);
  template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
    RandomAccessIterator
      is_heap_until(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                    RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
      constexpr I is_heap_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<RandomAccessRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr safe_iterator_t<R>
        is_heap_until(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.min.max}, minimum and maximum
  template<class T> constexpr const T& min(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& min(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T min(initializer_list<T> @\changed{t}{r}@);
  template<class T, class Compare>
    constexpr T min(initializer_list<T> @\changed{t}{r}@, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
      constexpr const T& min(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
    template<Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
      constexpr T min(initializer_list<T> r, Comp comp = Comp{}, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      requires Copyable<iter_value_t<iterator_t<R>>>
      constexpr iter_value_t<iterator_t<R>>
        min(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class T> constexpr const T& max(const T& a, const T& b);
  template<class T, class Compare>
    constexpr const T& max(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr T max(initializer_list<T> @\changed{t}{r}@);
  template<class T, class Compare>
    constexpr T max(initializer_list<T> @\changed{t}{r}@, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
      constexpr const T& max(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
    template<Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
      constexpr T max(initializer_list<T> r, Comp comp = Comp{}, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      requires Copyable<iter_value_t<iterator_t<R>>>
      constexpr iter_value_t<iterator_t<R>>
        max(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
  template<class T, class Compare>
    constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
  template<class T>
    constexpr pair<T, T> minmax(initializer_list<T> @\changed{t}{r}@);
  template<class T, class Compare>
    constexpr pair<T, T> minmax(initializer_list<T> @\changed{t}{r}@, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<class T>
    struct minmax_result {
      T min;
      T max;
    };

    template<class T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
      constexpr minmax_result<const T&>
        minmax(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
    template<Copyable T, class Proj = identity,
        IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
      constexpr minmax_result<T>
        minmax(initializer_list<T> r, Comp comp = Comp{}, Proj proj = Proj{});
    template<InputRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      requires Copyable<iter_value_t<iterator_t<R>>>
      constexpr minmax_result<iter_value_t<iterator_t<R>>>
        minmax(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  template<class ForwardIterator>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator min_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator min_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
      constexpr I min_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr safe_iterator_t<R>
        min_element(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                          Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    ForwardIterator max_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    ForwardIterator max_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                                ForwardIterator first, ForwardIterator last,
                                Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
      constexpr I max_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr safe_iterator_t<R>
        max_element(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class ForwardIterator>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last);
  template<class ForwardIterator, class Compare>
    constexpr pair<ForwardIterator, ForwardIterator>
      minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
  template<class ExecutionPolicy, class ForwardIterator>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last);
  template<class ExecutionPolicy, class ForwardIterator, class Compare>
    pair<ForwardIterator, ForwardIterator>
      minmax_element(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                     ForwardIterator first, ForwardIterator last, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
        IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
      constexpr minmax_result<I>
        minmax_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<ForwardRange R, class Proj = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
      constexpr minmax_result<safe_iterator_t<R>>
        minmax_element(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.clamp}, bounded value
  [...]

  // \ref{alg.lex.comparison}, lexicographical comparison
  template<class InputIterator1, class InputIterator2>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2);
  template<class InputIterator1, class InputIterator2, class Compare>
    constexpr bool
      lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              Compare comp);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
    bool
      lexicographical_compare(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2);
  template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
           class Compare>
    bool
      lexicographical_compare(ExecutionPolicy&& exec, // see \cxxref{algorithms.parallel.overloads}
                              ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2,
                              Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
        class Proj1 = identity, class Proj2 = identity,
        IndirectStrictWeakOrder<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less<>>
      constexpr bool
        lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
    template<InputRange R1, InputRange R2, class Proj1 = identity,
        class Proj2 = identity,
        IndirectStrictWeakOrder<projected<iterator_t<R1>, Proj1>,
          projected<iterator_t<R2>, Proj2>> Comp = ranges::less<>>
      constexpr bool
        lexicographical_compare(R1&& r1, R2&& r2, Comp comp = Comp{},
                                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{alg.3way}, three-way comparison algorithms
  [...]

  // \ref{alg.permutation.generators}, permutations
  template<class BidirectionalIterator>
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    constexpr bool next_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<BidirectionalIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr bool
        next_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<BidirectionalRange R, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr bool
        next_permutation(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  template<class BidirectionalIterator>
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last);
  template<class BidirectionalIterator, class Compare>
    constexpr bool prev_permutation(BidirectionalIterator first,
                                    BidirectionalIterator last, Compare comp);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  namespace ranges {
    template<BidirectionalIterator I, Sentinel<I> S, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<I, Comp, Proj>
      constexpr bool
        prev_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
    template<BidirectionalRange R, class Comp = ranges::less<>,
        class Proj = identity>
      requires Sortable<iterator_t<R>, Comp, Proj>
      constexpr bool
        prev_permutation(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
}
\end{codeblock}

\rSec1[algorithms.requirements]{Algorithms requirements}
\pnum
All of the algorithms are separated from the particular implementations of data structures and are
parameterized by iterator types.
Because of this, they can work with program-defined data structures, as long
as these data structures have iterator types satisfying the assumptions on the algorithms.

\begin{addedblock}
\pnum
The function templates defined in the \tcode{std::ranges} namespace
in this Clause are not found by argument-dependent
name lookup\cxxiref{basic.lookup.argdep}. When found by
unqualified\cxxiref{basic.lookup.unqual} name lookup for the
\grammarterm{postfix-expression} in a function call\cxxiref{expr.call}, they
inhibit argument-dependent name lookup.

\begin{example}
\begin{codeblock}
void foo() {
    using namespace std::ranges;
    std::vector<int> vec{1,2,3};
    find(begin(vec), end(vec), 2); // \#1
}
\end{codeblock}
The function call expression at \tcode{\#1} invokes \tcode{std::ranges::find},
not \tcode{std::find}, despite that (a) the iterator type returned from \tcode{begin(vec)}
and \tcode{end(vec)} may be associated with namespace \tcode{std} and (b)
\tcode{std::find} is more specialized~(\cxxref{temp.func.order}) than
\tcode{std::ranges::find} since the former requires its first two parameters to
have the same type.
\end{example}
\end{addedblock}

\pnum
For purposes of determining the existence of data races, [...]

\pnum
Throughout this Clause, \added{where the template parameters are not constrained,}
the names of template parameters are used to express type requirements. [...]

\pnum
If an algorithm's
\effects
element specifies that a value pointed to by any iterator passed
as an argument is modified, then that algorithm has an additional
type requirement:
The type of that argument shall \change{satisfy}{meet} the requirements
of a mutable iterator\iref{iterator.requirements}.
\begin{note}
This requirement does not affect arguments that are named
\tcode{OutputIterator},
\tcode{OutputIterator1},
or
\tcode{OutputIterator2},
because output iterators must always be mutable\added{, nor does it affect
arguments that are constrained, for which mutability requirements are expressed
explicitly}.
\end{note}

\pnum
Both in-place and copying versions are provided for certain
algorithms. [...]

\pnum
\added{When not otherwise constrained,} the
\tcode{Predicate}
parameter is used whenever an algorithm expects a function object\cxxref{function.objects}
that, when applied to the result
of dereferencing the corresponding iterator, [...]

\pnum
\added{When not otherwise constrained,} the
\tcode{BinaryPredicate}
parameter is used whenever an algorithm expects a function object that [...]

[...]

\setcounter{Paras}{10}
\pnum
In the description of the algorithms operators
\tcode{+}
and
\tcode{-}
are used for some of the iterator categories [...]

\begin{addedblock}
\pnum
In the description of algorithm return values, sentinel values are sometimes
returned where an iterator is expected. In these cases, the semantics are as
if the sentinel is converted into an iterator \newtxt{using
\tcode{ranges::next(first, last)}.} \oldtxt{as follows:}

{\color{oldclr}
\begin{codeblock}
I tmp = first;
while(tmp != last)
  ++tmp;
return tmp;
\end{codeblock}
} %% \color{oldclr}

\pnum
Overloads of algorithms that take \libconcept{Range} arguments\iref{range.range}
behave as if they are implemented by calling \tcode{ranges::begin} and
\tcode{ranges::end} on the \libconcept{Range}(s) and dispatching
to the overload \newtxt{in namespace \tcode{ranges}} that takes
separate iterator and sentinel arguments.

\pnum
The number and order of template parameters for algorithm declarations
is unspecified, except where explicitly stated otherwise.

{\color{newclr}
\pnum
The class templates  \tcode{binary_transform_result}, \tcode{copy_result},
\tcode{for_each_result}, \tcode{minmax_result}, \tcode{mismatch_result}, and
\tcode{partition_copy_result} have the template parameters, data members, and
special members specified above. They have no base classes or members other than
those specified.
} %% \color{newclr}
\end{addedblock}

\setcounter{section}{4}
\rSec1[alg.nonmodifying]{Non-modifying sequence operations}

\rSec2[alg.all_of]{All of}

\indexlibrary{\idxcode{all_of}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool all_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool all_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
              Predicate pred);
\end{itemdecl}\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr bool all_of(I first, S last, Pred pred, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool all_of(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be \tcode{pred(*i)} and \tcode{invoke(pred, invoke(proj, *i))}
for the overloads in namespace \tcode{std} and \tcode{std::ranges}, respectively.
\end{addedblock}

\pnum
\removed{\returns \tcode{true} if \range{first}{last} is empty or if \tcode{pred(*i)} is
\tcode{true} for every iterator \tcode{i} in the range \range{first}{last}, and
\tcode{false} otherwise.}

\added{\returns \tcode{false} if $E$ is \tcode{false} for some iterator \tcode{i} in the
range \range{first}{last}, and \tcode{true} otherwise.}

\pnum
\complexity At most \tcode{last - first} applications of the predicate
\added{and any projection}.
\end{itemdescr}

\rSec2[alg.any_of]{Any of}

\indexlibrary{\idxcode{any_of}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool any_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool any_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
              Predicate pred);
\end{itemdecl}\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr bool any_of(I first, S last, Pred pred, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool any_of(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\added{Let $E$ be \tcode{pred(*i)} and \tcode{invoke(pred, invoke(proj, *i))}
for the overloads in namespace \tcode{std} and \tcode{std::ranges}, respectively.}

\pnum
\removed{\returns \tcode{false} if \range{first}{last} is empty or if there is no
iterator \tcode{i} in the range \range{first}{last} such that \tcode{pred(*i)}
is \tcode{true}, and \tcode{true} otherwise.}

\added{\returns \tcode{true} if $E$ is \tcode{true} for some iterator \tcode{i}
in the range \range{first}{last}, and \tcode{false} otherwise.}

\pnum
\complexity At most \tcode{last - first} applications of the predicate
\added{and any projection}.
\end{itemdescr}

\rSec2[alg.none_of]{None of}

\indexlibrary{\idxcode{none_of}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool none_of(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool none_of(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
               Predicate pred);
\end{itemdecl}\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr bool none_of(I first, S last, Pred pred, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool none_of(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}\end{addedblock}

\begin{itemdescr}
\pnum
\added{Let $E$ be \tcode{pred(*i)} and \tcode{invoke(pred, invoke(proj, *i))}
for the overloads in namespace \tcode{std} and \tcode{std::ranges}, respectively.}

\pnum
\removed{\returns \tcode{true} if \range{first}{last} is empty or if
\tcode{pred(*i)} is \tcode{false} for every iterator \tcode{i} in the range
\range{first}{last}, and \tcode{false} otherwise.}

\added{\returns \tcode{false} if $E$ is \tcode{true} for some iterator \tcode{i}
in the range \range{first}{last}, and \tcode{true} otherwise.}

\pnum
\complexity At most \tcode{last - first} applications of the predicate
\added{and any projection}.
\end{itemdescr}

\rSec2[alg.foreach]{For each}

[...]

\setcounter{Paras}{9}
\begin{itemdescr}
\pnum
\begin{note}
Does not return a copy of its \tcode{Function} parameter, since
parallelization may not permit efficient state accumulation.
\end{note}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{for_each}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryInvocable<projected<I, Proj>> Fun>
    constexpr for_each_result<I, Fun>
      for_each(I first, S last, Fun f, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryInvocable<projected<iterator_t<R>, Proj>> Fun>
    constexpr for_each_result<safe_iterator_t<R>, Fun>
      for_each(R&& r, Fun f, Proj proj = Proj{});
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Calls
\tcode{invoke(f, invoke(proj, *i))} for every iterator
\tcode{i} in the range
\range{first}{last},
starting from
\tcode{first}
and proceeding to
\tcode{last - 1}.
\begin{note}
If the result of
\tcode{invoke(proj, *i)} is a mutable reference, \tcode{f} may apply
non-constant functions.
\end{note}

\pnum
\returns
\tcode{\{last, std::move(f)\}}.

\pnum
\complexity
Applies \tcode{f} and \tcode{proj}
exactly
\tcode{last - first}
times.

\pnum
\remarks
If \tcode{f} returns a result, the result is ignored.

\pnum
\begin{note}
\newtxt{The overloads in namespace \tcode{ranges} require \tcode{Fun} to model
\libconcept{CopyConstructible}.}
\end{note}
\end{itemdescr}
\end{addedblock}

[...]

\rSec2[alg.find]{Find}

\indexlibrary{\idxcode{find}}%
\indexlibrary{\idxcode{find_if}}%
\indexlibrary{\idxcode{find_if_not}}%
\begin{itemdecl}
template<class InputIterator, class T>
  constexpr InputIterator find(InputIterator first, InputIterator last,
                               const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  ForwardIterator find(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                       const T& value);

template<class InputIterator, class Predicate>
  constexpr InputIterator find_if(InputIterator first, InputIterator last,
                                  Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator find_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                          Predicate pred);

template<class InputIterator, class Predicate>
  constexpr InputIterator find_if_not(InputIterator first, InputIterator last,
                                      Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator find_if_not(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
                              Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class T, class Proj = identity>
    requires IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
      constexpr I find(I first, S last, const T& value, Proj proj = Proj{});
  template<InputRange R, class T, class Proj = identity>
    requires IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
    constexpr safe_iterator_t<R>
      find(R&& r, const T& value, Proj proj = Proj{});
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr I find_if(I first, S last, Pred pred, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr safe_iterator_t<R>
      find_if(R&& r, Pred pred, Proj proj = Proj{});
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr I find_if_not(I first, S last, Pred pred, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr safe_iterator_t<R>
      find_if_not(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be:
\begin{itemize}
\item \tcode{*i == value} for \tcode{find},
\item \tcode{pred(*i) != false} for \tcode{find_if},
\item \tcode{pred(*i) == false} for \tcode{find_if_not},
\item \tcode{invoke(proj, *i) == value} for \tcode{ranges::find},
\item \tcode{invoke(pred, invoke(proj, *i)) != false} for \tcode{ranges::find_if},
\item \tcode{invoke(pred, invoke(proj, *i)) == false} for \tcode{ranges::find_if_not}.
\end{itemize}
\end{addedblock}

\pnum
\returns
The first iterator
\tcode{i}
in the range
\range{first}{last}
for which \added{$E$ is \tcode{true}.} \removed{the following corresponding
conditions hold:
\tcode{*i == value}, \tcode{pred(*i) != false}, \tcode{pred(*i) == false}.}
Returns \tcode{last} if no such iterator is found.

\pnum
\complexity
At most
\tcode{last - first}
applications of the corresponding predicate \added{and any projection}.
\end{itemdescr}

\rSec2[alg.find.end]{Find end}

\indexlibrary{\idxcode{find_end}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    find_end(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  constexpr ForwardIterator1
    find_end(ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    find_end(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2,
      class Pred = ranges::equal_to<>, class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
    constexpr subrange<I1>
      find_end(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<ForwardRange R1, ForwardRange R2,
      class Pred = ranges::equal_to<>, class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr safe_subrange_t<R1>
      find_end(R1&& r1, R2&& r2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\ednote{This wording incorporates the PR for
\href{https://github.com/ericniebler/stl2/issues/180}{stl2\#180} and
\href{https://github.com/ericniebler/stl2/issues/526}{stl2\#526}).}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let:
\begin{itemize}
\item \tcode{pred} be \tcode{equal_to<>\{\}} for the overloads with no parameter
\tcode{pred}.

\item $\oldtxt{P}\newtxt{E}$ be:
\begin{itemize}
\item \tcode{pred(*(i + n), *(first2 + n))}
for the overloads in namespace \tcode{std},

\item \tcode{invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n)))}
for the overloads in namespace \tcode{ranges}.
\end{itemize}

\item \tcode{i} be the last iterator in the range
\range{first1}{last1 - (last2 - first2)}
such that for every non-negative integer
\tcode{n < (last2 - first2)}, $\oldtxt{P}\newtxt{E}$ is \tcode{true};
or \tcode{last1} if no such iterator exists.
\end{itemize}
\end{addedblock}

\pnum
\effects
Finds a subsequence of equal values in a sequence.

\begin{removedblock}
\pnum
\returns
The last iterator
\tcode{i}
in the range \range{first1}{last1 - (last2 - first2)}
such that for every non-negative integer
\tcode{n < (last2 - first2)},
the following corresponding conditions hold:
\tcode{*(i + n) == *(\brk{}first2 + n), pred(*(i + n), *(first2 + n)) != false}.
Returns \tcode{last1}
if
\range{first2}{last2} is empty or if
no such iterator is found.
\end{removedblock}

\begin{addedblock}
\pnum
\returns
\begin{itemize}
\item \tcode{i} for the overloads in namespace \tcode{std}, and
\item \tcode{\{i, i + (i == last1 ? 0 : last2 - first2)\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity
At most
\tcode{(last2 - first2) * (last1 - first1 - (last2 - first2) + 1)}
applications of the corresponding predicate \added{and any projections}.
\end{itemdescr}

\rSec2[alg.find.first.of]{Find first}

\indexlibrary{\idxcode{find_first_of}}%
\begin{itemdecl}
template<class InputIterator, class ForwardIterator>
  constexpr InputIterator
    find_first_of(InputIterator first1, InputIterator last1,
                  ForwardIterator first2, ForwardIterator last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator1
    find_first_of(ExecutionPolicy&& exec,
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator, class ForwardIterator,
         class BinaryPredicate>
  constexpr InputIterator
    find_first_of(InputIterator first1, InputIterator last1,
                  ForwardIterator first2, ForwardIterator last2,
                  BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator1
    find_first_of(ExecutionPolicy&& exec,
                  ForwardIterator1 first1, ForwardIterator1 last1,
                  ForwardIterator2 first2, ForwardIterator2 last2,
                  BinaryPredicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, ForwardIterator I2, Sentinel<I2> S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectRelation<projected<I1, Proj1>, projected<I2, Proj2>> Pred = ranges::equal_to<>>
    constexpr I1 find_first_of(I1 first1, S1 last1, I2 first2, S2 last2,
                                Pred pred = Pred{},
                                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, ForwardRange R2, class Proj1 = identity,
      class Proj2 = identity,
      IndirectRelation<projected<iterator_t<R1>, Proj1>,
        projected<iterator_t<R2>, Proj2>> Pred = ranges::equal_to<>>
    constexpr safe_iterator_t<R1>
      find_first_of(R1&& r1, R2&& r2,
                    Pred pred = Pred{},
                    Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be:
\begin{itemize}
\item \tcode{*i == *j} for the overloads with no parameter \tcode{pred},
\item \tcode{pred(*i, *j) != false} for the overloads with a parameter \tcode{pred} and no parameter \tcode{proj1},
\item \tcode{invoke(pred, invoke(proj1, *i), invoke(proj2, *j)) != false} for the overloads with both parameters \tcode{pred} and \tcode{proj1}.
\end{itemize}
\end{addedblock}

\pnum
\effects
Finds an element that matches one of a set of values.

\pnum
\returns
The first iterator
\tcode{i}
in the range \range{first1}{last1}
such that for some
iterator
\tcode{j}
in the range \range{first2}{last2} \added{$E$ holds.}
\removed{the following conditions hold:
\tcode{*i == *j, pred(*i, *j) != false}.}
Returns \tcode{last1}
if \range{first2}{last2} is empty or
if no such iterator is found.

\pnum
\complexity
At most
\tcode{(last1 - first1) * (last2 - first2)}
applications of the corresponding predicate \added{and any projections}.
\end{itemdescr}

\rSec2[alg.adjacent.find]{Adjacent find}

\indexlibrary{\idxcode{adjacent_find}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    adjacent_find(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class BinaryPredicate>
  constexpr ForwardIterator
    adjacent_find(ForwardIterator first, ForwardIterator last,
                  BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
  ForwardIterator
    adjacent_find(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last,
                  BinaryPredicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
      IndirectRelation<projected<I, Proj>> Pred = ranges::equal_to<>>
    constexpr I adjacent_find(I first, S last, Pred pred = Pred{},
                              Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectRelation<projected<iterator_t<R>, Proj>> Pred = ranges::equal_to<>>
    constexpr safe_iterator_t<R>
      adjacent_find(R&& r, Pred pred = Pred{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be:
\begin{itemize}
\item \tcode{*i == *(i + 1)} for the overloads with no parameter \tcode{pred},
\item \tcode{pred(*i, *(i + 1)) != false} for the overloads with a parameter \tcode{pred} and no parameter \tcode{proj},
\item \tcode{invoke(pred, invoke(proj, *i), invoke(proj, *(i + 1))) != false} for the overloads with both parameters \tcode{pred} and \tcode{proj}.
\end{itemize}
\end{addedblock}

\pnum
\returns
The first iterator
\tcode{i}
such that both
\tcode{i}
and
\tcode{i + 1}
are in
the range
\range{first}{last}
for which \added{$E$ holds.}
\removed{the following corresponding conditions hold:
\tcode{*i == *(i + 1), pred(*i, *(i + 1)) != false}.}
Returns \tcode{last}
if no such iterator is found.

\pnum
\complexity
For the overloads with no \tcode{ExecutionPolicy}, exactly
\tcode{min((i - first) + 1, (last - first) - 1)}
applications of the corresponding predicate, where \tcode{i} is
\tcode{adjacent_find}'s
return value\added{, and no more than twice as many applications of any projection}.
  For the overloads with an \tcode{ExecutionPolicy},
\bigoh{\tcode{last - first}} applications of the corresponding predicate.
\end{itemdescr}

\rSec2[alg.count]{Count}

\indexlibrary{\idxcode{count}}%
\indexlibrary{\idxcode{count_if}}%
\begin{itemdecl}
template<class InputIterator, class T>
  constexpr typename iterator_traits<InputIterator>::difference_type
    count(InputIterator first, InputIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  typename iterator_traits<ForwardIterator>::difference_type
    count(ExecutionPolicy&& exec,
          ForwardIterator first, ForwardIterator last, const T& value);

template<class InputIterator, class Predicate>
  constexpr typename iterator_traits<InputIterator>::difference_type
    count_if(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  typename iterator_traits<ForwardIterator>::difference_type
    count_if(ExecutionPolicy&& exec,
             ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class T, class Proj = identity>
    requires IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
    constexpr iter_difference_t<I>
      count(I first, S last, const T& value, Proj proj = Proj{});
  template<InputRange R, class T, class Proj = identity>
    requires IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
    constexpr iter_difference_t<iterator_t<R>>
      count(R&& r, const T& value, Proj proj = Proj{});
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr iter_difference_t<I>
      count_if(I first, S last, Pred pred, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr iter_difference_t<iterator_t<R>>
      count_if(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be:
\begin{itemize}
\item \tcode{*i == value} for the overloads with no parameter \tcode{pred} or \tcode{proj},
\item \tcode{pred(*i) != false} for the overloads with a parameter \tcode{pred} but no parameter \tcode{proj},
\item \tcode{invoke(proj, *i) == value} for the overloads with a parameter \tcode{proj} but no parameter \tcode{pred},
\item \tcode{invoke(pred, invoke(proj, *i)) != false} for the overloads both parameters \tcode{proj} and \tcode{pred}.
\end{itemize}
\end{addedblock}

\pnum
\effects
Returns the number of iterators
\tcode{i}
in the range \range{first}{last}
for which \added{$E$ holds.} \removed{the following corresponding
conditions hold:
\tcode{*i == value, pred(*i) != false}.}

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate \added{and any projection}.
\end{itemdescr}

\rSec2[mismatch]{Mismatch}

\indexlibrary{\idxcode{mismatch}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr pair<InputIterator1, InputIterator2>
    mismatch(InputIterator1 first1, InputIterator1 last1,
             InputIterator2 first2, InputIterator2 last2,
             BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  pair<ForwardIterator1, ForwardIterator2>
    mismatch(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectRelation<projected<I1, Proj1>, projected<I2, Proj2>> Pred = ranges::equal_to<>>
    constexpr mismatch_result<I1, I2>
      mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectRelation<projected<iterator_t<R1>, Proj1>,
        projected<iterator_t<R2>, Proj2>> Pred = ranges::equal_to<>>
    constexpr mismatch_result<safe_iterator_t<R1>, safe_iterator_t<R2>>
      mismatch(R1&& r1, R2&& r2, Pred pred = Pred{},
               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\removed{\remarks If \tcode{last2} was not given in the argument list, it denotes
\tcode{first2 + (last1 - first1)} below.}

\begin{addedblock}
\pnum
Let \tcode{last2} be \tcode{first2 + (last1 - first1)} for the overloads with no parameter \tcode{last2} or \tcode{r2}.

\pnum
Let $E$ be:
\begin{itemize}
\item \tcode{!(*(first1 + n) == *(first2 + n))} for the overloads with no parameter \tcode{pred},
\item \tcode{pred(*(first1 + n), *(first2 + n)) == false} for the overloads with a parameter \tcode{pred} and no parameter \tcode{proj1},
\item \tcode{!invoke(pred, invoke(proj1, *(first1 + n)), invoke(proj2, *(first2 + n)))} for the overloads with both parameters \tcode{pred} and \tcode{proj1}.
\end{itemize}
\end{addedblock}

\pnum
\returns
\removed{A pair of iterators \tcode{first1 + n} and
\tcode{first2 + n}} \added{\tcode{\{ first1 + n, first2 + n \}}}, where \tcode{n} is the smallest integer
such that \added{$E$ holds}, \removed{respectively,}
\begin{itemize}
\item \removed{\tcode{!(*(first1 + n) == *(first2 + n))} or}
\item \removed{\tcode{pred(*(first1 + n), *(first2 + n)) == false},}
\end{itemize}
or \tcode{min(last1 - first1, last2 - first2)} if no such integer exists.

\pnum
\complexity
At most
\tcode{min(last1 - first1, last2 - first2)}
applications of the corresponding predicate \added{and any projections}.
\end{itemdescr}

\rSec2[alg.equal]{Equal}

\indexlibrary{\idxcode{equal}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, BinaryPredicate pred);

template<class InputIterator1, class InputIterator2>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2,
         class BinaryPredicate>
  constexpr bool equal(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, InputIterator2 last2,
                       BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  bool equal(ExecutionPolicy&& exec,
             ForwardIterator1 first1, ForwardIterator1 last1,
             ForwardIterator2 first2, ForwardIterator2 last2,
             BinaryPredicate pred);
\end{itemdecl}
\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      class Pred = ranges::equal_to<>, class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool equal(I1 first1, S1 last1, I2 first2, S2 last2,
                         Pred pred = Pred{},
                         Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, class Pred = ranges::equal_to<>,
      class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool equal(R1&& r1, R2&& r2, Pred pred = Pred{},
                         Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}\end{addedblock}

\begin{itemdescr}
\pnum
\removed{\remarks If \tcode{last2} was not given in the argument list, it denotes
\tcode{first2 + (last1 - first1)} below.}

\begin{addedblock}
\pnum
Let:
\begin{itemize}
\item \tcode{last2} be \tcode{first2 + (last1 - first1)} for the overloads with no parameter \tcode{last2} or \tcode{r2},

\item \tcode{pred} be \tcode{equal_to<>\{\}} for the overloads with no parameter \tcode{pred},

\item $E$ be:
\begin{itemize}
\item \tcode{pred(*i, *(first2 + (i - first1)))} for the overloads with no parameter \tcode{proj1},
\item \tcode{invoke(pred, invoke(proj1, *i), invoke(proj2, *(first2 + (i - first1))))} for the overloads with parameter \tcode{proj1}.
\end{itemize}
\end{itemize}
\end{addedblock}

\pnum
\returns
If
\tcode{last1 - first1 != last2 - first2},
return
\tcode{false}.
Otherwise return
\tcode{true}
if \added{$E$ holds} for every iterator
\tcode{i}
in the range \range{first1}{last1}
\removed{the following corresponding conditions hold:
\tcode{*i == *(first2 + (i - first1)), pred(*i, *(first2 + (i - first1))) != false}}.
Otherwise, returns
\tcode{false}.

\pnum
\complexity
\begin{addedblock}
If the types of \tcode{first1}, \tcode{last1}, \tcode{first2}, and \tcode{last2}:
\begin{itemize}
\item meet the \oldconcept{RandomAccessIterator}
  requirements\iref{random.access.iterators}
  for the overloads in namespace \tcode{std}, or
\item pairwise model \tcode{SizedSentinel}\iref{iterator.concept.sizedsentinel} for the
overloads in namespace \tcode{ranges},
\end{itemize}
and
\tcode{last1 - first1 != last2 - first2},
then
no applications of the corresponding predicate and each projection; otherwise,
\end{addedblock}

\begin{itemize}
\item
For the overloads with no \tcode{ExecutionPolicy}, at most
$\min(\tcode{last1 - first1}, \tcode{last2 - first2})$
applications of the corresponding predicate \added{and any projections}.
\begin{itemize}
\item
\removed{if
\tcode{InputIterator1}
and
\tcode{InputIterator2}
meet the \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}
and
\tcode{last1 - first1 != last2 - first2},
then
no applications of the corresponding predicate; otherwise,}
\end{itemize}

\item
For the overloads with an \tcode{ExecutionPolicy},
\bigoh{\min(\tcode{last1 - first1}, \tcode{last2 - first2})} applications
of the corresponding predicate.
\begin{itemize}
\item
\removed{if
\tcode{ForwardIterator1}
and
\tcode{ForwardIterator2}
meet the \oldconcept{RandomAccessIterator} requirements and
\tcode{last1 - first1 != last2 - first2}, then
no applications of the corresponding predicate; otherwise,}
\end{itemize}
\end{itemize}
\end{itemdescr}

\rSec2[alg.is_permutation]{Is permutation}

[...]

\setcounter{Paras}{4}
\begin{addedblock}
\indexlibrary{\idxcode{is_permutation}}%
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
      Sentinel<I2> S2, class Pred = ranges::equal_to<>, class Proj1 = identity,
      class Proj2 = identity>
    requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
    constexpr bool is_permutation(I1 first1, S1 last1, I2 first2, S2 last2,
                                  Pred pred = Pred{},
                                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to<>,
      class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr bool is_permutation(R1&& r1, R2&& r2, Pred pred = Pred{},
                                  Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}

\ednote{FIXME: This formulation in terms of range-and-a-half \tcode{ranges::equal}
is broken, since we are not proposing a range-and-a-half \tcode{ranges::equal}.}

\begin{itemdescr}
\pnum
\returns If \tcode{last1 - first1 != last2 - first2}, return \tcode{false}.
Otherwise return \tcode{true} if there exists a permutation of the elements in the
range \range{first2}{first2 + (last1 - first1)}, beginning with
\tcode{I2 begin}, such that
\tcode{ranges::equal(first1, last1, begin, pred, proj1, proj2)} returns \tcode{true};
otherwise, returns \tcode{false}.

\pnum
\complexity
No applications of the corresponding predicate and projections if:
\begin{itemize}
\item \tcode{S1} and \tcode{I1} model \libconcept{SizedSentinel},
\item \tcode{S2} and \tcode{I2} model \libconcept{SizedSentinel}, and
\item \tcode{last1 - first1 != last2 - first2}.
\end{itemize}
Otherwise, exactly \tcode{last1 - first1} applications of the
corresponding predicate and projections if
\tcode{ranges::equal(\brk{}first1, last1, first2, last2, pred, proj1, proj2)}
would return \tcode{true}; otherwise, at
worst \bigoh{N^2}, where $N$ has the value \tcode{last1 - first1}.
\end{itemdescr}
\end{addedblock}

\rSec2[alg.search]{Search}

[...]

\setcounter{Paras}{2}
\begin{itemdescr}
\pnum
\complexity
At most
\tcode{(last1 - first1) * (last2 - first2)}
applications of the corresponding predicate.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{search}}%
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I1, Sentinel<I1> S1, ForwardIterator I2,
      Sentinel<I2> S2, class Pred = ranges::equal_to<>,
      class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<I1, I2, Pred, Proj1, Proj2>
    constexpr subrange<I1>
      search(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<ForwardRange R1, ForwardRange R2, class Pred = ranges::equal_to<>,
      class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Pred, Proj1, Proj2>
    constexpr safe_subrange_t<R1>
      search(R1&& r1, R2&& r2, Pred pred = Pred{},
             Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}

\ednote{This wording incorporates the PR for
\href{https://github.com/ericniebler/stl2/issues/180}{stl2\#180} and
\href{https://github.com/ericniebler/stl2/issues/526}{stl2\#526}).}

\begin{itemdescr}
\pnum
\effects
Finds a subsequence of equal values in a sequence.

\pnum
\returns
\begin{itemize}
\item \tcode{\{first1, first1\}} if \range{first2}{last2} is empty,

\item Otherwise, returns \tcode{\{i, i + (last2 - first2)\}} where \tcode{i} is
the first iterator in the range \range{first1}{last1 - (last2 - first2)}
such that for every non-negative integer
\tcode{n}
less than
\tcode{last2 - first2}
the following condition holds:
\begin{codeblock}
invoke(pred, invoke(proj1, *(i + n)), invoke(proj2, *(first2 + n))).
\end{codeblock}

\item Returns
\tcode{\{last1, last1\}}
if no such iterator is found.
\end{itemize}

\pnum
\complexity
At most
\tcode{(last1 - first1) * (last2 - first2)}
applications of the corresponding predicate and projections.
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{search_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Size, class T>
  constexpr ForwardIterator
    search_n(ForwardIterator first, ForwardIterator last,
             Size count, const T& value);
\end{itemdecl}

[...]

\setcounter{Paras}{9}
\begin{itemdescr}
\pnum
\complexity
At most
\tcode{last - first}
applications of the corresponding predicate.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{search_n}}%
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class T,
      class Pred = ranges::equal_to<>, class Proj = identity>
    requires IndirectlyComparable<I, const T*, Pred, Proj>
    constexpr subrange<I>
      search_n(I first, S last, iter_difference_t<I> count,
               const T& value, Pred pred = Pred{}, Proj proj = Proj{});
  template<ForwardRange R, class T, class Pred = ranges::equal_to<>,
      class Proj = identity>
    requires IndirectlyComparable<iterator_t<R>, const T*, Pred, Proj>
    constexpr safe_subrange_t<R>
      search_n(R&& r, iter_difference_t<iterator_t<R>> count,
               const T& value, Pred pred = Pred{}, Proj proj = Proj{});
}
\end{itemdecl}

\ednote{This wording incorporates the PR for
\href{https://github.com/ericniebler/stl2/issues/180}{stl2\#180} and
\href{https://github.com/ericniebler/stl2/issues/526}{stl2\#526}).}

\begin{itemdescr}
\pnum
\effects
Finds a subsequence of equal values in a sequence.

\pnum
\returns
\tcode{\{i, i + count\}} where \tcode{i} is the first iterator
in the range \range{first}{last - count}
such that for every non-negative integer
\tcode{n}
less than
\tcode{count},
the following condition holds:
\tcode{invoke(pred, invoke(proj, *(i + n)), value)}.
Returns \tcode{\{last, last\}}
if no such iterator is found.

\pnum
\complexity
At most
\tcode{last - first}
applications of the corresponding predicate and projection.
\end{itemdescr}
\end{addedblock}

[...]

\rSec1[alg.modifying.operations]{Mutating sequence operations}

\rSec2[alg.copy]{Copy}

\indexlibrary{\idxcode{copy}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator copy(InputIterator first, InputIterator last,
                                OutputIterator result);
\end{itemdecl}\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
    requires IndirectlyCopyable<I, O>
    constexpr copy_result<I, O>
      copy(I first, S last, O result);
  template<InputRange R, WeaklyIncrementable O>
    requires IndirectlyCopyable<iterator_t<R>, O>
    constexpr copy_result<safe_iterator_t<R>, O>
      copy(R&& r, O result);
}
\end{itemdecl}\end{addedblock}

\begin{itemdescr}
\pnum
\requires \tcode{result} shall not be in the range \range{first}{last}.

\pnum
\effects
Copies elements in the range \range{first}{last}
into the range \range{result}{result + (last - first)}
starting from \tcode{first} and proceeding to \tcode{last}.
For each non-negative integer \removed{\tcode{n < (last - first)}}
\added{$n < \tcode{(last - first)}$}, performs
\tcode{*(result + \changed{n}{$n$}) = *(first + \changed{n}{$n$})}.

\pnum
\returns
\begin{itemize}
\item \tcode{result + (last - first)} \added{for the overload in
  namespace \tcode{std}, or}
\item \added{\tcode{\{last, result + (last - first)\}} for the overloads in
  namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity Exactly \tcode{last - first} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{copy}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 copy(ExecutionPolicy&& policy,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The ranges \range{first}{last} and
\range{result}{result + (last - first)} shall not overlap.

\pnum
\effects Copies elements in the range \range{first}{last} into
the range \range{result}{result + (last - first)}.
For each non-negative integer
\changed{\tcode{n < (last - first)}}{$n < \tcode{(last - first)}$},
performs \tcode{*(result + \changed{n}{$n$}) = *(first + \changed{n}{$n$})}.

\pnum
\returns \tcode{result + (last - first)}.

\pnum
\complexity Exactly \tcode{last - first} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{copy_n}}%
\begin{itemdecl}
template<class InputIterator, class Size, class OutputIterator>
  constexpr OutputIterator copy_n(InputIterator first, Size n,
                                  OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class Size, class ForwardIterator2>
  ForwardIterator2 copy_n(ExecutionPolicy&& exec,
                          ForwardIterator1 first, Size n,
                          ForwardIterator2 result);
\end{itemdecl}\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<InputIterator I, WeaklyIncrementable O>
    requires IndirectlyCopyable<I, O>
    constexpr copy_n_result<I, O>
      copy_n(I first, iter_difference_t<I> n, O result);
}
\end{itemdecl}\end{addedblock}

\ednote{This wording incorporates the PR for
\href{https://github.com/ericniebler/stl2/issues/498}{stl2\#498}).}

\begin{itemdescr}
\pnum
\added{Let $M$ be $\max(\tcode{n}, 0)$.}

\pnum
\effects For each non-negative integer
$i < \changed{\tcode{n}}{M}$, performs \tcode{*(result + $i$) = *(first + $i$)}.

\pnum
\returns
\begin{itemize}
\item \tcode{result + \changed{n}{$M$}}
  \added{for the overload in namespace \tcode{std}, or}
\item \added{\tcode{\{\oldtxt{last}\newtxt{first} + $M$, result + $M$\}}
  for the overload in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity Exactly \tcode{\changed{n}{$M$}} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{copy_if}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class Predicate>
  constexpr OutputIterator copy_if(InputIterator first, InputIterator last,
                                   OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate>
  ForwardIterator2 copy_if(ExecutionPolicy&& exec,
                           ForwardIterator1 first, ForwardIterator1 last,
                           ForwardIterator2 result, Predicate pred);
\end{itemdecl}
\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    requires IndirectlyCopyable<I, O>
    constexpr copy_if_result<I, O>
      copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});
  template<InputRange R, WeaklyIncrementable O, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires IndirectlyCopyable<iterator_t<R>, O>
    constexpr copy_if_result<safe_iterator_t<R>, O>
      copy_if(R&& r, O result, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}\end{addedblock}

\begin{itemdescr}
\pnum
\begin{addedblock}
Let $E$ be:
\begin{itemize}
\item \tcode{bool(pred(*i))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
and $N$ be the number of iterators \tcode{i} in the range \range{first}{last}
for which the condition $E$ holds.
\end{addedblock}

\pnum
\requires The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap.
\begin{note}
For the overload with an \tcode{ExecutionPolicy}, there may be a performance
cost if \tcode{iterator_traits<ForwardIterator1>::value_type} is not
\oldconcept{Move\-Constructible} (\cxxref{tab:moveconstructible}).
\end{note}

\pnum
\effects Copies all of the elements referred to by the iterator \tcode{i}
in the range \range{first}{last} for which \changed{\tcode{pred(*i)}}{$E$} is
\tcode{true}.

\pnum
\returns \removed{The end of the resulting range.}
\begin{itemize}
\item \added{\tcode{result + $N$} for the overload in namespace \tcode{std}, or}
\item \added{\tcode{\{last, result + $N$\}}
  for the overloads in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
Exactly \tcode{last - first} applications of the corresponding predicate
\added{and any projection}.

\pnum
\remarks Stable\cxxiref{algorithm.stable}.
\end{itemdescr}

\indexlibrary{\idxcode{copy_backward}}%
\begin{itemdecl}
template<class BidirectionalIterator1, class BidirectionalIterator2>
  constexpr BidirectionalIterator2
    copy_backward(BidirectionalIterator1 first,
                  BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
\end{itemdecl}\begin{addedblock}\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
    requires IndirectlyCopyable<I1, I2>
    constexpr copy_backward_result<I1, I2>
      copy_backward(I1 first, S1 last, I2 result);
  template<BidirectionalRange R, BidirectionalIterator I>
    requires IndirectlyCopyable<iterator_t<R>, I>
    constexpr copy_backward_result<safe_iterator_t<R>, I>
      copy_backward(R&& r, I result);
}
\end{itemdecl}\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\tcode{result}
shall not be in the range
\brange{first}{last}.

\pnum
\effects
Copies elements in the range \range{first}{last}
into the
range \range{result - (last-first)}{result}
starting from
\tcode{last - 1}
and proceeding to \tcode{first}.\footnote{\tcode{copy_backward}
should be used instead of copy when \tcode{last}
is in
the range
\range{result - (last - first)}{result}.}
For each positive integer
\tcode{\removed{n <= (last - first)}}
\added{$n \le \tcode{(last - first)}$},
performs
\tcode{*(result - \changed{n}{$n$}) = *(last - \changed{n}{$n$})}.

\pnum
\returns
\begin{itemize}
\item \tcode{result - (last - first)}
  \added{for the overload in namespace \tcode{std}, or}
\item \added{\tcode{\{last, result - (last - first)\}}
  for the overloads in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}

\rSec2[alg.move]{Move}

\indexlibrary{\idxcode{move}!algorithm}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator move(InputIterator first, InputIterator last,
                                OutputIterator result);
\end{itemdecl}
\begin{addedblock}
\indexlibrary{\idxcode{move}}%
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O>
    requires IndirectlyMovable<I, O>
    constexpr move_result<I, O>
      move(I first, S last, O result);
  template<InputRange R, WeaklyIncrementable O>
    requires IndirectlyMovable<iterator_t<R>, O>
    constexpr move_result<safe_iterator_t<R>, O>
      move(R&& r, O result);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{std::move(*(first + $n$))} for the overload in namespace \tcode{std}, or
\item \tcode{ranges::iter_move(first + $n$)} for the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\requires
\tcode{result}
shall not be in the range
\range{first}{last}.

\pnum
\effects
Moves elements in the range \range{first}{last}
into the range \range{result}{result + (last - first)}
starting from first and proceeding to last.
For each non-negative integer
\removed{\tcode{n < (last-first)}} \added{$n < \tcode{(last - first)}$},
performs
\removed{\tcode{*(result + n) = std::move(*(first + n))}}
\added{\tcode{*(result + $n$) = $E$}}.

\pnum
\returns
\begin{itemize}
\item \tcode{result + (last - first)} \added{for the overload in namespace \tcode{std}, or}
\item \added{\tcode{\{last, result + (last - first)\}} for the overloads in
  namespace \tcode{ranges}.}
\end{itemize}

\pnum
\complexity
Exactly
\tcode{last - first}
\removed{move} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{move}!algorithm}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2 move(ExecutionPolicy&& policy,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires The ranges \range{first}{last} and
\range{result}{result + (last - first)} shall not overlap.

\pnum
\effects Moves elements in the range \range{first}{last} into
the range \range{result}{result + (last - first)}.
For each non-negative integer \tcode{n < (last - first)},
performs \tcode{*(result + n) = std::\brk{}move(*(first + n))}.

\pnum
\returns \tcode{result + (last - first)}.

\pnum
\complexity Exactly \tcode{last - first} assignments.
\end{itemdescr}

\indexlibrary{\idxcode{move_backward}}%
\begin{itemdecl}
template<class BidirectionalIterator1, class BidirectionalIterator2>
  constexpr BidirectionalIterator2
    move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                  BidirectionalIterator2 result);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I1, Sentinel<I1> S1, BidirectionalIterator I2>
    requires IndirectlyMovable<I1, I2>
    constexpr move_backward_result<I1, I2>
      move_backward(I1 first, S1 last, I2 result);
  template<BidirectionalRange R, BidirectionalIterator I>
    requires IndirectlyMovable<iterator_t<R>, I>
    constexpr move_backward_result<safe_iterator_t<R>, I>
      move_backward(R&& r, I result);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{std::move(*(last - $n$))} for the overload in namespace \tcode{std}, or
\item \tcode{ranges::iter_move(last - $n$)} for the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\requires
\tcode{result}
shall not be in the range
\brange{first}{last}.

\pnum
\effects
Moves elements in the range \range{first}{last}
into the
range \range{result - (last\added{ }-\added{ }first)}{result}
starting from
\tcode{last - 1}
and proceeding to first.\footnote{\tcode{move_backward}
should be used instead of move when \changed{last}{\tcode{last}}
is in
the range
\range{result - (last - first)}{result}.}
For each positive integer
\tcode{\removed{n <= (last - first)}}
\added{$n \le \tcode{(last - first)}$},
performs
\tcode{\removed{*(result - n) = std::move(*(last - n))}}
\tcode{\added{*(result - $n$) = $E$}}.

\pnum
\returns
\begin{itemize}
\item \tcode{result - (last - first)} \added{for the overload in namespace \tcode{std}, or}
\item \added{\tcode{\{last, result - (last - first)\}} for the overloads
  in namespace \tcode{ranges}.}
\end{itemize}

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}


\rSec2[alg.swap]{Swap}

\ednote{This wording integrates the PR for
\href{https://github.com/ericniebler/stl2/issues/415}{stl2\#415}.}

\indexlibrary{\idxcode{swap_ranges}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr ForwardIterator2
    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    swap_ranges(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2>
    requires IndirectlySwappable<I1, I2>
    constexpr swap_ranges_result<I1, I2>
      swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);
  template<InputRange R1, InputRange R2>
    requires IndirectlySwappable<iterator_t<R1>, iterator_t<R2>>
    constexpr swap_ranges_result<safe_iterator_t<R1>, safe_iterator_t<R2>>
      swap_ranges(R1&& r1, R2&& r2);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let:
\begin{itemize}
\item \tcode{last2} be \tcode{first2 + (last1 - first1)} for the overloads with
  no parameter named \tcode{last2}, and
\item $M$ be $min(\tcode{last1 - first1}, \tcode{last2 - first2})$.
\end{itemize}
\end{addedblock}

\pnum
\requires
The two ranges \range{first1}{last1}
and
\range{first2}{\removed{first2 + (last1 - first1)} \added{last2}}
shall not overlap. \added{For the overloads in namespace \tcode{std},}
\tcode{*(first1 + \changed{n}{$n$})} shall be swappable with\cxxiref{swappable.requirements}
\tcode{*(first2 + \changed{n}{$n$})}.

\pnum
\effects
For each non-negative integer
\tcode{\removed{n < (last1 - first1)}}
\added{$n < M$}
performs: \tcode{\removed{swap(*(first1 + n), *(first2 + n))}}
\begin{addedblock}
\begin{itemize}
\item \tcode{swap(*(first1 + $n$), *(first2 + $n$))} for the overloads in
  namespace \tcode{std}, or
\item \tcode{ranges::iter_swap(first1 + $n$, first2 + $n$)} for the overloads
  in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\returns \tcode{\removed{first2 + (last1 - first1)}}
\begin{addedblock}
\begin{itemize}
\item \tcode{last2} for the overloads in namespace \tcode{std}, or
\item \tcode{\{first1 + $M$, first2 + $M$\}}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity
Exactly
\changed{\tcode{last1 - first1}}{$M$}
swaps.
\end{itemdescr}


\indexlibrary{\idxcode{iter_swap}}%
\begin{itemdecl}
template<class ForwardIterator1, class ForwardIterator2>
  constexpr void iter_swap(ForwardIterator1 a, ForwardIterator2 b);
\end{itemdecl}

[...]

\rSec2[alg.transform]{Transform}

\indexlibrary{\idxcode{transform}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator,
         class UnaryOperation>
  constexpr OutputIterator
    transform(InputIterator first@\added{1}@, InputIterator last@\added{1}@,
              OutputIterator result, UnaryOperation op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class UnaryOperation>
  ForwardIterator2
    transform(ExecutionPolicy&& exec,
              ForwardIterator1 first@\added{1}@, ForwardIterator1 last@\added{1}@,
              ForwardIterator2 result, UnaryOperation op);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class BinaryOperation>
  constexpr OutputIterator
    transform(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, OutputIterator result,
              BinaryOperation binary_op);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class BinaryOperation>
  ForwardIterator
    transform(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator result,
              BinaryOperation binary_op);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
      CopyConstructible F, class Proj = identity>
    requires Writable<O, indirect_result_t<F&, projected<I, Proj>>>
    constexpr unary_transform_result<I, O>
      transform(I first1, S last1, O result, F op, Proj proj = Proj{});
  template<InputRange R, WeaklyIncrementable O, CopyConstructible F,
      class Proj = identity>
    requires Writable<O, indirect_result_t<F&,
      projected<iterator_t<R>, Proj>>>
    constexpr unary_transform_result<safe_iterator_t<R>, O>
      transform(R&& r, O result, F op, Proj proj = Proj{});
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      WeaklyIncrementable O, CopyConstructible F, class Proj1 = identity,
      class Proj2 = identity>
    requires Writable<O, indirect_result_t<F&, projected<I1, Proj1>,
      projected<I2, Proj2>>>
    constexpr binary_transform_result<I1, I2, O>
      transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, WeaklyIncrementable O,
      CopyConstructible F, class Proj1 = identity, class Proj2 = identity>
    requires Writable<O, indirect_result_t<F&,
      projected<iterator_t<R1>, Proj1>, projected<iterator_t<R2>, Proj2>>>
    constexpr binary_transform_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
      transform(R1&& r1, R2&& r2, O result,
                F binary_op, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let:
\begin{itemize}
\item \tcode{last2} be \tcode{first2 + (last1 - first1)} for the overloads with
  parameter \tcode{first2} but no parameter \tcode{last2},
\item $N$ be \tcode{last1 - first1} for unary transforms, or
  $\min(\tcode{last1 - first1}, \tcode{last2 - first2})$ for binary transforms, and
\item $E$ be
  \begin{itemize}
  \item \tcode{op(*(first1 + (i - result)))} for unary transforms defined in
    namespace \tcode{std},
  \item \tcode{binary_op(*(first1 + (i - result)), *(first2 + (i - result)))} for
    binary transforms defined in namespace \tcode{std},
  \item \tcode{invoke(op, invoke(proj, *(first1 + (i - result))))} for unary
    transforms defined in namespace \tcode{ranges}, or
  \item \tcode{invoke(binary_op, invoke(proj1, *(first1 + (i - result))), invoke(proj2, *(first2 + (i - result))))}
    for binary transforms defined in namespace \tcode{ranges}.
  \end{itemize}
\end{itemize}
\end{addedblock}

\pnum
\requires
\tcode{op} and \tcode{binary_op}
shall not invalidate iterators or subranges, or modify elements in the ranges
\begin{itemize}
\item \crange{first1}{\changed{last1}{first1 + $N$}},
\item \crange{first2}{first2 + \changed{(last1 - first1)}{$N$}}, and
\item \crange{result}{result + \changed{(last1 - first1)}{$N$}}.\footnote{The
use of fully closed ranges is intentional.}
\end{itemize}

\pnum
\effects
Assigns through every iterator
\tcode{i}
in the range
\range{result}{result + \changed{(last1 - first1)}{$N$}}
a new
corresponding value equal to \added{$E$}
\tcode{\removed{op(*(first1 + (i - result)))}}\removed{
or
}\tcode{\removed{binary_op(*(first1 + (i - result)), *(first2 + (i - result)))}}.

\pnum
\returns
\begin{itemize}
\item \tcode{result + \changed{(last1 - first1)}{$N$}}
  \added{for the overloads defined in namespace \tcode{std},}
\item \added{\tcode{\{first1 + $N$, result + $N$\}} for unary transforms
  defined in namespace \tcode{ranges}, or}
\item \added{\tcode{\{first1 + $N$, first2 + $N$, result + $N$\}} for binary
  transforms defined in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
Exactly
\changed{\tcode{last1 - first1}}{$N$}
applications of
\tcode{op} or \tcode{binary_op}\added{, and any projections}.
This requirement also applies to the overload with an \tcode{ExecutionPolicy}.

\pnum
\remarks
\tcode{result} may be equal \removed{to \tcode{first}
in case of unary transform,
or} to \tcode{first1} or \tcode{first2}
\removed{in case of binary transform}.
\end{itemdescr}


\rSec2[alg.replace]{Replace}

\indexlibrary{\idxcode{replace}}%
\indexlibrary{\idxcode{replace_if}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr void replace(ForwardIterator first, ForwardIterator last,
                         const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  void replace(ExecutionPolicy&& exec,
               ForwardIterator first, ForwardIterator last,
               const T& old_value, const T& new_value);

template<class ForwardIterator, class Predicate, class T>
  constexpr void replace_if(ForwardIterator first, ForwardIterator last,
                            Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator, class Predicate, class T>
  void replace_if(ExecutionPolicy&& exec,
                  ForwardIterator first, ForwardIterator last,
                  Predicate pred, const T& new_value);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class T1, class T2, class Proj = identity>
    requires Writable<I, const T2&> &&
      IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T1*>
    constexpr I
      replace(I first, S last, const T1& old_value, const T2& new_value, Proj proj = Proj{});
  template<InputRange R, class T1, class T2, class Proj = identity>
    requires Writable<iterator_t<R>, const T2&> &&
      IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T1*>
    constexpr safe_iterator_t<R>
      replace(R&& r, const T1& old_value, const T2& new_value, Proj proj = Proj{});
  template<InputIterator I, Sentinel<I> S, class T, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    requires Writable<I, const T&>
    constexpr I replace_if(I first, S last, Pred pred, const T& new_value, Proj proj = Proj{});
  template<InputRange R, class T, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires Writable<iterator_t<R>, const T&>
    constexpr safe_iterator_t<R>
      replace_if(R&& r, Pred pred, const T& new_value, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*i == old_value)} for the \tcode{replace},
\item \tcode{bool(pred(*i))} for \tcode{replace_if},
\item \tcode{bool(invoke(proj, *i) == old_value)} for \tcode{ranges::replace}, or
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::replace_if}.
\end{itemize}
\end{addedblock}

\pnum
\requires
The expression
\tcode{*first = new_value}
shall be valid.

\pnum
\effects
Substitutes elements referred by the iterator
\tcode{i}
in the range \range{first}{last}
with \tcode{new_value},
when \added{$E$ is \tcode{true}}
\removed{the following corresponding conditions hold:
\tcode{*i == old_value}, \tcode{pred(*i) != false}}.

\begin{addedblock}
\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate \added{and any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{replace_copy}}%
\indexlibrary{\idxcode{replace_copy_if}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T>
  constexpr OutputIterator
    replace_copy(InputIterator first, InputIterator last,
                 OutputIterator result,
                 const T& old_value, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class T>
  ForwardIterator2
    replace_copy(ExecutionPolicy&& exec,
                 ForwardIterator1 first, ForwardIterator1 last,
                 ForwardIterator2 result,
                 const T& old_value, const T& new_value);

template<class InputIterator, class OutputIterator, class Predicate, class T>
  constexpr OutputIterator
    replace_copy_if(InputIterator first, InputIterator last,
                    OutputIterator result,
                    Predicate pred, const T& new_value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate, class T>
  ForwardIterator2
    replace_copy_if(ExecutionPolicy&& exec,
                    ForwardIterator1 first, ForwardIterator1 last,
                    ForwardIterator2 result,
                    Predicate pred, const T& new_value);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class T1, class T2, OutputIterator<const T2&> O,
      class Proj = identity>
    requires IndirectlyCopyable<I, O> &&
      IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T1*>
    constexpr replace_copy_result<I, O>
      replace_copy(I first, S last, O result, const T1& old_value, const T2& new_value,
                    Proj proj = Proj{});
  template<InputRange R, class T1, class T2, OutputIterator<const T2&> O,
      class Proj = identity>
    requires IndirectlyCopyable<iterator_t<R>, O> &&
      IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T1*>
    constexpr replace_copy_result<safe_iterator_t<R>, O>
      replace_copy(R&& r, O result, const T1& old_value, const T2& new_value,
                    Proj proj = Proj{});

  template<InputIterator I, Sentinel<I> S, class T, OutputIterator<const T&> O,
      class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
    requires IndirectlyCopyable<I, O>
    constexpr replace_copy_if_result<I, O>
      replace_copy_if(I first, S last, O result, Pred pred, const T& new_value,
                      Proj proj = Proj{});
  template<InputRange R, class T, OutputIterator<const T&> O, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires IndirectlyCopyable<iterator_t<R>, O>
    constexpr replace_copy_if_result<safe_iterator_t<R>, O>
      replace_copy_if(R&& r, O result, Pred pred, const T& new_value,
                      Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*(first + (i - result)) == old_value)}
  for \tcode{replace_copy},
\item \tcode{bool(pred(*(first + (i - result))))}
  for \tcode{replace_copy_if},
\item \tcode{bool(invoke(proj, *(first + (i - result))) == old_value)}
  for \tcode{ranges::replace_copy},
\item \tcode{bool(invoke(pred, invoke(proj, *(first + (i - result)))))}
  for \tcode{ranges::replace_copy_if}.
\end{itemize}
\end{addedblock}

\pnum
\requires
The results of the expressions
\tcode{*first}
and
\tcode{new_value}
shall be writable\iref{iterator.requirements.general} to the
\tcode{result}
output iterator.
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap.

\pnum
\effects
Assigns to every iterator
\tcode{i}
in the
range
\range{result}{result + (last - first)}
either
\tcode{new_value}
or
\tcode{*\brk(first + (i - result))}
depending on whether \added{$E$ holds.}
\begin{removedblock}
the following corresponding conditions hold:
\begin{codeblock}
*(first + (i - result)) == old_value
pred(*(first + (i - result))) != false
\end{codeblock}
\end{removedblock}

\pnum
\returns
\begin{itemize}
\item \tcode{result + (last - first)} \added{for the overloads in
  namespace \tcode{std}, or}
\item \added{\tcode{\{last, result + (last - first)\}} for the overloads in
  namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate \added{and any projection}.
\end{itemdescr}


\rSec2[alg.fill]{Fill}

\indexlibrary{\idxcode{fill}}%
\indexlibrary{\idxcode{fill_n}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr void fill(ForwardIterator first, ForwardIterator last, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  void fill(ExecutionPolicy&& exec,
            ForwardIterator first, ForwardIterator last, const T& value);

template<class OutputIterator, class Size, class T>
  constexpr OutputIterator fill_n(OutputIterator first, Size n, const T& value);
template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
  ForwardIterator fill_n(ExecutionPolicy&& exec,
                         ForwardIterator first, Size n, const T& value);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<class T, OutputIterator<const T&> O, Sentinel<O> S>
    constexpr O fill(O first, S last, const T& value);
  template<class T, OutputRange<const T&> R>
    constexpr safe_iterator_t<R> fill(R&& r, const T& value);
  template<class T, OutputIterator<const T&> O>
    constexpr O fill_n(O first, iter_difference_t<O> n, const T& value);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $N$ be $\max(0, \tcode{n})$ for the \tcode{fill_n} algorithms, and
\tcode{last - first} for the \tcode{fill} algorithms.
\end{addedblock}

\pnum
\requires
The expression
\tcode{value}
shall be writable\iref{iterator.requirements.general} to the output iterator. The type
\tcode{Size}
shall be convertible to an integral type~(\cxxref{conv.integral}, \cxxref{class.conv}).

\pnum
\effects
\added{Assigns \tcode{value} through all the iterators in the range \range{first}{first + $N$}.}
\removed{The \tcode{fill} algorithms assign \tcode{value} through all the iterators in the range
\range{first}{last}. The \tcode{fill_n} algorithms assign \tcode{value}
through all the iterators in the range \range{first}{first + n}
if \tcode{n} is positive, otherwise they do nothing.}

\pnum
\returns
\added{\tcode{first + $N$}.}
\removed{\tcode{fill_n} returns \tcode{first + n} for non-negative values of \tcode{n}
and \tcode{first} for negative values.}

\pnum
\complexity
Exactly \added{$N$}
\removed{\tcode{last - first},
\tcode{n}, or 0} assignments\removed{, respectively}.
\end{itemdescr}


\rSec2[alg.generate]{Generate}

\indexlibrary{\idxcode{generate}}%
\indexlibrary{\idxcode{generate_n}}%
\begin{itemdecl}
template<class ForwardIterator, class Generator>
  constexpr void generate(ForwardIterator first, ForwardIterator last,
                          Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Generator>
  void generate(ExecutionPolicy&& exec,
                ForwardIterator first, ForwardIterator last,
                Generator gen);

template<class OutputIterator, class Size, class Generator>
  constexpr OutputIterator generate_n(OutputIterator first, Size n, Generator gen);
template<class ExecutionPolicy, class ForwardIterator, class Size, class Generator>
  ForwardIterator generate_n(ExecutionPolicy&& exec,
                             ForwardIterator first, Size n, Generator gen);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<Iterator O, Sentinel<O> S, CopyConstructible F>
      requires Invocable<F&> && Writable<O, invoke_result_t<F&>>
    constexpr O generate(O first, S last, F gen);
  template<class R, CopyConstructible F>
      requires Invocable<F&> && OutputRange<R, invoke_result_t<F&>>
    constexpr safe_iterator_t<R> generate(R&& r, F gen);
  template<Iterator O, CopyConstructible F>
      requires Invocable<F&> && Writable<O, invoke_result_t<F&>>
    constexpr O generate_n(O first, iter_difference_t<O> n, F gen);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $N$ be $\max(0, \tcode{n})$ for the \tcode{generate_n} algorithms, and
\tcode{last - first} for the \tcode{generate} algorithms.
\end{addedblock}

\pnum
\requires
\tcode{gen} takes no arguments,
\tcode{Size}
shall be convertible to an integral type~(\cxxref{conv.integral}, \cxxref{class.conv}).

\pnum
\effects
\added{Invokes the function object \tcode{gen} and assigns the return value
through all the iterators in the range \range{first}{first + $N$}.}

\removed{The \tcode{generate} algorithms invoke the function object \tcode{gen} and assign the return
value of \tcode{gen} through all the iterators in the range
\range{first}{last}. The \tcode{generate_n} algorithms invoke the function object
\tcode{gen} and assign the return value of \tcode{gen} through all the iterators in
the range \range{first}{first + n} if \tcode{n} is positive,
otherwise they do nothing.}

\pnum
\returns
\added{\tcode{first + $N$}.}

\removed{\tcode{generate_n} returns \tcode{first + n} for non-negative values of \tcode{n}
and \tcode{first} for negative values.}

\pnum
\complexity
Exactly \added{$N$}
\removed{\tcode{last - first},
\tcode{n}, or 0}
invocations of \tcode{gen} and assignments\removed{, respectively}.
\end{itemdescr}


\rSec2[alg.remove]{Remove}

\indexlibrary{\idxcode{remove}}%
\indexlibrary{\idxcode{remove_if}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                                   const T& value);
template<class ExecutionPolicy, class ForwardIterator, class T>
  ForwardIterator remove(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last,
                         const T& value);

template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                      Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator remove_if(ExecutionPolicy&& exec,
                            ForwardIterator first, ForwardIterator last,
                            Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class T, class Proj = identity>
    requires @\oldtxt{Permutable<I> \&\&}@
      IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
    constexpr I remove(I first, S last, const T& value, Proj proj = Proj{});
  template<ForwardRange R, class T, class Proj = identity>
    requires Permutable<iterator_t<R>> &&
      IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
    constexpr safe_iterator_t<R>
      remove(R&& r, const T& value, Proj proj = Proj{});
  template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    @\oldtxt{requires Permutable<I>}@
    constexpr I remove_if(I first, S last, Pred pred, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires Permutable<iterator_t<R>>
    constexpr safe_iterator_t<R>
      remove_if(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*i == value)} for \tcode{remove},
\item \tcode{bool(pred(*i))} for \tcode{remove_if},
\item \tcode{bool(invoke(proj, *i) == value)} for \tcode{ranges::remove}, or
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::remove_if}.
\end{itemize}
\end{addedblock}

\pnum
\requires
\changed{The}{For the algorithms in namespace \tcode{std}, the} type of
\tcode{*first} shall \changed{satisfy}{meet} the
\oldconcept{MoveAssignable} requirements\cxxiref{tab:moveassignable}.

\pnum
\effects
Eliminates all the elements referred to by iterator
\tcode{i}
in the range \range{first}{last}
for which \added{$E$ holds} \removed{the following corresponding conditions hold:
\tcode{*i == value, pred(*i) != false}}.

\pnum
\returns
The end of the resulting range.

\pnum
\remarks Stable\cxxiref{algorithm.stable}.

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate \added{and any projection}.

\pnum
\begin{note}
Each element in the range \range{ret}{last}, where \tcode{ret} is
the returned value, has a valid but unspecified state, because the algorithms
can eliminate elements by moving from elements that were originally
in that range.
\end{note}
\end{itemdescr}


\indexlibrary{\idxcode{remove_copy}}%
\indexlibrary{\idxcode{remove_copy_if}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator, class T>
  constexpr OutputIterator
    remove_copy(InputIterator first, InputIterator last,
                OutputIterator result, const T& value);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class T>
  ForwardIterator2
    remove_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, const T& value);

template<class InputIterator, class OutputIterator, class Predicate>
  constexpr OutputIterator
    remove_copy_if(InputIterator first, InputIterator last,
                   OutputIterator result, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Predicate>
  ForwardIterator2
    remove_copy_if(ExecutionPolicy&& exec,
                   ForwardIterator1 first, ForwardIterator1 last,
                   ForwardIterator2 result, Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O, class T,
      class Proj = identity>
    requires IndirectlyCopyable<I, O> &&
      IndirectRelation<ranges::equal_to<>, projected<I, Proj>, const T*>
    constexpr remove_copy_result<I, O>
      remove_copy(I first, S last, O result, const T& value, Proj proj = Proj{});
  template<InputRange R, WeaklyIncrementable O, class T, class Proj = identity>
    requires IndirectlyCopyable<iterator_t<R>, O> &&
      IndirectRelation<ranges::equal_to<>, projected<iterator_t<R>, Proj>, const T*>
    constexpr remove_copy_result<safe_iterator_t<R>, O>
      remove_copy(R&& r, O result, const T& value, Proj proj = Proj{});
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
      class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
    requires IndirectlyCopyable<I, O>
    constexpr remove_copy_if_result<I, O>
      remove_copy_if(I first, S last, O result, Pred pred, Proj proj = Proj{});
  template<InputRange R, WeaklyIncrementable O, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires IndirectlyCopyable<iterator_t<R>, O>
    constexpr remove_copy_if_result<safe_iterator_t<R>, O>
      remove_copy_if(R&& r, O result, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(*i == value)} for \tcode{remove_copy},
\item \tcode{bool(pred(*i))} for \tcode{remove_copy_if},
\item \tcode{bool(invoke(proj, *i) == value)} for \tcode{ranges::remove_copy}, or
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for \tcode{ranges::remove_copy_if}.
\end{itemize}

\pnum
Let $N$ be the number of elements in \range{first}{last} for which $E$ is \tcode{false}.
\end{addedblock}

\pnum
\requires
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap. The expression \tcode{*result = *first} shall be valid.
\begin{note}
For the overloads with an \tcode{ExecutionPolicy}, there may be a performance
cost if \tcode{iterator_traits<ForwardIterator1>::value_type} \changed{is}{does} not
\added{meet the} \oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible}
\added{requirements}.
\end{note}

\pnum
\effects
Copies all the elements referred to by the iterator
\tcode{i}
in the range
\range{first}{last}
for which \added{$E$ is \tcode{false}}
\removed{the following corresponding conditions do not hold:
\tcode{*i == value, pred(*i) != false}}.

\pnum
\returns \removed{The end of the resulting range.}
\begin{addedblock}
\begin{itemize}
\item \tcode{result + $N$}, for the algorithms in namespace \tcode{std}, or
\item \tcode{\{last, result + $N$\}}, for the algorithms in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity
Exactly
\tcode{last - first}
applications of the corresponding predicate \added{and any projection}.

\pnum
\remarks Stable\cxxiref{algorithm.stable}.
\end{itemdescr}


\rSec2[alg.unique]{Unique}

\indexlibrary{\idxcode{unique}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator unique(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class BinaryPredicate>
  constexpr ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                                   BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
  ForwardIterator unique(ExecutionPolicy&& exec,
                         ForwardIterator first, ForwardIterator last,
                         BinaryPredicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class Proj = identity,
      IndirectRelation<projected<I, Proj>> C = ranges::equal_to<>>
    @\oldtxt{requires Permutable<I>}@
    constexpr I unique(I first, S last, C comp = C{}, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectRelation<projected<iterator_t<R>, Proj>> C = ranges::equal_to<>>
    requires Permutable<iterator_t<R>>
    constexpr safe_iterator_t<R>
      unique(R&& r, C comp = C{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{pred} be \tcode{equal_to<>\{\}} for the overloads with no
parameter \tcode{pred}, and let $E$ be
\begin{itemize}
\item \tcode{bool(pred(*(i - 1), *i))}
  for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(comp, invoke(proj, *(i - 1)), invoke(proj, *i)))}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\requires
\removed{The comparison function} \added{For the overloads in
namepace \tcode{std}, \tcode{pred}} shall be
an equivalence relation\changed{. The}{ and the}
type of \tcode{*first} shall \changed{satisfy}{meet} the
\oldconcept{MoveAssignable} requirements\cxxiref{tab:moveassignable}.

\pnum
\effects
For a nonempty range, eliminates all but the first element from every
consecutive group of equivalent elements referred to by the iterator
\tcode{i}
in the range
\range{first + 1}{last}
for which \added{$E$ is \tcode{true}.} \removed{the following conditions hold:
\tcode{*(i - 1) == *i}
or
\tcode{pred(*(i - 1), *i) != false}.}

\pnum
\returns
The end of the resulting range.

\pnum
\complexity
For nonempty ranges, exactly
\tcode{(last - first) - 1}
applications of the corresponding predicate \added{and no more than twice as
many applications of any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{unique_copy}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator>
  constexpr OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    unique_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result);

template<class InputIterator, class OutputIterator,
         class BinaryPredicate>
  constexpr OutputIterator
    unique_copy(InputIterator first, InputIterator last,
                OutputIterator result, BinaryPredicate pred);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate>
  ForwardIterator2
    unique_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 last,
                ForwardIterator2 result, BinaryPredicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
      class Proj = identity, IndirectRelation<projected<I, Proj>> C = ranges::equal_to<>>
    requires IndirectlyCopyable<I, O> &&
      (ForwardIterator<I> ||
      (InputIterator<O> && Same<iter_value_t<I>, iter_value_t<O>>) ||
      IndirectlyCopyableStorable<I, O>)
    constexpr unique_copy_result<I, O>
      unique_copy(I first, S last, O result, C comp = C{}, Proj proj = Proj{});
  template<InputRange R, WeaklyIncrementable O, class Proj = identity,
      IndirectRelation<projected<iterator_t<R>, Proj>> C = ranges::equal_to<>>
    requires IndirectlyCopyable<iterator_t<R>, O> &&
      (ForwardIterator<iterator_t<R>> ||
      (InputIterator<O> && Same<iter_value_t<iterator_t<R>>, iter_value_t<O>>) ||
      IndirectlyCopyableStorable<iterator_t<R>, O>)
    constexpr unique_copy_result<safe_iterator_t<R>, O>
      unique_copy(R&& r, O result, C comp = C{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{pred} be \tcode{equal_to<>\{\}} for the overloads in
namespace \tcode{std} with no parameter \tcode{pred}, and let $E$ be
\begin{itemize}
\item \tcode{bool(pred(*i, *(i - 1)))}
  for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))}
  for the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\requires
\begin{itemize}
\item
\removed{The comparison function shall be an equivalence relation.}

\item
The ranges
\range{first}{last}
and
\range{result}{result\added{ }+\added{ }(last\added{ }-\added{ }first)}
shall not overlap.

\item
\added{For the overloads in namespace \tcode{std}:}
\begin{itemize}
\item
\added{The comparison function shall be an equivalence relation.}

\item
The expression
\tcode{*result = *first}
shall be valid.

\item
For the overloads with no \tcode{ExecutionPolicy},
let \tcode{T} be the value type of \tcode{InputIterator}.
If \tcode{InputIterator} meets the \removed{forward iterator}
\added{\oldconcept{ForwardIterator}} requirements,
then there are no additional requirements for \tcode{T}.
Otherwise, if \tcode{OutputIterator} meets the \removed{forward iterator}
\added{\oldconcept{ForwardIterator}} requirements and its value type is
the same as \tcode{T}, then \tcode{T} shall \changed{be}{meet the}
\oldconcept{CopyAssignable}\cxxiref{tab:copyassignable} \added{requirements}.
Otherwise, \tcode{T} shall \changed{be both}{meet the}
\oldconcept{CopyConstructible}\cxxiref{tab:copyconstructible} and
\oldconcept{CopyAssignable} \added{requirements}.
\begin{note}
For the overloads with an \tcode{ExecutionPolicy}, there may be a performance
cost if the value type of \tcode{ForwardIterator1} \removed{is not both}
\added{does not meet the} \oldconcept{CopyConstructible} and
\oldconcept{CopyAssignable} \added{requirements}.
\end{note}
\end{itemize}
\end{itemize}

\pnum
\effects
Copies only the first element from every consecutive group of equal elements referred to by
the iterator
\tcode{i}
in the range
\range{first}{last}
for which \added{$E$ holds.}
\removed{the following corresponding conditions hold:
\tcode{*i == *(i - 1)}
or
\tcode{pred(*i, *(i - 1)) != false}.}

\pnum
\returns
\removed{The end of the resulting range.}
\begin{addedblock}
\begin{itemize}
\item \tcode{result + $N$} for the overloads in namespace \tcode{std}, or
\item \tcode{\{last, result + $N$\}} for the overloads in namespace \tcode{ranges}
\end{itemize}
where $N$ is the number of groups of equal elements.
\end{addedblock}

\pnum
\complexity
For nonempty ranges, exactly
\tcode{last - first - 1}
applications of the corresponding predicate
\added{and no more than twice as many applications of any projection}.
\end{itemdescr}


\rSec2[alg.reverse]{Reverse}

\indexlibrary{\idxcode{reverse}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr void reverse(BidirectionalIterator first, BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
  void reverse(ExecutionPolicy&& exec,
               BidirectionalIterator first, BidirectionalIterator last);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I, Sentinel<I> S>
    requires Permutable<I>
    constexpr I reverse(I first, S last);
  template<BidirectionalRange R>
    requires Permutable<iterator_t<R>>
    constexpr safe_iterator_t<R> reverse(R&& r);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{BidirectionalIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements~(\cxxref{swappable.requirements}).

\pnum
\effects
For each non-negative integer
\tcode{i < (last - first) / 2},
applies
\tcode{\added{std::}iter_swap}\added{, or \tcode{ranges::iter_swap} for the overloads
in namespace \tcode{ranges},}
to all pairs of iterators
\tcode{first + i, (last - i) - 1}.

\begin{addedblock}
\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
Exactly
\tcode{(last - first)\added{ }/\added{ }2}
swaps.
\end{itemdescr}


\indexlibrary{\idxcode{reverse_copy}}%
\begin{itemdecl}
template<class BidirectionalIterator, class OutputIterator>
  constexpr OutputIterator
    reverse_copy(BidirectionalIterator first, BidirectionalIterator last,
                 OutputIterator result);
template<class ExecutionPolicy, class BidirectionalIterator, class ForwardIterator>
  ForwardIterator
    reverse_copy(ExecutionPolicy&& exec,
                 BidirectionalIterator first, BidirectionalIterator last,
                 ForwardIterator result);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I, Sentinel<I> S, WeaklyIncrementable O>
    requires IndirectlyCopyable<I, O>
    constexpr reverse_copy_result<I, O>
      reverse_copy(I first, S last, O result);
  template<BidirectionalRange R, WeaklyIncrementable O>
    requires IndirectlyCopyable<iterator_t<R>, O>
    constexpr reverse_copy_result<safe_iterator_t<R>, O>
      reverse_copy(R&& r, O result);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap.

\pnum
\effects
Copies the range
\range{first}{last}
to the range
\range{result}{result + (last - first)}
such that
for every non-negative integer
\tcode{i < (last - first)}
the following assignment takes place:
\tcode{*(result + (last - first) - 1 - i) = *(first + i)}.

\pnum
\returns
\begin{itemize}
\item \tcode{result + (last - first)}\added{ for the overloads in
  namespace \tcode{std}}, or

\item \added{\tcode{\{last, result + (last - first)\}} for the overloads
  in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}


\rSec2[alg.rotate]{Rotate}

\ednote{This wording incorporates the PR for
\href{https://github.com/ericniebler/stl2/issues/526}{stl2\#526}).}

\indexlibrary{\idxcode{rotate}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    rotate(ExecutionPolicy&& exec,
           ForwardIterator first, ForwardIterator middle, ForwardIterator last);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S>
    @\oldtxt{requires Permutable<I>}@
    constexpr subrange<I> rotate(I first, I middle, S last);
  template<ForwardRange R>
    requires Permutable<iterator_t<R>>
    constexpr safe_subrange_t<R> rotate(R&& r, iterator_t<R> middle);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\range{first}{middle}
and
\range{middle}{last}
shall be valid ranges.
\added{For the overloads in namespace \tcode{std},}
\tcode{ForwardIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable}
requirements\cxxiref{swappable.requirements}\changed{. The}{, and the}
type of \tcode{*first} shall \changed{satisfy}{meet}
the \oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
For each non-negative integer
\tcode{i < (last - first)},
places the element from the position
\tcode{first + i}
into position
\tcode{first + (i + (last - middle)) \% (last - first)}.
\begin{addedblock}
\begin{note}
This is a left rotate.
\end{note}
\end{addedblock}

\pnum
\returns
\begin{itemize}
\item \tcode{first + (last - middle)} \added{for the overloads in
  namespace \tcode{std}, or}
\item \added{\tcode{\{first + (last - middle), last\}} for the overloads in
  namespace \tcode{ranges}}.
\end{itemize}

\pnum
\removed{\remarks
This is a left rotate.}

\pnum
\complexity
At most
\tcode{last - first}
swaps.
\end{itemdescr}


\indexlibrary{\idxcode{rotate_copy}}%
\begin{itemdecl}
template<class ForwardIterator, class OutputIterator>
  constexpr OutputIterator
    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last,
                OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  ForwardIterator2
    rotate_copy(ExecutionPolicy&& exec,
                ForwardIterator1 first, ForwardIterator1 middle, ForwardIterator1 last,
                ForwardIterator2 result);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, WeaklyIncrementable O>
    requires IndirectlyCopyable<I, O>
    constexpr rotate_copy_result<I, O>
      rotate_copy(I first, I middle, S last, O result);
  template<ForwardRange R, WeaklyIncrementable O>
    requires IndirectlyCopyable<iterator_t<R>, O>
    constexpr rotate_copy_result<safe_iterator_t<R>, O>
      rotate_copy(R&& r, iterator_t<R> middle, O result);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
The ranges
\range{first}{last}
and
\range{result}{result + (last - first)}
shall not overlap.

\pnum
\effects
Copies the range
\range{first}{last}
to the range
\range{result}{result + (last - first)}
such that for each non-negative integer
\tcode{i < (last - first)}
the following assignment takes place:
\tcode{*(result + i) =  *(first +
(i + (middle - first)) \% (last - first))}.

\pnum
\returns
\begin{itemize}
\item \tcode{result + (last - first)} \added{for the overloads in
  namespace \tcode{std}, or}
\item \added{\tcode{\{last, result + (last - first)\}} for the overloads in
  namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
Exactly
\tcode{last - first}
assignments.
\end{itemdescr}


\rSec2[alg.random.sample]{Sample}

[...]

\rSec2[alg.random.shuffle]{Shuffle}

\indexlibrary{\idxcode{shuffle}}%
\begin{itemdecl}
template<class RandomAccessIterator, class UniformRandomBitGenerator>
  void shuffle(RandomAccessIterator first,
               RandomAccessIterator last,
               UniformRandomBitGenerator&& g);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Gen>
    requires Permutable<I> &&
      UniformRandomBitGenerator<remove_reference_t<Gen>> &&
      ConvertibleTo<invoke_result_t<Gen&>, iter_difference_t<I>>
    I shuffle(I first, S last, Gen&& g);
  template<RandomAccessRange R, class Gen>
    requires Permutable<iterator_t<R>> &&
      UniformRandomBitGenerator<remove_reference_t<Gen>> &&
      ConvertibleTo<invoke_result_t<Gen&>, iter_difference_t<iterator_t<R>>>
    safe_iterator_t<R>
      shuffle(R&& r, Gen&& g);
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std}:}
\begin{itemize}
\item \tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements~(\cxxref{swappable.requirements}).
\item The type
\tcode{remove_reference_t<UniformRandomBitGenerator>}
shall \changed{satisfy the requirements of a}{meet the}
uniform random bit generator\cxxiref{rand.req.urng} \added{requirements}
\removed{type whose return type is convertible to
\tcode{iterator_traits<Random\-Access\-Itera\-tor>::difference_type}}.
\end{itemize}

\pnum
\effects
Permutes the elements in the range
\range{first}{last}
such that each possible permutation of those elements has equal probability of appearance.

\begin{addedblock}
\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
Exactly
\tcode{(last - first) - 1}
swaps.

\pnum
\remarks
To the extent that the implementation of this function makes use of random
numbers, the object \added{referenced by} \tcode{g} shall serve as
the implementation's source of randomness.
\end{itemdescr}


\rSec2[alg.shift]{Shift}

[...]


\rSec1[alg.sorting]{Sorting and related operations}

\pnum
\changed{All the}{The} operations in~\ref{alg.sorting} \added{defined directly in namespace \tcode{std}}
have two versions: one that takes a function object of type
\tcode{Compare}
and one that uses an
\tcode{operator<}.

\pnum
\tcode{Compare}
is a function object
type\cxxref{function.objects}. The return value of the function call operation applied to
an object of type \tcode{Compare}, when contextually converted to
\tcode{bool}\cxxref{conv},
yields \tcode{true} if the first argument of the call
is less than the second, and
\tcode{false}
otherwise.
\tcode{Compare comp}
is used throughout for algorithms assuming an ordering relation.
It is assumed that
\tcode{comp}
will not apply any non-constant function through the dereferenced iterator.

\pnum
For all algorithms that take
\tcode{Compare},
there is a version that uses
\tcode{operator<}
instead.
That is,
\tcode{comp(*i, *j) != false}
defaults to
\tcode{*i < *j != false}.
For algorithms other than those described in~\ref{alg.binary.search},
\tcode{comp} shall induce a strict weak ordering on the values.

% \ednote{This specification of strict weak ordering may be redundant with the
% specification of strict weak ordering in \cxxref{concepts}.}

\pnum
The term
\term{strict}
refers to the
requirement of an irreflexive relation (\tcode{!comp(x, x)} for all \tcode{x}),
and the term
\term{weak}
to requirements that are not as strong as
those for a total ordering,
but stronger than those for a partial
ordering.
If we define
\tcode{equiv(a, b)}
as
\tcode{!comp(a, b) \&\& !comp(b, a)},
then the requirements are that
\tcode{comp}
and
\tcode{equiv}
both be transitive  relations:

\begin{itemize}
\item
\tcode{comp(a, b) \&\& comp(b, c)}
implies
\tcode{comp(a, c)}
\item
\tcode{equiv(a, b) \&\& equiv(b, c)}
implies
\tcode{equiv(a, c)}
\end{itemize}
\begin{note}
Under these conditions, it can be shown that
\begin{itemize}
\item
\tcode{equiv}
is an equivalence relation
\item
\tcode{comp}
induces a well-defined relation on the equivalence
classes determined by
\tcode{equiv}
\item
The induced relation is a strict total ordering.
\end{itemize}
\end{note}

\pnum
A sequence is
\term{sorted with respect to a comparator}
\tcode{comp} if for every iterator
\tcode{i}
pointing to the sequence and every non-negative integer
\tcode{n}
such that
\tcode{i + n}
is a valid iterator pointing to an element of the sequence,
\tcode{comp(*(i + n), *i) == false}.

\begin{addedblock}
\pnum
A sequence is
\term{sorted with respect to a comparator and projection}
\tcode{comp} and \tcode{proj} if for every iterator
\tcode{i}
pointing to the sequence and every non-negative integer
\tcode{n}
such that
\tcode{i + n}
is a valid iterator pointing to an element of the sequence,
\tcode{invoke(comp, invoke(proj, *(i + n)), invoke(proj, *i)) == false}.
\end{addedblock}

\pnum
A sequence
\range{start}{finish}
is
\term{partitioned with respect to an expression}
\tcode{f(e)}
if there exists an integer
\tcode{n}
such that for all
\tcode{0 <= i < (finish - start)},
\tcode{f(*(start + i))}
is \tcode{true} if and only if
\tcode{i < n}.

\pnum
In the descriptions of the functions that deal with ordering relationships we frequently use a notion of
equivalence to describe concepts such as stability.
The equivalence to which we refer is not necessarily an
\tcode{operator==},
but an equivalence relation induced by the strict weak ordering.
That is, two elements
\tcode{a}
and
\tcode{b}
are considered equivalent if and only if
\tcode{!(a < b) \&\& !(b < a)}.

\rSec2[alg.sort]{Sorting}

\rSec3[sort]{\tcode{sort}}

\indexlibrary{\idxcode{sort}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void sort(ExecutionPolicy&& exec,
            RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void sort(RandomAccessIterator first, RandomAccessIterator last,
            Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void sort(ExecutionPolicy&& exec,
            RandomAccessIterator first, RandomAccessIterator last,
            Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr I
      sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr safe_iterator_t<R>
      sort(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements~(\cxxref{swappable.requirements})\changed{.
The}{ and the} type of \tcode{*first} shall \changed{satisfy}{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
Sorts the elements in the range
\range{first}{last}.

\begin{addedblock}
\pnum
\returns \tcode{last}, for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
\added{Let $N$ be \tcode{last - first}.} \bigoh{N \log\added{(}N\added{)}}
comparisons\added{ and twice as many applications of any
projection.}\removed{, where $N = \tcode{last - first}$.}
\end{itemdescr}


\rSec3[stable.sort]{\tcode{stable_sort}}

\indexlibrary{\idxcode{stable_sort}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void stable_sort(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void stable_sort(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator last,
                   Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    I stable_sort(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    safe_iterator_t<R>
      stable_sort(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}\removed{.
The} \added{and the} type of \tcode{*first} shall
\changed{satisfy}{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
Sorts the elements in the range \range{first}{last}.

\begin{addedblock}
\pnum
\returns \tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
\added{Let $N$ be \tcode{last - first}.
If enough extra memory is available, $N \log(N)$ comparisons.
Otherwise, at most $N \log^2(N)$ comparisons.
In either case, twice as many applications of any projection as
the number of comparisons.} \removed{At most $N \log^2(N)$
comparisons, where $N = \tcode{last - first}$,
but only $N \log N$ comparisons if there is enough extra memory.}

\pnum
\remarks Stable\cxxiref{algorithm.stable}.
\end{itemdescr}


\rSec3[partial.sort]{\tcode{partial_sort}}

\indexlibrary{\idxcode{partial_sort}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void partial_sort(RandomAccessIterator first,
                              RandomAccessIterator middle,
                              RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void partial_sort(ExecutionPolicy&& exec,
                    RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void partial_sort(RandomAccessIterator first,
                              RandomAccessIterator middle,
                              RandomAccessIterator last,
                              Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void partial_sort(ExecutionPolicy&& exec,
                    RandomAccessIterator first,
                    RandomAccessIterator middle,
                    RandomAccessIterator last,
                    Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr I
      partial_sort(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr safe_iterator_t<R>
      partial_sort(R&& r, iterator_t<R> middle, Comp comp = Comp{},
                   Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable}
requirements\cxxiref{swappable.requirements}\removed{. The} \added{and
the} type of \tcode{*first} shall \changed{satisfy}{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
Places the first
\tcode{middle - first}
sorted elements from the range
\range{first}{last}
into the range
\range{first}{middle}.
The rest of the elements in the range
\range{middle}{last}
are placed in an unspecified order.
\indextext{unspecified}%

\begin{addedblock}
\pnum
\returns \tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
Approximately
\tcode{(last - first) * log(middle - first)}
comparisons\added{, and exactly twice as many applications
of any projection}.
\end{itemdescr}


\rSec3[partial.sort.copy]{\tcode{partial_sort_copy}}

\indexlibrary{\idxcode{partial_sort_copy}}%
\begin{itemdecl}
template<class InputIterator, class RandomAccessIterator>
  constexpr RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator>
  RandomAccessIterator
    partial_sort_copy(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last);

template<class InputIterator, class RandomAccessIterator,
         class Compare>
  constexpr RandomAccessIterator
    partial_sort_copy(InputIterator first, InputIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last,
                      Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class RandomAccessIterator,
         class Compare>
  RandomAccessIterator
    partial_sort_copy(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last,
                      RandomAccessIterator result_first,
                      RandomAccessIterator result_last,
                      Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, RandomAccessIterator I2, Sentinel<I2> S2,
      class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyCopyable<I1, I2> && Sortable<I2, Comp, Proj2> &&
        IndirectStrictWeakOrder<Comp, projected<I1, Proj1>, projected<I2, Proj2>>
    constexpr I2
      partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,
                        Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, RandomAccessRange R2, class Comp = ranges::less<>,
      class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyCopyable<iterator_t<R1>, iterator_t<R2>> &&
        Sortable<iterator_t<R2>, Comp, Proj2> &&
        IndirectStrictWeakOrder<Comp, projected<iterator_t<R1>, Proj1>,
          projected<iterator_t<R2>, Proj2>>
    constexpr safe_iterator_t<R2>
      partial_sort_copy(R1&& r, R2&& result_r, Comp comp = Comp{},
                        Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}\removed{.
The} \added{and the} type of \tcode{*result_first} shall
\changed{satisfy}{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
Places the first
\tcode{min(last - first, result_last - result_first)}
sorted elements into the range
\range{result_first}{result_first + min(last - first, result_last - result_first)}.

\pnum
\returns
The smaller of:
\tcode{result_last} or
\tcode{result_first + (last - first)}.

\pnum
\complexity
Approximately
\tcode{(last - first) * log(min(last - first, result_last - result_first))}
comparisons\added{, and exactly twice as many applications of any projections}.
\end{itemdescr}


\rSec3[is.sorted]{\tcode{is_sorted}}

\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr bool is_sorted(ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns}\added{\effects Equivalent to:} \tcode{\added{return} is_sorted_until(first, last) == last\added{;}}\removed{.}
\end{itemdescr}

\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator>
  bool is_sorted(ExecutionPolicy&& exec,
                 ForwardIterator first, ForwardIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns}\added{\effects Equivalent to:}
\begin{codeblock}
@\added{return}@ is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last) == last@\added{;}@
\end{codeblock}
\removed{.}
\end{itemdescr}

\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ForwardIterator, class Compare>
  constexpr bool is_sorted(ForwardIterator first, ForwardIterator last,
                           Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns}\added{\effects Equivalent to:} \tcode{\added{return} is_sorted_until(first, last, comp) == last\added{;}}\removed{.}
\end{itemdescr}


\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  bool is_sorted(ExecutionPolicy&& exec,
                 ForwardIterator first, ForwardIterator last,
                 Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns}\added{\effects Equivalent to:}
\begin{codeblock}
@\added{return}@ is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last@\added{;}@
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{is_sorted}}%
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
      IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
    constexpr bool is_sorted(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr bool is_sorted(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return is_sorted_until(first, last, comp, proj) == last;}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{is_sorted_until}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator
    is_sorted_until(ExecutionPolicy&& exec,
                    ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator
    is_sorted_until(ForwardIterator first, ForwardIterator last,
                    Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator
    is_sorted_until(ExecutionPolicy&& exec,
                    ForwardIterator first, ForwardIterator last,
                    Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
      IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
    constexpr I is_sorted_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr safe_iterator_t<R>
      is_sorted_until(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\returns If \tcode{(last - first) < 2}, returns
\tcode{last}. Otherwise, returns
the last iterator \tcode{i} in \crange{first}{last} for which the
range \range{first}{i} is sorted.

\pnum
\complexity Linear.
\end{itemdescr}


\rSec2[alg.nth.element]{Nth element}

\indexlibrary{\idxcode{nth_element}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                             RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  void nth_element(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                             RandomAccessIterator last,  Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  void nth_element(ExecutionPolicy&& exec,
                   RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr I
      nth_element(I first, I nth, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr safe_iterator_t<R>
      nth_element(R&& r, iterator_t<R> nth, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overloads with no parameter
named \tcode{comp}.
\end{addedblock}

\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}\removed{.
The}\added{and the} type of \tcode{*first} shall
\changed{satisfy}{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
After
\tcode{nth_element}
the element in the position pointed to by \tcode{nth}
is the element that would be
in that position if the whole range were sorted, unless \tcode{nth == last}.
Also for every iterator
\tcode{i}
in the range
\range{first}{nth}
and every iterator
\tcode{j}
in the range
\range{nth}{last}
it holds that:
\removed{\tcode{!(*j < *i)}
or
\tcode{comp(*j, *i) == false}.}
\begin{addedblock}
\begin{itemize}
\item \tcode{bool(comp(*j, *i))} is \tcode{false} for the overloads in namespace
  \tcode{std}, or
\item \tcode{bool(invoke(comp, invoke(proj, *j), invoke(proj, *i)))} is
  \tcode{false} for the overloads in namespace \tcode{ranges}.
\end{itemize}

\pnum
\returns \tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
For the overloads with no \tcode{ExecutionPolicy}, linear on average.
For the overloads with an \tcode{ExecutionPolicy}, \bigoh{N} applications of
the predicate, and \bigoh{N \log N} swaps, where $N = \tcode{last - first}$.
\end{itemdescr}


\rSec2[alg.binary.search]{Binary search}

\pnum
All of the algorithms in this subclause are versions of binary search
and assume that the sequence being searched is partitioned with respect to
an expression formed by binding the search key to an argument of the
implied or explicit comparison function \added{(and possibly projection)}.
They work on non-random access iterators minimizing the number of comparisons,
which will be logarithmic for all types of iterators.
They are especially appropriate for random access iterators,
because these algorithms do a logarithmic number of steps
through the data structure.
For non-random access iterators they execute a linear number of steps.

\rSec3[lower.bound]{\tcode{lower_bound}}

\indexlibrary{\idxcode{lower_bound}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last,
                const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr ForwardIterator
    lower_bound(ForwardIterator first, ForwardIterator last,
                const T& value, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
    constexpr I lower_bound(I first, S last, const T& value, Comp comp = Comp{},
                            Proj proj = Proj{});
  template<ForwardRange R, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr safe_iterator_t<R>
      lower_bound(R&& r, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overload with no parameter
named \tcode{comp}.
\end{addedblock}

\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expression
\removed{\tcode{e < value}
or}\added{:}
\begin{itemize}
\item \tcode{\added{bool(}comp(e, value)\added{)}}\added{,
  for the overloads in namespace \tcode{std}, or}
\item \added{\tcode{bool(invoke(comp, invoke(proj, e), value))},
  for the overloads in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\returns
The furthermost iterator
\tcode{i}
in the range
\crange{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{i}
the following corresponding conditions hold:
\removed{\tcode{*j < value}
or}
\begin{itemize}
\item \tcode{\added{bool(}comp(*j, value)\added{)} \removed{!= false}}
  \added{for the overloads in namespace \tcode{std}, or}
\item \added{\tcode{bool(invoke(comp, invoke(proj, *j), value))},
  for the overloads in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
At most
$\log_2(\tcode{last - first}) + \bigoh{1}$
comparisons \added{and applications of any projection}.
\end{itemdescr}


\rSec3[upper.bound]{\tcode{upper_bound}}

\indexlibrary{\idxcode{upper_bound}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last,
                const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr ForwardIterator
    upper_bound(ForwardIterator first, ForwardIterator last,
                const T& value, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
    constexpr I upper_bound(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
  template<ForwardRange R, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr safe_iterator_t<R>
      upper_bound(R&& r, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overload with no parameter
named \tcode{comp}.
\end{addedblock}

\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expression
\removed{\tcode{!(value < e)}
or}
\begin{itemize}
\item \tcode{!\added{bool(}comp(value, e)\added{)}}
  \added{for the overloads in namespace \tcode{std}, or}
\item \added{\tcode{!invoke(comp, value, invoke(proj, e))}
  for the overloads in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\returns
The furthermost iterator
\tcode{i}
in the range
\crange{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{i}
the following corresponding conditions hold:
\removed{\tcode{!(value < *j)}
or}
\begin{itemize}
\item \tcode{\added{!bool(}comp(value, *j)\added{)} \removed{== false}}
  \added{for the overloads in namespace \tcode{std}, or}
\item \added{\tcode{!invoke(comp, value, invoke(proj, *j))}
  for the overloads in namespace \tcode{ranges}}.
\end{itemize}

\pnum
\complexity
At most
$\log_2(\tcode{last - first}) + \bigoh{1}$
comparisons \added{and applications of any projection}.
\end{itemdescr}


\rSec3[equal.range]{\tcode{equal_range}}

\ednote{This wording incorporates the PR for
\href{https://github.com/ericniebler/stl2/issues/526}{stl2\#526}).}

\indexlibrary{\idxcode{equal_range}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first,
                ForwardIterator last, const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first,
                ForwardIterator last, const T& value,
                Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
    constexpr subrange<I>
      equal_range(I first, S last, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
  template<ForwardRange R, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr safe_subrange_t<R>
      equal_range(R&& r, const T& value, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overload with no parameter
named \tcode{comp}.
\end{addedblock}

\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expressions
\removed{\tcode{e < value}
and
\tcode{!(value < e)}
or}
\begin{itemize}
\item \tcode{\added{bool(}comp(e, value)\added{)}}
and
\tcode{!\added{bool(}comp(value, e)\added{)}}
\added{for the overloads in namespace \tcode{std}, or}
\item
\added{\tcode{invoke(comp, invoke(proj, e), value)}
and
\tcode{!invoke(comp, value, invoke(proj, e))}.
for the overloads in namespace \tcode{ranges}}.
\end{itemize}
Also, for all elements
\tcode{e}
of
\tcode{[first, last)},
\removed{\tcode{e < value}
shall imply
\tcode{!(value < e)}
or}
\tcode{\added{bool(}comp(e, value)\added{)}}
shall imply
\tcode{!\added{bool(}comp(value, e)\added{)}}
\added{for the overloads in namespace \tcode{std}}.

\pnum
\returns
\begin{itemize}
\item \added{For the overloads in namespace \tcode{std}:}
\begin{codeblock}
@\removed{make_pair(lower_bound(first, last, value),}@
          @\removed{upper_bound(first, last, value))}@
\end{codeblock}
\removed{or}
\begin{codeblock}
@\removed{make_pair(}\added{\{}@lower_bound(first, last, value, comp),
           upper_bound(first, last, value, comp)@\added{\}}\removed{)}@
\end{codeblock}

\item \added{For the overloads in namespace \tcode{ranges}:}
\begin{codeblock}
@\added{\{ranges::lower_bound(first, last, value, comp, proj),}@
 @\added{ranges::upper_bound(first, last, value, comp, proj)\}}@
\end{codeblock}
\end{itemize}

\pnum
\complexity
At most
$2 * \log_2(\tcode{last - first}) + \bigoh{1}$
comparisons \added{and applications of any projection}.
\end{itemdescr}


\rSec3[binary.search]{\tcode{binary_search}}

\indexlibrary{\idxcode{binary_search}}%
\begin{itemdecl}
template<class ForwardIterator, class T>
  constexpr bool
    binary_search(ForwardIterator first, ForwardIterator last,
                  const T& value);

template<class ForwardIterator, class T, class Compare>
  constexpr bool
    binary_search(ForwardIterator first, ForwardIterator last,
                  const T& value, Compare comp);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overload with no parameter
named \tcode{comp}.
\end{addedblock}

\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
shall be partitioned with respect to the expressions
\removed{\tcode{e < value}
and
\tcode{!(value < e)}
or}
\tcode{\added{bool(}comp(e, value)\added{)}}
and
\tcode{!\added{bool(}comp(value, e)\added{)}}.
Also, for all elements
\tcode{e}
of
\tcode{[first, last)},
\removed{\tcode{e < value}
shall imply
\tcode{!(value < e)}
or}
\tcode{\added{bool(}comp(e, value)\added{)}}
shall imply
\tcode{!\added{bool(}comp(value, e)\added{)}}.

\pnum
\returns
\tcode{true}
if \added{and only if} there is an iterator
\tcode{i}
in the range
\range{first}{last}
that satisfies the corresponding conditions:
\removed{\tcode{!(*i < value) \&\& !(value < *i)}
or}
\tcode{\added{!bool(}comp(*i, value)\added{)} \removed{== false} \&\& \added{!bool(}comp(value, *i)\added{)} \removed{== false}}.

\pnum
\complexity
At most
$\log_2(\tcode{last - first}) + \bigoh{1}$
comparisons.
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{binary_search}}%
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<I, Proj>> Comp = ranges::less<>>
    constexpr bool binary_search(I first, S last, const T& value, Comp comp = Comp{},
                                 Proj proj = Proj{});
  template<ForwardRange R, class T, class Proj = identity,
      IndirectStrictWeakOrder<const T*, projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr bool binary_search(R&& r, const T& value, Comp comp = Comp{},
                                 Proj proj = Proj{});
}
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
The elements
\tcode{e}
of
\range{first}{last}
are partitioned with respect to the expressions
\tcode{bool(invoke(comp, invoke(proj, e), value))}
and
\tcode{!invoke(comp, value, invoke(proj, e))}.

\pnum
\returns
\tcode{true}
if and only if there is an iterator
\tcode{i}
in the range
\range{first}{last}
that satisfies the corresponding conditions:
\tcode{!invoke(comp, invoke(proj, *i), value) \&\&
!invoke(comp, value, invoke(proj, *i))}.

\pnum
\complexity
At most
$\log_2(\tcode{last - first}) + \bigoh{1}$
applications of the comparison function and projection.
\end{itemdescr}
\end{addedblock}


\rSec2[alg.partitions]{Partitions}

\indexlibrary{\idxcode{is_partitioned}}%
\begin{itemdecl}
template<class InputIterator, class Predicate>
  constexpr bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  bool is_partitioned(ExecutionPolicy&& exec,
                      ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr bool is_partitioned(I first, S last, Pred pred, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr bool is_partitioned(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{$E$(i)} be
\begin{itemize}
\item \tcode{bool(pred(*i))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}

\pnum
\requires
For the overloads in namespace \tcode{std},
\tcode{$E$(first)} shall be a well-formed expression.
\end{addedblock}

\begin{removedblock}
\pnum
\requires For the overload with no \tcode{ExecutionPolicy},
\tcode{InputIterator}'s value type shall be convertible to \tcode{Predicate}'s
argument type.  For the overload with an \tcode{ExecutionPolicy},
\tcode{ForwardIterator}'s value type shall be convertible to \tcode{Predicate}'s
argument type.
\end{removedblock}

\pnum
\returns \tcode{true} if \added{and only if}
\range{first}{last} is \removed{empty or if
the elements \tcode{e} of
\range{first}{last} are} partitioned with respect to the expression
\removed{\tcode{pred(e)}} \added{\tcode{$E$(i)}}.

\pnum
\complexity Linear. At most \tcode{last - first} applications of \tcode{pred}
\added{and any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{partition}}%
\begin{itemdecl}
template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator
    partition(ForwardIterator first, ForwardIterator last, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class Predicate>
  ForwardIterator
    partition(ExecutionPolicy&& exec,
              ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<@\oldtxt{ForwardIterator}\newtxt{Permutable}@ I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    @\oldtxt{requires Permutable<I>}@
    constexpr I
      partition(I first, S last, Pred pred, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires Permutable<iterator_t<R>>
    constexpr safe_iterator_t<R>
      partition(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{$E$(j)} be
\begin{itemize}
\item \tcode{bool(pred(*j))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(pred, invoke(proj, *j)))} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\requires
\added{For the overloads in namespace \tcode{std}, \tcode{$E$(first)} shall
be a valid expression and} \tcode{ForwardIterator} shall \removed{satisfy}
\added{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}.

\pnum
\effects Places all the elements in the range \range{first}{last} that satisfy
\removed{\tcode{pred}} \added{$E$} before all the elements that
do not satisfy it.

\pnum
\returns An iterator \tcode{i} such that
\added{\tcode{$E$(j)} is \tcode{true}}
for every iterator \tcode{j} in \removed{the range} \range{first}{i}
\removed{\tcode{pred(*j) != false},}
and \added{\tcode{false}} for every iterator \removed{\tcode{k}} in
\removed{the range} \range{i}{last}\removed{, \tcode{pred(*k) == false}
is \tcode{false}}.

\pnum
\complexity Let $N = \tcode{last - first}$:
\begin{itemize}
\item For the overload\added{s} with no \tcode{ExecutionPolicy},
exactly $N$ applications of the predicate \added{and any projection}.
At most $N / 2$ swaps if \tcode{ForwardIterator} meets the
\oldconcept{BidirectionalIterator} requirements \added{for the overloads in
namespace \tcode{std} or models \libconcept{BidirectionalIterator} for the
overloads in namespace \tcode{ranges},} and at most $N$ swaps otherwise.
\item For the overload with an \tcode{ExecutionPolicy},
\bigoh{N \log N} swaps and \bigoh{N} applications of the predicate.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{stable_partition}}%
\begin{itemdecl}
template<class BidirectionalIterator, class Predicate>
  BidirectionalIterator
    stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);
template<class ExecutionPolicy, class BidirectionalIterator, class Predicate>
  BidirectionalIterator
    stable_partition(ExecutionPolicy&& exec,
                     BidirectionalIterator first, BidirectionalIterator last, Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    requires Permutable<I>
    I stable_partition(I first, S last, Pred pred, Proj proj = Proj{});
  template<BidirectionalRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires Permutable<iterator_t<R>>
    safe_iterator_t<R> stable_partition(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{$E$(j)} be
\begin{itemize}
\item \tcode{bool(pred(*j))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(pred, invoke(proj, *j)))} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{BidirectionalIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}\removed{.
The} \added{and the} type of \tcode{*first} shall \removed{satisfy}
\added{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
Places all the elements in the range
\range{first}{last}
that satisfy \removed{\tcode{pred}} \added{\tcode{$E$}} before all the
elements that do not satisfy it.

\pnum
\returns
An iterator
\tcode{i}
such that for every iterator
\tcode{j}
in the range
\range{first}{i},
\removed{\tcode{pred(*j) != false}}
\added{\tcode{$E$(j)} is \tcode{true}},
and for every iterator
\tcode{k}
in the range
\range{i}{last},
\removed{\tcode{pred(*k) == false}}
\added{\tcode{$E$(k)} is \tcode{false}}.
The relative order of the elements in both groups is preserved.

\pnum
\complexity
Let $N$ = \tcode{last - first}:
\begin{itemize}
\item For the overload\added{s} with no \tcode{ExecutionPolicy},
at most $N \log N$ swaps,
but only \bigoh{N} swaps if there is enough extra memory.
Exactly $N$ applications of the predicate \added{and any projection}.
\item For the overload with an \tcode{ExecutionPolicy},
\bigoh{N \log N} swaps and \bigoh{N} applications of the predicate.
\end{itemize}
\end{itemdescr}

\indexlibrary{\idxcode{partition_copy}}%
\begin{itemdecl}
template<class InputIterator, class OutputIterator1,
         class OutputIterator2, class Predicate>
  constexpr pair<OutputIterator1, OutputIterator2>
    partition_copy(InputIterator first, InputIterator last,
                   OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);
template<class ExecutionPolicy, class ForwardIterator, class ForwardIterator1,
         class ForwardIterator2, class Predicate>
  pair<ForwardIterator1, ForwardIterator2>
    partition_copy(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last,
                   ForwardIterator1 out_true, ForwardIterator2 out_false, Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O1, WeaklyIncrementable O2,
      class Proj = identity, IndirectUnaryPredicate<projected<I, Proj>> Pred>
    requires IndirectlyCopyable<I, O1> && IndirectlyCopyable<I, O2>
    constexpr partition_copy_result<I, O1, O2>
      partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,
                     Proj proj = Proj{});
  template<InputRange R, WeaklyIncrementable O1, WeaklyIncrementable O2,
      class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    requires IndirectlyCopyable<iterator_t<R>, O1> &&
      IndirectlyCopyable<iterator_t<R>, O2>
    constexpr partition_copy_result<safe_iterator_t<R>, O1, O2>
      partition_copy(R&& r, O1 out_true, O2 out_false, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let $E$ be
\begin{itemize}
\item \tcode{bool(pred(*i))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}

\pnum
\requires
The input range shall not overlap with either of the output ranges.
For the overloads in namespace \tcode{std},
\tcode{pred(*first)} shall be a valid expression and
the expression \tcode{*first} shall be
writable\iref{iterator.requirements.general} to
\tcode{out_true} and \tcode{out_false}.
\begin{note}
For the overload with an \tcode{ExecutionPolicy},
there may be a performance cost if \tcode{first}'s value type is not
\oldconcept{CopyConstructible}.
\end{note}
\end{addedblock}

\begin{removedblock}
\begin{itemize}
\item
For the overload with no \tcode{ExecutionPolicy}, \tcode{InputIterator}'s
value type shall be \oldconcept{CopyAssignable}\cxxiref{tab:copyassignable},
and shall be writable\iref{iterator.requirements.general} to the \tcode{out_true}
and \tcode{out_false} \tcode{OutputIterator}s, and shall be convertible to
\tcode{Predicate}'s argument type.

\item
For the overload with an \tcode{ExecutionPolicy}, \tcode{ForwardIterator}'s
value type shall be \oldconcept{CopyAssignable}, and shall be writable to the
\tcode{out_true} and \tcode{out_false} \tcode{ForwardIterator}s, and shall be
convertible to \tcode{Predicate}'s argument type.
\begin{note}
There may be a performance cost if \tcode{ForwardIterator}'s value type is not
\oldconcept{CopyConstructible}.
\end{note}

\item
For both overloads, the input range shall not overlap with either of the output ranges.
\end{itemize}
\end{removedblock}

\pnum
\effects For each iterator \tcode{i} in \range{first}{last}, copies \tcode{*i}
to the output range beginning with \tcode{out_true} if
\removed{\tcode{pred(*i)}} \added{\tcode{$E$(i)}} is \tcode{true}, or
to the output range beginning with \tcode{out_false} otherwise.

\pnum
\returns
\removed{A pair \tcode{p} such that
\tcode{p.first} is the end of the output range beginning at \tcode{out_true} and
\tcode{p.second} is the end of the output range beginning at \tcode{out_false}.}
\begin{addedblock}
Let \tcode{o1} be the end of the output range beginning at \tcode{out_true},
and \tcode{o2} the end of the output range beginning at \tcode{out_false}
Returns:
\begin{itemize}
\item \tcode{\{o1, o2\}} for the overloads in namespace \tcode{std}, or
\item \tcode{\{last, o1, o2\}} for the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity Exactly \tcode{last - first} applications of \tcode{pred}
\added{and any projection}.
\end{itemdescr}

\indexlibrary{\idxcode{partition_point}}%
\begin{itemdecl}
template<class ForwardIterator, class Predicate>
  constexpr ForwardIterator
    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
      IndirectUnaryPredicate<projected<I, Proj>> Pred>
    constexpr I partition_point(I first, S last, Pred pred, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectUnaryPredicate<projected<iterator_t<R>, Proj>> Pred>
    constexpr safe_iterator_t<R>
      partition_point(R&& r, Pred pred, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{$E$(i)} be
\begin{itemize}
\item \tcode{bool(pred(*i))} for the overload in namespace \tcode{std}, or
\item \tcode{bool(invoke(pred, invoke(proj, *i)))} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}

\pnum
\requires
The sequence \range{first}{last} shall be partitioned with respect to
the expression \tcode{$E$(i)}. For the overload in namespace \tcode{std},
\tcode{$E$(first)} shall be a valid expression.
\end{addedblock}

\pnum
\removed{\requires \tcode{ForwardIterator}'s value type shall be convertible to
\tcode{Predicate}'s argument type. The elements \tcode{e} of \range{first}{last}
shall be partitioned with respect to the expression \tcode{pred(e)}.}

\pnum
\returns
An iterator \tcode{mid} such that
\removed{\tcode{all_of(first, mid, pred)} and
\tcode{none_of(mid, last, pred)} are both \tcode{true}}
\added{\tcode{$E$(i)} is \tcode{true} for all iterators \tcode{i}
in \range{first}{mid}, and
\tcode{false} for all iterators in \range{mid}{last}}.

\pnum
\complexity \bigoh{\log(\tcode{last - first})} applications of \tcode{pred}
\added{and any projection}.
\end{itemdescr}


\begin{itemdescr}
\pnum
\returns An iterator \tcode{mid} such that \tcode{all_of(first, mid, pred, proj)} and
\tcode{none_of(mid, last, pred, proj)} are both true.
\end{itemdescr}


\rSec2[alg.merge]{Merge}

\indexlibrary{\idxcode{merge}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    merge(ExecutionPolicy&& exec,
          ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2,
          ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    merge(InputIterator1 first1, InputIterator1 last1,
          InputIterator2 first2, InputIterator2 last2,
          OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    merge(ExecutionPolicy&& exec,
          ForwardIterator1 first1, ForwardIterator1 last1,
          ForwardIterator2 first2, ForwardIterator2 last2,
          ForwardIterator result, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity,
      class Proj2 = identity>
    requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr merge_result<I1, I2, O>
      merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,
            Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, WeaklyIncrementable O, class Comp = ranges::less<>,
      class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr merge_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
      merge(R1&& r1, R2&& r2, O result,
            Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overloads with no parameter
\tcode{comp}, and let $N$ be \tcode{(last1 - first1) + (last2 - first2)}.
\end{addedblock}

\pnum
\requires The ranges \range{first1}{last1} and \range{first2}{last2} shall be
sorted with respect to \removed{\tcode{oper\-ator<} or} \tcode{comp}\added{,
and the corresponding projection \tcode{proj1} or \tcode{proj2} for
the overloads in namespace \tcode{ranges}}.
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects Copies all the elements of the two ranges \range{first1}{last1} and
\range{first2}{last2} into the range \range{result}{result_last}, where
\tcode{result_last} is
\tcode{result + \added{$N$} \removed{(last1 - first1) + (last2 - first2)}}\removed{,
such that the resulting range satisfies
\tcode{is_sorted(result, result_last)} or
\tcode{is_sorted(result, result_last, comp)}, respectively}.
\begin{addedblock}
If an element \tcode{a} precedes \tcode{b} in an input range, \tcode{a} is
copied into the output range before \tcode{b}. If \tcode{e1} is an element of
\range{first1}{last1} and \tcode{e2} of \range{first2}{last2}, \tcode{e2} is
copied into the output range before \tcode{e1} if and only if
\begin{itemize}
\item \tcode{bool(comp(e2, e1))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(comp, invoke(proj2, e2), invoke(proj1, e1)))}
  for the overloads in namespace \tcode{ranges}
\end{itemize}
is \tcode{true}.
\end{addedblock}

\pnum
\returns \removed{\tcode{result + (last1 - first1) + (last2 - first2)}.}
\begin{addedblock}
\begin{itemize}
\item \tcode{result_last} for the overloads in namespace \tcode{std}, or
\item \tcode{\{last1, last2, result_last\}} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity \removed{Let $N = \tcode{(last1 - first1) + (last2 - first2)}$:}
\begin{itemize}
\item For the overloads with no \tcode{ExecutionPolicy},
  at most $N - 1$ comparisons \added{and applications of each projection}.
\item For the overloads with an \tcode{ExecutionPolicy},
  \bigoh{N} comparisons.
\end{itemize}

\pnum
\remarks Stable\cxxiref{algorithm.stable}.
\end{itemdescr}


\indexlibrary{\idxcode{inplace_merge}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  void inplace_merge(BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last);
template<class ExecutionPolicy, class BidirectionalIterator>
  void inplace_merge(ExecutionPolicy&& exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  void inplace_merge(BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last, Compare comp);
template<class ExecutionPolicy, class BidirectionalIterator, class Compare>
  void inplace_merge(ExecutionPolicy&& exec,
                     BidirectionalIterator first,
                     BidirectionalIterator middle,
                     BidirectionalIterator last, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    I inplace_merge(I first, I middle, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<BidirectionalRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    safe_iterator_t<R>
      inplace_merge(R&& r, iterator_t<R> middle, Comp comp = Comp{},
                    Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overloads with no parameter
\tcode{comp}.
\end{addedblock}

\pnum
\requires
The ranges \range{first}{middle} and \range{middle}{last} shall be
sorted with respect to \removed{\tcode{operator<} or} \tcode{comp}\added{,
and \tcode{proj} for the overloads in namespace \tcode{ranges}}.
\added{For the overloads in namespace \tcode{std},}
\tcode{BidirectionalIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}\removed{.
The} \added{and the} type
of \tcode{*first} shall \changed{satisfy}{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
Merges two sorted consecutive ranges
\range{first}{middle}
and
\range{middle}{last},
putting the result of the merge into the range
\range{first}{last}.
The resulting range will be in non-decreasing order;
that is, for every iterator
\tcode{i}
in
\range{first}{last}
other than
\tcode{first},
the condition
\removed{\tcode{*i < *(i - 1)}
or, respectively,}
\begin{itemize}
\item \tcode{\added{bool(}comp(*i, *(i - 1))\added{)}}
  \added{for the overloads in namespace \tcode{std}, or}
\item \added{\tcode{bool(invoke(comp, invoke(proj, *i), invoke(proj, *(i - 1))))}
  for the overloads in namespace \tcode{ranges}}
\end{itemize}
will be \tcode{false}.

\begin{addedblock}
\pnum
\returns \tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity Let $N = \tcode{last - first}$:
\begin{itemize}
\item For the overloads with no \tcode{ExecutionPolicy}, if enough additional
memory is available, exactly $N - 1$ comparisons.
\item \removed{For the overloads with no \tcode{ExecutionPolicy} if no additional
memory is available, \bigoh{N \log N} comparisons.}
\item \added{Otherwise} \removed{For the overloads with an \tcode{ExecutionPolicy}}, \bigoh{N \log N} comparisons.
\end{itemize}
\added{In any case, exactly twice as many applications of any projection as
the number of comparisons.}

\pnum
\remarks Stable\cxxiref{algorithm.stable}.
\end{itemdescr}


\rSec2[alg.set.operations]{Set operations on sorted structures}

\pnum
This subclause defines all the basic set operations on sorted structures.
They also work with
\tcode{multiset}s~(\cxxref{multiset})
containing multiple copies of equivalent elements.
The semantics of the set operations are generalized to
\tcode{multiset}s
in a standard way by defining
\tcode{set_union()}
to contain the maximum number of occurrences of every element,
\tcode{set_intersection()}
to contain the minimum, and so on.

\rSec3[includes]{\tcode{includes}}

\ednote{This wording includes the proposed resolution for
\href{https://wg21.link/lwg3115}{LWG 3115}.}

\indexlibrary{\idxcode{includes}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool includes(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>
  constexpr bool includes(InputIterator1 first1, InputIterator1 last1,
                          InputIterator2 first2, InputIterator2 last2,
                          Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class Compare>
  bool includes(ExecutionPolicy&& exec,
                ForwardIterator1 first1, ForwardIterator1 last1,
                ForwardIterator2 first2, ForwardIterator2 last2,
                Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectStrictWeakOrder<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less<>>
    constexpr bool includes(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = Comp{},
                            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, class Proj1 = identity,
      class Proj2 = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R1>, Proj1>,
        projected<iterator_t<R2>, Proj2>> Comp = ranges::less<>>
    constexpr bool includes(R1&& r1, R2&& r2, Comp comp = Comp{},
                            Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overloads with no parameter
\tcode{comp}.

\pnum
\requires
The ranges \range{first1}{last1} and \range{first2}{last2} shall be
sorted with respect to \tcode{comp},
and \tcode{proj} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\returns
\tcode{true}
if \added{and only if} \range{first2}{last2} is \removed{empty or
if every element in the range
\range{first2}{last2}
is contained in the range
\range{first1}{last1}.
Returns \tcode{false} otherwise.}
\begin{addedblock}
a subsequence of \range{first1}{last1}.
\begin{note}
A sequence $S$ is a subsequence of another sequence $T$ if $S$ can be obtained
from $T$ by removing some, all, or none of $T$'s elements and keeping the
remaining elements in the same order.
\end{note}
\end{addedblock}

\pnum
\complexity
At most
\tcode{2 * (last1 - first1)}
comparisons \added{and applications of any projections}.
\end{itemdescr}


\rSec3[set.union]{\tcode{set_union}}

\indexlibrary{\idxcode{set_union}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_union(InputIterator1 first1, InputIterator1 last1,
              InputIterator2 first2, InputIterator2 last2,
              OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_union(ExecutionPolicy&& exec,
              ForwardIterator1 first1, ForwardIterator1 last1,
              ForwardIterator2 first2, ForwardIterator2 last2,
              ForwardIterator result, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_union_result<I1, I2, O>
      set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = Comp{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, WeaklyIncrementable O,
      class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_union_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
      set_union(R1&& r1, R2&& r2, O result, Comp comp = Comp{},
                Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{The ranges \range{first1}{last1} and \range{first2}{last2} shall be
sorted with respect to \tcode{comp}, and the corresponding projection
\tcode{proj1} or \tcode{proj2} for the overloads in namespace \tcode{ranges}}.
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Constructs a sorted union of the elements from the two ranges;
that is, the set of elements that are present in one or both of the ranges.

\pnum
\returns
\removed{T}\added{Let \tcode{result_last} be t}he end of the
constructed range.
\begin{addedblock}
Returns
\begin{itemize}
\item \tcode{result_last} for the overloads in namespace \tcode{std}, or
\item \tcode{\{last1, last2, result_last\}} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons \added{and applications of any projections}.

\pnum
\remarks \added{Stable\cxxiref{algorithm.stable}.}
If \range{first1}{last1} contains $m$ elements that are equivalent to
each other and \range{first2}{last2} contains $n$ elements that are equivalent
to them, then all $m$ elements from the first range shall be copied to the output
range, in order, and then \added{the final} $\max(n - m, 0)$
elements from the second range shall be copied to the output range, in order.
\end{itemdescr}


\rSec3[set.intersection]{\tcode{set_intersection}}

\indexlibrary{\idxcode{set_intersection}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_intersection(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_intersection(InputIterator1 first1, InputIterator1 last1,
                     InputIterator2 first2, InputIterator2 last2,
                     OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_intersection(ExecutionPolicy&& exec,
                     ForwardIterator1 first1, ForwardIterator1 last1,
                     ForwardIterator2 first2, ForwardIterator2 last2,
                     ForwardIterator result, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_intersection_result<I1, I2, O>
      set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, WeaklyIncrementable O,
      class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_intersection_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
      set_intersection(R1&& r1, R2&& r2, O result,
                       Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{The ranges \range{first1}{last1} and \range{first2}{last2} shall be
sorted with respect to \tcode{comp}, and the corresponding projection
\tcode{proj1} or \tcode{proj2} for the overloads in namespace \tcode{ranges}}.
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Constructs a sorted intersection of the elements from the two ranges;
that is, the set of elements that are present in both of the ranges.

\pnum
\returns
\removed{T}\added{Let \tcode{result_last} be t}he end of the
constructed range.
\begin{addedblock}
Returns
\begin{itemize}
\item \tcode{result_last} for the overloads in namespace \tcode{std}, or
\item \tcode{\{last1, last2, result_last\}} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons \added{and applications of any projections}.

\pnum
\remarks \added{Stable\cxxiref{algorithm.stable}.}
If \range{first1}{last1} contains $m$ elements that are equivalent to
each other and \range{first2}{last2} contains $n$ elements that are equivalent
to them, the first $\min(m, n)$ elements shall be copied from the first range
to the output range, in order.
\end{itemdescr}


\rSec3[set.difference]{\tcode{set_difference}}

\indexlibrary{\idxcode{set_difference}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_difference(InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, InputIterator2 last2,
                   OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_difference(ExecutionPolicy&& exec,
                   ForwardIterator1 first1, ForwardIterator1 last1,
                   ForwardIterator2 first2, ForwardIterator2 last2,
                   ForwardIterator result, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_difference_result<I1, O>
      set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, WeaklyIncrementable O,
      class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_difference_result<safe_iterator_t<R1>, O>
      set_difference(R1&& r1, R2&& r2, O result,
                     Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{The ranges \range{first1}{last1} and \range{first2}{last2} shall be
sorted with respect to \tcode{comp}, and the corresponding projection
\tcode{proj1} or \tcode{proj2} for the overloads in namespace \tcode{ranges}}.
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Copies the elements of the range
\range{first1}{last1}
which are not present in the range
\range{first2}{last2}
to the range beginning at
\tcode{result}.
The elements in the constructed range are sorted.

\pnum
\returns
\removed{T}\added{Let \tcode{result_last} be t}he end of the
constructed range.
\begin{addedblock}
Returns
\begin{itemize}
\item \tcode{result_last} for the overloads in namespace \tcode{std}, or
\item \tcode{\{last1, result_last\}} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons \added{and applications of any projections}.

\pnum
\remarks
If
\range{first1}{last1}
contains $m$
elements that are equivalent to each other and
\range{first2}{last2}
contains $n$
elements that are equivalent to them, the last
$\max(m - n, 0)$
elements from
\range{first1}{last1}
shall be copied to the output range.
\end{itemdescr}


\rSec3[set.symmetric.difference]{\tcode{set_symmetric_difference}}

\indexlibrary{\idxcode{set_symmetric_difference}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2,
         class OutputIterator>
  constexpr OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator>
  ForwardIterator
    set_symmetric_difference(ExecutionPolicy&& exec,
                             ForwardIterator1 first1, ForwardIterator1 last1,
                             ForwardIterator2 first2, ForwardIterator2 last2,
                             ForwardIterator result);

template<class InputIterator1, class InputIterator2,
         class OutputIterator, class Compare>
  constexpr OutputIterator
    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                             InputIterator2 first2, InputIterator2 last2,
                             OutputIterator result, Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class ForwardIterator, class Compare>
  ForwardIterator
    set_symmetric_difference(ExecutionPolicy&& exec,
                             ForwardIterator1 first1, ForwardIterator1 last1,
                             ForwardIterator2 first2, ForwardIterator2 last2,
                             ForwardIterator result, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      WeaklyIncrementable O, class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<I1, I2, O, Comp, Proj1, Proj2>
    constexpr set_symmetric_difference_result<I1, I2, O>
      set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,
                               Comp comp = Comp{}, Proj1 proj1 = Proj1{},
                               Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, WeaklyIncrementable O,
      class Comp = ranges::less<>, class Proj1 = identity, class Proj2 = identity>
    requires Mergeable<iterator_t<R1>, iterator_t<R2>, O, Comp, Proj1, Proj2>
    constexpr set_symmetric_difference_result<safe_iterator_t<R1>, safe_iterator_t<R2>, O>
      set_symmetric_difference(R1&& r1, R2&& r2, O result, Comp comp = Comp{},
                               Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{The ranges \range{first1}{last1} and \range{first2}{last2} shall be
sorted with respect to \tcode{comp}, and the corresponding projection
\tcode{proj1} or \tcode{proj2} for the overloads in namespace \tcode{ranges}}.
The resulting range shall not overlap with either of the original ranges.

\pnum
\effects
Copies the elements of the range
\range{first1}{last1}
that are not present in the range
\range{first2}{last2},
and the elements of the range
\range{first2}{last2}
that are not present in the range
\range{first1}{last1}
to the range beginning at
\tcode{result}.
The elements in the constructed range are sorted.

\pnum
\returns
\removed{T}\added{Let \tcode{result_last} be t}he end of the
constructed range.
\begin{addedblock}
Returns
\begin{itemize}
\item \tcode{result_last} for the overloads in namespace \tcode{std}, or
\item \tcode{\{last1, last2, result_last\}} for the overloads in
  namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\complexity
At most
\tcode{2 * ((last1 - first1) + (last2 - first2)) - 1}
comparisons \added{and applications of any projections}.

\pnum
\remarks
If \range{first1}{last1} contains $m$ elements that are equivalent to each other and
\range{first2}{last2} contains $n$ elements that are equivalent to them, then
$|m - n|$ of those elements shall be copied to the output range: the last
$m - n$ of these elements from \range{first1}{last1} if $m > n$, and the last
$n - m$ of these elements from \range{first2}{last2} if $m < n$.
\end{itemdescr}


\rSec2[alg.heap.operations]{Heap operations}

[...]

\rSec3[push.heap]{\tcode{push_heap}}

\indexlibrary{\idxcode{push_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr I
      push_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr safe_iterator_t<R>
      push_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
The range
\range{first}{last - 1}
shall be a valid heap.
\removed{T}\added{For the overloads in namespace \tcode{std}, t}he type of
\tcode{*first} shall \changed{satisfy}{meet}
the \oldconcept{MoveConstructible} requirements\cxxiref{tab:moveconstructible}
and the \oldconcept{MoveAssignable} requirements\cxxiref{tab:moveassignable}.

\pnum
\effects
Places the value in the location
\tcode{last - 1}
into the resulting heap
\range{first}{last}.

\begin{addedblock}
\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
At most
$\log(\tcode{last - first})$
comparisons \added{and twice as many applications of any projection}.
\end{itemdescr}


\rSec3[pop.heap]{\tcode{pop_heap}}

\indexlibrary{\idxcode{pop_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                          Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr I
      pop_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr safe_iterator_t<R>
      pop_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
The range
\range{first}{last}
shall be a valid non-empty heap.
\added{For the overloads in namespace \tcode{std},}
\tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}\removed{.
The} \added{and the} type
of \tcode{*first} shall \changed{satisfy}{meet} the
\oldconcept{MoveConstructible}\cxxiref{tab:moveconstructible} and
\oldconcept{MoveAssignable}\cxxiref{tab:moveassignable} requirements.

\pnum
\effects
Swaps the value in the location \tcode{first}
with the value in the location
\tcode{last - 1}
and makes
\range{first}{last - 1}
into a heap.

\begin{addedblock}
\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
At most
$2 \log(\tcode{last - first})$
comparisons \added{and twice as many applications of any projection}.
\end{itemdescr}


\rSec3[make.heap]{\tcode{make_heap}}

\indexlibrary{\idxcode{make_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr I
      make_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr safe_iterator_t<R>
      make_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std}, t}\removed{T}he type of
\tcode{*first} shall \changed{satisfy}{meet}
the \oldconcept{MoveConstructible} requirements\cxxiref{tab:moveconstructible}
and the \oldconcept{MoveAssignable} requirements\cxxiref{tab:moveassignable}.

\pnum
\effects
Constructs a heap out of the range
\range{first}{last}.

\begin{addedblock}
\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
At most
$3(\tcode{last - first})$
comparisons \added{and twice as many applications of any projection}.
\end{itemdescr}


\rSec3[sort.heap]{\tcode{sort_heap}}

\indexlibrary{\idxcode{sort_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                           Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr I
      sort_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Comp = ranges::less<>, class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr safe_iterator_t<R>
      sort_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires The range \range{first}{last} shall be a valid heap.
\added{For the overloads in namespace \tcode{std}, }
\tcode{RandomAccessIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements~(\cxxref{swappable.requirements})\removed{.
The} \added{and the} type
of \tcode{*first} shall \changed{satisfy}{meet} the
\oldconcept{MoveConstructible} (\cxxref{tab:moveconstructible}) and
\oldconcept{MoveAssignable} (\cxxref{tab:moveassignable}) requirements.

\pnum
\effects
Sorts elements in the heap
\range{first}{last}.

\begin{addedblock}
\pnum
\returns
\tcode{last} for the overloads in namespace \tcode{ranges}.
\end{addedblock}

\pnum
\complexity
At most $2N \log N$
comparisons, where
$N = \tcode{last - first}$\added{,
and exactly twice as many applications of any projection}.
\end{itemdescr}


\rSec3[is.heap]{\tcode{is_heap}}

\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns} \added{\effects Equivalent to:}
\tcode{\added{return} is_heap_until(first, last) == last\added{;}}\removed{.}
\end{itemdescr}

\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class ExecutionPolicy, class RandomAccessIterator>
  bool is_heap(ExecutionPolicy&& exec,
               RandomAccessIterator first, RandomAccessIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns} \added{\effects Equivalent to:}
\begin{codeblock}
@\added{return}@ is_heap_until(std::forward<ExecutionPolicy>(exec), first, last) == last@\added{;}\removed{.}@
\end{codeblock}
\end{itemdescr}

\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class RandomAccessIterator, class Compare>
  constexpr bool is_heap(RandomAccessIterator first, RandomAccessIterator last,
                         Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns} \added{\effects Equivalent to:}
\tcode{\added{return} is_heap_until(first, last, comp) == last\added{;}}\removed{.}
\end{itemdescr}

\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  bool is_heap(ExecutionPolicy&& exec,
               RandomAccessIterator first, RandomAccessIterator last,
               Compare comp);
\end{itemdecl}

\begin{itemdescr}
\pnum
\removed{\returns} \added{\effects Equivalent to:}
\begin{codeblock}
@\added{return}@ is_heap_until(std::forward<ExecutionPolicy>(exec), first, last, comp) == last@\added{;}@
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibrary{\idxcode{is_heap}}%
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
      IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
    constexpr bool is_heap(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr bool is_heap(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return ranges::is_heap_until(first, last, comp, proj) == last;}
\end{itemdescr}
\end{addedblock}

\indexlibrary{\idxcode{is_heap_until}}%
\begin{itemdecl}
template<class RandomAccessIterator>
  constexpr RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessIterator last);
template<class ExecutionPolicy, class RandomAccessIterator>
  RandomAccessIterator
    is_heap_until(ExecutionPolicy&& exec,
                  RandomAccessIterator first, RandomAccessIterator last);

template<class RandomAccessIterator, class Compare>
  constexpr RandomAccessIterator
    is_heap_until(RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);
template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
  RandomAccessIterator
    is_heap_until(ExecutionPolicy&& exec,
                  RandomAccessIterator first, RandomAccessIterator last,
                  Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<RandomAccessIterator I, Sentinel<I> S, class Proj = identity,
      IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
    constexpr I is_heap_until(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<RandomAccessRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr safe_iterator_t<R>
      is_heap_until(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\returns If \tcode{(last - first) < 2}, returns
\tcode{last}. Otherwise, returns
the last iterator \tcode{i} in \crange{first}{last} for which the
range \range{first}{i} is a heap.

\pnum
\complexity Linear.
\end{itemdescr}


\rSec2[alg.min.max]{Minimum and maximum}

\indexlibrary{\idxcode{min}}%
\begin{itemdecl}
template<class T> constexpr const T& min(const T& a, const T& b);
template<class T, class Compare>
  constexpr const T& min(const T& a, const T& b, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<class T, class Proj = identity,
      IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
    constexpr const T& min(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
For the first form, type \tcode{T} shall be
\oldconcept{LessThanComparable}\cxxiref{tab:lessthancomparable}.

\pnum
\returns
The smaller value.

\pnum
\remarks
Returns the first argument when the arguments are equivalent.

\pnum
\complexity
Exactly one comparison \added{and two applications of any projection}.
\end{itemdescr}

\indexlibrary{\idxcode{min}}%
\begin{itemdecl}
template<class T>
  constexpr T min(initializer_list<T> @\changed{t}{r}@);
template<class T, class Compare>
  constexpr T min(initializer_list<T> @\changed{t}{r}@, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<Copyable T, class Proj = identity,
      IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
    constexpr T min(initializer_list<T> r, Comp comp = Comp{}, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    requires Copyable<iter_value_t<iterator_t<R>>>
    constexpr iter_value_t<iterator_t<R>>
      min(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{\tcode{ranges::distance(r)) > 0}. For the overloads in namespace \tcode{std},}
\tcode{T} shall be \oldconcept{CopyConstructible} \removed{and \tcode{t.size() > 0}}.
For the first form, type \tcode{T} shall be \oldconcept{LessThanComparable}.

\pnum
\returns The smallest value in the \removed{initializer list}
\added{input range}.

\pnum
\remarks Returns a copy of the leftmost \removed{argument} \added{element} when several \removed{argument} \added{element}s are equivalent to the smallest.

\pnum
\complexity
Exactly \tcode{\removed{t.size()}\added{ranges::distance(r)} - 1} comparisons
\added{and twice as many applications of any projection}.
\end{itemdescr}

\indexlibrary{\idxcode{max}}%
\begin{itemdecl}
template<class T> constexpr const T& max(const T& a, const T& b);
template<class T, class Compare>
  constexpr const T& max(const T& a, const T& b, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<class T, class Proj = identity,
      IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
    constexpr const T& max(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
For the first form, type \tcode{T} shall be
\oldconcept{LessThanComparable}\cxxiref{tab:lessthancomparable}.

\pnum
\returns The larger value.

\pnum
\remarks Returns the first argument when the arguments are equivalent.

\pnum
\complexity Exactly one comparison \added{and two applications of any projection}.
\end{itemdescr}

\indexlibrary{\idxcode{max}}%
\begin{itemdecl}
template<class T>
  constexpr T max(initializer_list<T> @\changed{t}{r}@);
template<class T, class Compare>
  constexpr T max(initializer_list<T> @\changed{t}{r}@, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<Copyable T, class Proj = identity,
      IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
    constexpr T max(initializer_list<T> r, Comp comp = Comp{}, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    requires Copyable<iter_value_t<iterator_t<R>>>
    constexpr iter_value_t<iterator_t<R>>
      max(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{\tcode{ranges::distance(r) > 0}.
For the overloads in namespace \tcode{std}, }
\tcode{T} shall be \oldconcept{CopyConstructible} \removed{and \tcode{t.size() > 0}}.
For the first form, type \tcode{T} shall be \oldconcept{LessThanComparable}.

\pnum
\returns The largest value in the \removed{initializer list} \added{input range}.

\pnum
\remarks Returns a copy of the leftmost \removed{argument} \added{element} when several \removed{argument} \added{element}s are equivalent to the largest.

\pnum
\complexity
Exactly \tcode{\removed{t.size()} \added{ranges::distance(r)} - 1} comparisons
\added{and twice as many applications of any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{minmax}}%
\begin{itemdecl}
template<class T> constexpr pair<const T&, const T&> minmax(const T& a, const T& b);
template<class T, class Compare>
  constexpr pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<class T, class Proj = identity,
      IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
    constexpr minmax_result<const T&>
      minmax(const T& a, const T& b, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
For the first form, type \tcode{T} shall be
\oldconcept{LessThanComparable}\cxxiref{tab:lessthancomparable}.

\pnum
\returns
\added{Let \tcode{X} be the return type of the overload in question. Returns}
\tcode{\removed{pair<const T\&, const T\&>(}\added{X\{}b, a\added{\}}\removed{)}} if \tcode{b} is smaller
than \tcode{a}, and
\tcode{\removed{pair<const T\&, const T\&>(}\added{X\{}a, b\added{\}}\removed{)}} otherwise.

\begin{removedblock}
\pnum
\remarks
Returns \tcode{pair<const T\&, const T\&>(a, b)} when the arguments are equivalent.
\end{removedblock}

\pnum
\complexity
Exactly one comparison \added{and two applications of any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{minmax}}%
\begin{itemdecl}
template<class T>
  constexpr pair<T, T> minmax(initializer_list<T> @\changed{t}{r}@);
template<class T, class Compare>
  constexpr pair<T, T> minmax(initializer_list<T> @\changed{t}{r}@, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<Copyable T, class Proj = identity,
      IndirectStrictWeakOrder<projected<const T*, Proj>> Comp = ranges::less<>>
    constexpr minmax_result<T>
      minmax(initializer_list<T> r, Comp comp = Comp{}, Proj proj = Proj{});
  template<InputRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    requires Copyable<iter_value_t<iterator_t<R>>>
    constexpr minmax_result<iter_value_t<iterator_t<R>>>
      minmax(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{\tcode{ranges::distance(r) > 0}. For the overloads in namespace
\tcode{std}, } \tcode{T} shall be \oldconcept{CopyConstructible} \removed{and \tcode{t.size() > 0}}.
For the first form, type \tcode{T} shall be \oldconcept{LessThanComparable}.

\pnum
\returns \added{Let \tcode{X} be the return type of the overload in question.
Returns}
\tcode{\removed{pair<T, T>(}\added{X\{}x, y\added{\}}\removed{)}},
where \tcode{x} \removed{has} \added{is a copy of the leftmost element
with} the smallest \added{value} and \tcode{y} \removed{has} \added{a
copy of the rightmost element with} the
largest value in the \removed{initializer list} \added{input range}.

\begin{removedblock}
\pnum
\remarks \tcode{x} is a copy of the leftmost argument when several arguments are equivalent to
the smallest. \tcode{y} is a copy of the rightmost argument when several arguments are
equivalent to the largest.
\end{removedblock}

\pnum
\complexity At most
$(3/2)\tcode{\removed{t.size()}\added{ranges::distance(r)}}$ applications of
the corresponding predicate
\added{and twice as many applications of any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{min_element}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last);

template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator min_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                        Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator min_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last,
                              Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
      IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
    constexpr I min_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr safe_iterator_t<R>
      min_element(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overloads with no parameter
\tcode{comp}, and let \tcode{$E$(x, y)} be
\begin{itemize}
\item \tcode{bool(comp(*x, *y))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(comp, invoke(proj, *x), invoke(proj, *y)))} for
  the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\returns
The first iterator
\tcode{i}
in the range
\range{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{last}
\added{\tcode{$E$(j, i)} is \tcode{false}.}
\removed{the following corresponding conditions hold:
\tcode{!(*j < *i)}
or
\tcode{comp(*j, *i) == false}.}
Returns
\tcode{last}
if
\tcode{first == last}.

\pnum
\complexity
Exactly
$\max(\tcode{last - first - 1}, 0)$
\removed{applications of the corresponding} comparisons
\added{and twice as many applications of any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{max_element}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  ForwardIterator max_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                        Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  ForwardIterator max_element(ExecutionPolicy&& exec,
                              ForwardIterator first, ForwardIterator last,
                              Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
      IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
    constexpr I max_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr safe_iterator_t<R>
      max_element(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\begin{addedblock}
\pnum
Let \tcode{comp} be \tcode{std::less<>\{\}} for the overloads with no parameter
\tcode{comp}, and let \tcode{$E$(x, y)} be
\begin{itemize}
\item \tcode{bool(comp(*x, *y))} for the overloads in namespace \tcode{std}, or
\item \tcode{bool(invoke(comp, invoke(proj, *x), invoke(proj, *y)))} for
  the overloads in namespace \tcode{ranges}.
\end{itemize}
\end{addedblock}

\pnum
\returns
The first iterator
\tcode{i}
in the range
\range{first}{last}
such that for every iterator
\tcode{j}
in the range
\range{first}{last}
\added{\tcode{$E$(i, j)} is \tcode{false}.}
\removed{the following corresponding conditions hold:
\tcode{!(*i < *j)}
or
\tcode{comp(*i, *j) == false}.}
Returns
\tcode{last}
if
\tcode{first == last}.

\pnum
\complexity
Exactly
$\max(\tcode{last - first - 1}, 0)$
\removed{applications of the corresponding} comparisons
\added{and twice as many applications of any projection}.
\end{itemdescr}


\indexlibrary{\idxcode{minmax_element}}%
\begin{itemdecl}
template<class ForwardIterator>
  constexpr pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last);
template<class ExecutionPolicy, class ForwardIterator>
  pair<ForwardIterator, ForwardIterator>
    minmax_element(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last);

template<class ForwardIterator, class Compare>
  constexpr pair<ForwardIterator, ForwardIterator>
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);
template<class ExecutionPolicy, class ForwardIterator, class Compare>
  pair<ForwardIterator, ForwardIterator>
    minmax_element(ExecutionPolicy&& exec,
                   ForwardIterator first, ForwardIterator last, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<ForwardIterator I, Sentinel<I> S, class Proj = identity,
      IndirectStrictWeakOrder<projected<I, Proj>> Comp = ranges::less<>>
    constexpr minmax_result<I>
      minmax_element(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<ForwardRange R, class Proj = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R>, Proj>> Comp = ranges::less<>>
    constexpr minmax_result<safe_iterator_t<R>>
      minmax_element(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\returns \added{Let \tcode{X} be the return type of the overload in question.
Returns}
\tcode{\removed{make_pair(}\added{X\{}first, first\added{\}}\removed{)}}
if \range{first}{last} is empty, otherwise
\tcode{\removed{make_pair(}\added{X\{}m, M\added{\}}\removed{)}}, where \tcode{m} is
the first iterator in \range{first}{last} such that no iterator in the range refers
to a smaller element, and where \tcode{M} is the last iterator\footnote{This behavior
intentionally differs from \tcode{max_element()}.}
in \range{first}{last} such that no iterator in the range refers to a larger element.

\pnum
\complexity \added{Let $N$ be \tcode{last - first}.}
At most
$\max(\bigl\lfloor{\frac{3}{2}} (N-1)\bigr\rfloor, 0)$
\added{comparisons and twice as many applications of any projection.}
\removed{applications of the corresponding predicate, where $N$ is \tcode{last - first}.}
\end{itemdescr}


\rSec2[alg.clamp]{Bounded value}

[...]

\rSec2[alg.lex.comparison]{Lexicographical comparison}

\indexlibrary{\idxcode{lexicographical_compare}}%
\begin{itemdecl}
template<class InputIterator1, class InputIterator2>
  constexpr bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
  bool
    lexicographical_compare(ExecutionPolicy&& exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2);

template<class InputIterator1, class InputIterator2, class Compare>
  constexpr bool
    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,
                            InputIterator2 first2, InputIterator2 last2,
                            Compare comp);
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class Compare>
  bool
    lexicographical_compare(ExecutionPolicy&& exec,
                            ForwardIterator1 first1, ForwardIterator1 last1,
                            ForwardIterator2 first2, ForwardIterator2 last2,
                            Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
      class Proj1 = identity, class Proj2 = identity,
      IndirectStrictWeakOrder<projected<I1, Proj1>, projected<I2, Proj2>> Comp = ranges::less<>>
    constexpr bool
      lexicographical_compare(I1 first1, S1 last1, I2 first2, S2 last2,
                              Comp comp = Comp{}, Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
  template<InputRange R1, InputRange R2, class Proj1 = identity,
      class Proj2 = identity,
      IndirectStrictWeakOrder<projected<iterator_t<R1>, Proj1>,
        projected<iterator_t<R2>, Proj2>> Comp = ranges::less<>>
    constexpr bool
      lexicographical_compare(R1&& r1, R2&& r2, Comp comp = Comp{},
                              Proj1 proj1 = Proj1{}, Proj2 proj2 = Proj2{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\returns
\tcode{true}
if \added{and only if} the sequence of elements defined by the range
\range{first1}{last1}
is lexicographically less than the sequence of elements defined by the range
\range{first2}{last2} \removed{and
\tcode{false}
otherwise}.

\pnum
\complexity
At most
$2 \min(\tcode{last1 - first1}, \ \tcode{last2 - first2})$
applications of the corresponding comparison \added{and any projections}.

\pnum
\remarks
If two sequences have the same number of elements and their corresponding
elements (if any) are equivalent, then neither sequence is lexicographically
less than the other.
If one sequence is a prefix of the other, then the shorter sequence is
lexicographically less than the longer sequence.
Otherwise, the lexicographical comparison of the sequences yields the same
result as the comparison of the first corresponding pair of
elements that are not equivalent.

\pnum
\begin{example}
\added{Let \tcode{comp} be \tcode{std::less<>\{\}} for the overloads with
no parameter \tcode{comp}, and let \tcode{proj1} and \tcode{proj2} be
\tcode{std::identity\{\}} for the overloads with no parameters \tcode{proj1} and
\tcode{proj2}.}
The following sample implementation satisfies these requirements:
\begin{codeblock}
for ( ; first1 != last1 && first2 != last2 ; ++first1, (void) ++first2) {
  @\removed{if (*first1 < *first2) return true;}@
  @\removed{if (*first2 < *first1) return false;}@
  @\added{if (invoke(comp, invoke(proj1, *first1), invoke(proj2, *first2))) return true;}@
  @\added{if (invoke(comp, invoke(proj2, *first2), invoke(proj1, *first1))) return false;}@
}
return first1 == last1 && first2 != last2;
\end{codeblock}
\end{example}

\pnum
\begin{note}
An empty sequence is lexicographically less than any non-empty sequence, but
not less than any empty sequence.
\end{note}
\end{itemdescr}


\rSec2[alg.3way]{Three-way comparison algorithms}

[...]

\rSec2[alg.permutation.generators]{Permutation generators}

\indexlibrary{\idxcode{next_permutation}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  constexpr bool next_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr bool
      next_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<BidirectionalRange R, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr bool
      next_permutation(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{BidirectionalIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}.

\pnum
\effects
Takes a sequence defined by the range
\range{first}{last}
and transforms it into the next permutation.
The next permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect to
\tcode{operator<}
or \tcode{comp} \added{(and \tcode{proj}, if present)}.

\pnum
\returns
\tcode{true}
if such a permutation exists.
Otherwise, it transforms the sequence into the smallest permutation,
that is, the ascendingly sorted one, and returns
\tcode{false}.

\pnum
\complexity
At most
\tcode{(last - first) / 2}
swaps.
\end{itemdescr}


\indexlibrary{\idxcode{prev_permutation}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last);

template<class BidirectionalIterator, class Compare>
  constexpr bool prev_permutation(BidirectionalIterator first,
                                  BidirectionalIterator last, Compare comp);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
namespace ranges {
  template<BidirectionalIterator I, Sentinel<I> S, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<I, Comp, Proj>
    constexpr bool
      prev_permutation(I first, S last, Comp comp = Comp{}, Proj proj = Proj{});
  template<BidirectionalRange R, class Comp = ranges::less<>,
      class Proj = identity>
    requires Sortable<iterator_t<R>, Comp, Proj>
    constexpr bool
      prev_permutation(R&& r, Comp comp = Comp{}, Proj proj = Proj{});
}
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
\pnum
\requires
\added{For the overloads in namespace \tcode{std},}
\tcode{BidirectionalIterator} shall \changed{satisfy}{meet} the
\oldconcept{ValueSwappable} requirements\cxxiref{swappable.requirements}.

\pnum
\effects
Takes a sequence defined by the range
\range{first}{last}
and transforms it into the previous permutation.
The previous permutation is found by assuming that the set of all permutations is
lexicographically sorted with respect to
\tcode{operator<}
or \tcode{comp} \added{(and \tcode{proj}, if present)}.

\pnum
\returns
\tcode{true}
if such a permutation exists.
Otherwise, it transforms the sequence into the largest permutation,
that is, the descendingly sorted one, and returns
\tcode{false}.

\pnum
\complexity
At most
\tcode{(last - first) / 2}
swaps.
\end{itemdescr}

[...]
