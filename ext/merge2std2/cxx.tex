% Define section from the C++ standard that can be indexed
% using its dotted identifer. That is:
%
%  \cxxsec{basic.def.odr}{6.2}
%
% This is used to make references to sections of the C++ Standard
% that are not labeled within this document.
\newcommand{\cxxsec}[2]{%
  \expandafter\def\csname #1 \endcsname{#2}%
}

% Generate a reference to the section with the given id. This
% expands to the full chapter/section/subsection number declared
% by \cxxsec. For example:
%
%  \cxxref{basic.def.odr}
%
% Expands to the string 3.2.
\newcommand{\stdcxxref}[1]{%
  \csname #1 \endcsname%
}

\newcommand{\cxxref}[1]{%
  \stdcxxref{#1}%
}

\newcommand{\tsref}[1]{%
  ISO/IEC TS 21425:2017 \S\stdcxxref{#1}%
}

\cxxsec{intro.compliance}{4.1}

\cxxsec{lex.phases}{2.2}
\cxxsec{lex.key}{2.12}

\cxxsec{basic.def.odr}{6.2}
\cxxsec{basic.scope.namespace}{6.3.6}
\cxxsec{basic.lookup}{6.4}
\cxxsec{basic.lookup.unqual}{6.4.1}
\cxxsec{basic.lookup.argdep}{6.4.2}
\cxxsec{basic.lookup.classref}{6.4.5}
\cxxsec{basic.link}{6.5}
\cxxsec{intro.execution}{6.8.1}
\cxxsec{intro.multithread}{6.8.2}
\cxxsec{basic.types}{6.7}
\cxxsec{basic.fundamental}{6.7.1}
\cxxsec{basic.compound}{6.7.2}
\cxxsec{basic.type.qualifier}{6.7.3}

\cxxsec{conv}{7}
\cxxsec{conv.array}{7.2}
\cxxsec{conv.integral}{7.8}

\cxxsec{expr}{8}
\cxxsec{basic.lval}{8.2.1}
\cxxsec{expr.prim}{8.4}
\cxxsec{expr.prim.lambda}{8.4.5}
\cxxsec{expr.prim.fold}{8.4.6}
\cxxsec{expr.prim.req}{8.4.7}
\cxxsec{expr.call}{8.5.1.2}
\cxxsec{expr.typeid}{8.5.1.8}
\cxxsec{expr.unary}{8.5.2}
\cxxsec{expr.pre.incr}{8.5.2.2}
\cxxsec{expr.sizeof}{8.5.2.3}
\cxxsec{expr.new}{8.5.2.4}
\cxxsec{expr.delete}{8.5.2.5}
\cxxsec{expr.alignof}{8.5.2.6}
\cxxsec{expr.unary.noexcept}{8.5.2.7}
\cxxsec{expr.cast}{8.5.3}
\cxxsec{expr.mptr.oper}{8.5.4}
\cxxsec{expr.mul}{8.5.5}
\cxxsec{expr.add}{8.5.6}
\cxxsec{expr.shift}{8.5.7}
\cxxsec{expr.rel}{8.5.9}
\cxxsec{expr.eq}{8.5.10}
\cxxsec{expr.bit.and}{8.5.11}
\cxxsec{expr.bit.xor}{8.5.12}
\cxxsec{expr.bit.or}{8.5.13}
\cxxsec{expr.log.and}{8.5.14}
\cxxsec{expr.log.or}{8.5.15}
\cxxsec{expr.cond}{8.5.16}
\cxxsec{expr.ass}{8.5.18}
\cxxsec{expr.comma}{8.5.19}
\cxxsec{expr.const}{8.6}

\cxxsec{stmt.block}{9.3}
\cxxsec{stmt.select}{9.4}
\cxxsec{stmt.iter}{9.5}
\cxxsec{stmt.for}{9.5.3}
\cxxsec{stmt.ranged}{9.5.4}

\cxxsec{dcl.dcl}{10}
\cxxsec{dcl.spec}{10.1}
\cxxsec{dcl.fct.spec}{10.1.2}
\cxxsec{dcl.constexpr}{10.1.5}
\cxxsec{dcl.type}{10.1.7}
\cxxsec{dcl.type.cv}{10.1.7.1}
\cxxsec{dcl.type.simple}{10.1.7.2}
\cxxsec{dcl.type.elab}{10.1.7.3}
\cxxsec{dcl.spec.auto}{10.1.7.4}
\cxxsec{namespace.alias}{10.3.2}
\cxxsec{namespace.udecl}{10.3.3}
\cxxsec{dcl.link}{10.5}
\cxxsec{dcl.attr.deprecated}{10.6.4}

\cxxsec{dcl.decl}{11}
\cxxsec{dcl.name}{11.1}
\cxxsec{dcl.ambig.res}{11.2}
\cxxsec{dcl.meaning}{11.3}
\cxxsec{dcl.fct}{11.3.5}
\cxxsec{dcl.fct.default}{11.3.6}
\cxxsec{dcl.fct.def}{11.4}
\cxxsec{dcl.fct.def.general}{11.4.1}
\cxxsec{dcl.init}{11.6}
\cxxsec{dcl.init.list}{11.6.4}

\cxxsec{class}{12}
\cxxsec{class.name}{12.1}
\cxxsec{class.mem}{12.2}
\cxxsec{class.static.data}{12.4.2}

\cxxsec{class.derived}{13}
\cxxsec{class.mi}{13.1}
\cxxsec{class.member.lookup}{13.2}
\cxxsec{class.virtual}{13.3}
\cxxsec{class.abstract}{13.4}

\cxxsec{special}{15}
\cxxsec{class.ctor}{15.1}
\cxxsec{class.ctor}{15.1}
\cxxsec{class.conv}{15.3}
\cxxsec{class.dtor}{15.4}

\cxxsec{over}{16}
\cxxsec{over.load}{16.1}
\cxxsec{over.dcl}{16.2}
\cxxsec{over.match}{16.3}
\cxxsec{over.match.funcs}{16.3.1}
\cxxsec{over.match.viable}{16.3.2}
\cxxsec{over.match.best}{16.3.3}
\cxxsec{over.over}{16.4}
\cxxsec{over.oper}{16.5}
\cxxsec{over.call}{16.5.4}
\cxxsec{over.built}{16.6}

\cxxsec{temp}{17}
\cxxsec{temp.param}{17.1}
\cxxsec{temp.names}{17.2}
\cxxsec{temp.arg}{17.3}
\cxxsec{temp.arg.type}{17.3.1}
\cxxsec{temp.arg.nontype}{17.3.2}
\cxxsec{temp.arg.template}{17.3.3}
\cxxsec{temp.constr}{17.4}
\cxxsec{temp.constr.decl}{17.4.2}
\cxxsec{temp.constr.order}{17.4.4}
\cxxsec{temp.type}{17.5}
\cxxsec{temp.dcls}{17.5}
\cxxsec{temp.class}{17.5.1}
\cxxsec{temp.mem.func}{17.5.1.1}
\cxxsec{temp.mem.class}{17.5.1.2}
\cxxsec{temp.static}{17.5.1.3}
\cxxsec{temp.mem.enum}{17.5.1.4}
\cxxsec{temp.mem}{17.5.2}
\cxxsec{temp.variadic}{17.5.3}
\cxxsec{temp.friend}{17.5.4}
\cxxsec{temp.class.spec.match}{17.5.5.1}
\cxxsec{temp.class.order}{17.5.5.2}
\cxxsec{temp.class.spec.mfunc}{17.5.5.3}
\cxxsec{temp.fct}{17.5.6}
\cxxsec{temp.over.link}{17.5.6.1}
\cxxsec{temp.func.order}{17.5.6.2}
\cxxsec{temp.res}{17.6}
\cxxsec{temp.local}{17.6.1}
\cxxsec{temp.dep}{17.6.2}
\cxxsec{temp.dep.type}{17.6.2.1}
\cxxsec{temp.dep.expr}{17.6.2.2}
\cxxsec{temp.dep.constexpr}{17.6.2.3}
\cxxsec{temp.dep.temp}{17.6.2.4}
\cxxsec{temp.nondep}{17.6.3}
\cxxsec{temp.dep.res}{17.6.4}
\cxxsec{temp.point}{17.6.4.1}
\cxxsec{temp.inject}{17.6.5}
\cxxsec{temp.concept}{17.6.8}
\cxxsec{temp.spec}{17.7}
\cxxsec{temp.inst}{17.7.1}
\cxxsec{temp.explicit}{17.7.2}
\cxxsec{temp.expl.spec}{17.7.3}
\cxxsec{temp.deduct}{17.8.2}
\cxxsec{temp.deduct.call}{17.8.2.1}
\cxxsec{temp.deduct.funcaddr}{17.8.2.2}
\cxxsec{temp.deduct.conv}{17.8.2.3}
\cxxsec{temp.deduct.partial}{17.8.2.4}
\cxxsec{temp.deduct.type}{17.8.2.5}
\cxxsec{temp.deduct.decl}{17.8.2.6}

\cxxsec{except}{18}
\cxxsec{except.throw}{18.1}
\cxxsec{except.ctor}{18.2}
\cxxsec{except.handle}{18.3}
\cxxsec{except.spec}{18.4}
\cxxsec{except.special}{18.5}
\cxxsec{except.terminate}{18.5.1}
\cxxsec{except.unexcpected}{18.5.2}
\cxxsec{except.uncaught}{18.5.3}

\cxxsec{library}{20}
\cxxsec{definitions}{20.3}
\cxxsec{structure.specifications}{20.4.1.4}
\cxxsec{type.descriptions}{20.4.2.1}
\cxxsec{functions.within.classes}{20.4.2.2}
\cxxsec{operators}{20.4.2.3}
\cxxsec{objects.within.classes}{20.4.2.4}
\cxxsec{requirements}{20.5}
\cxxsec{headers}{20.5.1.2}
\cxxsec{using.headers}{20.5.2.2}
\cxxsec{utility.requirements}{20.5.3}
\cxxsec{utility.arg.requirements}{20.5.3.1}
\cxxsec{equalitycomparable}{20}
\cxxsec{lessthancomparable}{21}
\cxxsec{defaultconstructible}{22}
\cxxsec{moveconstructible}{23}
\cxxsec{copyconstructible}{24}
\cxxsec{moveassignable}{25}
\cxxsec{copyassignable}{26}
\cxxsec{destructible}{27}
\cxxsec{allocator.requirements}{20.5.3.5}
\cxxsec{namespace.std}{20.5.4.2.1}
\cxxsec{res.on.arguments}{20.5.4.9}
\cxxsec{res.on.objects}{20.5.4.10}
\cxxsec{conforming}{20.5.5}
\cxxsec{algorithm.stable}{20.5.5.7}
\cxxsec{res.on.exception.handling}{20.5.5.12}
\cxxsec{lib.types.movedfrom}{20.5.5.15}

\cxxsec{language.support}{21}
\cxxsec{new.delete}{21.6.2}
\cxxsec{new.handler}{21.6.3.3}
\cxxsec{terminate.handler}{21.8.4.1}
\cxxsec{support.initlist}{21.9}

\cxxsec{concepts.lib}{XX}

\cxxsec{diagnostics}{22}

\cxxsec{utilities}{23}
\cxxsec{utility.swap}{23.2.2}
\cxxsec{declval}{23.2.6}
\cxxsec{pairs}{23.4}
\cxxsec{tuple}{23.5}
\cxxsec{tuple.helper}{23.5.3.6}
\cxxsec{tuple.elem}{23.5.3.7}
\cxxsec{template.bitset}{23.9.2}
\cxxsec{func.def}{23.14.2}
\cxxsec{func.require}{23.14.3}
\cxxsec{func.invoke}{23.14.4}
\cxxsec{refwrap}{23.14.5}
\cxxsec{func.notfn}{23.14.10}
\cxxsec{meta}{23.15}
\cxxsec{meta.type.synop}{23.15.2}
\cxxsec{meta.unary}{23.15.4}
\cxxsec{meta.unary.prop}{23.15.4.3}
\cxxsec{meta.trans.other}{23.15.7.6}

\cxxsec{strings}{24}

\cxxsec{localization}{25}

\cxxsec{containers}{26}
\cxxsec{container.requirements}{26.2}
\cxxsec{associative}{26.4}
\cxxsec{set}{26.4.6}
\cxxsec{multiset}{26.4.7}
\cxxsec{unord.set}{26.5.6}
\cxxsec{unord.multiset}{26.5.7}

\cxxsec{iterators}{27}
\cxxsec{iterator.requirements}{27.2}
\cxxsec{iterators.input}{27.2.3}
\cxxsec{iterator.traits}{27.4.1}
\cxxsec{tab:iterator.forward.requirements}{89}
\cxxsec{tab:iterator.bidirectional.requirements}{90}
\cxxsec{tab:iterator.random.access.requirements}{91}

\cxxsec{algorithms}{28}
\cxxsec{algorithms.requirements}{28.3}
\cxxsec{alg.foreach}{28.5.4}

\cxxsec{numerics}{29}
\cxxsec{numeric.requirements}{29.3}
\cxxsec{rand}{29.6}
\cxxsec{rand.req}{29.6.1}
\cxxsec{rand.req.urng}{29.6.1.3}
\cxxsec{rand.eng.lcong}{29.6.3.1}

\cxxsec{input.output}{30}
\cxxsec{stream.buffers}{30.6}
\cxxsec{iostream.format}{30.7}

\cxxsec{re}{31}

\cxxsec{atomics}{32}

\cxxsec{thread}{33}

\cxxsec{depr.c.headers}{D.5}
\cxxsec{depr.algo.range-and-a-half}{A.3}
