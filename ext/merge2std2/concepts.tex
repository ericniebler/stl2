%!TEX root = P0896.tex

\setcounter{chapter}{16}
\rSec0[concepts]{Concepts library}

\setcounter{section}{2}
\rSec1[concepts.syn]{Header \tcode{<concepts>} synopsis}

\indexlibrary{\idxhdr{concepts}}%
\begin{codeblock}
namespace std {
  [...]

  // \cxxref{concept.assignable}, concept \libconcept{Assignable}
  template<class LHS, class RHS>
    concept Assignable = @\seebelow@;

  // \ref{concept.swappable}, concept \libconcept{Swappable}
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
  @\newtxt{namespace ranges \{}@
    @\newtxt{inline namespace \unspec{} \{}@
      @\newtxt{inline constexpr \unspec{} swap = \unspecnc{};}@
    @\newtxt{\}}@
  @\newtxt{\}}@
\end{codeblock}
\end{addedblock}
\begin{codeblock}
  template<class T>
    concept Swappable = @\seebelow@;
  template<class T, class U>
    concept SwappableWith = @\seebelow@;

  [...]
}
\end{codeblock}

\rSec1[concepts.lang]{Language-related concepts}

\setcounter{subsection}{10}
\rSec2[concept.swappable]{Concept \libconcept{Swappable}}

\begin{addedblock}
{\color{newclr}
\pnum
Let \tcode{t1} and \tcode{t2} be equality-preserving expressions that denote
distinct equal objects of type \tcode{T}, and let \tcode{u1} and \tcode{u2}
similarly denote distinct equal objects of type \tcode{U}. An operation
\term{exchanges the values} denoted by \tcode{t1} and \tcode{u1} if and only
if the operation modifies neither \tcode{t2} nor \tcode{u2} and:
\begin{itemize}
\item If \tcode{T} and \tcode{U} are the same type, the result of the operation
  is that \tcode{t1} equals \tcode{u2} and \tcode{u1} equals \tcode{t2}.

\item If \tcode{T} and \tcode{U} are different types that model
  \libconcept{CommonReference<const T\&, const U\&>},
  the result of the operation is that
  \tcode{C(t1)} equals \tcode{C(u2)}
  and
  \tcode{C(u1)} equals \tcode{C(t2)}
  where \tcode{C} is \tcode{common_reference_t<const T\&, const U\&>}.
\end{itemize}
} %% \color{newclr}

\indexlibrary{\idxcode{ranges::swap}}%
\pnum The name \tcode{ranges::swap} denotes a customization point
object\cxxiref{customization.point.object}. The expression
\tcode{ranges::swap(E1, E2)} for some subexpressions \tcode{E1}
and \tcode{E2} is expression-equivalent to:

\begin{itemize}
\item
  \tcode{(void)swap(E1, E2)}\footnote{The name \tcode{swap} is used
  here unqualified.}, if \newtxt{\tcode{E1} or \tcode{E2}
  has class type\cxxiref{basic.compound} and} that expression is valid, with
  overload resolution performed in a context that includes the declarations
\begin{codeblock}
  template<class T>
    void swap(T&, T&) = delete;
  template<class T, size_t N>
    void swap(T(&)[N], T(&)[N]) = delete;
\end{codeblock}
  and does not include a declaration of \tcode{ranges::swap}.
  If the function selected by overload resolution does not
  exchange the values \oldtxt{referenced} \newtxt{denoted} by
  \tcode{E1} and \tcode{E2},
  the program is ill-formed with no diagnostic required.

\item
  Otherwise, \tcode{(void)ranges::swap_ranges(E1, E2)} if \tcode{E1} and
  \tcode{E2} are lvalues of array types\cxxiref{basic.compound}
  with equal extent and \tcode{ranges::swap(*\oldtxt{(}E1\oldtxt{)}, *\oldtxt{(}E2\oldtxt{)})}
  is a valid expression, except that
  \tcode{noexcept(\brk{}ranges::swap(E1, E2))} is equal to
  \tcode{noexcept(\brk{}ranges::swap(*\oldtxt{(}E1\oldtxt{)}, *\oldtxt{(}E2\oldtxt{)}))}.

\item
  Otherwise, if \tcode{E1} and \tcode{E2} are lvalues of the
  same type \tcode{T} that \oldtxt{meets the syntactic requirements of}
  \newtxt{models} \libconcept{MoveConstructible<T>} and
  \libconcept{Assignable<T\&, T>}, exchanges the \oldtxt{referenced}
  \newtxt{denoted} values.
  \tcode{ranges::swap(\brk{}E1, E2)} is a constant expression if
  \oldtxt{the constructor selected by overload resolution for
  \tcode{T\{std::move(E1)\}} is a constexpr constructor and
  \oldtxt{the expression} \tcode{E1 = std::move(E2)} can appear in a
  constexpr function.}
  {\color{newclr}
  \begin{itemize}
  \item both \tcode{E1 = std::move(E2)} and \tcode{E2 = std::move(E1)} are
    constant expressions, and
  \item the initializers in the declarations \tcode{T t1(std::move(E1));} and
    \tcode{T t2(std::move(E2));} are
    constant initializers\cxxiref{basic.start.static}.
  \end{itemize}
  } %% \color{newclr}
  \tcode{noexcept(ranges::swap(E1, E2))} is equal to
  \tcode{is_nothrow_move_constructible_v<T> \&\&
  is_nothrow_move_assignable_v<T>}. \oldtxt{If either
  \libconcept{MoveConstructible} or
  \libconcept{Assignable} is not satisfied, the program
  is ill-formed with no diagnostic required.}

\item
  Otherwise, \tcode{ranges::swap(E1, E2)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
Whenever \tcode{ranges::swap(E1, E2)} is a valid expression, it
exchanges the values \oldtxt{referenced} \newtxt{denoted} by
\tcode{E1} and \tcode{E2} and has type \tcode{void}.
\end{note}
\end{addedblock}

\indexlibrary{\idxcode{Swappable}}%
\begin{itemdecl}
template<class T>
  @\removed{concept Swappable = is_swappable_v<T>;}@
  @\added{concept Swappable = requires(T\& a, T\& b) \{ ranges::swap(a, b); \};}@
\end{itemdecl}

\begin{removedblock}
\begin{itemdescr}
\pnum
Let \tcode{a1} and \tcode{a2} denote distinct equal objects of type \tcode{T},
and let \tcode{b1} and \tcode{b2} similarly denote distinct equal objects of
type \tcode{T}. \tcode{\libconcept{Swappable}<T>} is satisfied only if after
evaluating either \tcode{swap(a1, b1)} or \tcode{swap(b1, a1)} in the context
described below, \tcode{a1} is equal to \tcode{b2} and \tcode{b1} is equal to
\tcode{a2}.

\pnum
The context in which \tcode{swap(a1, b1)} or \tcode{swap(b1, a1)} is evaluated
shall ensure that a binary non-member function named \tcode{swap} is selected via
overload resolution\cxxiref{over.match} on a candidate set that includes:
\begin{itemize}
\item the two \tcode{swap} function templates defined in
  \tcode{<utility>}\cxxiref{utility} and
\item the lookup set produced by argument-dependent
  lookup\cxxiref{basic.lookup.argdep}.
\end{itemize}
\end{itemdescr}
\end{removedblock}

\indexlibrary{\idxcode{SwappableWith}}%
\begin{itemdecl}
template<class T, class U>
  concept SwappableWith =
    @\removed{is_swappable_with_v<T, T> \&\& is_swappable_with_v<U, U> \&\&}@
    CommonReference<const remove_reference_t<T>&, const remove_reference_t<U>&> &&
    @\removed{is_swappable_with_v<T, U> \&\& is_swappable_with_v<U, T>;}@
    @\added{requires(T\&\& t, U\&\& u) \{}@
      @\added{ranges::swap(std::forward<T>(t), std::forward<T>(t));}@
      @\added{ranges::swap(std::forward<U>(u), std::forward<U>(u));}@
      @\added{ranges::swap(std::forward<T>(t), std::forward<U>(u));}@
      @\added{ranges::swap(std::forward<U>(u), std::forward<T>(t));}@
    @\added{\};}@
\end{itemdecl}

\begin{removedblock}
\begin{itemdescr}
\pnum
Let:
\begin{itemize}
\item \tcode{t1} and \tcode{t2} denote distinct equal objects of type
  \tcode{remove_cvref_t<T>},
\item $E_t$ be an expression that denotes \tcode{t1} such that
  \tcode{decltype(($E_t$))} is \tcode{T},
\item \tcode{u1} and \tcode{u2} similarly denote distinct equal objects of type
  \tcode{remove_cvref_t<U>},
\item $E_u$ be an expression that denotes \tcode{u1} such that
  \tcode{decltype(($E_u$))} is \tcode{U}, and
\item \tcode{C} be
  % This comfortably fits on one line as a codeblock, but overfills the page as
  % tcode. :(
  \begin{codeblock}
    common_reference_t<const remove_reference_t<T>&, const remove_reference_t<U>&>
  \end{codeblock}
\end{itemize}
\tcode{\libconcept{SwappableWith}<T, U>} is satisfied only if after evaluating
either \tcode{swap($E_t$, $E_u$)} or \tcode{swap($E_u$, $E_t$)} in the context
described above, \tcode{C(t1)} is equal to \tcode{C(u2)} and \tcode{C(u1)} is
equal to \tcode{C(t2)}.

\pnum
The context in which \tcode{swap($E_t$, $E_u$)} or \tcode{swap($E_u$, $E_t$)}
is evaluated shall ensure that a binary non-member function named \tcode{swap} is
selected via overload resolution\cxxiref{over.match} on a candidate set that
includes:
\begin{itemize}
\item the two \tcode{swap} function templates defined in
  \tcode{<utility>}\cxxiref{utility} and
\item the lookup set produced by argument-dependent
  lookup\cxxiref{basic.lookup.argdep}.
\end{itemize}
\end{itemdescr}
\end{removedblock}

\begin{addedblock}
{\color{oldclr}
\begin{itemdescr}
\pnum
This subclause provides definitions for swappable types and expressions.
In these definitions, let \tcode{t} denote an expression of type \tcode{T}, and
let \tcode{u} denote an expression of type \tcode{U}.

\pnum
An object \tcode{t} is \defn{swappable with} an object \tcode{u} if and only if
\tcode{SwappableWith<T, U>} is satisfied. \tcode{SwappableWith<T, U>} is
satisfied only if given distinct objects \tcode{t2} equal to \tcode{t}
and \tcode{u2} equal to \tcode{u}, after evaluating either
\tcode{ranges::swap(t, u)} or \tcode{ranges::swap(u, t)}, \tcode{t2} is equal to
\tcode{u} and \tcode{u2} is equal to \tcode{t}.

\pnum
An rvalue or lvalue \tcode{t} is \defn{swappable} if and only if \tcode{t} is
swappable with any rvalue or lvalue, respectively, of type \tcode{T}.
\end{itemdescr}
} %% \color{oldclr}

{\color{newclr}
\pnum
\begin{note}
The semantics of the \libconcept{Swappable} and \libconcept{SwappableWith}
concepts are fully defined by the \tcode{ranges::swap} customization point.
\end{note}
} %% \color{newclr}
\end{addedblock}

\pnum
\begin{example}
User code can ensure that the evaluation of \tcode{swap} calls
is performed in an appropriate context under the various conditions as follows:
\begin{codeblock}
#include <cassert>
#include <concepts>
#include <utility>

@\newtxt{namespace ranges = std::ranges;}@

template<class T, std::SwappableWith<T> U>
void value_swap(T&& t, U&& u) {
  @\removed{using std::swap;}@
  @\added{ranges::}@swap(std::forward<T>(t), std::forward<U>(u)); @\oldoldtxt{// OK: uses ``swappable with'' conditions}@
                                                        @\oldoldtxt{// for rvalues and lvalues}@
}

template<std::Swappable T>
void lv_swap(T& t1, T& t2) {
  @\removed{using std::swap;}@
  @\added{ranges::}@swap(t1, t2);                                 @\oldoldtxt{// OK: uses swappable conditions for}@
}                                                       @\oldoldtxt{// lvalues of type \tcode{T}}@

namespace N {
  struct A { int m; };
  struct Proxy { A* a; };
  Proxy proxy(A& a) { return Proxy{ &a }; }

  void swap(A& x, Proxy p) {
    @\changed{std}{ranges}@::swap(x.m, p.a->m);                       @\oldoldtxt{// OK: uses context equivalent to swappable}@
                                                        @\oldoldtxt{// conditions for fundamental types}@
  }
  void swap(Proxy p, A& x) { swap(x, p); }              // satisfy symmetry \oldoldtxt{constraint}\newnewtxt{requirement}
}

int main() {
  int i = 1, j = 2;
  lv_swap(i, j);
  assert(i == 2 && j == 1);

  N::A a1 = { 5 }, a2 = { -5 };
  value_swap(a1, proxy(a2));
  assert(a1.m == -5 && a2.m == 5);
}
\end{codeblock}
\end{example}
