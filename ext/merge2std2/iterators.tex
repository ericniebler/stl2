%!TEX root = P0896.tex

\setcounter{chapter}{27}
\setcounter{table}{86}
\rSec0[iterators]{Iterators library}

\rSec1[iterators.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to perform
iterations over containers\iref{containers},
streams\cxxiref{iostream.format},
\removed{and} stream buffers\cxxiref{stream.buffers}\newtxt{, and other ranges\iref{range}}.

\pnum
The following subclauses describe
iterator requirements, and
components for
iterator primitives,
predefined iterators,
and stream iterators,
as summarized in \tref{iterators.lib.summary}.

\begin{libsumtab}{Iterators library summary}{tab:iterators.lib.summary}
\ref{iterator.requirements}     & \oldtxt{R}\newtxt{Iterator r}equirements & \newtxt{\tcode{<iterator>}}  \\
\newtxt{\ref{indirectcallable}} & \newtxt{Indirect callable requirements}  &                             \\
\newtxt{\ref{commonalgoreq}}    & \newtxt{Common algorithm requirements}   &                             \\
\ref{iterator.primitives}       & Iterator primitives                      & \oldtxt{\tcode{<iterator>}} \\
\ref{predef.iterators}          & Predefined iterators                     &                             \\
\ref{stream.iterators}          & Stream iterators                         &                             \\
\end{libsumtab}

\ednote{Move the section [iterator.synopsis] to immediately follow
[iterators.general] and precede [iterator.requirements], and change it as follows:}

\rSec1[iterator.synopsis]{Header \tcode{<iterator>} synopsis}

\indexlibrary{\idxhdr{iterator}}%
\begin{codeblock}
@\newtxt{\#include <concepts>}@

namespace std {
\end{codeblock}\begin{addedblock}\begin{codeblock}
  template<class T> concept @\oldtxt{bool}@ @\placeholder{dereferenceable}@ // \expos
    = requires(T& t) { { *t } -> auto&&; }; @\newtxt{// not required to be equality-preserving}@

  // \ref{iterator.assoc.types}, associated types
  // \ref{incrementable.traits}, \oldtxt{difference_type}\newtxt{incrementable traits}
  template<class> struct @\oldtxt{difference_type}\newtxt{incrementable_traits}@;
  template<class T>
    using @\newtxt{iter_}@difference@\oldtxt{_type}@_t @\newtxt{= \seebelownc;}@
      @\oldtxt{= typename difference_type<T>::type;}@

  // \ref{readable.traits}, \oldtxt{value_type}\newtxt{readable traits}
  template<class> struct @\oldtxt{value_type}\newtxt{readable_traits}@;
  template<class T>
    using @\oldtxt{value_type_t}\newtxt{iter_value_t = \seebelownc;}@
      @\oldtxt{= typename value_type<T>::type;}@

  @\oldtxt{// [iterator.assoc.types.iterator_category], iterator_category:}@
  @\oldtxt{template<class> struct iterator_category;}@
  @\oldtxt{template<class T> using iterator_category_t}@
    @\oldtxt{= typename iterator_category<T>::type;}@

\end{codeblock}\end{addedblock}\begin{codeblock}
  // \ref{iterator.traits}, Iterator traits \ednote{Moved here from below.}
  template<class Iterator> struct iterator_traits;
  template<class T> struct iterator_traits<T*>;
\end{codeblock}\begin{addedblock}\begin{codeblock}

  template<@\placeholder{dereferenceable}@ T>
    using @\newtxt{iter_}@reference_t = decltype(*declval<T&>());

  namespace ranges {
    // \ref{iterator.custpoints}, customization points
    @\newtxt{inline}@ namespace @\newtxt{\unspec}@ {
      // \ref{iterator.custpoints.iter_move}, iter_move
      @\newtxt{inline}@ constexpr @\unspec@ iter_move = @\unspecnc@;

      // \ref{iterator.custpoints.iter_swap}, iter_swap
      @\newtxt{inline}@ constexpr @\unspec@ iter_swap = @\unspecnc@;
    }
  }

  template<@\placeholder{dereferenceable}@ T>
      requires @\oldtxt{\seebelow}\newtxt{requires (T\& t) \{}@
        @\newtxt{\{ ranges::iter_move(t) \} -> auto \&\&;}@
      @\newtxt{\}}@
    using @\newtxt{iter_}@rvalue_reference_t = decltype(ranges::iter_move(declval<T&>()));

  // \ref{iterator.concepts}, iterator \oldtxt{requirements}\newtxt{concepts}
  // \ref{iterator.concept.readable}, Readable
  template<class In>
  concept @\oldtxt{bool}@ Readable = @\seebelownc@;

  template<Readable T>
    using iter_common_reference_t =
      common_reference_t<@\newtxt{iter_}@reference_t<T>, @\oldtxt{value_type_t}\newtxt{iter_value_t}@<T>&>;

  // \ref{iterator.concept.writable}, Writable
  template<class Out, class T>
  concept @\oldtxt{bool}@ Writable = @\seebelownc@;

  // \ref{iterator.concept.weaklyincrementable}, WeaklyIncrementable
  template<class I>
  concept @\oldtxt{bool}@ WeaklyIncrementable = @\seebelownc@;

  // \ref{iterator.concept.incrementable}, Incrementable
  template<class I>
  concept @\oldtxt{bool}@ Incrementable = @\seebelownc@;

  // \ref{iterator.concept.iterator}, Iterator
  template<class I>
  concept @\oldtxt{bool}@ Iterator = @\seebelownc@;

  // \ref{iterator.concept.incrementable}, Sentinel
  template<class S, class I>
  concept @\oldtxt{bool}@ Sentinel = @\seebelownc@;

  // \ref{iterator.concept.sizedsentinel}, SizedSentinel
  template<class S, class I>
  @\newtxt{inline}@ constexpr bool disable_sized_sentinel = false;

  template<class S, class I>
  concept @\oldtxt{bool}@ SizedSentinel = @\seebelownc@;

  // \ref{iterator.concept.input}, InputIterator
  template<class I>
  concept @\oldtxt{bool}@ InputIterator = @\seebelownc@;

  // \ref{iterator.concept.output}, OutputIterator
  template<class I>
  concept @\oldtxt{bool}@ OutputIterator = @\seebelownc@;

  // \ref{iterator.concept.forward}, ForwardIterator
  template<class I>
  concept @\oldtxt{bool}@ ForwardIterator = @\seebelownc@;

  // \ref{iterator.concept.bidirectional}, BidirectionalIterator
  template<class I>
  concept @\oldtxt{bool}@ BidirectionalIterator = @\seebelownc@;

  // \ref{iterator.concept.random.access}, RandomAccessIterator
  template<class I>
  concept @\oldtxt{bool}@ RandomAccessIterator = @\seebelownc@;

  // \ref{iterator.concept.contiguous}, ContiguousIterator
  template<class I>
  concept ContiguousIterator = @\seebelownc@;

  // \ref{indirectcallable}, indirect callable requirements
  // \ref{indirectcallable.indirectinvocable}, indirect callables
  template<class F, class I>
  concept @\oldtxt{bool}@ IndirectUnaryInvocable = @\seebelownc@;

  template<class F, class I>
  concept @\oldtxt{bool}@ IndirectRegularUnaryInvocable = @\seebelownc@;

  template<class F, class I>
  concept @\oldtxt{bool}@ IndirectUnaryPredicate = @\seebelownc@;

  template<class F, class I1, class I2 = I1>
  concept @\oldtxt{bool}@ IndirectRelation = @\seebelownc@;

  template<class F, class I1, class I2 = I1>
  concept @\oldtxt{bool}@ IndirectStrictWeakOrder = @\seebelownc@;

  @\oldtxt{template<class>}@
  @\oldtxt{struct indirect_result_of;}@

  @\oldtxt{template<class F, class... Is>}@
    @\oldtxt{requires Invocable<F, reference_t<Is>...>}@
  @\oldtxt{struct indirect_result_of<F(Is...)>;}@

  template<class F@\newtxt{, class... Is}@>
    @\newtxt{requires (Readable<Is> \&\& ...) \&\& Invocable<F, iter_reference_t<Is>...>}@
  using indirect_result@\oldtxt{_of}@_t
    = @\newtxt{invoke_result_t<F, iter_reference_t<Is>...>;} \oldtxt{typename indirect_result_of<F>::type;}@

  // \ref{projected}, projected
  template<Readable I, IndirectRegularUnaryInvocable<I> Proj>
  struct projected;

  template<WeaklyIncrementable I, class Proj>
  struct @\oldtxt{difference_type}\newtxt{incrementable_traits}@<projected<I, Proj>>;

  // \ref{commonalgoreq}, common algorithm requirements
  // \ref{commonalgoreq.indirectlymovable} IndirectlyMovable
  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyMovable = @\seebelownc@;

  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyMovableStorable = @\seebelownc@;

  // \ref{commonalgoreq.indirectlycopyable} IndirectlyCopyable
  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyCopyable = @\seebelownc@;

  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyCopyableStorable = @\seebelownc@;

  // \ref{commonalgoreq.indirectlyswappable} IndirectlySwappable
  template<class I1, class I2 = I1>
  concept @\oldtxt{bool}@ IndirectlySwappable = @\seebelownc@;

  // \ref{commonalgoreq.indirectlycomparable} IndirectlyComparable
  template<class I1, class I2, class R @\oldtxt{= equal_to<>}@, class P1 = identity,
      class P2 = identity>
  concept @\oldtxt{bool}@ IndirectlyComparable = @\seebelownc@;

  // \ref{commonalgoreq.permutable} Permutable
  template<class I>
  concept @\oldtxt{bool}@ Permutable = @\seebelownc@;

  // \ref{commonalgoreq.mergeable} Mergeable
  template<class I1, class I2, class Out,
      class R = @\newtxt{ranges::}@less<>, class P1 = identity, class P2 = identity>
  concept @\oldtxt{bool}@ Mergeable = @\seebelownc@;

  template<class I, class R = @\newtxt{ranges::}@less<>, class P = identity>
  concept @\oldtxt{bool}@ Sortable = @\seebelownc@;

  @\ednote{ranges::iterator_traits from the Ranges TS is intentionally omitted.}@

  // \ref{iterator.primitives}, primitives
  @\newtxt{// \ref{std.iterator.tags}, iterator tags}@\end{codeblock}\end{addedblock}\begin{codeblock}
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
  @\added{struct contiguous_iterator_tag: public random_access_iterator_tag \{ \};}@

  @\ednote{The iterator tags from the Ranges TS are intentionally omitted.}@

  // \ref{iterator.operations}, iterator operations
  template<class InputIterator, class Distance>
    constexpr void
      advance(InputIterator& i, Distance n);
  template<class InputIterator>
    constexpr typename iterator_traits<InputIterator>::difference_type
      distance(InputIterator first, InputIterator last);
  template<class InputIterator>
    constexpr InputIterator
      next(InputIterator x,
           typename iterator_traits<InputIterator>::difference_type n = 1);
  template<class BidirectionalIterator>
    constexpr BidirectionalIterator
      prev(BidirectionalIterator x,
           typename iterator_traits<BidirectionalIterator>::difference_type n = 1);
\end{codeblock}\begin{addedblock}\begin{codeblock}
  // \ref{range.iterator.operations}, range iterator operations
  namespace ranges {
    // \ref{range.iterator.operations}, \newtxt{Range} iterator operations
    @\oldtxt{namespace \{}@
      @\oldtxt{constexpr \unspec{} advance = \unspecnc;}@
      @\oldtxt{constexpr \unspec{} distance = \unspecnc;}@
      @\oldtxt{constexpr \unspec{} next = \unspecnc;}@
      @\oldtxt{constexpr \unspec{} prev = \unspecnc;}@
    @\oldtxt{\}}@
    @\newtxt{// \ref{range.iterator.operations.advance}, \tcode{ranges::advance}}@
    @\newtxt{template<Iterator I>}@
      @\newtxt{constexpr void advance(I\& i, iter_difference_t<I> n);}@
    @\newtxt{template<Iterator I, Sentinel<I> S>}@
      @\newtxt{constexpr void advance(I\& i, S bound);}@
    @\newtxt{template<Iterator I, Sentinel<I> S>}@
      @\newtxt{constexpr iter_difference_t<I> advance(I\& i, iter_difference_t<I> n, S bound);}@

    @\newtxt{// \ref{range.iterator.operations.distance}, \tcode{ranges::distance}}@
    @\newtxt{template<Iterator I, Sentinel<I> S>}@
      @\newtxt{constexpr iter_difference_t<I> distance(I first, S last);}@
    @\newtxt{template<Range R>}@
      @\newtxt{constexpr iter_difference_t<iterator_t<R>> distance(R\&\& r);}@

    @\newtxt{// \ref{range.iterator.operations.next}, \tcode{ranges::next}}@
    @\newtxt{template<Iterator I>}@
      @\newtxt{constexpr I next(I x);}@
    @\newtxt{template<Iterator I>}@
      @\newtxt{constexpr I next(I x, iter_difference_t<I> n);}@
    @\newtxt{template<Iterator I, Sentinel<I> S>}@
      @\newtxt{constexpr I next(I x, S bound);}@
    @\newtxt{template<Iterator I, Sentinel<I> S>}@
      @\newtxt{constexpr I next(I x, iter_difference_t<I> n, S bound);}@

    @\newtxt{// \ref{range.iterator.operations.prev}, \tcode{ranges::prev}}@
    @\newtxt{template<BidirectionalIterator I>}@
      @\newtxt{constexpr I prev(I x);}@
    @\newtxt{template<BidirectionalIterator I>}@
      @\newtxt{constexpr I prev(I x, iter_difference_t<I> n);}@
    @\newtxt{template<BidirectionalIterator I>}@
      @\newtxt{constexpr I prev(I x, iter_difference_t<I> n, I bound);}@
  }
\end{codeblock}\end{addedblock}\begin{codeblock}
  // \ref{predef.iterators}, predefined iterators \added{and sentinels}

  @\ednote{reverse_iterator, move_iterator, and the insert iterators from the Ranges TS are intentionally omitted.}@

  @\newtxt{// \ref{reverse.iterators}, reverse iterators}@
  template<class Iterator> class reverse_iterator;

  template<class Iterator1, class Iterator2>
    constexpr bool operator==(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator!=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);

  template<class Iterator1, class Iterator2>
    constexpr auto operator-(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
  template<class Iterator>
    constexpr reverse_iterator<Iterator>
      operator+(
    typename reverse_iterator<Iterator>::difference_type n,
    const reverse_iterator<Iterator>& x);

  template<class Iterator>
    constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i);

  template<class Container> class back_insert_iterator;
  template<class Container>
    back_insert_iterator<Container> back_inserter(Container& x);

  template<class Container> class front_insert_iterator;
  template<class Container>
    front_insert_iterator<Container> front_inserter(Container& x);

  template<class Container> class insert_iterator;
  template<class Container>
    insert_iterator<Container> inserter(Container& x, typename Container::iterator i);

  @\newtxt{// \ref{move.iterators}, move iterators and sentinels}@
  template<class Iterator> class move_iterator;
  template<class Iterator1, class Iterator2>
    constexpr bool operator==(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator!=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

  template<class Iterator1, class Iterator2>
    constexpr auto operator-(
    const move_iterator<Iterator1>& x,
    const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
  template<class Iterator>
    constexpr move_iterator<Iterator> operator+(
      typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);
  template<class Iterator>
    constexpr move_iterator<Iterator> make_move_iterator(Iterator i);

\end{codeblock}\begin{addedblock}\begin{codeblock}
  template<Semiregular S> class move_sentinel;

  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator==(}@
      @\oldtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator==(}@
      @\oldtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator!=(}@
      @\oldtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator!=(}@
      @\oldtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@

  @\oldtxt{template<class I, SizedSentinel<I> S>}@
    @\oldtxt{constexpr difference_type_t<I> operator-(}@
      @\oldtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\oldtxt{template<class I, SizedSentinel<I> S>}@
    @\oldtxt{constexpr difference_type_t<I> operator-(}@
      @\oldtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@

  @\oldtxt{template<Semiregular S>}@
    @\oldtxt{constexpr move_sentinel<S> make_move_sentinel(S s);}@

  // \ref{iterators.common}, common iterators
  template<Iterator I, Sentinel<I> S>
    requires !Same<I, S>
  class common_iterator;

  template<Readable I, class S>
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<common_iterator<I, S>>;

  template<InputIterator I, class S>
  struct iterator_@\oldtxt{category}\newtxt{traits}@<common_iterator<I, S>>;

  @\oldtxt{template<ForwardIterator I, class S>}@
  @\oldtxt{struct iterator_category<common_iterator<I, S>>;}@

  @\oldtxt{template<class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>}@
  @\oldtxt{bool operator==(}@
    @\oldtxt{const common_iterator<I1, S1>\& x, const common_iterator<I2, S2>\& y);}@
  @\oldtxt{template<class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>}@
    @\oldtxt{requires EqualityComparableWith<I1, I2>}@
  @\oldtxt{bool operator==(}@
    @\oldtxt{const common_iterator<I1, S1>\& x, const common_iterator<I2, S2>\& y);}@
  @\oldtxt{template<class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>}@
  @\oldtxt{bool operator!=(}@
    @\oldtxt{const common_iterator<I1, S1>\& x, const common_iterator<I2, S2>\& y);}@

  @\oldtxt{template<class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>}@
  @\oldtxt{difference_type_t<I2> operator-(}@
    @\oldtxt{const common_iterator<I1, S1>\& x, const common_iterator<I2, S2>\& y);}@

  // \ref{default.sentinels}, default sentinels
  class default_sentinel;

  // \ref{iterators.counted}, counted iterators
  template<Iterator I> class counted_iterator;

  @\newtxt{template<Readable I>}@
    @\newtxt{struct readable_traits<counted_iterator<I>{>};}@

  @\newtxt{template<InputIterator I>}@
    @\newtxt{struct iterator_traits<counted_iterator<I>{>};}@

  @\oldtxt{template<class I1, class I2>}@
      @\oldtxt{requires Common<I1, I2>}@
    @\oldtxt{constexpr bool operator==(}@
      @\oldtxt{const counted_iterator<I1>\& x, const counted_iterator<I2>\& y);}@
    @\oldtxt{constexpr bool operator==(}@
      @\oldtxt{const counted_iterator<auto>\& x, default_sentinel);}@
    @\oldtxt{constexpr bool operator==(}@
      @\oldtxt{default_sentinel, const counted_iterator<auto>\& x);}@
  @\oldtxt{template<class I1, class I2>}@
      @\oldtxt{requires Common<I1, I2>}@
    @\oldtxt{constexpr bool operator!=(}@
      @\oldtxt{const counted_iterator<I1>\& x, const counted_iterator<I2>\& y);}@
    @\oldtxt{constexpr bool operator!=(}@
      @\oldtxt{const counted_iterator<auto>\& x, default_sentinel y);}@
    @\oldtxt{constexpr bool operator!=(}@
      @\oldtxt{default_sentinel x, const counted_iterator<auto>\& y);}@
  @\oldtxt{template<class I1, class I2>}@
      @\oldtxt{requires Common<I1, I2>}@
    @\oldtxt{constexpr bool operator<(}@
      @\oldtxt{const counted_iterator<I1>\& x, const counted_iterator<I2>\& y);}@
  @\oldtxt{template<class I1, class I2>}@
      @\oldtxt{requires Common<I1, I2>}@
    @\oldtxt{constexpr bool operator<=(}@
      @\oldtxt{const counted_iterator<I1>\& x, const counted_iterator<I2>\& y);}@
  @\oldtxt{template<class I1, class I2>}@
      @\oldtxt{requires Common<I1, I2>}@
    @\oldtxt{constexpr bool operator>(}@
      @\oldtxt{const counted_iterator<I1>\& x, const counted_iterator<I2>\& y);}@
  @\oldtxt{template<class I1, class I2>}@
      @\oldtxt{requires Common<I1, I2>}@
    @\oldtxt{constexpr bool operator>=(}@
      @\oldtxt{const counted_iterator<I1>\& x, const counted_iterator<I2>\& y);}@
  @\oldtxt{template<class I1, class I2>}@
      @\oldtxt{requires Common<I1, I2>}@
    @\oldtxt{constexpr difference_type_t<I2> operator-(}@
      @\oldtxt{const counted_iterator<I1>\& x, const counted_iterator<I2>\& y);}@
  @\oldtxt{template<class I>}@
    @\oldtxt{constexpr difference_type_t<I> operator-(}@
      @\oldtxt{const counted_iterator<I>\& x, default_sentinel y);}@
  @\oldtxt{template<class I>}@
    @\oldtxt{constexpr difference_type_t<I> operator-(}@
      @\oldtxt{default_sentinel x, const counted_iterator<I>\& y);}@
  @\oldtxt{template<RandomAccessIterator I>}@
    @\oldtxt{constexpr counted_iterator<I>}@
      @\oldtxt{operator+(difference_type_t<I> n, const counted_iterator<I>\& x);}@
  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr counted_iterator<I> make_counted_iterator(I i, difference_type_t<I> n);}@

  // \ref{unreachable.sentinels}, unreachable sentinels
  class unreachable;

  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator==(const I\&, unreachable) noexcept;}@
  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator==(unreachable, const I\&) noexcept;}@
  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator!=(const I\&, unreachable) noexcept;}@
  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator!=(unreachable, const I\&) noexcept;}@
\end{codeblock}\end{addedblock}\begin{codeblock}

  // \ref{stream.iterators}, stream iterators
  @\ednote{The stream iterators from the Ranges TS are intentionally omitted.}@
  template<class T, class charT = char, class traits = char_traits<charT>,
           class Distance = ptrdiff_t>
  class istream_iterator;
  template<class T, class charT, class traits, class Distance>
    bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);
  template<class T, class charT, class traits, class Distance>
    bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);

  template<class T, class charT = char, class traits = char_traits<charT>>
      class ostream_iterator;

  template<class charT, class traits = char_traits<charT>>
    class istreambuf_iterator;
  template<class charT, class traits>
    bool operator==(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);
  template<class charT, class traits>
    bool operator!=(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);

  template<class charT, class traits = char_traits<charT>>
    class ostreambuf_iterator;

  // \cxxref{iterator.range}, range access
  template<class C> constexpr auto begin(C& c) -> decltype(c.begin());
  template<class C> constexpr auto begin(const C& c) -> decltype(c.begin());
  template<class C> constexpr auto end(C& c) -> decltype(c.end());
  template<class C> constexpr auto end(const C& c) -> decltype(c.end());
  template<class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept;
  template<class T, size_t N> constexpr T* end(T (&array)[N]) noexcept;
  template<class C> constexpr auto cbegin(const C& c) noexcept(noexcept(std::begin(c)))
    -> decltype(std::begin(c));
  template<class C> constexpr auto cend(const C& c) noexcept(noexcept(std::end(c)))
    -> decltype(std::end(c));
  template<class C> constexpr auto rbegin(C& c) -> decltype(c.rbegin());
  template<class C> constexpr auto rbegin(const C& c) -> decltype(c.rbegin());
  template<class C> constexpr auto rend(C& c) -> decltype(c.rend());
  template<class C> constexpr auto rend(const C& c) -> decltype(c.rend());
  template<class T, size_t N> constexpr reverse_iterator<T*> rbegin(T (&array)[N]);
  template<class T, size_t N> constexpr reverse_iterator<T*> rend(T (&array)[N]);
  template<class E> constexpr reverse_iterator<const E*> rbegin(initializer_list<E> il);
  template<class E> constexpr reverse_iterator<const E*> rend(initializer_list<E> il);
  template<class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));
  template<class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));

  // \cxxref{iterator.container}, container access
  template<class C> constexpr auto size(const C& c) -> decltype(c.size());
  template<class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept;
  template<class C> [[nodiscard]] constexpr auto empty(const C& c) -> decltype(c.empty());
  template<class T, size_t N> [[nodiscard]] constexpr bool empty(const T (&array)[N]) noexcept;
  template<class E> [[nodiscard]] constexpr bool empty(initializer_list<E> il) noexcept;
  template<class C> constexpr auto data(C& c) -> decltype(c.data());
  template<class C> constexpr auto data(const C& c) -> decltype(c.data());
  template<class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;
  template<class E> constexpr const E* data(initializer_list<E> il) noexcept;
}
\end{codeblock}

\rSec1[iterator.requirements]{Iterator requirements}

\rSec2[iterator.requirements.general]{In general}

\ednote{Merge the changes from the Ranges TS [iterator.requirements.general] as follows:}

\pnum
\indextext{requirements!iterator}%
Iterators are a generalization of pointers that allow a \Cpp{} program to work with different data structures
(\added{for example,} containers \added{and ranges}) in a uniform manner.
To be able to construct template algorithms that work correctly and
efficiently on different types of data structures, the library formalizes not just the interfaces but also the
semantics and complexity assumptions of iterators.
An input iterator
\tcode{i}
supports the expression
\tcode{*i},
resulting in a value of some object type
\tcode{T},
called the
\term{value type}
of the iterator.
% Think about making this "non-empty set of expression type-and-value-categories"
% what's here now is easy to understand and incorrect.
An output iterator \tcode{i} has a non-empty set of types that are
\defn{writable} to the iterator;
for each such type \tcode{T}, the expression \tcode{*i = o}
is valid where \tcode{o} is a value of type \tcode{T}.
\removed{An iterator
\tcode{i}
for which the expression
\tcode{(*i).m}
is well-defined supports the expression
\tcode{i->m}
with the same semantics as
\tcode{(*i).m}.}
For every iterator type
\tcode{X}
\removed{for which
equality is defined}, there is a corresponding signed integer type called the
\term{difference type}
of the iterator.

\pnum
Since iterators are an abstraction of pointers, their semantics is
a generalization of most of the semantics of pointers in \Cpp{}.
This ensures that every
function template
that takes iterators
works as well with regular pointers.
This document defines
\oldtxt{five}\newtxt{six} categories of iterators, according to the operations
defined on them:
\term{input iterators},
\term{output iterators},
\term{forward iterators},
\term{bidirectional iterators},
\term{random access iterators},
and
\added{\term{contiguous iterators}},
as shown in \tref{iterators.relations}.

\begin{floattable}{Relations among iterator categories}{tab:iterators.relations}
{lllll}
\topline
              \added{\textbf{Contiguous}}    & \added{$\rightarrow$} \textbf{Random Access} &
$\rightarrow$ \textbf{Bidirectional} & $\rightarrow$ \textbf{Forward}       &
$\rightarrow$ \textbf{Input}                                                \\
   &   &   &   &   $\rightarrow$ \textbf{Output}                            \\
\end{floattable}

{\color{addclr}
\pnum
The \oldtxt{five}\newtxt{six} categories of iterators correspond to the iterator concepts
\libconcept{Input\-Iterator}\iref{iterator.concept.input},
\libconcept{Output\-Iterator}\iref{iterator.concept.output},
\libconcept{Forward\-Iterator}\iref{iterator.concept.forward},
\libconcept{Bidirectional\-Iterator}\iref{iterator.concept.bidirectional}
\libconcept{RandomAccess\-Iterator}\iref{iterator.concept.random.access}, and
\libconcept{\added{Contiguous\-Iterator}}\iref{iterator.concept.contiguous}, respectively.
The generic term \term{iterator} refers to any type that satisfies \newtxt{the}
\libconcept{Iterator} \newtxt{concept}\iref{iterator.concept.iterator}.
} %% \color{addclr}


\pnum
Forward iterators satisfy all the requirements of input
iterators and can be used whenever
an input iterator is specified;
Bidirectional iterators also satisfy all the requirements of
forward iterators and can be used whenever a forward iterator is specified;
Random access iterators also satisfy all the requirements of bidirectional
iterators and can be used whenever a bidirectional iterator is specified;
\added{Contiguous iterators also satisfy all the requirements of random access
iterators and can be used whenever a random access iterator is specified}.

\pnum
Iterators that further satisfy the requirements of output iterators are
called \defnx{mutable iterators}{mutable iterator}. Nonmutable iterators are referred to
as \defnx{constant iterators}{constant iterator}.

\pnum
In addition to the requirements in this subclause,
the nested \grammarterm{typedef-name}{s} specified in \ref{iterator.traits}
shall be provided for the iterator type.
\begin{note} Either the iterator type must provide the \grammarterm{typedef-name}{s} directly
(in which case \tcode{iterator_traits} pick\newtxt{s} them up automatically), or
an \tcode{iterator_traits} specialization must provide them. \end{note}

{\color{oldclr}
\pnum
Iterators that further satisfy the requirement that,
for integral values \tcode{n} and
dereferenceable iterator values \tcode{a} and \tcode{(a + n)},
\tcode{*(a + n)} is equivalent to \tcode{*(addressof(*a) + n)},
are called \defn{contiguous iterators}.
\begin{note}
For example, the type ``pointer to \tcode{int}'' is a contiguous iterator,
but \tcode{reverse_iterator<int *>} is not.
For a valid iterator range $[$\tcode{a}$, $\tcode{b}$)$ with dereferenceable \tcode{a},
the corresponding range denoted by pointers is
$[$\tcode{addressof(*a)}$, $\tcode{addressof(*a) + (b - a)}$)$;
\tcode{b} might not be dereferenceable.
\end{note}
} %% \color{oldclr}

\pnum
Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence.
These values are called
\term{past-the-end}
values.
Values of an iterator
\tcode{i}
for which the expression
\tcode{*i}
is defined are called
\term{dereferenceable}.
The library never assumes that past-the-end values are dereferenceable.
Iterators can also have singular values that are not associated with any
sequence.
\begin{example}
After the declaration of an uninitialized pointer
\tcode{x}
(as with
\tcode{int* x;}),
\tcode{x}
must always be assumed to have a singular value of a pointer.
\end{example}
Results of most expressions are undefined for singular values;
the only exceptions are destroying an iterator that holds a singular value,
the assignment of a non-singular value to
an iterator that holds a singular value, and, for iterators that satisfy the
\oldconcept{DefaultConstructible} requirements, using a value-initialized iterator
as the source of a copy or move operation. \begin{note} This guarantee is not
offered for default-initialization, although the distinction only matters for types
with trivial default constructors such as pointers or aggregates holding pointers.
\end{note}
In these cases the singular
value is overwritten the same way as any other value.
Dereferenceable
values are always non-singular.

\begin{removedblock}
\pnum
An iterator
\tcode{j}
is called
\term{reachable}
from an iterator
\tcode{i}
if and only if there is a finite sequence of applications of
the expression
\tcode{++i}
that makes
\tcode{i == j}.
If
\tcode{j}
is reachable from
\tcode{i},
they refer to elements of the same sequence.

\pnum
Most of the library's algorithmic templates that operate on data structures have interfaces that use ranges.
A
\term{range}
is a pair of iterators that designate the beginning and end of the computation.
A range \range{i}{i}
is an empty range;
in general, a range \range{i}{j}
refers to the elements in the data structure starting with the element
pointed to by
\tcode{i}
and up to but not including the element pointed to by
\tcode{j}.
Range \range{i}{j}
is valid if and only if
\tcode{j}
is reachable from
\tcode{i}.
The result of the application of functions in the library to invalid ranges is
undefined.
\end{removedblock}

\begin{addedblock}
\pnum
Most of the library's algorithmic templates that operate on data structures have
interfaces that use ranges. A \term{range} is an iterator and a \term{sentinel}
that designate the beginning and end of the computation, or an iterator and a
count that designate the beginning and the number of elements to which the
computation is to be applied.\footnote{The sentinel denoting the end of a range
may have the same type as the iterator denoting the beginning of the range, or a
different type.}

\pnum
An iterator and a sentinel denoting a range are comparable. \oldtxt{The types of a
sentinel and an iterator that denote a range must satisfy
\tcode{Sentinel}~(\ref{iterator.concept.incrementable}).}
A range \range{i}{s}
is empty if \tcode{i == s};
otherwise, \range{i}{s}
refers to the elements in the data structure starting with the element
pointed to by
\tcode{i}
and up to but not including the element pointed to by
the first iterator \tcode{j} such that \tcode{j == s}.

\pnum
A sentinel \tcode{s} is called \term{reachable} from an iterator \tcode{i} if
and only if there is a finite sequence of applications of the expression
\tcode{++i} that makes \tcode{i == s}. If \tcode{s} is reachable from \tcode{i},
\range{i}{s} denotes a range.

\pnum
A counted range \range{i}{n} is empty if \tcode{n == 0}; otherwise, \range{i}{n}
refers to the \tcode{n} elements in the data structure starting with the element
pointed to by \tcode{i} and up to but not including the element pointed to by
the result of incrementing \tcode{i} \tcode{n} times.

\pnum
A range \range{i}{s} is valid if and only if \tcode{s} is reachable from
\tcode{i}. A counted range \range{i}{n} is valid if and only if \tcode{n == 0};
or \tcode{n} is positive, \tcode{i} is dereferenceable, and \range{++i}{-{-}n}
is valid. The result of the application of functions in the library to invalid
ranges is undefined.
\end{addedblock}

\pnum
All the categories of iterators require only those functions that are realizable for a given category in
constant time (amortized).
Therefore, requirement tables \newtxt{and concept definitions} for the iterators do not \oldtxt{have a} \newtxt{specify} complexity \oldtxt{column}.

\pnum
Destruction of an iterator \newtxt{whose category is weaker than forward} may invalidate pointers and references
previously obtained from that iterator.

\pnum
An
\term{invalid}
iterator is an iterator that may be singular.\footnote{This definition applies to pointers, since pointers are iterators.
The effect of dereferencing an iterator that has been invalidated
is undefined.
}

\pnum
\indextext{iterator!constexpr}%
Iterators are called \defn{constexpr iterators}
if all operations provided to satisfy iterator category operations
are constexpr functions, except for
\begin{itemize}
\item \tcode{swap},
\item a pseudo-destructor call\cxxiref{expr.pseudo}, and
\item the construction of an iterator with a singular value.
\end{itemize}
\begin{note}
For example, the types ``pointer to \tcode{int}'' and
\tcode{reverse_iterator<int*>} are constexpr iterators.
\end{note}

\begin{removedblock}
\pnum
In the following sections,
\tcode{a}
and
\tcode{b}
denote values of type
\tcode{X} or \tcode{const X},
\tcode{difference_type} and \tcode{reference} refer to the
types \tcode{iterator_traits<X>::difference_type} and
\tcode{iterator_traits<X>::reference}, respectively,
\tcode{n}
denotes a value of
\tcode{difference_type},
\tcode{u},
\tcode{tmp},
and
\tcode{m}
denote identifiers,
\tcode{r}
denotes a value of
\tcode{X\&},
\tcode{t}
denotes a value of value type
\tcode{T},
\tcode{o}
denotes a value of some type that is writable to the output iterator.
\begin{note} For an iterator type \tcode{X} there must be an instantiation
of \tcode{iterator_traits<X>}\iref{iterator.traits}. \end{note}
\end{removedblock}

\ednote{Relocate [iterator.assoc.types] from the Ranges TS here, and modify as follows:}
\begin{addedblock}
\rSec2[iterator.assoc.types]{Associated types}

{\color{oldclr}
\pnum
To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
\tcode{WI} is the name of a type that
satisfies the \tcode{WeaklyIncrementable}
concept\iref{iterator.concept.weaklyincrementable},
\tcode{R} is the name of a type that
satisfies the \tcode{Readable} concept\iref{iterator.concept.readable}, and
\tcode{II} is the name of a type that satisfies the
\tcode{InputIterator} concept\iref{iterator.concept.input} concept, the types

\begin{codeblock}
difference_type_t<WI>
value_type_t<R>
iterator_category_t<II>
\end{codeblock}

be defined as the iterator's difference type, value type
and iterator category, respectively.
} %% \color{oldclr}

\ednote{Change the stable name of Ranges [iterator.assoc.types.difference_type] to [incrementable.traits] and modify as follows:}
\rSec3[incrementable.traits]{Incrementable traits}

{\color{newclr}
\pnum
To implement algorithms only in terms of incrementable types, it is often necessary to
determine the difference type that corresponds to a particular incrementable type.
Accordingly, it is required that if \tcode{WI} is the name of a type that
models the \tcode{WeaklyIncrementable} concept\iref{iterator.concept.weaklyincrementable},
the type

\begin{codeblock}
iter_difference_t<WI>
\end{codeblock}

be defined as the incrementable type's difference type.
} %% \color{newclr}

\pnum
\tcode{\newtxt{iter_}difference\oldtxt{_type}_t} is implemented as if:

\indexlibrary{\idxcode{iter_difference_t}}%
\indexlibrary{\idxcode{incrementable_traits}}%
\begin{codeblock}
@\newtxt{namespace std::ranges \{}@
  template<class> struct @\oldtxt{difference_type}\newtxt{incrementable_traits}@ { };

  @\oldtxt{template<class T>}@
  @\oldtxt{struct difference_type<T*>}@
    @\oldtxt{: enable_if<is_object<T>::value, ptrdiff_t> \{ \};}@

  @\newtxt{template<class T>}@
    @\newtxt{requires is_object_v<T>}@
  @\newtxt{struct incrementable_traits<T*> \{}@
    @\newtxt{using difference_type = ptrdiff_t;}@
  @\newtxt{\};}@

  template<class I>
  struct @\oldtxt{difference_type}\newtxt{incrementable_traits}@<const I>
    : @\oldtxt{difference_type}\newtxt{incrementable_traits}@<decay_t<I>> { };

  template<class T>
    requires requires { typename T::difference_type; }
  struct @\oldtxt{difference_type}\newtxt{incrementable_traits}@<T> {
    using @\newtxt{difference_}@type = typename T::difference_type;
  };

  template<class T>
    requires !requires { typename T::difference_type; } &&
      requires(const T& a, const T& b) { { a - b } -> Integral; }
  struct @\oldtxt{difference_type}\newtxt{incrementable_traits}@<T>
    @\oldtxt{: make_signed<decltype(declval<T>() - declval<T>())>}@ {
    @\newtxt{using difference_type = make_signed_t<decltype(declval<T>() - declval<T>())>;}@
  };

  template<class T>
    using @\newtxt{iter_}@difference@\oldtxt{_type}@_t @\newtxt{= \seebelownc;}@
      @\oldtxt{= typename difference_type<T>::type;}@
@\newtxt{\}}@
\end{codeblock}

{\color{newclr}
\pnum
If \tcode{iterator_traits<I>} does not name an instantiation of the primary
template, then \tcode{iter_difference_t<I>}
is an alias for the type \tcode{iterator_traits<I>::difference_type}; otherwise,
it is an alias for the type \tcode{incrementable_traits<I>::difference_type}.
} %% \color{newclr}

\pnum
Users may specialize \tcode{\oldtxt{difference_type}\newtxt{incrementable_traits}}
on user-defined types.

\ednote{Change the stable name of Ranges TS [iterator.assoc.types.value_type] to [readable.traits] and modify as follows:}
\rSec3[readable.traits]{Readable traits}

\pnum
\oldtxt{A \tcode{Readable} type has an associated value type that can be accessed with the
\tcode{value_type_t} alias template.}

{\color{newclr}
\pnum
To implement algorithms only in terms of readable types, it is often necessary to
determine the value type that corresponds to a particular readable type.
Accordingly, it is required that if \tcode{R} is the name of a type that
models the \tcode{Readable} concept\iref{iterator.concept.readable},
the type

\begin{codeblock}
iter_value_t<R>
\end{codeblock}

be defined as the readable type's value type.

\pnum
\tcode{iter_value_t} is implemented as if:
} %% \color{newclr}

\indexlibrary{\idxcode{iter_value_t}}%
\indexlibrary{\idxcode{readable_traits}}%
\begin{codeblock}
  @\newtxt{template<class> struct \placeholder{cond-value-type} \{ \}; // \expos}@
  @\newtxt{template<class T>}@
    @\newtxt{requires is_object_v<T>}@
  @\newtxt{struct \placeholder{cond-value-type} \{}@
    @\newtxt{using value_type = remove_cv_t<T>;}@
  @\newtxt{\};}@

  template<class> struct @\oldtxt{value_type}\newtxt{readable_traits}@ { };

  template<class T>
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<T*>
    : @\oldtxt{enable_if<is_object<T>::value, remove_cv_t<T>>}@
      @\newtxt{\placeholder{cond-value-type}<T>}@ { };

  template<class I>
    requires is_array@\newtxt{_v}@<I>@\oldtxt{::value}@
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<I>
    : @\oldtxt{value_type}\newtxt{readable_traits}@<decay_t<I>> { };

  template<class I>
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<const I>
    : @\oldtxt{value_type}\newtxt{readable_traits}@<@\oldtxt{decay}\newtxt{remove_const}@_t<I>> { };

  template<class T>
    requires requires { typename T::value_type; }
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<T>
    : @\oldtxt{enable_if<is_object<typename T::value_type>::value, typename T::value_type>}@
      @\newtxt{\placeholder{cond-value-type}<typename T::value_type>}@ { };

  template<class T>
    requires requires { typename T::element_type; }
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<T>
    : @\oldtxt{enable_if<}@
        @\oldtxt{is_object<typename T::element_type>::value,}@
        @\oldtxt{remove_cv_t<typename T::element_type>>}@
      @\newtxt{\placeholder{cond-value-type}<typename T::element_type>}@ { };

  template<class T> using @\oldtxt{value_type_t}\newtxt{iter_value_t = // \seebelownc;}@
    @\oldtxt{= typename value_type<T>::type;}@
\end{codeblock}

{\color{newclr}
\pnum
If \tcode{iterator_traits<I>} does not name an instantiation of the primary
template, then \tcode{iter_value_t<I>} is an
alias for the type \tcode{iterator_traits<I>::value_type}; otherwise, it is an
alias for the type \tcode{readable_traits<I>::value_type}.
} %% \color{newclr}

\pnum
\oldtxt{If a type \tcode{I} has an associated value type, then \tcode{value_type<I>::type}
shall name the value type. Otherwise, there shall be no nested type \tcode{type}.}

\pnum
Class template \tcode{\oldtxt{value_type}\newtxt{readable_traits}} may be
specialized on user-defined types.

\pnum
\oldtxt{When instantiated with a type \tcode{I}
such that \tcode{I::value_type} is valid and denotes a type,
\tcode{value_type<I>::type} names that type, unless it is not an object type\cxxiref{basic.types} in which case
\tcode{value_type<I>} shall have no nested type \tcode{type}.}
\begin{note}
Some legacy output
iterators define a nested type named \tcode{value_type} that is an alias for \tcode{void}. These
types are not \tcode{Readable} and have no associated value types.
\end{note}

\pnum
\oldtxt{When instantiated with a type \tcode{I}
such that \tcode{I::element_type} is valid and denotes a type,
\tcode{value_type<I>::\brk{}type} names the type \tcode{remove_cv_t<I::element_type>}, unless it is
not an object type\cxxiref{basic.types} in which case
\tcode{value_type<I>} shall have no nested type \tcode{type}.}
\begin{note}
Smart pointers like
\tcode{shared_ptr<int>} are \tcode{Readable} and have an associated value type.
But a smart pointer like \tcode{shared_ptr<void>} is not \tcode{Readable} and
has no associated value type.
\end{note}
\end{addedblock}

\ednote{Subclauses [iterator.assoc.types.iterator_category], [iterator.traits], [iterator.stdtraits], and [std.iterator.tags] from the Ranges TS are intentionally ommitted.}

\ednote{Relocate the working draft's [iterator.traits] from
[iterator.primitives] to here and change it as follows:}
\rSec3[iterator.traits]{Iterator traits}

\pnum
\indexlibrary{\idxcode{iterator_traits}}%
To implement algorithms only in terms of iterators, it is \oldtxt{often}\newtxt{sometimes}
necessary to determine the \oldtxt{value and
difference types}\newtxt{iterator category} that correspond\newtxt{s} to a particular
iterator type. Accordingly, it is required that if
\tcode{\oldtxt{Iterator}\newtxt{I}} is the type of an iterator, the type\oldtxt{s}

\indexlibrarymember{iterator_category}{iterator_traits}%
\begin{codeblock}
@\oldtxt{iterator_traits<Iterator>::difference_type}@
@\oldtxt{iterator_traits<Iterator>::value_type}@
iterator_traits<@\oldtxt{Iterator}\newtxt{I}@>::iterator_category
\end{codeblock}

be defined as the iterator's \oldtxt{difference type, value type
and} iterator category\oldtxt{, respectively}.
In addition, the types

\indexlibrarymember{reference}{iterator_traits}%
\indexlibrarymember{pointer}{iterator_traits}%
\begin{codeblock}
iterator_traits<@\oldtxt{Iterator}\newtxt{I}@>::reference
iterator_traits<@\oldtxt{Iterator}\newtxt{I}@>::pointer
\end{codeblock}

shall be defined as the iterator's reference and pointer types\oldtxt{,}\newtxt{;} that is, for an
iterator object \tcode{a}, the same type as the type of \tcode{*a} and \tcode{a->},
respectively. \newtxt{The type }\tcode{\newtxt{iterator_traits<I>::pointer}}\newtxt{ shall be
\tcode{void} for a type \tcode{I} that does not support \tcode{operator->}.
Additionally, i}\oldtxt{I}n the case of an output iterator, the types

\begin{codeblock}
iterator_traits<@\oldtxt{Iterator}\newtxt{I}@>::difference_type
iterator_traits<@\oldtxt{Iterator}\newtxt{I}@>::value_type
iterator_traits<@\oldtxt{Iterator}\newtxt{I}@>::reference
@\oldtxt{iterator_traits<Iterator>::pointer}@
\end{codeblock}

may be defined as \tcode{void}.

{\color{newclr}
\pnum
The member types of the primary template are computed as defined below.
The definition below makes use of several exposition-only concepts equivalent
to the following:

\begin{codeblock}
template<class I>
concept @\placeholder{_Cpp17Iterator}@ =
  Copyable<I> && requires (I i) {
    { *i } -> auto &&;
    { ++i } -> Same<I>&;
    { *i++ } -> auto &&;
  };

template<class I>
concept @\placeholder{_Cpp17InputIterator}@ =
  @\placeholder{_Cpp17Iterator}@<I> && EqualityComparable<I> && requires (I i) {
    typename incrementable_traits<I>::difference_type;
    typename readable_traits<I>::value_type;
    typename common_reference_t<iter_reference_t<I> &&,
                                typename readable_traits<I>::value_type &>;
    typename common_reference_t<decltype(*i++) &&,
                                typename readable_traits<I>::value_type &>;
    requires SignedIntegral<typename incrementable_traits<I>::difference_type>;
  };

template<class I>
concept @\placeholder{_Cpp17ForwardIterator}@ =
  @\placeholder{_Cpp17InputIterator}@<I> && Constructible<I> &&
  Same<remove_cvref_t<iter_reference_t<I>>, typename readable_traits<I>::value_type> &&
  requires (I i) {
    { i++ } -> const I&;
    requires Same<iter_reference_t<I>, decltype(*i++)>;
  };

template<class I>
concept @\placeholder{_Cpp17BidirectionalIterator}@ =
  @\placeholder{_Cpp17ForwardIterator}@<I> && requires (I i) {
    { --i } -> Same<I>&;
    { i-- } -> const I&;
    requires Same<iter_reference_t<I>, decltype(*i--)>;
  };

template<class I>
concept @\placeholder{_Cpp17RandomAccessIterator}@ =
  @\placeholder{_Cpp17BidirectionalIterator}@<I> && StrictTotallyOrdered<I> &&
  requires (I i, typename incrementable_traits<I>::difference_type n) {
    { i += n } -> Same<I>&;
    { i -= n } -> Same<I>&;
    requires Same<I, decltype(i + n)>;
    requires Same<I, decltype(n + i)>;
    requires Same<I, decltype(i - n)>;
    requires Same<decltype(n), decltype(i - i)>;
    { i[n] } -> iter_reference_t<I>;
  };
\end{codeblock}
} %% \color{newclr}

\begin{itemize}
\item
If \tcode{\oldtxt{Iterator}\newtxt{I}} has valid\cxxiref{temp.deduct} member
types \tcode{difference_type}, \tcode{value_type}, \oldtxt{\tcode{pointer},}
\tcode{reference}, and \tcode{iterator_category},
\tcode{iterator_traits<\oldtxt{Iterator}\newtxt{I}>}
shall have the following as publicly accessible members:
\begin{codeblock}
  using difference_type   = typename @\oldtxt{Iterator}\newtxt{I}@::difference_type;
  using value_type        = typename @\oldtxt{Iterator}\newtxt{I}@::value_type;
  using pointer           = @\oldtxt{typename Iterator::pointer}\newtxt{\seebelownc}@;
  using reference         = typename @\oldtxt{Iterator}\newtxt{I}@::reference;
  using iterator_category = typename @\oldtxt{Iterator}\newtxt{I}@::iterator_category;
\end{codeblock}
\newtxt{If \tcode{I} has a valid member type \tcode{pointer}, then
}\tcode{\newtxt{iterator_traits<I>::pointer}}\newtxt{ names that type; otherwise, it
names \tcode{void}.}

{\color{newclr}
\item
Otherwise, if \tcode{I} satisfies the exposition-only concept
\tcode{\placeholder{_Cpp17InputIterator}}, \tcode{iterator_traits<I>} shall
have the following as publicly accessible members:
\begin{codeblock}
  using difference_type   = typename incrementable_traits<I>::difference_type;
  using value_type        = typename readable_traits<I>::value_type;
  using pointer           = @\seebelownc@;
  using reference         = @\seebelownc@;
  using iterator_category = @\seebelownc@;
\end{codeblock}
If \tcode{I::pointer} is well-formed and names a type, \tcode{pointer} names
that type. Otherwise, if \tcode{decltype(\brk{}declval<I\&>().operator->())}
is well-formed, then \tcode{pointer} names that type. \oldtxt{Otherwise, if
}\tcode{\oldtxt{iter_reference_t<I>}}\oldtxt{ is an lvalue reference type, \tcode{pointer}
is }\tcode{\oldtxt{add_pointer_t<iter_reference_t<I>>}}\oldtxt{.} Otherwise, \tcode{pointer}
is \tcode{void}.

If \tcode{I::reference} is well-formed and names a type, \tcode{reference}
names that type. Otherwise, \tcode{reference} is \tcode{iter_reference_t<I>}.

If \tcode{I::iterator_category} is well-formed and names a type,
\tcode{iterator_category} names that type. Otherwise, if \tcode{I}
satisfies \tcode{\placeholder{_Cpp17RandomAccessIterator}}, \tcode{iterator_category}
is \tcode{random_access_iterator_tag}. Otherwise, if \tcode{I}
satisfies \tcode{\placeholder{_Cpp17BidirectionalIterator}}, \tcode{iterator_category}
is \tcode{bidirectional_iterator_tag}. Otherwise, if \tcode{I}
satisfies \tcode{\placeholder{_Cpp17ForwardIterator}}, \tcode{iterator_category}
is \tcode{forward_iterator_tag}. Otherwise, \tcode{iterator_category}
is \tcode{input_iterator_tag}.

\item
Otherwise, if \tcode{I} satisfies the exposition-only concept
\tcode{\placeholder{_Cpp17Iterator}}, \tcode{iterator_traits<I>} shall
have the following as publicly accessible members:
\begin{codeblock}
  using difference_type   = @\seebelownc@;
  using value_type        = void;
  using pointer           = void;
  using reference         = void;
  using iterator_category = output_iterator_tag;
\end{codeblock}
If \tcode{incrementable_traits<I>::difference_type} is well-formed
and names a type, then \tcode{difference_type} names that type; otherwise, it is
\tcode{void}.
} %% \color{newclr}

\item
Otherwise, \tcode{iterator_traits<\oldtxt{Iterator}\newtxt{I}>}
shall have no members by any of the above names.
\end{itemize}

{\color{newclr}
\pnum
Additionally, user specializations of \tcode{iterator_traits} may have a member
type \tcode{iterator_concept} that is used to opt in or out of conformance to the
iterator concepts defined in~\ref{iterator.concepts}. If specified, it should be
an alias for one of the standard iterator tag types\iref{std.iterator.tags},
or an empty, copy- and move-constructible, trivial class type that is publicly
and unambiguously derived from one of the standard iterator tag types.
} %% \color{newclr}

\pnum
\oldtxt{It}\tcode{\newtxt{iterator_traits}} is specialized for pointers as

\begin{codeblock}
namespace std {
  template<class T> struct iterator_traits<T*> {
    using difference_type   = ptrdiff_t;
    using value_type        = remove_cv_t<T>;
    using pointer           = T*;
    using reference         = T&;
    using iterator_category = random_access_iterator_tag;
    @\newtxt{using iterator_concept}\newtxt{ }\newtxt{ }\newtxt{= contiguous_iterator_tag;}@
  };
}
\end{codeblock}

\pnum
\begin{example}
To implement a generic
\tcode{reverse}
function, a \Cpp{} program can do the following:

\begin{codeblock}
template<class BidirectionalIterator>
void reverse(BidirectionalIterator first, BidirectionalIterator last) {
  typename iterator_traits<BidirectionalIterator>::difference_type n =
    distance(first, last);
  --n;
  while(n > 0) {
    typename iterator_traits<BidirectionalIterator>::value_type
     tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
\end{codeblock}
\end{example}

\begin{addedblock}
\ednote{Relocate [iterator.custpoints] here from the Ranges TS and modify as follows:}
\rSec2[iterator.custpoints]{Customization points}

\rSec3[iterator.custpoints.iter_move]{\tcode{iter_move}}

\pnum
The name \tcode{iter_move} denotes a \term{customization point
object}\cxxiref{customization.point.object}. The expression
\tcode{ranges::iter_move(E)} for some subexpression \tcode{E} is expression-equivalent to the
following:

\begin{itemize}
\item \tcode{\oldtxt{static_cast<decltype(iter_move(E))>(}iter_move(E)\oldtxt{)}}, if that expression
is well-formed when evaluated in a context that does not include
\tcode{ranges::iter_move} but does include the
lookup set produced by argument-dependent lookup\cxxiref{basic.lookup.argdep}.

\item Otherwise, if the expression \tcode{*E} is well-formed:
\begin{itemize}
\item if \tcode{*E} is an lvalue, \tcode{std::move(*E)};

\item otherwise, \tcode{\oldtxt{static_cast<decltype(*E)>(}*E\oldtxt{)}}.
\end{itemize}

\item Otherwise, \tcode{ranges::iter_move(E)} is ill-formed.
\end{itemize}

\pnum
If \tcode{ranges::iter_move(E)} does not equal \tcode{*E}, the program is
ill-formed with no diagnostic required.

\rSec3[iterator.custpoints.iter_swap]{\tcode{iter_swap}}

\pnum
The name \tcode{iter_swap} denotes a \term{customization point
object}\cxxiref{customization.point.object}. The expression
\tcode{ranges::iter_swap(E1, E2)} for some subexpressions \tcode{E1} and \tcode{E2}
is expression-equivalent to the following:

\begin{itemize}
\item \tcode{(void)iter_swap(E1, E2)}, if that expression is well-formed when
evaluated in a context that does not include \tcode{ranges::iter_swap} but does
include the lookup set produced by argument-dependent
lookup\cxxiref{basic.lookup.argdep} and the following declaration:
\begin{codeblock}
@\newtxt{template<class I1, class I2>}@
void iter_swap(@\oldtxt{auto, auto}\newtxt{I1, I2}@) = delete;
\end{codeblock}

\item Otherwise, if the types of \tcode{E1} and \tcode{E2} both \oldtxt{satisfy}\newtxt{model}
\tcode{Readable}, and if the reference type of \tcode{E1} is swappable
with\iref{concept.swappable} the reference type of \tcode{E2},
then \tcode{ranges::swap(*E1, *E2)}

\item Otherwise, if the types \tcode{T1} and \tcode{T2} of \tcode{E1} and
\tcode{E2} \oldtxt{satisfy}\newtxt{model} \tcode{IndirectlyMovableStorable<T1, T2> \&\&
IndirectlyMovableStorable<T2, T1>}, \tcode{(void)(*E1 = \placeholdernc{iter-exchange-move}(E2, E1))},
except that \tcode{E1} is evaluated only once.

\item Otherwise, \tcode{ranges::iter_swap(E1, E2)} is ill-formed.
\end{itemize}

\pnum
If \tcode{ranges::iter_swap(E1, E2)} does not swap the values denoted by the
expressions \tcode{E1} and \tcode{E2}, the program is ill-formed with no
diagnostic required.

\pnum
\tcode{\placeholder{iter-exchange-move}} is an exposition-only function specified as:
\begin{itemdecl}
template<class X, class Y>
  constexpr @\newtxt{iter_}@value@\oldtxt{_type}@_t<remove_reference_t<X>> @\placeholdernc{iter-exchange-move}@(X&& x, Y&& y)
    noexcept(@\seebelownc@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
@\newtxt{iter_}@value@\oldtxt{_type}@_t<remove_reference_t<X>> old_value(iter_move(x));
*x = iter_move(y);
return old_value;
\end{codeblock}

\pnum
\remarks The expression in the \tcode{noexcept} is equivalent to:
\begin{codeblock}
NE(remove_reference_t<X>, remove_reference_t<Y>) &&
NE(remove_reference_t<Y>, remove_reference_t<X>)
\end{codeblock}
Where \tcode{NE(T1, T2)} is the expression:
\begin{codeblock}
is_nothrow_constructible@\newtxt{_v}@<@\newtxt{iter_}@value@\oldtxt{_type}@_t<T1>, @\newtxt{iter_}@rvalue_reference_t<T1>>@\oldtxt{::value}@ &&
is_nothrow_assignable@\newtxt{_v}@<@\newtxt{iter_}@value@\oldtxt{_type}@_t<T1>&, @\newtxt{iter_}@rvalue_reference_t<T1>>@\oldtxt{::value}@ &&
is_nothrow_assignable@\newtxt{_v}@<@\newtxt{iter_}@reference_t<T1>, @\newtxt{iter_}@rvalue_reference_t<T2>>@\oldtxt{::value}@ &&
is_nothrow_assignable@\newtxt{_v}@<@\newtxt{iter_}@reference_t<T1>, @\newtxt{iter_}@value@\oldtxt{_type}@_t<T2>>@\oldtxt{::value}@> &&
is_nothrow_move_constructible@\newtxt{_v}@<@\newtxt{iter_}@value@\oldtxt{_type}@_t<T1>>@\oldtxt{::value}@ &&
noexcept(ranges::iter_move(declval<T1&>()))
\end{codeblock}
\end{itemdescr}

\ednote{The Ranges TS concept definitions \libconcept{Readable} through
\libconcept{RandomAccessIterator} and P0944's \libconcept{ContiguousIterator}
concept all get moved into a new section [iterator.concepts]:}

\rSec2[iterator.concepts]{Iterator concepts}

{\color{newclr}
\rSec3[iterator.concepts.general]{General}

\pnum
Many of the concepts defined in this subclause\iref{iterator.concepts} use the
exposition-only type function \placeholder{ITER_CONCEPT} in their specifications.

\pnum
For a type \tcode{I}, let \tcode{\placeholdernc{ITER_TRAITS}(I)} denote the type
\tcode{I} if \tcode{iterator_traits<I>} names an instantiation of the primary
template. Otherwise, \tcode{\placeholdernc{ITER_TRAITS}(I)} denotes
\tcode{iterator_traits<I>}.
\begin{itemize}
\item If the \grammarterm{qualified-id}
  \tcode{\placeholdernc{ITER_TRAITS}(I)::iterator_concept} is valid
  and names a type, then \tcode{\placeholdernc{ITER_CONCEPT}(I)} denotes that
  type.
\item Otherwise, if \tcode{\placeholdernc{ITER_TRAITS}(I)\brk{}::iterator_category}
  is valid and names a type, then \tcode{\placeholdernc{ITER_CONCEPT}(I)}
  denotes that type.
\item Otherwise, if \tcode{iterator_traits<I>} names an instantiation of
  the primary template, then \tcode{\placeholdernc{ITER_CONCEPT}(I)} denotes
  \tcode{random_access_iterator_tag}.
\item Otherwise, \tcode{\placeholdernc{ITER_CONCEPT}(I)} does not denote a type.
\end{itemize}
} %% \color{newclr}

\rSec3[iterator.concept.readable]{Concept \libconcept{Readable}}

\pnum
The \libconcept{Readable} concept is satisfied by types that are readable by
applying \tcode{operator*} including pointers, smart pointers, and iterators.

\indexlibrary{\idxcode{Readable}}%
\begin{codeblock}
  template<class In>
  concept @\oldtxt{bool}@ Readable =
    requires {
      typename @\newtxt{iter_}@value@\oldtxt{_type}@_t<In>;
      typename @\newtxt{iter_}@reference_t<In>;
      typename @\newtxt{iter_}@rvalue_reference_t<In>;
    } &&
    CommonReference<@\newtxt{iter_}@reference_t<In>&&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<In>&> &&
    CommonReference<@\newtxt{iter_}@reference_t<In>&&, @\newtxt{iter_}@rvalue_reference_t<In>&&> &&
    CommonReference<@\newtxt{iter_}@rvalue_reference_t<In>&&, const @\newtxt{iter_}@value@\oldtxt{_type}@_t<In>&>;
\end{codeblock}

{\color{newclr}
\pnum
Given a value \tcode{i} of type \tcode{I}, \tcode{\libconcept{Readable}<I>} is satisfied only
if the expression \tcode{*i} (which is indirectly required to be valid via the
exposition-only \placeholder{dereferenceable} concept\iref{range.synopsis}) is
equality-preserving.
} % \color{newclr}

\rSec3[iterator.concept.writable]{Concept \tcode{Writable}}

\pnum
The \tcode{Writable} concept specifies the requirements for writing a value into an iterator's
referenced object.

\indexlibrary{\idxcode{Writable}}%
\begin{codeblock}
  template<class Out, class T>
  concept @\oldtxt{bool}@ Writable =
    requires(Out&& o, T&& t) {
      *o = std::forward<T>(t); // not required to be equality-preserving
      *std::forward<Out>(o) = std::forward<T>(t); // not required to be equality-preserving
      const_cast<const @\newtxt{iter_}@reference_t<Out>&&>(*o) =
        std::forward<T>(t); // not required to be equality-preserving
      const_cast<const @\newtxt{iter_}@reference_t<Out>&&>(*std::forward<Out>(o)) =
        std::forward<T>(t); // not required to be equality-preserving
    };
\end{codeblock}

\pnum
Let \tcode{E} be an an expression such that \tcode{decltype((E))} is \tcode{T}, and let \tcode{o}
be a dereferenceable object of type \tcode{Out}. \tcode{Writable<Out, T>} is satisfied only if

\begin{itemize}
\item If \tcode{Readable<Out> \&\& Same<\newtxt{iter_}value\oldtxt{_type}_t<Out>, decay_t<T>{>}} is satisfied,
then \tcode{*o} after any above assignment is equal
to the value of \tcode{E} before the assignment.
\end{itemize}

\pnum
After evaluating any above assignment expression, \tcode{o} is not required to be dereferenceable.

\pnum
If \tcode{E} is an xvalue\cxxiref{basic.lval}, the resulting
state of the object it denotes is valid but unspecified\cxxiref{lib.types.movedfrom}.

\pnum
\begin{note}
The only valid use of an \tcode{operator*} is on the left side of the assignment statement.
\textit{Assignment through the same value of the writable type happens only once.}
\end{note}

\rSec3[iterator.concept.weaklyincrementable]{Concept \tcode{WeaklyIncrementable}}

\pnum
The \tcode{WeaklyIncrementable} concept specifies the requirements on
types that can be incremented with the pre- and post-increment operators.
The increment operations are not required to be equality-preserving,
nor is the type required to be \libconcept{EqualityComparable}.

\indexlibrary{\idxcode{WeaklyIncrementable}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ WeaklyIncrementable =
    Semiregular<I> &&
    requires(I i) {
      typename @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>;
      requires SignedIntegral<@\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>>;
      { ++i } -> Same<I>&; // not required to be equality-preserving
      i++; // not required to be equality-preserving
    };
\end{codeblock}

\pnum
Let \tcode{i} be an object of type \tcode{I}. When \tcode{i} is in the domain of
both pre- and post-increment, \tcode{i} is said to be \term{incrementable}.
\tcode{WeaklyIncrementable<I>} is satisfied only if

\begin{itemize}
\item The expressions \tcode{++i} and \tcode{i++} have the same domain.
\item If \tcode{i} is incrementable, then both \tcode{++i}
  and \tcode{i++} advance \tcode{i} to the next element.
\item If \tcode{i} is incrementable, then
  \tcode{\oldtxt{\&}\newtxt{addressof(}++i\newtxt{)}} is equal to
  \tcode{\oldtxt{\&}\newtxt{addressof(}i\newtxt{)}}.
\end{itemize}

\pnum
\begin{note}
For \tcode{WeaklyIncrementable} types, \tcode{a} equals \tcode{b} does not imply that \tcode{++a}
equals \tcode{++b}. (Equality does not guarantee the substitution property or referential
transparency.) Algorithms on weakly incrementable types should never attempt to pass
through the same incrementable value twice. They should be single pass algorithms. These algorithms
can be used with istreams as the source of the input data through the \tcode{istream_iterator} class
template.
\end{note}

\rSec3[iterator.concept.incrementable]{Concept \tcode{Incrementable}}

\pnum
The \tcode{Incrementable} concept specifies requirements on types that can be incremented with the pre-
and post-increment operators. The increment operations are required to be equality-preserving,
and the type is required to be \libconcept{EqualityComparable}.
\begin{note}
This requirement
supersedes the annotations on the increment expressions in the definition of
\tcode{WeaklyIncrementable}.
\end{note}

\indexlibrary{\idxcode{Incrementable}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ Incrementable =
    Regular<I> &&
    WeaklyIncrementable<I> &&
    requires(I i) {
      @\oldtxt{\{ i++ \} -> Same<I>\&\&;}@
      @\newtxt{i++; requires Same<decltype(i++), I>;}@
    };
\end{codeblock}

\pnum
Let \tcode{a} and \tcode{b} be incrementable objects of type \tcode{I}.
\tcode{Incrementable<I>} is satisfied only if

\begin{itemize}
\item If \tcode{bool(a == b)} then \tcode{bool(a++ == b)}.
\item If \tcode{bool(a == b)} then \tcode{bool((\newtxt{(void)}a++, a) == ++b)}.
\end{itemize}

\pnum
\begin{note}
The requirement that \tcode{a} equals \tcode{b} implies \tcode{++a} equals \tcode{++b}
(which is not true for weakly incrementable types) allows the use of multi-pass one-directional
algorithms with types that satisfy \tcode{Increment\-able}.
\end{note}

\rSec3[iterator.concept.iterator]{Concept \tcode{Iterator}}

\pnum
The \tcode{Iterator} concept forms
the basis of the iterator concept taxonomy; every iterator satisfies the
\tcode{Iterator} requirements. This
concept specifies operations for dereferencing and incrementing
an iterator. Most algorithms will require additional operations
to compare iterators with sentinels\iref{iterator.concept.sentinel}, to
read\iref{iterator.concept.input} or write\iref{iterator.concept.output} values, or
to provide a richer set of iterator movements (\ref{iterator.concept.forward},
\ref{iterator.concept.bidirectional}, \ref{iterator.concept.random.access}).)

\indexlibrary{\idxcode{Iterator}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ Iterator =
    requires(I i) {
      { *i } -> auto&&; // Requires: i is dereferenceable
    } &&
    WeaklyIncrementable<I>;
\end{codeblock}

\pnum
\begin{note}
The requirement that the result of dereferencing the iterator is deducible from
\tcode{auto\&\&} means that it cannot be \tcode{void}.
\end{note}

\rSec3[iterator.concept.sentinel]{Concept \tcode{Sentinel}}

\pnum
The \tcode{Sentinel} concept
specifies the relationship
between an \tcode{Iterator} type and a \libconcept{Semiregular} type whose values
denote a range.

\indexlibrary{\idxcode{Sentinel}}%
\begin{itemdecl}
  template<class S, class I>
  concept @\oldtxt{bool}@ Sentinel =
    Semiregular<S> &&
    Iterator<I> &&
    @\placeholder{weakly-equality-comparable-with}@<S, I>; @\newtxt{// See \cxxref{concept.equalitycomparable}}@
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{s} and \tcode{i} be values of type \tcode{S} and
\tcode{I} such that \range{i}{s} denotes a range. Types
\tcode{S} and \tcode{I} satisfy \tcode{Sentinel<S, I>} only if:

\begin{itemize}
\item \tcode{i == s} is well-defined.

\item If \tcode{bool(i != s)} then \tcode{i} is dereferenceable and
      \range{++i}{s} denotes a range.
\end{itemize}
\end{itemdescr}

\pnum
The domain of \tcode{==} can change over time.
Given an iterator \tcode{i} and sentinel \tcode{s} such that \range{i}{s}
denotes a range and \tcode{i != s}, \range{i}{s} is not required to continue to
denote a range after incrementing any iterator equal to \tcode{i}. Consequently,
\tcode{i == s} is no longer required to be well-defined.

\rSec3[iterator.concept.sizedsentinel]{Concept \tcode{SizedSentinel}}

\pnum
The \tcode{SizedSentinel} concept specifies
requirements on an \tcode{Iterator} and a \tcode{Sentinel}
that allow the use of the \tcode{-} operator to compute the distance
between them in constant time.

\indexlibrary{\idxcode{SizedSentinel}}%

\begin{itemdecl}
  template<class S, class I>
  concept @\oldtxt{bool}@ SizedSentinel =
    Sentinel<S, I> &&
    !disable_sized_sentinel<remove_cv_t<S>, remove_cv_t<I>> &&
    requires(const I& i, const S& s) {
      @\oldtxt{\{ s - i \} -> Same<difference_type_t<I>>\&\&;}@
      @\newtxt{s - i; requires Same<decltype(s - i), iter_difference_t<I>>;}@
      @\oldtxt{\{ i - s \} -> Same<difference_type_t<I>>\&\&;}@
      @\newtxt{i - s; requires Same<decltype(i - s), iter_difference_t<I>>}@
    };
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{i} be an iterator of type \tcode{I}, and \tcode{s}
a sentinel of type \tcode{S} such that \range{i}{s} denotes a range.
Let $N$ be the smallest number of applications of \tcode{++i}
necessary to make \tcode{bool(i == s)} be \tcode{true}.
\tcode{SizedSentinel<S, I>} is satisfied only if:

\begin{itemize}
\item If $N$ is representable by \tcode{\newtxt{iter_}difference\oldtxt{_type}_t<I>},
      then \tcode{s - i} is well-defined and equals $N$.

\item If $-N$ is representable by \tcode{\newtxt{iter_}difference\oldtxt{_type}_t<I>},
      then \tcode{i - s} is well-defined and equals $-N$.
\end{itemize}
\end{itemdescr}

\pnum
\begin{note}
\tcode{disable_sized_sentinel} provides a mechanism to
enable use of sentinels and iterators with the library that meet the
syntactic requirements but do not in fact satisfy \tcode{SizedSentinel}.
A program that instantiates a library template that requires
\tcode{SizedSentinel} with an iterator type \tcode{I} and sentinel type
\tcode{S} that meet the syntactic requirements of \tcode{SizedSentinel<S, I>}
but do not satisfy \tcode{SizedSentinel} is ill-formed with no diagnostic required
\oldtxt{unless \tcode{disable_sized_sentinel<S, I>} evaluates to
\tcode{true}}\cxxiref{structure.requirements}.
\end{note}

\pnum
\begin{note}
The \tcode{SizedSentinel} concept is satisfied by pairs of
\tcode{RandomAccessIterator}s\iref{iterator.concept.random.access} and by
counted iterators and their sentinels\iref{counted.iterator}.
\end{note}

\rSec3[iterator.concept.input]{Concept \tcode{InputIterator}}

\pnum
The \tcode{InputIterator} concept is a refinement of
\tcode{Iterator}\iref{iterator.concept.iterator}. It defines requirements for a type
whose referenced values can be read (from the requirement for
\tcode{Readable}\iref{iterator.concept.readable}) and which can be both pre- and
post-incremented.
\begin{note}
\oldtxt{Unlike in ISO/IEC 14882, input iterators are not required to satisfy
\libconcept{EqualityComparable}~(\cxxref{concept.equalitycomparable}).}
\newtxt{Unlike the input iterator requirements in \ref{input.iterators},
the \tcode{InputIterator} concept does not require equality comparison}.
\end{note}

\indexlibrary{\idxcode{InputIterator}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ InputIterator =
    Iterator<I> &&
    Readable<I> &&
    requires { typename @\oldtxt{iterator_category_t<I>}\placeholdernc{\newtxt{ITER_CONCEPT}}\newtxt{(I)}@; } &&
    DerivedFrom<@\oldtxt{iterator_category_t<I>}\placeholdernc{\newtxt{ITER_CONCEPT}}\newtxt{(I)}@, input_iterator_tag>;
\end{codeblock}

\rSec3[iterator.concept.output]{Concept \tcode{OutputIterator}}

\pnum
The \tcode{OutputIterator} concept is a refinement of
\tcode{Iterator}\iref{iterator.concept.iterator}. It defines requirements for a type that
can be used to write values (from the requirement for
\tcode{Writable}\iref{iterator.concept.writable}) and which can be both pre- and post-incremented.
However, output iterators are not required to
satisfy \libconcept{EqualityComparable}.

\indexlibrary{\idxcode{OutputIterator}}%
\begin{codeblock}
  template<class I, class T>
  concept @\oldtxt{bool}@ OutputIterator =
    Iterator<I> &&
    Writable<I, T> &&
    requires(I i, T&& t) {
      *i++ = std::forward<T>(t); // not required to be equality-preserving
    };
\end{codeblock}

\pnum
Let \tcode{E} be an expression such that \tcode{decltype((E))} is \tcode{T}, and let \tcode{i} be a
dereferenceable object of type \tcode{I}. \tcode{OutputIterator<I, T>} is satisfied only if
\tcode{*i++ = E;} has effects equivalent to:
\begin{codeblock}
  *i = E;
  ++i;
\end{codeblock}

\pnum
\begin{note}
Algorithms on output iterators should never attempt to pass through the same iterator twice.
They should be
\term{single pass}
algorithms.
\end{note}

\rSec3[iterator.concept.forward]{Concept \tcode{ForwardIterator}}

\pnum
The \tcode{ForwardIterator} concept refines \tcode{InputIterator}\iref{iterator.concept.input},
adding equality comparison and the multi-pass guarantee, specified below.

\indexlibrary{\idxcode{ForwardIterator}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ ForwardIterator =
    InputIterator<I> &&
    DerivedFrom<@\oldtxt{iterator_category_t<I>}\placeholdernc{\newtxt{ITER_CONCEPT}}\newtxt{(I)}@, forward_iterator_tag> &&
    Incrementable<I> &&
    Sentinel<I, I>;
\end{codeblock}

\pnum
The domain of \tcode{==} for forward iterators is that of iterators over the same
underlying sequence. However, value-initialized iterators of the same type
may be compared and shall compare equal to other value-initialized iterators of the same type.
\begin{note}
Value-initialized iterators behave as if they refer past the end of the same
empty sequence.
\end{note}

\pnum
Pointers and references obtained from a forward iterator into a range \range{i}{s}
shall remain valid while \range{i}{s} continues to denote a range.

\pnum
Two dereferenceable iterators \tcode{a} and \tcode{b} of type \tcode{X} offer the
\defn{multi-pass guarantee} if:

\begin{itemize}
\item \tcode{a == b} implies \tcode{++a == ++b} and
\item The expression
\tcode{([](X x)\{++x;\}(a), *a)} is equivalent to the expression \tcode{*a}.
\end{itemize}

\pnum
\begin{note}
The requirement that
\tcode{a == b}
implies
\tcode{++a == ++b}
(which is not true for weaker iterators)
and the removal of the restrictions on the number of assignments through
a mutable iterator
(which applies to output iterators)
allow the use of multi-pass one-directional algorithms with forward iterators.
\end{note}

\rSec3[iterator.concept.bidirectional]{Concept \tcode{BidirectionalIterator}}

\pnum
The \tcode{BidirectionalIterator} concept refines \tcode{ForwardIterator}\iref{iterator.concept.forward},
and adds the ability to move an iterator backward as well as forward.

\indexlibrary{\idxcode{BidirectionalIterator}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ BidirectionalIterator =
    ForwardIterator<I> &&
    DerivedFrom<@\oldtxt{iterator_category_t<I>}\placeholdernc{\newtxt{ITER_CONCEPT}}\newtxt{(I)}@, bidirectional_iterator_tag> &&
    requires(I i) {
      { --i } -> Same<I>&;
      @\oldtxt{\{ i-- \} -> Same<I>\&\&;}@
      @\newtxt{i--; requires Same<decltype(i--), I>;}@
    };
\end{codeblock}

\pnum
A bidirectional iterator \tcode{r} is decrementable if and only if there exists some \tcode{s} such that
\tcode{++s == r}. Decrementable iterators \tcode{r} shall be in the domain of the expressions
\tcode{\dcr{}r} and \tcode{r\dcr{}}.

\pnum
Let \tcode{a} and \tcode{b} be decrementable objects of type \tcode{I}.
\tcode{BidirectionalIterator<I>} is satisfied only if:

\begin{itemize}
\item \tcode{\oldtxt{\&}\newtxt{addressof(}\dcr{}a\newtxt{)} == \oldtxt{\&}\newtxt{addressof(}a\newtxt{)}}.
\item If \tcode{bool(a == b)}, then \tcode{bool(a\dcr{} == b)}.
\item If \tcode{bool(a == b)}, then after evaluating both \tcode{a\dcr} and \tcode{\dcr{}b},
\tcode{bool(a == b)} still holds.
\item If \tcode{a} is incrementable and \tcode{bool(a == b)}, then
      \tcode{bool(\dcr{}(++a) == b)}.
\item If \tcode{bool(a == b)}, then \tcode{bool(++(\dcr{}a) == b)}.
\end{itemize}

\rSec3[iterator.concept.random.access]{Concept \tcode{RandomAccessIterator}}

\pnum
The \tcode{RandomAccessIterator} concept refines \tcode{BidirectionalIterator}\iref{iterator.concept.bidirectional}
and adds support for constant-time advancement with \tcode{+=}, \tcode{+},  \tcode{-=}, and \tcode{-}, and the
computation of distance in constant time with \tcode{-}. Random access iterators also support array
notation via subscripting.

\indexlibrary{\idxcode{RandomAccessIterator}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ RandomAccessIterator =
    BidirectionalIterator<I> &&
    DerivedFrom<@\oldtxt{iterator_category_t<I>}\placeholdernc{\newtxt{ITER_CONCEPT}}\newtxt{(I)}@, random_access_iterator_tag> &&
    StrictTotallyOrdered<I> &&
    SizedSentinel<I, I> &&
    requires(I i, const I j, const @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n) {
      { i += n } -> Same<I>&;
      @\oldtxt{\{ j + n \}  -> Same<I>\&\&;}@
      @\newtxt{j + n; requires Same<decltype(j + n), I>;}@
      @\oldtxt{\{ n + j \}  -> Same<I>\&\&;}@
      @\newtxt{n + j; requires Same<decltype(n + j), I>;}@
      { i -= n } -> Same<I>&;
      @\oldtxt{\{ j - n \}  -> Same<I>\&\&;}@
      @\newtxt{j - n; requires Same<decltype(j - n), I>;}@
      j[n]; requires Same<decltype(j[n]), @\newtxt{iter_}@reference_t<I>>;
    };
\end{codeblock}

\pnum
Let \tcode{a} and \tcode{b} be valid iterators of type \tcode{I} such that \tcode{b} is reachable
from \tcode{a}. Let \tcode{n} be the smallest value of type
\tcode{\newtxt{iter_}difference\oldtxt{_type}_t<I>} such that after
\tcode{n} applications of \tcode{++a}, then \tcode{bool(a == b)}.
\tcode{\libconcept{Random\-Access\-Iterator}<\brk{}I>} is satisfied only if:

\begin{itemize}
\item \tcode{(a += n)} is equal to \tcode{b}.
\item \tcode{\oldtxt{\&}\newtxt{addressof(}(a += n)\newtxt{)}} is equal to \tcode{\oldtxt{\&}\newtxt{addressof(}a\newtxt{)}}.
\item \tcode{(a + n)} is equal to \tcode{(a += n)}.
\item For any two positive integers \tcode{x} and \tcode{y}, if \tcode{a + (x + y)} is valid, then
\tcode{a + (x + y)} is equal to \tcode{(a + x) + y}.
\item \tcode{a + 0} is equal to \tcode{a}.
\item If \tcode{(a + (n - 1))} is valid, then \tcode{a + n} is equal to \tcode{++(a + (n - 1))}.
\item \tcode{(b += -n)} is equal to \tcode{a}.
\item \tcode{(b -= n)} is equal to \tcode{a}.
\item \tcode{\oldtxt{\&}\newtxt{addressof(}(b -= n)\newtxt{)}} is equal to \tcode{\oldtxt{\&}\newtxt{addressof(}b\newtxt{)}}.
\item \tcode{(b - n)} is equal to \tcode{(b -= n)}.
\item If \tcode{b} is dereferenceable, then \tcode{a[n]} is valid and is equal to \tcode{*b}.
\item \tcode{\newtxt{bool(a <= b)}}
\end{itemize}

\rSec3[iterator.concept.contiguous]{Concept \libconcept{ContiguousIterator}}

\pnum
The \libconcept{ContiguousIterator} concept refines \libconcept{RandomAccessIterator} and
provides a guarantee that the denoted elements are stored contiguously in memory.

\indexlibrary{\idxcode{ContiguousIterator}}%
\begin{codeblock}
  template<class I>
  concept @\libconcept{ContiguousIterator}@ =
    RandomAccessIterator<I> &&
    DerivedFrom<@\oldtxt{iterator_category_t<I>}\placeholdernc{\newtxt{ITER_CONCEPT}}\newtxt{(I)}@, contiguous_iterator_tag> &&
    is_lvalue_reference_v<@\newtxt{iter_}@reference_t<I>> &&
    Same<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>, remove_cvref_t<@\newtxt{iter_}@reference_t<I>>>;
\end{codeblock}

\pnum
Let \tcode{a} and \tcode{b} be dereferenceable iterators of type \tcode{I} such
that \tcode{b} is reachable from \tcode{a}. \tcode{\libconcept{ContiguousIterator}<I>} is
satisfied only if
\begin{codeblock}
addressof(*(a + (b - a))) == addressof(*a) + (b - a)
\end{codeblock}
is \tcode{true}.

\ednote{Add a new subclause [iterator.cpp17] with the "Cpp17" iterator category requirement subclauses:}

{\color{newclr}
\rSec2[iterator.cpp17]{\Cpp{}17 iterator requirements}

\pnum
In the following sections,
\tcode{a}
and
\tcode{b}
denote values of type
\tcode{X} or \tcode{const X},
\tcode{difference_type} and \tcode{reference} refer to the
types \tcode{iterator_traits<X>::difference_type} and
\tcode{iterator_traits<X>::reference}, respectively,
\tcode{n}
denotes a value of
\tcode{difference_type},
\tcode{u},
\tcode{tmp},
and
\tcode{m}
denote identifiers,
\tcode{r}
denotes a value of
\tcode{X\&},
\tcode{t}
denotes a value of value type
\tcode{T},
\tcode{o}
denotes a value of some type that is writable to the output iterator.
\begin{note} For an iterator type \tcode{X} there must be an instantiation
of \tcode{iterator_traits<X>}\iref{iterator.traits}. \end{note}
} %% \color{newclr}
\end{addedblock}

\rSec3[iterator.iterators]{\oldconcept{Iterator}}

\rSec3[input.iterators]{Input iterators}
[...]

\rSec3[output.iterators]{Output iterators}
[...]

\rSec3[forward.iterators]{Forward iterators}
[...]

\rSec3[bidirectional.iterators]{Bidirectional iterators}
[...]

\rSec3[random.access.iterators]{Random access iterators}
[...]

\begin{addedblock}
\ednote{Relocate Ranges TS [indirectcallable] here and modify as follows:}
\rSec2[indirectcallable]{Indirect callable requirements}

\rSec3[indirectcallable.general]{General}

\pnum
There are several concepts that group requirements of algorithms that take callable
objects~(\cxxref{func.require}) as arguments.

\rSec3[indirectcallable.indirectinvocable]{Indirect callables}

\pnum
The indirect callable concepts are used to constrain those algorithms that accept
callable objects~(\cxxref{func.def}) as arguments.

\indexlibrary{\idxcode{indirect_result}}%
\indexlibrary{\idxcode{IndirectUnaryInvocable}}%
\indexlibrary{\idxcode{IndirectRegularUnaryInvocable}}%
\indexlibrary{\idxcode{IndirectUnaryPredicate}}%
\indexlibrary{\idxcode{IndirectRelation}}%
\indexlibrary{\idxcode{IndirectStrictWeakOrder}}%
\begin{codeblock}
@\newtxt{namespace std \{}@
  template<class F, class I>
  concept @\oldtxt{bool}@ IndirectUnaryInvocable =
    Readable<I> &&
    CopyConstructible<F> &&
    Invocable<F&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I>&> &&
    Invocable<F&, @\newtxt{iter_}@reference_t<I>> &&
    Invocable<F&, iter_common_reference_t<I>> &&
    CommonReference<
      @\oldtxt{result_of_t<F\&(value_type_t<I>\&)>}\newtxt{invoke_result_t<F\&, iter_value_t<I>\&>}@,
      @\oldtxt{result_of_t<F\&(reference_t<I>\&\&)>}\newtxt{invoke_result_t<F\&, iter_reference_t<I>{}>}@>;

  template<class F, class I>
  concept @\oldtxt{bool}@ IndirectRegularUnaryInvocable =
    Readable<I> &&
    CopyConstructible<F> &&
    RegularInvocable<F&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I>&> &&
    RegularInvocable<F&, @\newtxt{iter_}@reference_t<I>> &&
    RegularInvocable<F&, iter_common_reference_t<I>> &&
    CommonReference<
      @\oldtxt{result_of_t<F\&(value_type_t<I>\&)>}\newtxt{invoke_result_t<F\&, iter_value_t<I>\&>}@,
      @\oldtxt{result_of_t<F\&(reference_t<I>\&\&)>}\newtxt{invoke_result_t<F\&, iter_reference_t<I>{}>}@>;

  template<class F, class I>
  concept @\oldtxt{bool}@ IndirectUnaryPredicate =
    Readable<I> &&
    CopyConstructible<F> &&
    Predicate<F&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I>&> &&
    Predicate<F&, @\newtxt{iter_}@reference_t<I>> &&
    Predicate<F&, iter_common_reference_t<I>>;

  template<class F, class I1, class I2 = I1>
  concept @\oldtxt{bool}@ IndirectRelation =
    Readable<I1> && Readable<I2> &&
    CopyConstructible<F> &&
    Relation<F&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I1>&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I2>&> &&
    Relation<F&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I1>&, @\newtxt{iter_}@reference_t<I2>> &&
    Relation<F&, @\newtxt{iter_}@reference_t<I1>, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I2>&> &&
    Relation<F&, @\newtxt{iter_}@reference_t<I1>, @\newtxt{iter_}@reference_t<I2>> &&
    Relation<F&, iter_common_reference_t<I1>, iter_common_reference_t<I2>>;

  template<class F, class I1, class I2 = I1>
  concept @\oldtxt{bool}@ IndirectStrictWeakOrder =
    Readable<I1> && Readable<I2> &&
    CopyConstructible<F> &&
    StrictWeakOrder<F&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I1>&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I2>&> &&
    StrictWeakOrder<F&, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I1>&, @\newtxt{iter_}@reference_t<I2>> &&
    StrictWeakOrder<F&, @\newtxt{iter_}@reference_t<I1>, @\newtxt{iter_}@value@\oldtxt{_type}@_t<I2>&> &&
    StrictWeakOrder<F&, @\newtxt{iter_}@reference_t<I1>, @\newtxt{iter_}@reference_t<I2>> &&
    StrictWeakOrder<F&, iter_common_reference_t<I1>, iter_common_reference_t<I2>>;

  @\oldtxt{template<class> struct indirect_result_of \{ \};}@

  @\oldtxt{template<class F, class... Is>}@
    @\oldtxt{requires Invocable<F, reference_t<Is>...>}@
  @\oldtxt{struct indirect_result_of<F(Is...)> :}@
    @\oldtxt{result_of<F(reference_t<Is>\&\&...)> \{ \};}@
@\newtxt{\}}@
\end{codeblock}

\ednote{Relocate [projected] here from the Ranges TS and change as follows:}
\rSec3[projected]{Class template \tcode{projected}}

\pnum
The \tcode{projected} class template is intended for use when specifying the constraints of
algorithms that accept callable objects and projections\iref{defns.projection}. It bundles a \tcode{Readable} type
\tcode{I} and a function \tcode{Proj} into a new \tcode{Readable} type whose
\tcode{reference} type is the result of applying \tcode{Proj} to the
\tcode{\newtxt{iter_}reference_t} of \tcode{I}.

\indexlibrary{\idxcode{projected}}%
\begin{codeblock}
@\newtxt{namespace std \{}@
  template<Readable I, IndirectRegularUnaryInvocable<I> Proj>
  struct projected {
    @\oldtxt{using value_type = remove_cv_t<remove_reference_t<indirect_result_of_t<Proj\&(I)>>>;}@
    @\newtxt{using value_type = remove_cvref_t<indirect_result_t<Proj\&, I>{}>;}@
    indirect_result@\oldtxt{_of}@_t<Proj&@\oldtxt{(}\newtxt{, }@I@\oldtxt{)}@> operator*() const;
  };

  template<WeaklyIncrementable I, class Proj>
  struct @\oldtxt{difference_type}\newtxt{incrementable_traits}@<projected<I, Proj>> {
    @\oldtxt{using type = difference_type_t<I>;}@
    @\newtxt{using difference_type = iter_difference_t<I>;}@
  };
@\newtxt{\}}@
\end{codeblock}

\pnum
\begin{note}
\tcode{projected} is only used to ease constraints specification. Its
member function need not be defined.
\end{note}

\ednote{Relocate Ranges TS [commonalgoreq] here and modify as follows:}
\rSec2[commonalgoreq]{Common algorithm requirements}

\rSec3[commonalgoreq.general]{General}

\pnum
There are several additional iterator concepts that are commonly applied to families of algorithms.
These group together iterator requirements of algorithm families. There are three relational
concepts that specify how element values are transferred between \tcode{Readable} and \tcode{Writable} types:
\tcode{Indirectly\-Movable}, \tcode{Indir\-ect\-ly\-Copy\-able}, and \tcode{Indirectly\-Swappable}. There are three relational concepts
for rearrangements: \tcode{Permut\-able}, \tcode{Mergeable}, and \tcode{Sortable}.
There is one relational concept for comparing values from different sequences: \tcode{IndirectlyComparable}.

\pnum
\begin{note}
The \oldtxt{\tcode{equal_to<>} and}
\tcode{\newtxt{ranges::}less<>}\iref{range.comparisons} function \newtxt{object}
type used in the concepts below imposes \oldtxt{additional} constraints on their
arguments \oldtxt{beyond} \newtxt{in addition to} those that appear explicitly
in the concepts' bodies. \oldtxt{\tcode{equal_to<>} requires its arguments satisfy
\libconcept{EqualityComparableWith}~(\cxxref{concept.equalitycomparable}),
and} \newtxt{The function call operator of }\tcode{\newtxt{ranges::}less<>}
requires its arguments \oldtxt{satisfy} \newtxt{to model}
\libconcept{StrictTotally\-OrderedWith}~(\cxxref{concept.stricttotallyordered}).
\end{note}

\rSec3[commonalgoreq.indirectlymovable]{Concept \tcode{IndirectlyMovable}}

\pnum
The \tcode{IndirectlyMovable} concept specifies the relationship between a \tcode{Readable}
type and a \tcode{Writable} type between which values may be moved.

\indexlibrary{\idxcode{IndirectlyMovable}}%
\begin{codeblock}
  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyMovable =
    Readable<In> &&
    Writable<Out, @\newtxt{iter_}@rvalue_reference_t<In>>;
\end{codeblock}

\pnum
The \tcode{IndirectlyMovableStorable} concept augments \tcode{IndirectlyMovable} with additional
requirements enabling the transfer to be performed through an intermediate object of the
\tcode{Readable} type's value type.

\indexlibrary{\idxcode{IndirectlyMovableStorable}}%
\begin{codeblock}
  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyMovableStorable =
    IndirectlyMovable<In, Out> &&
    Writable<Out, @\newtxt{iter_}@value@\oldtxt{_type}@_t<In>> &&
    Movable<@\newtxt{iter_}@value@\oldtxt{_type}@_t<In>> &&
    Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<In>, @\newtxt{iter_}@rvalue_reference_t<In>> &&
    Assignable<@\newtxt{iter_}@value@\oldtxt{_type}@_t<In>&, @\newtxt{iter_}@rvalue_reference_t<In>>;
\end{codeblock}

{\color{newclr}
\pnum
Let \tcode{i} be a dereferenceable value of type \tcode{In}.
\tcode{IndirectlyMovableStorable<In, Out>} is satisfied only if after the
initialization of the object \tcode{obj} in
\begin{codeblock}
iter_value_t<In> obj(ranges::iter_move(i));
\end{codeblock}
\tcode{obj} is equal to the value previously denoted by \tcode{*i}. If
\tcode{iter_rvalue_reference_t<In>} is an rvalue reference type, the resulting state
of the value denoted by \tcode{*i} is valid but
unspecified\cxxiref{lib.types.movedfrom}.
} %% \color{newclr}

\rSec3[commonalgoreq.indirectlycopyable]{Concept \tcode{IndirectlyCopyable}}

\pnum
The \tcode{IndirectlyCopyable} concept specifies the relationship between a \tcode{Readable}
type and a \tcode{Writable} type between which values may be copied.

\indexlibrary{\idxcode{IndirectlyCopyable}}%
\begin{codeblock}
  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyCopyable =
    Readable<In> &&
    Writable<Out, @\newtxt{iter_}@reference_t<In>>;
\end{codeblock}

\pnum
The \tcode{IndirectlyCopyableStorable} concept augments \tcode{IndirectlyCopyable} with additional
requirements enabling the transfer to be performed through an intermediate object of the
\tcode{Readable} type's value type. It also requires the capability to make copies of values.

\indexlibrary{\idxcode{IndirectlyCopyableStorable}}%
\begin{codeblock}
  template<class In, class Out>
  concept @\oldtxt{bool}@ IndirectlyCopyableStorable =
    IndirectlyCopyable<In, Out> &&
    Writable<Out, const @\newtxt{iter_}@value@\oldtxt{_type}@_t<In>&> &&
    Copyable<@\newtxt{iter_}@value@\oldtxt{_type}@_t<In>> &&
    Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<In>, @\newtxt{iter_}@reference_t<In>> &&
    Assignable<@\newtxt{iter_}@value@\oldtxt{_type}@_t<In>&, @\newtxt{iter_}@reference_t<In>>;
\end{codeblock}

{\color{newclr}
\pnum
Let \tcode{i} be a dereferenceable value of type \tcode{In}.
\tcode{IndirectlyCopyableStorable<In, Out>} is satisfied only if after the
initialization of the object \tcode{obj} in
\begin{codeblock}
iter_value_t<In> obj(*i);
\end{codeblock}
\tcode{obj} is equal to the value previously denoted by \tcode{*i}. If
\tcode{iter_reference_t<In>} is an rvalue reference type, the resulting state
of the value denoted by \tcode{*i} is valid but
unspecified\cxxiref{lib.types.movedfrom}.
} %% \color{newclr}

\rSec3[commonalgoreq.indirectlyswappable]{Concept \tcode{IndirectlySwappable}}

\pnum
The \tcode{IndirectlySwappable} concept specifies a swappable relationship between the
values referenced by two \tcode{Readable} types.

\indexlibrary{\idxcode{IndirectlySwappable}}%
\begin{codeblock}
  template<class I1, class I2 = I1>
  concept @\oldtxt{bool}@ IndirectlySwappable =
    Readable<I1> && Readable<I2> &&
    requires(I1&& i1, I2&& i2) {
      ranges::iter_swap(std::forward<I1>(i1), std::forward<I2>(i2));
      ranges::iter_swap(std::forward<I2>(i2), std::forward<I1>(i1));
      ranges::iter_swap(std::forward<I1>(i1), std::forward<I1>(i1));
      ranges::iter_swap(std::forward<I2>(i2), std::forward<I2>(i2));
    };
\end{codeblock}

\pnum
Given an object \tcode{i1} of type \tcode{I1} and an object \tcode{i2} of
type \tcode{I2}, \tcode{IndirectlySwappable<I1, I2>} is satisfied if after
\tcode{ranges::iter_swap(i1, i2)}, the value of \tcode{*i1} is equal to the
value of \tcode{*i2} before the call, and \textit{vice versa}.

\rSec3[commonalgoreq.indirectlycomparable]{Concept \tcode{IndirectlyComparable}}

\pnum
The \tcode{IndirectlyComparable} concept specifies the common requirements of algorithms that
compare values from two different sequences.

\indexlibrary{\idxcode{IndirectlyComparable}}%
\begin{codeblock}
  template<class I1, class I2, class R @\oldtxt{= equal_to<>}@, class P1 = identity,
    class P2 = identity>
  concept @\oldtxt{bool}@ IndirectlyComparable =
    IndirectRelation<R, projected<I1, P1>, projected<I2, P2>>;
\end{codeblock}

\rSec3[commonalgoreq.permutable]{Concept \tcode{Permutable}}

\pnum
The \tcode{Permutable} concept specifies the common requirements of algorithms that reorder
elements in place by moving or swapping them.

\indexlibrary{\idxcode{Permutable}}%
\begin{codeblock}
  template<class I>
  concept @\oldtxt{bool}@ Permutable =
    ForwardIterator<I> &&
    IndirectlyMovableStorable<I, I> &&
    IndirectlySwappable<I, I>;
\end{codeblock}

\rSec3[commonalgoreq.mergeable]{Concept \tcode{Mergeable}}

\pnum
The \tcode{Mergeable} concept specifies the requirements of
algorithms that merge sorted sequences into an output sequence by copying elements.

\indexlibrary{\idxcode{Mergeable}}%
\begin{codeblock}
  template<class I1, class I2, class Out,
      class R = @\newtxt{ranges::}@less<>, class P1 = identity, class P2 = identity>
  concept @\oldtxt{bool}@ Mergeable =
    InputIterator<I1> &&
    InputIterator<I2> &&
    WeaklyIncrementable<Out> &&
    IndirectlyCopyable<I1, Out> &&
    IndirectlyCopyable<I2, Out> &&
    IndirectStrictWeakOrder<R, projected<I1, P1>, projected<I2, P2>>;
\end{codeblock}

\rSec3[commonalgoreq.sortable]{Concept \tcode{Sortable}}

\pnum
The \tcode{Sortable} concept specifies the common requirements of algorithms that permute
sequences into ordered sequences (e.g., \tcode{sort}).

\indexlibrary{\idxcode{Sortable}}%
\begin{codeblock}
  template<class I, class R = @\newtxt{ranges::}@less<>, class P = identity>
  concept @\oldtxt{bool}@ Sortable =
    Permutable<I> &&
    IndirectStrictWeakOrder<R, projected<I, P>>;
\end{codeblock}
\end{addedblock}

\rSec1[iterator.primitives]{Iterator primitives}

\pnum
To simplify the task of defining iterators, the library provides
several classes and functions:

\rSec2[std.iterator.tags]{Standard iterator tags}

\pnum
\indexlibrary{\idxcode{input_iterator_tag}}%
\indexlibrary{\idxcode{output_iterator_tag}}%
\indexlibrary{\idxcode{forward_iterator_tag}}%
\indexlibrary{\idxcode{bidirectional_iterator_tag}}%
\indexlibrary{\idxcode{random_access_iterator_tag}}%
\indexlibrary{\idxcode{contiguous_iterator_tag}}%
It is often desirable for a
function template specialization
to find out what is the most specific category of its iterator
argument, so that the function can select the most efficient algorithm at compile time.
To facilitate this, the
library introduces
\term{category tag}
classes which are used as compile time tags for algorithm selection.
They are:
\tcode{input_iterator_tag},
\tcode{output_iterator_tag},
\tcode{forward_iterator_tag},
\tcode{bidirectional_iterator_tag}\newtxt{,}
\oldtxt{and}
\tcode{random_access_iterator_tag}
\newtxt{and}
\tcode{\added{contiguous_iterator_tag}}.
For every iterator of type
\tcode{\removed{Iterator}\added{I}},
\tcode{iterator_traits<\oldtxt{Iterator}\newtxt{I}>::it\-er\-a\-tor_ca\-te\-go\-ry}
shall be defined to be the most specific category tag that describes the
iterator's behavior. \added{Additionally and optionally,
\tcode{iterator_traits<I>::it\-er\-a\-tor_\oldtxt{ca\-te\-go\-ry}\newtxt{con\-cept}}
may be used to opt in or out of conformance to the iterator concepts defined
in\iref{iterator.concepts}.}

\begin{codeblock}
namespace std {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: @\oldtxt{public}@ input_iterator_tag { };
  struct bidirectional_iterator_tag: @\oldtxt{public}@ forward_iterator_tag { };
  struct random_access_iterator_tag: @\oldtxt{public}@ bidirectional_iterator_tag { };
  @\added{struct contiguous_iterator_tag: random_access_iterator_tag \{ \};}@
}
\end{codeblock}

\pnum
\indexlibrary{\idxcode{empty}}%
\indexlibrary{\idxcode{input_iterator_tag}}%
\indexlibrary{\idxcode{output_iterator_tag}}%
\indexlibrary{\idxcode{forward_iterator_tag}}%
\indexlibrary{\idxcode{bidirectional_iterator_tag}}%
\indexlibrary{\idxcode{random_access_iterator_tag}}%
\indexlibrary{\idxcode{contiguous_iterator_tag}}%
\begin{example}
For a program-defined iterator
\tcode{BinaryTreeIterator},
it could be included
into the bidirectional iterator category by specializing the
\tcode{iterator_traits}
template:
[...]
\end{example}

[...] \ednote{Remainder as in the working draft.}

\rSec2[iterator.operations]{Iterator operations}
\ednote {As in the working draft with no modifications.}

\begin{addedblock}
\ednote{Relocate [iterator.operations] here from the Ranges TS and modify as follows:}
\rSec2[range.iterator.operations]{Range iterator operations}

\pnum
Since only types that satisfy
\tcode{RandomAccessIterator} provide the \tcode{+} operator, and
types that satisfy \tcode{Sized\-Sent\-inel} provide the \tcode{-}
operator, the library provides \oldtxt{customization point objects\cxxiref{customization.point.object}}
\newtxt{function templates}
\tcode{advance}, \tcode{dist\-ance}, \tcode{next}, and \tcode{prev}.
These
\oldtxt{customization point objects} \newtxt{function templates}
use
\tcode{+}
and
\tcode{-}
for random access iterators and ranges that satisfy \tcode{SizedSentinel} (and are,
therefore, constant time for them); for output, input, forward and bidirectional
iterators they use
\tcode{++}
to provide linear time
implementations.

{\color{newclr}
\pnum
The function templates defined in this subclause are not found by argument-dependent
name lookup\cxxiref{basic.lookup.argdep}. When found by
unqualified\cxxiref{basic.lookup.unqual} name lookup for the
\grammarterm{postfix-expression} in a function call\cxxiref{expr.call}, they
inhibit argument-dependent name lookup.

\begin{example}
\begin{codeblock}
void foo() {
    using namespace std::ranges;
    std::vector<int> vec{1,2,3};
    distance(begin(vec), end(vec)); // \#1
}
\end{codeblock}
The function call expression at \tcode{\#1} invokes \tcode{std::ranges::distance},
not \tcode{std::distance}, despite that (a) the iterator type returned from \tcode{begin(vec)}
and \tcode{end(vec)} may be associated with namespace \tcode{std} and (b)
\tcode{std::distance} is more specialized~(\cxxref{temp.func.order}) than
\tcode{std::ranges::distance} since the former requires its first two parameters
to have the same type.
\end{example}
} %% \color{newclr}

\rSec3[range.iterator.operations.advance]{\tcode{ranges::advance}}
\indexlibrary{\idxcode{advance}}%
\pnum
\oldtxt{The name \tcode{advance} denotes a
customization point object\cxxiref{customization.point.object}.
It has the following function call operators:}

\begin{itemdecl}
template<Iterator I>
  constexpr void @\oldtxt{operator()}\newtxt{advance}@(I& i, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{n}
shall be negative only for bidirectional iterators.

\pnum
\effects
For random access iterators, equivalent to \tcode{i += n}.
Otherwise, increments (or decrements for negative
\tcode{n})
iterator
\tcode{i}
by
\tcode{n}.
\end{itemdescr}

\begin{itemdecl}
template<Iterator I, Sentinel<I> S>
  constexpr void @\oldtxt{operator()}\newtxt{advance}@(I& i, S bound) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
If
\tcode{Assignable<I\&, S>} is not satisfied, \range{i}{bound}
shall denote a range.

\pnum
\effects
\begin{itemize}
\item If \tcode{Assignable<I\&, S>} is satisfied,
      equivalent to \tcode{i = std::move(bound)}.

\item Otherwise, if
      \tcode{SizedSentinel<S, I>} is satisfied, equivalent to \tcode{advance(i, bound - i)}.

\item Otherwise, increments \tcode{i} until \tcode{i == bound}.
\end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<Iterator I, Sentinel<I> S>
  constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> @\oldtxt{operator()}\newtxt{advance}@(I& i, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, S bound) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
If \tcode{n > 0}, \range{i}{bound} shall denote a range. If
\tcode{n == 0}, \range{i}{bound} or \range{bound}{i} shall denote a range. If \tcode{n < 0},
\range{bound}{i} shall denote a range and \tcode{(BidirectionalIterator<I> \&\& Same<I, S>)}
shall be satisfied.

\pnum
\effects
\begin{itemize}
\item If \tcode{SizedSentinel<S, I>} is satisfied:
      \begin{itemize}
      \item If \brk{}$|\tcode{n}| >= |\tcode{bound - i}|$, equivalent to \tcode{advance(i, bound)}.

      \item Otherwise, equivalent to \tcode{advance(i, n)}.
      \end{itemize}

\item Otherwise, increments (or decrements for negative \tcode{n})
      iterator \tcode{i} either \tcode{n} times or until \tcode{i == bound},
      whichever comes first.
\end{itemize}

\pnum
\returns
\tcode{n - $M$}, where $M$ is the distance from the starting position of
\tcode{i} to the ending position.
\end{itemdescr}

\rSec3[range.iterator.operations.distance]{\tcode{ranges::distance}}
\indexlibrary{\idxcode{distance}}%
\pnum
\oldtxt{The name \tcode{distance} denotes a customization point object.
It has the following function call operators:}

\begin{itemdecl}
template<Iterator I, Sentinel<I> S>
  constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> @\oldtxt{operator()}\newtxt{distance}@(I first, S last) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\range{first}{last} shall denote a range, or \tcode{(Same<S, I> \&\& SizedSentinel<S, I>)} shall be
satisfied and \range{last}{first} shall denote a range.

\pnum
\effects
If \tcode{SizedSentinel<S, I>} is satisfied, returns \tcode{(last - first)}; otherwise,
returns the number of increments needed to get from
\tcode{first}
to
\tcode{last}.
\end{itemdescr}

\begin{itemdecl}
template<Range R>
  constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<iterator_t<R>> @\oldtxt{operator()}\newtxt{distance}@(R&& r) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\newtxt{If \tcode{SizedRange<R>} is satisfied, equivalent to:}
\begin{codeblock}
@\newtxt{return ranges::size(r); // \ref{range.primitives.size}}@
\end{codeblock}
\newtxt{Otherwise,} equivalent to:
\begin{codeblock}
return distance(ranges::begin(r), ranges::end(r)); // \ref{range.access}
\end{codeblock}

\oldtxt{
\pnum
\remarks
Instantiations of this member function template may be ill-formed if the
declarations in \tcode{<experimental/ranges/range>} are not in scope at the
point of instantiation~(\cxxref{temp.point}).}
\end{itemdescr}

{\color{oldclr}
\begin{itemdecl}
template<SizedRange R>
  constexpr difference_type_t<iterator_t<R>> operator()(R&& r) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return ranges::size(r);}\iref{range.primitives.size}

\pnum
\remarks
Instantiations of this member function template may be ill-formed if the
declarations in \tcode{<experimental/ranges/range>} are not in scope at the
point of instantiation~(\cxxref{temp.point}).
\end{itemdescr}
} % \color{oldclr}

\rSec3[range.iterator.operations.next]{\tcode{ranges::next}}
\indexlibrary{\idxcode{next}}%
\pnum
\oldtxt{The name \tcode{next} denotes a customization point object. It has the following function call operators:}

\begin{itemdecl}
template<Iterator I>
  constexpr I @\oldtxt{operator()}\newtxt{next}@(I x) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{++x; return x;}
\end{itemdescr}

\begin{itemdecl}
template<Iterator I>
  constexpr I @\oldtxt{operator()}\newtxt{next}@(I x, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, n); return x;}
\end{itemdescr}

\begin{itemdecl}
template<Iterator I, Sentinel<I> S>
  constexpr I @\oldtxt{operator()}\newtxt{next}@(I x, S bound) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, bound); return x;}
\end{itemdescr}

\begin{itemdecl}
template<Iterator I, Sentinel<I> S>
  constexpr I @\oldtxt{operator()}\newtxt{next}@(I x, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, S bound) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, n, bound); return x;}
\end{itemdescr}

\rSec3[range.iterator.operations.prev]{\tcode{ranges::prev}}
\indexlibrary{\idxcode{prev}}%
\pnum
\oldtxt{The name \tcode{prev} denotes a customization point object. It has the following function call operators:}

\begin{itemdecl}
template<BidirectionalIterator I>
  constexpr I @\oldtxt{operator()}\newtxt{prev}@(I x) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{-{-}x; return x;}
\end{itemdescr}

\begin{itemdecl}
template<BidirectionalIterator I>
  constexpr I @\oldtxt{operator()}\newtxt{prev}@(I x, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, -n); return x;}
\end{itemdescr}

\begin{itemdecl}
template<BidirectionalIterator I>
  constexpr I @\oldtxt{operator()}\newtxt{prev}@(I x, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, I bound) @\oldtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, -n, bound); return x;}
\end{itemdescr}
\end{addedblock}

\rSec1[predef.iterators]{Iterator adaptors}

\rSec2[reverse.iterators]{Reverse iterators}

\pnum
Class template \tcode{reverse_iterator} is an iterator adaptor that iterates
from the end of the sequence defined by its underlying iterator to the beginning
of that sequence.
\removed{The fundamental relation between a reverse iterator
and its corresponding iterator \tcode{i} is established by the identity:
\tcode{\&*(reverse_iterator(i)) == \&*(i - 1)}.}

\rSec3[reverse.iterator]{Class template \tcode{reverse_iterator}}

\ednote{Change the synopsis of \tcode{reverse_iterator} as follows:}

\indexlibrary{\idxcode{reverse_iterator}}%
\begin{codeblock}
namespace std {
  template<class Iterator>
  class reverse_iterator {
  public:
    using iterator_type     = Iterator;
    @\oldtxt{using iterator_category = typename iterator_traits<Iterator>::iterator_category;}@
    @\oldtxt{using value_type        = typename iterator_traits<Iterator>::value_type;}@
    @\oldtxt{using difference_type   = typename iterator_traits<Iterator>::difference_type;}@
    @\oldtxt{using pointer           = typename iterator_traits<Iterator>::pointer;}@
    @\oldtxt{using reference         = typename iterator_traits<Iterator>::reference;}@
    @\newtxt{using iterator_category = \seebelownc;}@
    @\newtxt{using iterator_concept  = \seebelownc;}@
    @\newtxt{using value_type        = iter_value_t<Iterator>;}@
    @\newtxt{using difference_type   = iter_difference_t<Iterator>;}@
    @\newtxt{using pointer           = Iterator;}@
    @\newtxt{using reference         = iter_reference_t<Iterator>;}@

    constexpr reverse_iterator();
    constexpr explicit reverse_iterator(Iterator x);
    template<class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
    template<class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);

    constexpr Iterator base() const;      @\oldtxt{// explicit}@
    constexpr reference operator*() const;
    constexpr pointer   operator->() const;

    [...]

    constexpr reverse_iterator& operator-=(difference_type n);
    constexpr @\unspec@ operator[](difference_type n) const;

    @\newtxt{friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const reverse_iterator\& i)}@
      @\newtxt{noexcept(\seebelownc);}@
    @\newtxt{template<IndirectlySwappable<Iterator> Iterator2>}@
      @\newtxt{friend constexpr void iter_swap(const reverse_iterator\& x,}@
                                      @\newtxt{const reverse_iterator<Iterator2>\& y)}@
        @\newtxt{noexcept(\seebelownc);}@

  protected:
    Iterator current;
  };

  [...]

  template<class Iterator>
    constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i);

  @\newtxt{template<class Iterator1, class Iterator2>}@
    @\newtxt{requires !SizedSentinel<Iterator1, Iterator2>}@
  @\newtxt{inline constexpr bool disable_sized_sentinel<reverse_iterator<Iterator1>,}@
                                               @\newtxt{reverse_iterator<Iterator2>{>} = true;}@
}
\end{codeblock}

{\color{newclr}
\pnum
The member \grammarterm{typedef-name} \tcode{iterator_category} denotes
\tcode{random_access_iterator_tag} if \tcode{iterator_traits<\brk{}Iterator>::iterator_category} is
\tcode{contiguous_iterator_tag}, and \tcode{iterator_traits<Iterator>::iterator_category} otherwise.

\pnum
The member \grammarterm{typedef-name} \tcode{iterator_concept} denotes
\tcode{random_access_iterator_tag} if \tcode{Iterator} models \tcode{RandomAccessIterator}, and \tcode{bidirectional_iterator_tag} otherwise.
} %% \color{newclr}


\ednote{Change [reverse.iterator.elem] as follows (note that this change resolves
\href{https://wg21.link/lwg1052}{LWG 1052}):}
\setcounter{subsubsection}{4}
\rSec3[reverse.iterator.elem]{\tcode{reverse_iterator} element access}

[...]

\setcounter{Paras}{1}

\indexlibrarymember{operator->}{reverse_iterator}%
\begin{itemdecl}
constexpr pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\oldtxt{addressof(operator*())}\newtxt{prev(current)}}.
\end{itemdescr}

[...]

\setcounter{subsubsection}{6}
\ednote{After [reverse.iter.nav], add a new subsection for \tcode{reverse_iterator} friend functions.}

{\color{newclr}
\rSec3[reverse.iter.friends]{\tcode{reverse_iterator} friend functions}
\indexlibrarymember{iter_move}{reverse_iterator}%
\begin{itemdecl}
friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const reverse_iterator& i)
   noexcept(@\seebelownc@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(prev(i.current));}

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
   noexcept(ranges::iter_move(declval<Iterator&>())) && noexcept(--declval<Iterator&>()) &&
     is_nothrow_copy_constructible_v<Iterator>
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{iter_swap}{reverse_iterator}%
\begin{itemdecl}
template<IndirectlySwappable<Iterator> Iterator2>
  friend constexpr void iter_swap(const reverse_iterator& x, const reverse_iterator<Iterator2>& y)
    noexcept(@\seebelownc@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(prev(x.current), prev(y.current))}.

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
  noexcept(ranges::iter_swap(declval<Iterator>(), declval<Iterator>())) &&
    noexcept(--declval<Iterator&>())
\end{codeblock}
\end{itemdescr}
} %% \color{newclr}

\rSec3[reverse.iter.cmp]{\tcode{reverse_iterator} comparisons}
\ednote{Insert a new initial paragraph:}

\pnum
\newtxt{The functions in this subsection only participate in overload resolution if the
expression in their \textit{Returns:} element is well-formed.}

[...]


\rSec2[insert.iterators]{Insert iterators}
\rSec3[back.insert.iterator]{Class template \tcode{back_insert_iterator}}

\ednote{Change \tcode{back_insert_iterator} so that it
satisfies the \tcode{Iterator} concept.)}

\indexlibrary{\idxcode{back_insert_iterator}}%
\begin{codeblock}
namespace std {
  template<class Container>
  class back_insert_iterator {
  protected:
    Container* container @\newtxt{= nullptr}@;

  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\oldtxt{void}\newtxt{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;

    @\newtxt{constexpr back_insert_iterator() noexcept = default;}@
    explicit back_insert_iterator(Container& x);
    back_insert_iterator& operator=(const typename Container::value_type& value);
    back_insert_iterator& operator=(typename Container::value_type&& value);

    back_insert_iterator& operator*();
    back_insert_iterator& operator++();
    back_insert_iterator  operator++(int);
  };

  template<class Container>
    back_insert_iterator<Container> back_inserter(Container& x);
}
\end{codeblock}

[...]

\rSec3[front.insert.iterator]{Class template \tcode{front_insert_iterator}}

\ednote{Change \tcode{front_insert_iterator} so that it
satisfies the \tcode{Iterator} concept.}

\indexlibrary{\idxcode{front_insert_iterator}}%
\begin{codeblock}
namespace std {
  template<class Container>
  class front_insert_iterator {
  protected:
    Container* container @\newtxt{= nullptr}@;

  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\oldtxt{void}\newtxt{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;

    @\newtxt{constexpr front_insert_iterator() noexcept = default;}@
    explicit front_insert_iterator(Container& x);
    front_insert_iterator& operator=(const typename Container::value_type& value);
    front_insert_iterator& operator=(typename Container::value_type&& value);

    front_insert_iterator& operator*();
    front_insert_iterator& operator++();
    front_insert_iterator  operator++(int);
  };

  template<class Container>
    front_insert_iterator<Container> front_inserter(Container& x);
}
\end{codeblock}

[...]

\rSec3[insert.iterator]{Class template \tcode{insert_iterator}}

\ednote{Change \tcode{insert_iterator} so it satisfies the \tcode{Iterator} concept:}

\indexlibrary{\idxcode{insert_iterator}}%
\begin{codeblock}
namespace std {
  template<class Container>
  class insert_iterator {
  protected:
    Container* container @\newtxt{= nullptr}@;
    @\oldtxt{typename Container::iterator}\newtxt{iterator_t<Container>}@ iter @\newtxt{\{\}}@;

  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\oldtxt{void}\newtxt{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;

    @\newtxt{insert_iterator() = default;}@
    insert_iterator(Container& x, @\oldtxt{typename Container::iterator}\newtxt{iterator_t<Container>}@ i);
    insert_iterator& operator=(const typename Container::value_type& value);
    insert_iterator& operator=(typename Container::value_type&& value);

    insert_iterator& operator*();
    insert_iterator& operator++();
    insert_iterator& operator++(int);
  };

  template<class Container>
    insert_iterator<Container> inserter(Container& x, @\oldtxt{typename Container::iterator}\newtxt{iterator_t<Container>}@ i);
}
\end{codeblock}

[...]

\rSec4[insert.iter.ops]{\tcode{insert_iterator} operations}

\indexlibrary{\idxcode{insert_iterator}!constructor}%
\begin{itemdecl}
insert_iterator(Container& x, @\oldtxt{typename Container::iterator}\newtxt{iterator_t<Container>}@ i);
\end{itemdecl}

[...]

\rSec4[inserter]{\tcode{inserter}}

\indexlibrary{\idxcode{inserter}}%
\begin{itemdecl}
template<class Container>
  insert_iterator<Container> inserter(Container& x, @\oldtxt{typename Container::iterator}\newtxt{iterator_t<Container>}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{insert_iterator<Container>(x, i)}.
\end{itemdescr}


\ednote{Retitle [move.iterators] from
``Move iterators'' to ``Move iterators and sentinels'' and modify as follows:}
\rSec2[move.iterators]{Move iterators and sentinels}

[...]

\rSec3[move.iterator]{Class template \tcode{move_iterator}}

\indexlibrary{\idxcode{move_iterator}}%
\begin{codeblock}
namespace std {
  template<class Iterator>
  class move_iterator {
  public:
    using iterator_type     = Iterator;
    using iterator_category = typename iterator_traits<Iterator>::iterator_category;
    using value_type        = @\oldtxt{typename iterator_traits<Iterator>::value_type}\newtxt{iter_value_t<Iterator>}@;
    using difference_type   = @\oldtxt{typename iterator_traits<Iterator>::difference_type}\newtxt{iter_difference_t<Iterator>}@;
    using pointer           = Iterator;
    using reference         = @\oldtxt{\seebelow}\newtxt{iter_rvalue_reference_t<Iterator>}@;
    @\newtxt{using iterator_concept   = input_iterator_tag;}@

    constexpr move_iterator();
    constexpr explicit move_iterator(Iterator i);

    [...]

    constexpr move_iterator& operator++();
    constexpr @\oldtxt{move_iterator}\newtxt{decltype(auto)}@ operator++(int);
    constexpr move_iterator& operator--();

    [...]

    constexpr move_iterator operator-(difference_type n) const;
    constexpr move_iterator& operator-=(difference_type n);
    constexpr @\oldtxt{\unspec}\newtxt{reference}@ operator[](difference_type n) const;

    @\ednote{These operators are relocated from \tcode{move_sentinel}.}@
    @\newtxt{template<Sentinel<Iterator> S>}@
      @\newtxt{friend constexpr bool operator==(}@
        @\newtxt{const move_iterator\& x, const move_sentinel<S>\& y);}@
    @\newtxt{template<Sentinel<Iterator> S>}@
      @\newtxt{friend constexpr bool operator==(}@
        @\newtxt{const move_sentinel<S>\& x, const move_iterator\& y);}@
    @\newtxt{template<Sentinel<Iterator> S>}@
      @\newtxt{friend constexpr bool operator!=(}@
        @\newtxt{const move_iterator\& x, const move_sentinel<S>\& y);}@
    @\newtxt{template<Sentinel<Iterator> S>}@
      @\newtxt{friend constexpr bool operator!=(}@
        @\newtxt{const move_sentinel<S>\& x, const move_iterator\& y);}@

    @\newtxt{template<SizedSentinel<Iterator> S>}@
      @\newtxt{friend constexpr iter_difference_t<Iterator> operator-(}@
        @\newtxt{const move_sentinel<S>\& x, const move_iterator\& y);}@
    @\newtxt{template<SizedSentinel<Iterator> S>}@
      @\newtxt{friend constexpr iter_difference_t<Iterator> operator-(}@
        @\newtxt{const move_iterator\& x, const move_sentinel<S>\& y);}@

    @\newtxt{friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const move_iterator\& i)}@
      @\newtxt{noexcept(noexcept(ranges::iter_move(i.current)));}@
    @\newtxt{template<IndirectlySwappable<Iterator> Iterator2>}@
      @\newtxt{friend constexpr void iter_swap(const move_iterator\& x, const move_iterator<Iterator2>\& y)}@
        @\newtxt{noexcept(noexcept(ranges::iter_swap(x.current, y.current)));}@

  private:
    Iterator current;   // \expos
  };

  [...]

  template<class Iterator>
    constexpr move_iterator<Iterator> operator+(
      @\oldtxt{typename move_iterator<Iterator>::difference_type}\newtxt{iter_difference_t<move_iterator<Iterator>{>}}@ n,
      const move_iterator<Iterator>& x);
  template<class Iterator>
    constexpr move_iterator<Iterator> make_move_iterator(Iterator i);
}
\end{codeblock}

{\color{oldclr}
\pnum
Let \tcode{\placeholder{R}} denote \tcode{iterator_traits<Iterator>::reference}.
If \tcode{is_reference_v<\placeholder{R}>} is \tcode{true},
the template specialization \tcode{move_iterator<Iterator>} shall define
the nested type named \tcode{reference} as a synonym for
\tcode{remove_reference_t<\placeholder{R}>\&\&},
otherwise as a synonym for \tcode{\placeholder{R}}.
} %% \color{oldclr}

[...]

\setcounter{subsubsection}{2}
\rSec3[move.iter.ops]{\tcode{move_iterator} operations}

[...]

\setcounter{paragraph}{3}
\rSec4[move.iter.op.star]{\tcode{move_iterator::operator*}}

\indexlibrarymember{operator*}{move_iterator}%
\begin{itemdecl}
constexpr reference operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns \tcode{static_cast<reference>(*current)}.}

\newtxt{\effects Equivalent to: }\tcode{\newtxt{return ranges::iter_move(current);}}
\end{itemdescr}

\rSec4[move.iter.op.ref]{\tcode{move_iterator::operator->}}

\ednote{My preference is to remove \tcode{operator->} since for \tcode{move_iterator},
the expressions \tcode{(*i).m} and \tcode{i->m} are not, and cannot be,
equivalent. I am leaving the operator as-is in an excess of caution; perhaps we
should consider deprecation for C++20?}

\indexlibrarymember{operator->}{move_iterator}%
\begin{itemdecl}
constexpr pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[move.iter.op.incr]{\tcode{move_iterator::operator++}}

[...]
\setcounter{Paras}{2}

\indexlibrarymember{operator++}{move_iterator}%
\begin{itemdecl}
constexpr @\oldtxt{move_iterator}\newtxt{decltype(auto)}@ operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\oldtxt{As if by}\newtxt{If \tcode{Iterator} models \tcode{ForwardIterator}, equivalent to}:
\begin{codeblock}
move_iterator tmp = *this;
++current;
return tmp;
\end{codeblock}
\newtxt{Otherwise, equivalent to \tcode{++current}.}
\end{itemdescr}

[...]

\setcounter{paragraph}{11}
\rSec4[move.iter.op.index]{\tcode{move_iterator::operator[]}}

\indexlibrarymember{operator[]}{move_iterator}%
\begin{itemdecl}
constexpr @\changed{\unspec}{reference}@ operator[](difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{\removed{std::move(current[n])}\added{ranges::iter_move(current + n)}}.
\end{itemdescr}

\rSec4[move.iter.op.comp]{\tcode{move_iterator} comparisons}

\pnum
\newtxt{The functions in this subsection only participate in overload resolution if the
expression in their \textit{Returns:} element is well-formed.}

\indexlibrarymember{operator==}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
@\newtxt{template<Sentinel<Iterator> S>}@
@\newtxt{friend constexpr bool operator==(const move_iterator\& x, const move_sentinel<S>\& y);}@
@\newtxt{template<Sentinel<Iterator> S>}@
@\newtxt{friend constexpr bool operator==(const move_sentinel<S>\& x, const move_iterator\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() == y.base()}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
@\newtxt{template<Sentinel<Iterator> S>}@
@\newtxt{friend constexpr bool operator!=(const move_iterator\& x, const move_sentinel<S>\& y);}@
@\newtxt{template<Sentinel<Iterator> S>}@
@\newtxt{friend constexpr bool operator!=(const move_sentinel<S>\& x, const move_iterator\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

[...]

\rSec4[move.iter.nonmember]{\tcode{move_iterator} non-member functions}

\pnum
\newtxt{The functions in this subsection only participate in overload resolution if the
expression in their \textit{Returns:} element is well-formed.}

\indexlibrarymember{operator-}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr auto operator-(
    const move_iterator<Iterator1>& x,
    const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
@\newtxt{template<SizedSentinel<Iterator> S>}@
@\newtxt{friend constexpr iter_difference_t<Iterator> operator-(}@
    @\newtxt{const move_sentinel<S>\& x, const move_iterator\& y);}@
@\newtxt{template<SizedSentinel<Iterator> S>}@
@\newtxt{friend constexpr iter_difference_t<Iterator> operator-(}@
    @\newtxt{const move_iterator\& x, const move_sentinel<S>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() - y.base()}.
\end{itemdescr}

{\color{newclr}
\indexlibrarymember{iter_move}{move_iterator}%
\begin{itemdecl}
friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const move_iterator& i)
  noexcept(noexcept(ranges::iter_move(i.current)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(i.current);}
\end{itemdescr}

\indexlibrarymember{iter_swap}{move_iterator}%
\begin{itemdecl}
template<IndirectlySwappable<Iterator> Iterator2>
  friend constexpr void iter_swap(const move_iterator& x, const move_iterator<Iterator2>& y)
    noexcept(noexcept(ranges::iter_swap(x.current, y.current)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{ranges::iter_swap(x.current, y.current)}.
\end{itemdescr}
} %% \color{newclr}

\indexlibrarymember{operator+}{move_iterator}%
\begin{itemdecl}
template<class Iterator>
  constexpr move_iterator<Iterator> operator+(
    @\oldtxt{typename move_iterator<Iterator>::difference_type}\newtxt{iter_difference_t<move_iterator<Iterator>{>}}@ n,
    const move_iterator<Iterator>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x + n}.
\end{itemdescr}

[...]


\ednote{Relocate Ranges TS [move.sentinel] here and modify as follows:}
\begin{addedblock}
\rSec3[move.sentinel]{Class template \tcode{move_sentinel}}

\pnum
Class template \tcode{move_sentinel} is a sentinel adaptor useful for denoting
ranges together with \tcode{move_iterator}. When an input iterator type
\tcode{I} and sentinel type \tcode{S} satisfy \tcode{Sentinel<S, I>},
\tcode{Sentinel<move_sentinel<S>, move_iterator<I>{>}} is satisfied as well.

\pnum
\begin{example}
A \tcode{move_if} algorithm is easily implemented with
\tcode{copy_if} using \tcode{move_iterator} and \tcode{move_sentinel}:

\begin{codeblock}
template<InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
          IndirectUnaryPredicate<I> Pred>
  requires IndirectlyMovable<I, O>
void move_if(I first, S last, O out, Pred pred)
{
  copy_if(move_iterator<I>{first}, move_sentinel<S>{last}, out, pred);
}
\end{codeblock}
\end{example}

\indexlibrary{\idxcode{move_sentinel}}%
\begin{codeblock}
namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  template<Semiregular S>
  class move_sentinel {
  public:
    constexpr move_sentinel();
    explicit @\newtxt{constexpr}@ move_sentinel(S s);
    @\newtxt{template<ConvertibleTo<S> S2>}@
      @\newtxt{constexpr}@ move_sentinel(const move_sentinel<@\oldtxt{ConvertibleTo<S>}\newtxt{S2}@>& s);
    @\newtxt{template<ConvertibleTo<S> S2>}@
      @\newtxt{constexpr}@ move_sentinel& operator=(const move_sentinel<@\oldtxt{ConvertibleTo<S>}\newtxt{S2}@>& s);

    @\newtxt{constexpr}@ S base() const;

  private:
    S last; // \expos
  };

  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator==(}@
      @\oldtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator==(}@
      @\oldtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator!=(}@
      @\oldtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\oldtxt{template<class I, Sentinel<I> S>}@
    @\oldtxt{constexpr bool operator!=(}@
      @\oldtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@

  @\oldtxt{template<class I, SizedSentinel<I> S>}@
    @\oldtxt{constexpr difference_type_t<I> operator-(}@
      @\oldtxt{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\oldtxt{template<class I, SizedSentinel<I> S>}@
    @\oldtxt{constexpr difference_type_t<I> operator-(}@
      @\oldtxt{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@

  @\oldtxt{template<Semiregular S>}@
    @\oldtxt{constexpr move_sentinel<S> make_move_sentinel(S s);}@
}@\oldtxt{\}\}\}}@
\end{codeblock}

\rSec3[move.sent.ops]{\tcode{move_sentinel} operations}

\rSec4[move.sent.op.const]{\tcode{move_sentinel} constructors and conversions}

\indexlibrary{\idxcode{move_sentinel}!\idxcode{move_sentinel}}%
\begin{itemdecl}
constexpr move_sentinel();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, value-initializing
\tcode{last}. If \tcode{is_trivially_default_constructible\newtxt{_v}<S>\oldtxt{::value}} is \tcode{true}, then this constructor
is a \tcode{constexpr} constructor.
\end{itemdescr}

\indexlibrary{\idxcode{move_sentinel}!constructor}%
\begin{itemdecl}
explicit @\newtxt{constexpr}@ move_sentinel(S s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, initializing
\tcode{last} with \tcode{\newtxt{std::move(}s\newtxt{)}}.
\end{itemdescr}

\indexlibrary{\idxcode{move_sentinel}!constructor}%
\begin{itemdecl}
@\newtxt{template<ConvertibleTo<S> S2>}@
  @\newtxt{constexpr}@ move_sentinel(const move_sentinel<@\oldtxt{ConvertibleTo<S>}\newtxt{S2}@>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, initializing
\tcode{last} with \tcode{s.last}.
\end{itemdescr}

\rSec4[move.sent.op=]{\tcode{move_sentinel::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{move_sentinel}}%
\indexlibrary{\idxcode{move_sentinel}!\idxcode{operator=}}%
\begin{itemdecl}
@\newtxt{template<ConvertibleTo<S> S2>}@
  @\newtxt{constexpr}@ move_sentinel& operator=(const move_sentinel<@\oldtxt{ConvertibleTo<S>}\newtxt{S2}@>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{s.last} to \tcode{last}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\ednote{Subclauses [move.sent.op.comp] and [move.sent.nonmember] from the Ranges TS intentionally ommitted.}


\ednote{Relocate [iterators.common] from the Ranges TS here and modify as follows:}
\rSec2[iterators.common]{Common iterators}

\pnum
Class template \tcode{common_iterator} is an iterator/sentinel adaptor that is
capable of representing a non-common range of elements (where the types of the
iterator and sentinel differ) as a common range (where they are the same). It
does this by holding either an iterator or a sentinel, and implementing the
equality comparison operators appropriately.

\pnum
\begin{note}
The \tcode{common_iterator} type is useful for interfacing with legacy
code that expects the begin and end of a range to have the same type.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
template<class ForwardIterator>
void fun(ForwardIterator begin, ForwardIterator end);

list<int> s;
// populate the list \tcode{s}
using CI =
  common_iterator<counted_iterator<list<int>::iterator>,
                  default_sentinel>;
// call \tcode{fun} on a range of 10 ints
fun(CI(make_counted_iterator(s.begin(), 10)),
    CI(default_sentinel()));
\end{codeblock}
\end{example}

\rSec3[common.iterator]{Class template \tcode{common_iterator}}

\indexlibrary{\idxcode{common_iterator}}%
\begin{codeblock}
namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  template<Iterator I, Sentinel<I> S>
    requires !Same<I, S>
  class common_iterator {
  public:
    using difference_type = @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>;

    constexpr common_iterator() @\newtxt{= default;}@
    constexpr common_iterator(I i);
    constexpr common_iterator(S s);
    @\oldtxt{constexpr common_iterator(const common_iterator<ConvertibleTo<I>, ConvertibleTo<S>>\& u);}@
    @\newtxt{template<ConvertibleTo<I> I2, ConvertibleTo<S> S2>}@
      @\newtxt{constexpr common_iterator(const common_iterator<I2, S2>\& that);}@

    @\oldtxt{common_iterator\& operator=(const common_iterator<ConvertibleTo<I>, ConvertibleTo<S>>\& u);}@
    @\newtxt{template<ConvertibleTo<I> I2, ConvertibleTo<S> S2>}@
      @\newtxt{common_iterator\& operator=(const common_iterator<I2, S2>\& that);}@

    decltype(auto) operator*();
    decltype(auto) operator*() const
      requires @\placeholder{dereferenceable}@<const I>;
    decltype(auto) operator->() const
      requires @\seebelownc@;

    common_iterator& operator++();
    decltype(auto) operator++(int);
    common_iterator operator++(int)
      requires ForwardIterator<I>;

    @\ednote{Make non-member operators hidden friends.}@
    template<@\oldtxt{class I1}@, class I2, @\oldtxt{Sentinel<I2> S1,}@ Sentinel<I@\oldtxt{1}@> S2>
      @\newtxt{requires Sentinel<S, I2>}@
    friend bool operator==(
      const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);
    template<@\oldtxt{class I1,}@ class I2, @\oldtxt{Sentinel<I2> S1,}@ Sentinel<I@\oldtxt{1}@> S2>
      requires @\newtxt{Sentinel<S, I2> \&\&}@ EqualityComparableWith<I@\oldtxt{1}@, I2>
    friend bool operator==(
      const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);
    template<@\oldtxt{class I1,}@ class I2, @\oldtxt{Sentinel<I2> S1,}@ Sentinel<I@\oldtxt{1}@> S2>
      @\newtxt{requires Sentinel<S, I2>}@
    friend bool operator!=(
      const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);

    template<@\oldtxt{class}\newtxt{SizedSentinel<I>}@ I2, @\oldtxt{SizedSentinel<I2> I1,}@ @\oldtxt{SizedSentinel<I2> S1,}@ SizedSentinel<I@\oldtxt{1}@> S2>
      @\newtxt{requires SizedSentinel<S, I2>}@
    friend difference_type_t<I2> operator-(
      const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);

    friend @\newtxt{iter_}@rvalue_reference_t<I> iter_move(const common_iterator& i)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(declval<const I\&>()))}@)
        requires InputIterator<I>;
    template<IndirectlySwappable<I> I2, class S2>
      friend void iter_swap(const common_iterator& x, const common_iterator<I2, S2>& y)
        noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(declval<const I\&>(), declval<const I\&>()))}@);

  private:
    @\newtxt{variant<I, S> v_{}; // \expos}@
    @\oldtxt{bool is_sentinel;   // \expos}@
    @\oldtxt{I iter;             // \expos}@
    @\oldtxt{S sentinel;         // \expos}@
  };

  template<Readable I, class S>
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<common_iterator<I, S>> {
    using @\newtxt{value_}@type = @\newtxt{iter_}@value@\oldtxt{_type}@_t<I>;
  };

  template<InputIterator I, class S>
  struct iterator_@\oldtxt{category}\newtxt{traits}@<common_iterator<I, S>> {
    @\newtxt{using difference_type = iter_difference_t<I>;}@
    @\newtxt{using value_type = iter_value_t<I>;}@
    @\newtxt{using reference = iter_reference_t<I>;}@
    @\newtxt{using pointer = \seebelownc;}@
    @\newtxt{using iterator_category = \seebelownc;}@
    @\newtxt{using iterator_concept = \seebelownc;}@
    @\oldtxt{using type = input_iterator_tag}@;
  };

  @\oldtxt{template<ForwardIterator I, class S>}@
  @\oldtxt{struct iterator_category<common_iterator<I, S>> \{}@
    @\oldtxt{using type = forward_iterator_tag;}@
  @\oldtxt{\};}@
}@\oldtxt{\}\}\}}@
\end{codeblock}

{\color{newclr}
\rSec3[common.iterator.traits]{\tcode{iterator_traits} for \tcode{common_iterator}}

\pnum
The nested \grammarterm{typedef-name}s of the specialization of
\tcode{iterator_traits} for \tcode{common_iterator<I, S>} are defined as follows.

\pnum
If the expression \tcode{a.operator->()} is well-formed, where \tcode{a}
is an lvalue of type \tcode{const common_iterator<I, S>}, then
\tcode{pointer} denotes the type of that expression. Otherwise, \tcode{pointer}
denotes \tcode{void}.

\pnum
Let \tcode{C} denote the type \tcode{iterator_traits<I>::iterator_category}. If
\tcode{C} models \tcode{DerivedFrom<forward_iterator_tag>},
\tcode{iterator_category} denotes \tcode{forward_iterator_tag}. Otherwise,
\tcode{iterator_category} denotes \tcode{input_iterator_tag}.

\pnum
\tcode{iterator_concept} denotes \tcode{forward_iterator_tag} if \tcode{I}
models \libconcept{ForwardIterator}; otherwise it denotes
\tcode{input_iterator_tag}.
} %% \color{newclr}

\rSec3[common.iterator.ops]{\tcode{common_iterator} operations}

\rSec4[common.iterator.op.const]{\tcode{common_iterator} constructors and conversions}

{\color{oldclr}
\indexlibrary{\idxcode{common_iterator}!\idxcode{common_iterator}}%
\begin{itemdecl}
constexpr common_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{common_iterator}, value-initializing
\tcode{is_sentinel}, \tcode{iter}, and \tcode{sentinel}. Iterator operations
applied to the resulting iterator have defined behavior if and only if the
corresponding operations are defined on a value-initialized iterator of type
\tcode{I}.
\end{itemdescr}
} %% \color{oldclr}

\indexlibrary{\idxcode{common_iterator}!constructor}%
\begin{itemdecl}
constexpr common_iterator(I i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
\newtxt{Initializes }\tcode{\newtxt{v_}}\newtxt{ as if by
}\tcode{\newtxt{v_\{in_place_type<I>, std::move(i)\}}}\newtxt{.}
\oldtxt{Constructs a \tcode{common_iterator}, initializing
\tcode{is_sentinel} with \tcode{false}, \tcode{iter} with \tcode{i}, and
value-initializing \tcode{sentinel}.}
\end{itemdescr}

\indexlibrary{\idxcode{common_iterator}!constructor}%
\begin{itemdecl}
constexpr common_iterator(S s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects \newtxt{Initializes }\tcode{\newtxt{v_}}\newtxt{ as if by
}\tcode{\newtxt{v_\{in_place_type<S>, std::move(s)\}}}\newtxt{.}
\oldtxt{Constructs a \tcode{common_iterator}, initializing
\tcode{is_sentinel} with \tcode{true}, value-initializing \tcode{iter}, and
initializing \tcode{sentinel} with \tcode{s}.}
\end{itemdescr}

\indexlibrary{\idxcode{common_iterator}!constructor}%
\begin{itemdecl}
@\oldtxt{constexpr common_iterator(const common_iterator<ConvertibleTo<I>, ConvertibleTo<S>>\& u);}@
@\newtxt{template<ConvertibleTo<I> I2, ConvertibleTo<S> S2>}@
  @\newtxt{constexpr common_iterator(const common_iterator<I2, S2>\& that);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\requires
}\tcode{\newtxt{that.v_.valueless_by_exception()}}\newtxt{ is \tcode{false}.}

\pnum
\effects
\newtxt{Initializes }\tcode{\newtxt{v_}}\newtxt{ as if by
}\tcode{\newtxt{v_\{in_place_index<$i$>, get<$i$>(that.v_)\}}}\newtxt{,
where $i$ is }\tcode{\newtxt{that.v_.index()}}\newtxt{.}
\oldtxt{Constructs a \tcode{common_iterator}, initializing \tcode{is_sentinel}
with \tcode{u.is_sentinel}, \tcode{iter} with \tcode{u.iter}, and \tcode{sentinel}
with \tcode{u.sentinel}.}
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator=}}%
\begin{itemdecl}
    @\oldtxt{common_iterator\& operator=(const common_iterator<ConvertibleTo<I>, ConvertibleTo<S>>\& u);}@
    @\newtxt{template<ConvertibleTo<I> I2, ConvertibleTo<S> S2>}@
      @\newtxt{common_iterator\& operator=(const common_iterator<I2, S2>\& that);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\requires
}\tcode{\newtxt{that.v_.valueless_by_exception()}}\newtxt{ is \tcode{false}.}

\pnum
\effects
{\color{newclr}
Equivalent to:
\begin{itemize}
\item If \tcode{v_.index() == that.v_.index()}, then
\tcode{get<$i$>(v_) = get<$i$>(that.v_)}.

\item Otherwise, \tcode{v_.emplace<$i$>(get<$i$>(that.v_))}.
\end{itemize}
where $i$ is \tcode{that.v_.index()}.
} %% \color{newclr}
\oldtxt{Assigns \tcode{u.is_sentinel} to \tcode{is_sentinel}, \tcode{u.iter} to
\tcode{iter}, and \tcode{u.sentinel} to \tcode{sentinel}.}

\pnum
\returns \tcode{*this}
\end{itemdescr}

\rSec4[common.iterator.op.star]{\tcode{common_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator*}}%
\begin{itemdecl}
decltype(auto) operator*();
decltype(auto) operator*() const
  requires @\placeholder{dereferenceable}@<const I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\newtxt{holds_alternative<I>(v_)}}\newtxt{.}
\oldtxt{\tcode{!is_sentinel}}

\pnum
\effects Equivalent to:
\tcode{\newtxt{return *get<I>(v_);}}
\oldtxt{\tcode{return *iter;}}
\end{itemdescr}

\rSec4[common.iterator.op.ref]{\tcode{common_iterator::operator->}}

\indexlibrary{\idxcode{operator->}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator->}}%
\begin{itemdecl}
decltype(auto) operator->() const
  requires @\seebelownc@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\newtxt{holds_alternative<I>(v_)}}\newtxt{.}
\oldtxt{\tcode{!is_sentinel}}

\pnum
\effects Equivalent to:
\begin{itemize}
\item
If \tcode{I} is a pointer type or if the expression \tcode{i.operator->()} is
well-formed, \tcode{return \oldtxt{iter} \newtxt{get<I>(v_)};}

\item
Otherwise, if the expression \tcode{\oldtxt{*iter} \newtxt{*get<I>(v_)}} is a glvalue:
\begin{codeblock}
auto&& tmp = @\oldtxt{*iter} \newtxt{*get<I>(v_)}@;
return addressof(tmp);
\end{codeblock}

\item
Otherwise, \tcode{return proxy(\oldtxt{*iter} \newtxt{*get<I>(v_)});} where
\tcode{proxy} is the exposition-only class:
\begin{codeblock}
class proxy {               // \expos
  @\newtxt{iter_}@value@\oldtxt{_type}@_t<I> keep_;
  proxy(@\newtxt{iter_}@reference_t<I>&& x)
    : keep_(std::move(x)) {}
public:
  const @\newtxt{iter_}@value@\oldtxt{_type}@_t<I>* operator->() const {
    return addressof(keep_);
  }
};
\end{codeblock}
\end{itemize}

\pnum
The expression in the requires clause is equivalent to:
\begin{codeblock}
Readable<const I> &&
  (requires(const I& i) { i.operator->(); } ||
   is_reference@\newtxt{_v}@<@\newtxt{iter_}@reference_t<I>>@\oldtxt{::value}@ ||
   Constructible<@\newtxt{iter_}@value@\oldtxt{_type}@_t<I>, @\newtxt{iter_}@reference_t<I>>)
\end{codeblock}
\end{itemdescr}

\rSec4[common.iterator.op.incr]{\tcode{common_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
common_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\newtxt{holds_alternative<I>(v_)}}\newtxt{.}
\oldtxt{\tcode{!is_sentinel}}

\pnum
\effects Equivalent to \tcode{\oldtxt{++iter} \newtxt{++get<I>(v_)}}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
decltype(auto) operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\newtxt{holds_alternative<I>(v_)}}\newtxt{.}
\oldtxt{\tcode{!is_sentinel}}

\pnum
\effects Equivalent to: \tcode{return \oldtxt{iter} \newtxt{get<I>(v_)}++;}
\end{itemdescr}

\begin{itemdecl}
common_iterator operator++(int)
  requires ForwardIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\newtxt{holds_alternative<I>(v_)}}\newtxt{.}
\oldtxt{\tcode{!is_sentinel}}

\pnum
\effects Equivalent to:
\begin{codeblock}
common_iterator tmp = *this;
@\newtxt{++get<I>(v_);}@
@\oldtxt{++iter;}@
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[common.iterator.op.comp]{\tcode{common_iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template<@\oldtxt{class I1}@, class I2, @\oldtxt{Sentinel<I2> S1,}@ Sentinel<I1> S2>
  @\newtxt{requires Sentinel<S1, I2>}@
friend bool operator==(
  const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\requires
}\tcode{\newtxt{x.v_.valueless_by_exception()}}\newtxt{ and
}\tcode{\newtxt{y.v_.valueless_by_exception()}}\newtxt{ are each \tcode{false}.}

\pnum
\oldtxt{\effects Equivalent to:}
\begin{codeblock}
  @\oldtxt{return x.is_sentinel}@
    @\oldtxt{?  (y.is_sentinel || y.iter == x.sentinel)}@
    @\oldtxt{: (!y.is_sentinel || x.iter == y.sentinel);}@
\end{codeblock}

\pnum
\newtxt{\returns
\tcode{true} if \tcode{$i$ == $j$},
and otherwise }\tcode{\newtxt{get<$i$>(x.v_) == get<$j$>(y.v_)}}\newtxt{,
where $i$ is }\tcode{\newtxt{x.v_.index()}}\newtxt{ and $j$ is
}\tcode{\newtxt{y.v_.index()}}\newtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator==}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ class I2, @\oldtxt{Sentinel<I2> S1,}@ Sentinel<I1> S2>
  requires @\newtxt{Sentinel<S1, I2> \&\&}@ EqualityComparableWith<I1, I2>
friend bool operator==(
  const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\requires
}\tcode{\newtxt{x.v_.valueless_by_exception()}}\newtxt{ and
}\tcode{\newtxt{y.v_.valueless_by_exception()}}\newtxt{ are each \tcode{false}.}

\pnum
\oldtxt{\effects Equivalent to:}
\begin{codeblock}
  @\oldtxt{return x.is_sentinel}@
    @\oldtxt{? (y.is_sentinel || y.iter == x.sentinel)}@
    @\oldtxt{: (y.is_sentinel}@
      @\oldtxt{? x.iter == y.sentinel}@
      @\oldtxt{: x.iter == y.iter);}@
\end{codeblock}

\pnum
\newtxt{\returns
\tcode{true} if $i$ and $j$ are each \tcode{1}, and otherwise
}\tcode{\newtxt{get<$i$>(x.v_) == get<$j$>(y.v_)}}\newtxt{, where
$i$ is }\tcode{\newtxt{x.v_.index()}}\newtxt{ and $j$ is
}\tcode{\newtxt{y.v_.index()}}\newtxt{.}
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ class I2, @\oldtxt{Sentinel<I2> S1,}@ Sentinel<I1> S2>
  @\newtxt{requires Sentinel<S1, I2>}@
friend bool operator!=(
  const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return !(x == y);}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
template<@\oldtxt{class}\newtxt{SizedSentinel<I>}@ I2, @\oldtxt{SizedSentinel<I2> I1,}@ @\oldtxt{SizedSentinel<I2> S1,}@ SizedSentinel<I@\oldtxt{1}@> S2>
  @\newtxt{requires SizedSentinel<S, I2>}@
friend difference_type_t<I2> operator-(
  const common_iterator@\oldtxt{<I1, S1>}@& x, const common_iterator<I2, S2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\requires
}\tcode{\newtxt{x.v_.valueless_by_exception()}}\newtxt{ and
}\tcode{\newtxt{y.v_.valueless_by_exception()}}\newtxt{ are each \tcode{false}.}

\pnum
\oldtxt{\effects Equivalent to:}
\begin{codeblock}
  @\oldtxt{return x.is_sentinel}@
    @\oldtxt{? (y.is_sentinel ? 0 : x.sentinel - y.iter)}@
    @\oldtxt{: (y.is_sentinel ? x.iter - y.sentinel : x.iter - y.iter);}@
\end{codeblock}

\pnum
\newtxt{\returns
\tcode{0} if $i$ and $j$ are each \tcode{1}, and otherwise
}\tcode{\newtxt{get<$i$>(x.v_) - get<$j$>(y.v_)}}\newtxt{, where
$i$ is }\tcode{\newtxt{x.v_.index()} and $j$ is \tcode{y.v_.index()}}\newtxt{.}
\end{itemdescr}

\rSec4[common.iterator.op.iter_move]{\tcode{iter_move}}

\indexlibrary{\idxcode{iter_move}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{iter_move}}%
\begin{itemdecl}
friend @\newtxt{iter_}@rvalue_reference_t<I> iter_move(const common_iterator& i)
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(declval<const I\&>()))}@)
    requires InputIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\newtxt{holds_alternative<I>(v_)}}\newtxt{.}
\oldtxt{\tcode{!is_sentinel}}

\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(\newtxt{get<I>(i.v_)} \oldtxt{i.iter});}

\pnum
\oldtxt{\remarks The expression in \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_move(i.iter))}@
\end{codeblock}
\end{itemdescr}

\rSec4[common.iterator.op.iter_swap]{\tcode{iter_swap}}

\indexlibrary{\idxcode{iter_swap}!\idxcode{common_iterator}}%
\indexlibrary{\idxcode{common_iterator}!\idxcode{iter_swap}}%
\begin{itemdecl}
template<IndirectlySwappable<I> I2>
  friend void iter_swap(const common_iterator& x, const common_iterator<I2>& y)
    noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(declval<const I\&>(), declval<const I\&>()))}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{\newtxt{holds_alternative<I>(x.v_)}}\newtxt{ and
}\tcode{\newtxt{holds_alternative<I>(y.v_)}}\newtxt{ are each \tcode{true}.}
\oldtxt{\tcode{!is_sentinel}}

\pnum
\effects
Equivalent to
\tcode{ranges::iter_swap(\newtxt{get<I>(x.v_), get<I>(y.v_)} \oldtxt{x.iter, y.iter})}.

\pnum
\oldtxt{\remarks The expression in \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_swap(x.iter, y.iter))}@
\end{codeblock}
\end{itemdescr}


\ednote{Relocate Ranges TS [default.sentinels] here and modify as follows:}
\rSec2[default.sentinels]{Default sentinels}
\rSec3[default.sent]{Class \tcode{default_sentinel}}

\indexlibrary{\idxcode{default_sentinel}}%
\begin{itemdecl}
namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  class default_sentinel { };
}@\oldtxt{\}\}\}}@
\end{itemdecl}

\pnum
Class \tcode{default_sentinel} is an empty type used to denote the end of a
range. It is intended to be used together with iterator types that know the bound
of their range (e.g., \tcode{counted_iterator}\iref{counted.iterator}).


\ednote{Merge Ranges TS [iterators.counted] and modify as follows:}
\rSec2[iterators.counted]{Counted iterators}
\rSec3[counted.iterator]{Class template \tcode{counted_iterator}}

\pnum
Class template \tcode{counted_iterator} is an iterator adaptor
with the same behavior as the underlying iterator except that it
keeps track of its distance from its starting position. It can be
used together with class \tcode{default_sentinel} in calls to generic
algorithms to operate on a range of $N$ elements starting at a given
position without needing to know the end position \textit{a priori}.

\ednote{The following example incorporates the PR for
\href{https://github.com/ericniebler/stl2/issues/554}{stl2\#554}:}

\pnum
\begin{example}
\begin{codeblock}
list<string> s;
// populate the list \tcode{s} with at least 10 strings
@\oldtxt{vector<string> v(make_counted_iterator(s.begin(), 10),}@
                 @\oldtxt{default_sentinel()); // copies 10 strings into \tcode{v}}@
@\newtxt{vector<string> v;}@
@\newtxt{// copies 10 strings into \tcode{v}:}@
@\newtxt{ranges::copy(make_counted_iterator(s.begin(), 10), default_sentinel(), back_inserter(v));}@
\end{codeblock}
\end{example}

\pnum
Two values \tcode{i1} and \tcode{i2} of (possibly differing) types
\tcode{counted_iterator<I1>} and \tcode{counted_iterator<I2>} refer to
elements of the same sequence if and only if \tcode{next(i1.base(), i1.count())}
and \tcode{next(\brk{}i2.\brk{}base(), i2.count())} refer to the same (possibly past-the-end) element.

\indexlibrary{\idxcode{counted_iterator}}%
\begin{codeblock}
namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  template<Iterator I>
  class counted_iterator {
  public:
    using iterator_type = I;
    using difference_type = @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I>;

    constexpr counted_iterator();
    constexpr counted_iterator(I x, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);
    @\newtxt{template<ConvertibleTo<I> I2>}@
      constexpr counted_iterator(const counted_iterator<@\oldtxt{ConvertibleTo<I>}\newtxt{I2}@>& that);
    @\newtxt{template<ConvertibleTo<I> I2>}@
      constexpr counted_iterator& operator=(const counted_iterator<@\oldtxt{ConvertibleTo<I>}\newtxt{I2}@>& that);

    @\ednote{Non-member operators have been inlined, as members or hidden friends.}@

    constexpr I base() const;
    constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> count() const;
    constexpr decltype(auto) operator*();
    constexpr decltype(auto) operator*() const
      requires @\placeholder{dereferenceable}@<const I>;

    constexpr counted_iterator& operator++();
    decltype(auto) operator++(int);
    constexpr counted_iterator operator++(int)
      requires ForwardIterator<I>;
    constexpr counted_iterator& operator--()
      requires BidirectionalIterator<I>;
    constexpr counted_iterator operator--(int)
      requires BidirectionalIterator<I>;

    constexpr counted_iterator  operator+ (difference_type n) const
      requires RandomAccessIterator<I>;
    @\oldtxt{template<RandomAccessIterator I>}@
      @\newtxt{friend}@ constexpr counted_iterator@\oldtxt{<I>}@ operator+(
        @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, const counted_iterator@\oldtxt{<I>}@& @\oldtxt{x}\newtxt{self}@)
          @\newtxt{requires RandomAccessIterator<I>}@;
    constexpr counted_iterator& operator+=(difference_type n)
      requires RandomAccessIterator<I>;

    constexpr counted_iterator  operator- (difference_type n) const
      requires RandomAccessIterator<I>;
    template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
        @\oldtxt{requires Common<I1, I2>}@
      constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I2> operator-(
        @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
    @\oldtxt{template<class I>}@
      constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> operator-(
        @\oldtxt{const counted_iterator<I>\& x,}@ default_sentinel @\oldtxt{y}@) @\newtxt{const}@;
    @\oldtxt{template<class I>}@
      @\newtxt{friend}@ constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> operator-(
        default_sentinel @\oldtxt{x}@, const counted_iterator@\oldtxt{<I>}@& @\oldtxt{y}\newtxt{self}@);
    constexpr counted_iterator& operator-=(difference_type n)
      requires RandomAccessIterator<I>;

    constexpr decltype(auto) operator[](difference_type n) const
      requires RandomAccessIterator<I>;

    template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
        @\oldtxt{requires Common<I1, I2>}@
      constexpr bool operator==(
        @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
    constexpr bool operator==(
      @\oldtxt{const counted_iterator<auto>\& x,}@ default_sentinel) @\newtxt{const}@;
    @\newtxt{friend}@ constexpr bool operator==(
      default_sentinel, const counted_iterator@\oldtxt{<auto>}@& @\oldtxt{x}\newtxt{self}@);

    template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
        @\oldtxt{requires Common<I1, I2>}@
      constexpr bool operator!=(
        @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
    constexpr bool operator!=(
      @\oldtxt{const counted_iterator<auto>\& x,}@ default_sentinel @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
    @\newtxt{friend}@ constexpr bool operator!=(
      default_sentinel @\oldtxt{x}\newtxt{that}@, const counted_iterator@\oldtxt{<auto>}@& @\oldtxt{y}\newtxt{self}@);

    template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
        @\oldtxt{requires Common<I1, I2>}@
      constexpr bool operator<(
        @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
    template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
        @\oldtxt{requires Common<I1, I2>}@
      constexpr bool operator>(
        @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
    template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
        @\oldtxt{requires Common<I1, I2>}@
      constexpr bool operator<=(
        @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
    template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
        @\oldtxt{requires Common<I1, I2>}@
      constexpr bool operator>=(
        @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;

    friend constexpr @\newtxt{iter_}@rvalue_reference_t<I> iter_move(const counted_iterator& @\oldtxt{i}\newtxt{self}@)
      noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(self.current))}@)
        requires InputIterator<I>;
    template<IndirectlySwappable<I> I2>
      friend constexpr void iter_swap(const counted_iterator& x, const counted_iterator<I2>& y)
        noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.current, y.current))}@);

  private:
    I current;                     // \expos
    @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> cnt; // \expos
  };

  template<Readable I>
  struct @\oldtxt{value_type}\newtxt{readable_traits}@<counted_iterator<I>> {
    using @\newtxt{value_}@type = @\newtxt{iter_}@value@\oldtxt{_type}@_t<I>;
  };

  template<InputIterator I>
  struct iterator_@\oldtxt{category}\newtxt{traits}@<counted_iterator<I>>
    @\newtxt{: iterator_traits<I>}@ {
    @\oldtxt{using type = iterator_category_t<I>;}@
    @\newtxt{using pointer = void;}@
  };

  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr counted_iterator<I> make_counted_iterator(I i, difference_type_t<I> n);}@
}@\oldtxt{\}\}\}}@
\end{codeblock}

\rSec3[counted.iter.ops]{\tcode{counted_iterator} operations}

\rSec4[counted.iter.op.const]{\tcode{counted_iterator} constructors and conversions}

\indexlibrary{\idxcode{counted_iterator}!\idxcode{counted_iterator}}%
\begin{itemdecl}
constexpr counted_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{counted_iterator}, value-initializing
\tcode{current} and \tcode{cnt}. Iterator operations applied to the
resulting iterator have defined behavior if and only if the corresponding operations
are defined on a value-initialized iterator of type \tcode{I}.
\end{itemdescr}

\indexlibrary{\idxcode{counted_iterator}!constructor}%
\begin{itemdecl}
constexpr counted_iterator(I i, @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n >= 0}

\pnum
\effects Constructs a \tcode{counted_iterator}, initializing
\tcode{current} with \tcode{i} and \tcode{cnt} with \tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{counted_iterator}!constructor}%
\begin{itemdecl}
@\newtxt{template<ConvertibleTo<I> I2>}@
  constexpr counted_iterator(const counted_iterator<@\oldtxt{ConvertibleTo<I>}\newtxt{I2}@>& that);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{counted_iterator}, initializing
\tcode{current} with \tcode{that.current} and \tcode{cnt} with \tcode{that.cnt}.
\end{itemdescr}

\indexlibrary{\idxcode{operator=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator=}}%
\begin{itemdecl}
@\newtxt{template<ConvertibleTo<I> I2>}@
  constexpr counted_iterator& operator=(const counted_iterator<@\oldtxt{ConvertibleTo<I>}\newtxt{I2}@>& that);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{that.current} to
\tcode{current} and \tcode{that.cnt} to \tcode{cnt}.
\end{itemdescr}

\rSec4[counted.iter.op.conv]{\tcode{counted_iterator} conversion}

\indexlibrary{\idxcode{base}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{base}}%
\begin{itemdecl}
constexpr I base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[counted.iter.op.cnt]{\tcode{counted_iterator} count}

\indexlibrary{\idxcode{count}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{count}}%
\begin{itemdecl}
constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> count() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{cnt}.
\end{itemdescr}

\rSec4[counted.iter.op.star]{\tcode{counted_iterator::operator*}}

\indexlibrary{\idxcode{operator*}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator*}}%
\begin{itemdecl}
constexpr decltype(auto) operator*();
constexpr decltype(auto) operator*() const
  requires @\placeholder{dereferenceable}@<const I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return *current;}
\end{itemdescr}

\rSec4[counted.iter.op.incr]{\tcode{counted_iterator::operator++}}

\indexlibrary{\idxcode{operator++}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
constexpr counted_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{cnt > 0}

\pnum
\effects Equivalent to:
\begin{codeblock}
++current;
@\dcr@cnt;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator++}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator++}}%
\begin{itemdecl}
decltype(auto) operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{cnt > 0}.

\pnum
\effects Equivalent to:
\begin{codeblock}
--cnt;
try { return current++; }
catch(...) { ++cnt; throw; }
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
constexpr counted_iterator operator++(int)
  requires ForwardIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{cnt > 0}

\pnum
\effects Equivalent to:
\begin{codeblock}
counted_iterator tmp = *this;
++*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[counted.iter.op.decr]{\tcode{counted_iterator::operator-{-}}}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator\dcr}}%
\begin{itemdecl}
  constexpr counted_iterator& operator--();
    requires BidirectionalIterator<I>
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
--current;
++cnt;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{operator\dcr}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator\dcr}}%
\begin{itemdecl}
  constexpr counted_iterator operator--(int)
    requires BidirectionalIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\begin{codeblock}
counted_iterator tmp = *this;
--*this;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[counted.iter.op.+]{\tcode{counted_iterator::operator+}}

\indexlibrary{\idxcode{operator+}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator+}}%
\begin{itemdecl}
  constexpr counted_iterator operator+(difference_type n) const
    requires RandomAccessIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= cnt}

\pnum
\effects Equivalent to:
\tcode{return counted_iterator(current + n, cnt - n);}
\end{itemdescr}

\indexlibrary{\idxcode{operator+}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator+}}%
\begin{itemdecl}
@\oldtxt{template<RandomAccessIterator I>}@
  @\newtxt{friend}@ constexpr counted_iterator@\oldtxt{<I>}@ operator+(
    @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> n, const counted_iterator@\oldtxt{<I>}@& @\oldtxt{x}\newtxt{self}@)
      @\newtxt{requires RandomAccessIterator<I>}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= \oldtxt{x}\newtxt{self}.cnt}.

\pnum
\effects Equivalent to:
\tcode{return \oldtxt{x}\newtxt{self} + n;}
\end{itemdescr}

\rSec4[counted.iter.op.+=]{\tcode{counted_iterator::operator+=}}

\indexlibrary{\idxcode{operator+=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator+=}}%
\begin{itemdecl}
  constexpr counted_iterator& operator+=(difference_type n)
    requires RandomAccessIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= cnt}

\pnum
\effects
\begin{codeblock}
current += n;
cnt -= n;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[counted.iter.op.-]{\tcode{counted_iterator::operator-}}

\indexlibrary{\idxcode{operator-}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
  constexpr counted_iterator operator-(difference_type n) const
    requires RandomAccessIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{-n <= cnt}

\pnum
\effects Equivalent to:
\tcode{return counted_iterator(current - n, cnt + n);}
\end{itemdescr}

\indexlibrary{\idxcode{operator-}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator-}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
    @\oldtxt{requires Common<I1, I2>}@
  constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I2> operator-(
    @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{\oldtxt{x}\newtxt{*this}} and \tcode{\oldtxt{y}\newtxt{that}} shall refer to
elements of the same sequence\iref{counted.iterator}.

\pnum
\effects Equivalent to:
\tcode{return \oldtxt{y}\newtxt{that}.cnt - \oldtxt{x}\newtxt{*this}.cnt;}
\end{itemdescr}

\begin{itemdecl}
@\oldtxt{template<class I>}@
  constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> operator-(
    @\oldtxt{const counted_iterator<I>\& x,}@ default_sentinel @\oldtxt{y}@) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return -\oldtxt{x.}cnt;}
\end{itemdescr}

\begin{itemdecl}
@\oldtxt{template<class I>}@
  @\newtxt{friend}@ constexpr @\newtxt{iter_}@difference@\oldtxt{_type}@_t<I> operator-(
    default_sentinel @\oldtxt{x}@, const counted_iterator@\oldtxt{<I>}@& @\oldtxt{y}\newtxt{self}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to:
\tcode{return \oldtxt{y}\newtxt{self}.cnt;}
\end{itemdescr}

\rSec4[counted.iter.op.-=]{\tcode{counted_iterator::operator-=}}

\indexlibrary{\idxcode{operator-=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator-=}}%
\begin{itemdecl}
  constexpr counted_iterator& operator-=(difference_type n)
    requires RandomAccessIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{-n <= cnt}

\pnum
\effects
\begin{codeblock}
current -= n;
cnt += n;
\end{codeblock}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[counted.iter.op.index]{\tcode{counted_iterator::operator[]}}

\indexlibrary{\idxcode{operator[]}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator[]}}%
\begin{itemdecl}
  constexpr decltype(auto) operator[](difference_type n) const
    requires RandomAccessIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{n <= cnt}

\pnum
\effects Equivalent to:
\tcode{return current[n];}
\end{itemdescr}

\rSec4[counted.iter.op.comp]{\tcode{counted_iterator} comparisons}

\indexlibrary{\idxcode{operator==}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator==}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
    @\oldtxt{requires Common<I1, I2>}@
  constexpr bool operator==(
    @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const};
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{\oldtxt{x}\newtxt{*this}} and \tcode{\oldtxt{y}\newtxt{that}} shall refer to elements of the same
sequence\iref{counted.iterator}.

\pnum
\effects Equivalent to:
\tcode{return \oldtxt{x.}cnt == \oldtxt{y}\newtxt{that}.cnt;}
\end{itemdescr}

\begin{itemdecl}
constexpr bool operator==(
  @\oldtxt{const counted_iterator<auto>\& x,}@ default_sentinel) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return \oldtxt{x.}cnt == 0;}
\end{itemdescr}

\begin{itemdecl}
@\newtxt{friend}@ constexpr bool operator==(
  default_sentinel, const counted_iterator@\oldtxt{<auto>}@& @\oldtxt{x}\newtxt{self}@));
\end{itemdecl}

{\color{newclr}
\begin{itemdescr}
\pnum
\newtxt{\effects Equivalent to: }\tcode{\newtxt{return self == default_sentinel\{\};}}
\end{itemdescr}
} %% \color{newclr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator"!=}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
    @\oldtxt{requires Common<I1, I2>}@
  constexpr bool operator!=(
    @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
constexpr bool operator!=(
  @\oldtxt{const counted_iterator<auto>\& x,}@ default_sentinel @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires For the first overload, \tcode{\oldtxt{x}\newtxt{*this}} and \tcode{\oldtxt{y}\newtxt{that}} shall refer to
elements of the same sequence\iref{counted.iterator}.

\pnum
\effects Equivalent to:
\tcode{return !(\oldtxt{x == y}\newtxt{*this == that});}
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator"!=}}%
\begin{itemdecl}
@\newtxt{friend}@ constexpr bool operator!=(
  default_sentinel @\oldtxt{x}\newtxt{that}@, const counted_iterator@\oldtxt{<auto>}@& @\oldtxt{y}\newtxt{self}@);
\end{itemdecl}

{\color{newclr}
\begin{itemdescr}
\pnum
\newtxt{\effects Equivalent to: }\tcode{\newtxt{return !(that == self);}}
\end{itemdescr}
} %% \color{newclr}

\indexlibrary{\idxcode{operator<}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator<}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
    @\oldtxt{requires Common<I1, I2>}@
  constexpr bool operator<(
    @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{\oldtxt{x}\newtxt{*this}} and \tcode{\oldtxt{y}\newtxt{that}} shall refer to
elements of the same sequence\iref{counted.iterator}.

\pnum
\effects Equivalent to:
\tcode{return \oldtxt{y}\newtxt{that}.cnt < \oldtxt{x}\newtxt{*this}.cnt;}

\pnum
\begin{note}
The argument order in the \textit{Effects} element is reversed because \tcode{cnt}
counts down, not up.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{operator>}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator>}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
    @\oldtxt{requires Common<I1, I2>}@
  constexpr bool operator>(
    @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{\oldtxt{x}\newtxt{*this}} and \tcode{\oldtxt{y}\newtxt{that}} shall refer to
elements of the same sequence\iref{counted.iterator}.

\pnum
\effects Equivalent to:
\tcode{return \oldtxt{y}\newtxt{that} < \oldtxt{x}\newtxt{*this};}
\end{itemdescr}

\indexlibrary{\idxcode{operator<=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator<=}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
    @\oldtxt{requires Common<I1, I2>}@
  constexpr bool operator<=(
    @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{\oldtxt{x}\newtxt{*this}} and \tcode{\oldtxt{y}\newtxt{that}} shall refer to
elements of the same sequence\iref{counted.iterator}.

\pnum
\effects Equivalent to:
\tcode{return !(\oldtxt{y}\newtxt{that} < \oldtxt{x}\newtxt{*this});}
\end{itemdescr}

\indexlibrary{\idxcode{operator>=}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{operator>=}}%
\begin{itemdecl}
template<@\oldtxt{class I1,}@ @\oldtxt{class}\newtxt{Common<I>}@ I2>
    @\oldtxt{requires Common<I1, I2>}@
  constexpr bool operator>=(
    @\oldtxt{const counted_iterator<I1>\& x,}@ const counted_iterator<I2>& @\oldtxt{y}\newtxt{that}@) @\newtxt{const}@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires \tcode{\oldtxt{x}\newtxt{*this}} and \tcode{\oldtxt{y}\newtxt{that}} shall refer to
elements of the same sequence\iref{counted.iterator}.

\pnum
\effects Equivalent to:
\tcode{return !(\oldtxt{x}\newtxt{*this} < \oldtxt{y}\newtxt{that});}
\end{itemdescr}

\rSec4[counted.iter.nonmember]{\tcode{counted_iterator} customizations}

\indexlibrary{\idxcode{iter_move}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{iter_move}}%
\begin{itemdecl}
friend constexpr @\newtxt{iter_}@rvalue_reference_t<I> iter_move(const counted_iterator& \oldtxt{i}\newtxt{self})
  noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_move(self.current))}@)
    requires InputIterator<I>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(\oldtxt{i}\newtxt{self}.current);}

{\color{oldclr}
\pnum
\oldtxt{\remarks The expression in \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_move(i.current))}@
\end{codeblock}
} %% \color{oldclr}
\end{itemdescr}

\indexlibrary{\idxcode{iter_swap}!\idxcode{counted_iterator}}%
\indexlibrary{\idxcode{counted_iterator}!\idxcode{iter_swap}}%
\begin{itemdecl}
template<IndirectlySwappable<I> I2>
  friend constexpr void iter_swap(const counted_iterator& x, const counted_iterator<I2>& y)
    noexcept(@\oldtxt{\seebelow}\newtxt{noexcept(ranges::iter_swap(x.current, y.current))}@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(x.current, y.current)}.

{\color{oldclr}
\pnum
\oldtxt{\remarks The expression in \tcode{noexcept} is equivalent to:}
\begin{codeblock}
@\oldtxt{noexcept(ranges::iter_swap(x.current, y.current))}@
\end{codeblock}
} %% \color{oldclr}
\end{itemdescr}

{\color{oldclr}
\indexlibrary{\idxcode{make_counted_iterator}}%
\begin{itemdecl}
@\oldtxt{template<Iterator I>}@
  @\oldtxt{constexpr counted_iterator<I> make_counted_iterator(I i, difference_type_t<I> n);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\requires \tcode{n >= 0}.}

\pnum
\oldtxt{\returns \tcode{counted_iterator<I>(i, n)}.}
\end{itemdescr}
} %% \color{oldclr}


\ednote{Merge Ranges TS [unreachable.sentinels] and modify as follows
(this wording integrates the PR for
\href{https://github.com/ericniebler/stl2/issues/507}{stl2\#507}):}

\rSec2[unreachable.sentinels]{Unreachable sentinel}
\rSec3[unreachable.sentinel]{Class \tcode{unreachable}}

\pnum
\indexlibrary{\idxcode{unreachable}}%
Class \tcode{unreachable} is a \oldtxt{sentinel}\newtxt{placeholder} type that can be
used with any \oldtxt{\tcode{Iterator}}\newtxt{\tcode{WeaklyIncrementable} type} to
denote \oldtxt{an infinite range}\newtxt{the ``upper bound'' of an open interval}.
Comparing \oldtxt{an iterator}\newtxt{anything} for equality with an object of type
\tcode{unreachable} always returns \tcode{false}.

\pnum
\begin{example}
\begin{codeblock}
char* p;
// set p to point to a character buffer containing newlines
char* nl = find(p, unreachable(), '\n');
\end{codeblock}

Provided a newline character really exists in the buffer, the use of
\tcode{unreachable} above potentially makes the call to \tcode{find} more
efficient since the loop test against the sentinel does not require a
conditional branch.
\end{example}

\begin{codeblock}
namespace std { @\oldtxt{namespace experimental \{ namespace ranges \{ inline namespace v1 \{}@
  class unreachable {
  @\newtxt{public:}@
    @\newtxt{template<WeaklyIncrementable I>}@
      @\newtxt{friend constexpr bool operator==(unreachable, const I\&) noexcept;}@
    @\newtxt{template<WeaklyIncrementable I>}@
      @\newtxt{friend constexpr bool operator==(const I\&, unreachable) noexcept;}@
    @\newtxt{template<WeaklyIncrementable I>}@
      @\newtxt{friend constexpr bool operator!=(unreachable, const I\&) noexcept;}@
    @\newtxt{template<WeaklyIncrementable I>}@
      @\newtxt{friend constexpr bool operator!=(const I\&, unreachable) noexcept;}@
  };

  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator==(unreachable, const I\&) noexcept;}@
  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator==(const I\&, unreachable) noexcept;}@
  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator!=(unreachable, const I\&) noexcept;}@
  @\oldtxt{template<Iterator I>}@
    @\oldtxt{constexpr bool operator!=(const I\&, unreachable) noexcept;}@
}@\oldtxt{\}\}\}}@
\end{codeblock}

\rSec3[unreachable.sentinel.ops]{\tcode{unreachable} operations}

\indexlibrary{\idxcode{operator==}!\idxcode{unreachable}}%
\indexlibrary{\idxcode{unreachable}!\idxcode{operator==}}%
\begin{itemdecl}
template<@\oldtxt{Iterator}\newtxt{WeaklyIncrementable}@ I>
  @\newtxt{friend}@ constexpr bool operator==(unreachable, const I&) noexcept;
template<@\oldtxt{Iterator}\newtxt{WeaklyIncrementable}@ I>
  @\newtxt{friend}@ constexpr bool operator==(const I&, unreachable) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns \tcode{false}.}

\newtxt{\effects Equivalent to: \tcode{return false;}}
\end{itemdescr}

\indexlibrary{\idxcode{operator"!=}!\idxcode{unreachable}}%
\indexlibrary{\idxcode{unreachable}!\idxcode{operator"!=}}%
\begin{itemdecl}
template<@\oldtxt{Iterator}\newtxt{WeaklyIncrementable}@ I>
  @\newtxt{friend}@ constexpr bool operator!=(unreachable x, const I& y) noexcept;
template<@\oldtxt{Iterator}\newtxt{WeaklyIncrementable}@ I>
  @\newtxt{friend}@ constexpr bool operator!=(const I& x, unreachable y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\oldtxt{\returns \tcode{true}.}

\newtxt{\effects Equivalent to: \tcode{return true;}}
\end{itemdescr}
\end{addedblock}


\rSec1[stream.iterators]{Stream iterators}

[...]

\rSec2[istream.iterator]{Class template \tcode{istream_iterator}}

[...]

\begin{codeblock}
namespace std {
  template<class T, class charT = char, class traits = char_traits<charT>,
           class Distance = ptrdiff_t>
  class istream_iterator {
  public:
    [...]

    constexpr istream_iterator();
    @\newtxt{constexpr istream_iterator(default_sentinel);}@
    istream_iterator(istream_type& s);

    [...]

    istream_iterator  operator++(int);

    @\newtxt{friend bool operator==(const istream_iterator\& i, default_sentinel);}@
    @\newtxt{friend bool operator==(default_sentinel, const istream_iterator\& i);}@
    @\newtxt{friend bool operator!=(const istream_iterator\& x, default_sentinel y);}@
    @\newtxt{friend bool operator!=(default_sentinel x, const istream_iterator\& y);}@

  private:
    [...]
  };

  [...]
}
\end{codeblock}

\rSec3[istream.iterator.cons]{\tcode{istream_iterator} constructors and destructor}

\indexlibrary{\idxcode{istream_iterator}!constructor}%
\begin{itemdecl}
constexpr istream_iterator();
@\newtxt{constexpr istream_iterator(default_sentinel);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs the end-of-stream iterator.
If \tcode{is_trivially_default_constructible_v<T>} is \tcode{true},
then \oldtxt{this constructor is a}\newtxt{these constructors are} constexpr
constructor\added{s}.

\pnum
\postconditions \tcode{in_stream == 0}.
\end{itemdescr}

[...]

\rSec3[istream.iterator.ops]{\tcode{istream_iterator} operations}

[...]

\setcounter{Paras}{7}
\indexlibrarymember{operator==}{istream_iterator}%
\begin{itemdecl}
template<class T, class charT, class traits, class Distance>
  bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
                  const istream_iterator<T,charT,traits,Distance>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.in_stream == y.in_stream}.
\end{itemdescr}

\begin{addedblock}
{\color{newclr}
\indexlibrarymember{operator==}{istream_iterator}%
\begin{itemdecl}
@\newtxt{friend bool operator==(default_sentinel, const istream_iterator\& i);}@
@\newtxt{friend bool operator==(const istream_iterator\& i, default_sentinel);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\returns
}\tcode{\newtxt{!i.in_stream}}\newtxt{.}
\end{itemdescr}
} %% \color{newclr}
\end{addedblock}

\indexlibrarymember{operator"!=}{istream_iterator}%
\begin{itemdecl}
template<class T, class charT, class traits, class Distance>
  bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
                  const istream_iterator<T,charT,traits,Distance>& y);
@\newtxt{friend bool operator!=(default_sentinel x, const istream_iterator\& y);}@
@\newtxt{friend bool operator!=(const istream_iterator\& x, default_sentinel y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!(x == y)}
\end{itemdescr}

\rSec2[ostream.iterator]{Class template \tcode{ostream_iterator}}

[...]

\setcounter{Paras}{1}
\pnum \tcode{ostream_iterator} is defined as:

\begin{codeblock}
namespace std {
  template<class T, class charT = char, class traits = char_traits<charT>>
  class ostream_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\oldtxt{void}\newtxt{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using char_type         = charT;
    using traits_type       = traits;
    using ostream_type      = basic_ostream<charT,traits>;

    @\newtxt{constexpr ostream_iterator() noexcept = default;}@
    ostream_iterator(ostream_type& s);

    [...]

  private:
    basic_ostream<charT,traits>* out_stream @\newtxt{= nullptr}@;  // \expos
    const charT* delim @\newtxt{= nullptr}@;                       // \expos
  };
}
\end{codeblock}

[...]

\rSec2[istreambuf.iterator]{Class template \tcode{istreambuf_iterator}}

[...]

\indexlibrary{\idxcode{istreambuf_iterator}}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>>
  class istreambuf_iterator {
  public:
    [...]

    constexpr istreambuf_iterator() noexcept;
    @\newtxt{constexpr istreambuf_iterator(default_sentinel) noexcept;}@
    istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

    [...]

    bool equal(const istreambuf_iterator& b) const;

    @\newtxt{friend bool operator==(default_sentinel s, const istreambuf_iterator\& i);}@
    @\newtxt{friend bool operator==(const istreambuf_iterator\& i, default_sentinel s);}@
    @\newtxt{friend bool operator!=(default_sentinel a, const istreambuf_iterator\& b);}@
    @\newtxt{friend bool operator!=(const istreambuf_iterator\& a, default_sentinel b);}@

  private:
    streambuf_type* sbuf_;                // \expos
  };

  [...]
}
\end{codeblock}

[...]

\setcounter{subsubsection}{1}
\rSec3[istreambuf.iterator.cons]{\tcode{istreambuf_iterator} constructors}

[...]

\setcounter{Paras}{1}
\indexlibrary{\idxcode{istreambuf_iterator}!constructor}%
\begin{itemdecl}
constexpr istreambuf_iterator() noexcept;
@\newtxt{constexpr istreambuf_iterator(default_sentinel) noexcept;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{sbuf_} with \tcode{nullptr}.
\end{itemdescr}

[...]

\rSec3[istreambuf.iterator.ops]{\tcode{istreambuf_iterator} operations}

[...]

\setcounter{Paras}{5}
\indexlibrarymember{operator==}{istreambuf_iterator}%
\begin{itemdecl}
template<class charT, class traits>
  bool operator==(const istreambuf_iterator<charT,traits>& a,
                  const istreambuf_iterator<charT,traits>& b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{a.equal(b)}.
\end{itemdescr}

\begin{addedblock}
{\color{newclr}
\indexlibrarymember{operator==}{istreambuf_iterator}%
\begin{itemdecl}
@\newtxt{friend bool operator==(default_sentinel s, const istreambuf_iterator\& i);}@
@\newtxt{friend bool operator==(const istreambuf_iterator\& i, default_sentinel s);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\newtxt{\returns
\tcode{i.equal(s)}.}
\end{itemdescr}
} %% \color{newclr}
\end{addedblock}

\indexlibrarymember{operator"!=}{istreambuf_iterator}%
\begin{itemdecl}
template<class charT, class traits>
  bool operator!=(const istreambuf_iterator<charT,traits>& a,
                  const istreambuf_iterator<charT,traits>& b);
@\newtxt{friend bool operator!=(default_sentinel a, const istreambuf_iterator\& b);}@
@\newtxt{friend bool operator!=(const istreambuf_iterator\& a, default_sentinel b);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\oldtxt{\tcode{!a.equal(b)}}\newtxt{\tcode{!(a == b)}}.
\end{itemdescr}

[...]

\rSec2[ostreambuf.iterator]{Class template \tcode{ostreambuf_iterator}}

[...]

\indexlibrary{\idxcode{ostreambuf_iterator}}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>>
  class ostreambuf_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\oldtxt{void}\newtxt{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using char_type         = charT;
    using traits_type       = traits;
    using streambuf_type    = basic_streambuf<charT,traits>;
    using ostream_type      = basic_ostream<charT,traits>;

    @\newtxt{constexpr ostreambuf_iterator() noexcept = default;}@

    [...]

  private:
    streambuf_type* sbuf_ @\newtxt{= nullptr}@;                // \expos
  };
}
\end{codeblock}
