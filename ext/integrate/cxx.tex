% Define section from the C++ standard that can be indexed
% using its dotted identifer. That is:
%
%  \cxxsec{basic.def.odr}{3.2}
%
% This is used to make references to sections of the C++ Standard
% that are not labeled within this document.
\newcommand{\cxxsec}[2]{%
  \expandafter\def\csname #1 \endcsname{#2}%
}

% Generate a reference to the section with the given id. This
% expands to the full chapter/section/subsection number declared
% by \cxxsec. For example:
%
%  \cxxref{basic.def.odr}
%
% Expands to the string 3.2.
\newcommand{\stdcxxref}[1]{%
  \csname #1 \endcsname%
}

\newcommand{\cxxref}[1]{%
  \stdcxxref{#1}%
}

\newcommand{\tsref}[1]{%
  ISO/IEC TS 21425:2017 \S\stdcxxref{#1}%
}

% From the Ranges TS
\cxxsec{func.identity}{8.3.3}
\cxxsec{func.invoke}{23.14.4}
\cxxsec{meta.trans.other}{8.4.3}

\cxxsec{intro.compliance}{4.1}
\cxxsec{intro.execution}{6.8.1}
\cxxsec{intro.multithread}{6.8.2}

\cxxsec{lex.key}{5.11}

\cxxsec{basic.def.odr}{6.2}
\cxxsec{basic.scope.namespace}{6.3.6}
\cxxsec{basic.lookup}{6.4}
\cxxsec{basic.lookup.unqual}{6.4.1}
\cxxsec{basic.lookup.argdep}{6.4.2}
\cxxsec{basic.lookup.classref}{6.4.5}
\cxxsec{basic.types}{6.7}
\cxxsec{basic.fundamental}{6.7.1}
\cxxsec{basic.compound}{6.7.2}
\cxxsec{basic.type.qualifier}{6.7.3}

\cxxsec{conv}{7}
\cxxsec{conv.array}{7.2}
\cxxsec{conv.integral}{7.8}

\cxxsec{expr}{8}
\cxxsec{expr.prim}{8.4}
\cxxsec{expr.prim.lambda}{8.4.5}
\cxxsec{expr.prim.fold}{8.4.6}
\cxxsec{expr.prim.req}{8.4.7}
\cxxsec{expr.typeid}{8.5.1.8}
\cxxsec{expr.unary}{8.5.2}
\cxxsec{expr.unary.op}{8.5.2.1}
\cxxsec{expr.pre.incr}{8.5.2.2}
\cxxsec{expr.sizeof}{8.5.2.3}
\cxxsec{expr.new}{8.5.2.4}
\cxxsec{expr.delete}{8.5.2.5}
\cxxsec{expr.alignof}{8.5.2.6}
\cxxsec{expr.unary.noexcept}{8.5.2.7}
\cxxsec{expr.cast}{8.5.3}
\cxxsec{expr.mptr.oper}{8.5.4}
\cxxsec{expr.mul}{8.5.5}
\cxxsec{expr.add}{8.5.6}
\cxxsec{expr.shift}{8.5.7}
\cxxsec{expr.rel}{8.5.9}
\cxxsec{expr.eq}{8.5.10}
\cxxsec{expr.bit.and}{8.5.11}
\cxxsec{expr.xor}{8.5.12}
\cxxsec{expr.or}{8.5.13}
\cxxsec{expr.log.and}{8.5.14}
\cxxsec{expr.log.or}{8.5.15}
\cxxsec{expr.cond}{8.5.16}
\cxxsec{expr.throw}{8.5.17}
\cxxsec{expr.ass}{8.5.18}
\cxxsec{expr.comma}{8.5.19}
\cxxsec{expr.const}{8.6}

\cxxsec{stmt.block}{9.3}
\cxxsec{stmt.select}{9.4}
\cxxsec{stmt.iter}{9.5}
\cxxsec{stmt.for}{9.5.3}

\cxxsec{dcl.dcl}{10}
\cxxsec{dcl.spec}{10.1}
\cxxsec{dcl.fct.spec}{10.1.2}
\cxxsec{dcl.constexpr}{10.1.5}
\cxxsec{dcl.type}{10.1.7}
\cxxsec{dcl.type.cv}{10.1.7.1}
\cxxsec{dcl.type.simple}{10.1.7.2}
\cxxsec{dcl.type.elab}{10.1.6.3}
\cxxsec{dcl.spec.auto}{10.1.6.4}
\cxxsec{namespace.alias}{10.3.2}
\cxxsec{namespace.udecl}{10.3.3}
\cxxsec{dcl.attr.deprecated}{10.6.4}

\cxxsec{dcl.decl}{11}
\cxxsec{dcl.name}{11.1}
\cxxsec{dcl.ambig.res}{11.2}
\cxxsec{dcl.meaning}{11.3}
\cxxsec{dcl.fct}{11.3.5}
\cxxsec{dcl.fct.default}{11.3.6}
\cxxsec{dcl.fct.def}{11.4}
\cxxsec{dcl.fct.def.general}{11.4.1}
\cxxsec{dcl.init}{11.6}
\cxxsec{dcl.init.list}{11.6.4}

\cxxsec{class}{12}
\cxxsec{class.name}{12.1}
\cxxsec{class.mem}{12.2}
\cxxsec{class.static.data}{12.2.3.2}

\cxxsec{class.derived}{13}
\cxxsec{class.mi}{13.1}
\cxxsec{class.member.lookup}{13.2}
\cxxsec{class.virtual}{13.3}
\cxxsec{class.abstract}{13.4}

\cxxsec{class.ctor}{15.1}
\cxxsec{class.conv}{15.3}
\cxxsec{class.dtor}{15.4}

\cxxsec{over}{16}
\cxxsec{over.load}{16.1}
\cxxsec{over.dcl}{16.2}
\cxxsec{over.match}{16.3}
\cxxsec{over.match.funcs}{16.3.1}
\cxxsec{over.match.class.deduct}{16.3.1.8}
\cxxsec{over.match.viable}{16.3.2}
\cxxsec{over.match.best}{16.3.3}
\cxxsec{over.over}{16.4}
\cxxsec{over.oper}{16.5}
\cxxsec{over.call}{16.5.4}
\cxxsec{over.built}{16.6}

\cxxsec{temp}{17}
\cxxsec{temp.param}{17.1}
\cxxsec{temp.names}{17.2}
\cxxsec{temp.arg}{17.3}
\cxxsec{temp.arg.type}{17.3.1}
\cxxsec{temp.arg.nontype}{17.3.2}
\cxxsec{temp.arg.template}{17.3.3}
\cxxsec{temp.constr}{17.4}
\cxxsec{temp.type}{17.5}
\cxxsec{temp.dcls}{17.6}
\cxxsec{temp.class}{17.6.1}
\cxxsec{temp.mem.func}{17.6.1.1}
\cxxsec{temp.mem.class}{17.6.1.2}
\cxxsec{temp.static}{17.6.1.3}
\cxxsec{temp.mem.enum}{17.6.1.4}
\cxxsec{temp.mem}{17.6.2}
\cxxsec{temp.variadic}{17.6.3}
\cxxsec{temp.friend}{17.6.4}
\cxxsec{temp.class.spec.match}{17.6.5.1}
\cxxsec{temp.class.order}{17.6.5.2}
\cxxsec{temp.class.spec.mfunc}{17.6.5.3}
\cxxsec{temp.fct}{17.6.6}
\cxxsec{temp.over.link}{17.6.6.1}
\cxxsec{temp.func.order}{17.6.6.2}
\cxxsec{temp.res}{17.7}
\cxxsec{temp.local}{17.7.1}
\cxxsec{temp.dep}{17.7.2}
\cxxsec{temp.dep.type}{17.7.2.1}
\cxxsec{temp.dep.expr}{17.7.2.2}
\cxxsec{temp.dep.constexpr}{17.7.2.3}
\cxxsec{temp.dep.temp}{17.7.2.4}
\cxxsec{temp.nondep}{17.7.3}
\cxxsec{temp.dep.res}{17.7.4}
\cxxsec{temp.point}{17.7.4.1}
\cxxsec{temp.inject}{17.7.5}
\cxxsec{temp.spec}{17.8}
\cxxsec{temp.inst}{17.8.1}
\cxxsec{temp.explicit}{17.8.2}
\cxxsec{temp.expl.spec}{17.8.3}
\cxxsec{temp.deduct}{17.9.2}
\cxxsec{temp.deduct.call}{17.9.2.1}
\cxxsec{temp.deduct.funcaddr}{17.9.2.2}
\cxxsec{temp.deduct.conv}{17.9.2.3}
\cxxsec{temp.deduct.partial}{17.9.2.4}
\cxxsec{temp.deduct.type}{17.9.2.5}
\cxxsec{temp.deduct.decl}{17.9.2.6}

\cxxsec{except}{18}
\cxxsec{except.throw}{18.1}
\cxxsec{except.ctor}{18.2}
\cxxsec{except.handle}{18.3}
\cxxsec{except.spec}{18.4}
\cxxsec{except.special}{18.5}
\cxxsec{except.terminate}{18.5.1}
\cxxsec{except.uncaught}{18.5.2}

\cxxsec{library}{20}
\cxxsec{type.descriptions}{20.4.2.1}
\cxxsec{customization.point.object}{20.4.2.1.6}
\cxxsec{operators}{20.4.2.3}
\cxxsec{requirements}{20.5}
\cxxsec{utility.requirements}{20.5.3}
\cxxsec{utility.arg.requirements}{20.5.3.1}
\cxxsec{conforming}{20.5.5}
\cxxsec{algorithm.stable}{20.5.5.7}
\cxxsec{res.on.exception.handling}{20.5.5.12}

\cxxsec{support}{21}
\cxxsec{support.initlist}{21.9}

\cxxsec{tab:equalitycomparable}{20}
\cxxsec{tab:lessthancomparable}{21}
\cxxsec{tab:moveconstructible}{23}
\cxxsec{tab:copyconstructible}{24}
\cxxsec{tab:moveassignable}{25}

\cxxsec{concepts.lib}{?}
\cxxsec{concepts.lib.general.equality}{?.1.1}
\cxxsec{concepts.lib.corelang.swappable}{?.3.11}
\cxxsec{concepts.lib.compare.equalitycomparable}{?.4.3}
\cxxsec{concepts.lib.compare.stricttotallyordered}{?.4.4}
\cxxsec{utility.swap}{23.2.2}
\cxxsec{pairs}{23.4}
\cxxsec{tuple}{23.5}
\cxxsec{tuple.helper}{23.5.3.6}
\cxxsec{tuple.elem}{23.5.3.7}
\cxxsec{func.def}{23.14.2}
\cxxsec{func.require}{23.14.3}
\cxxsec{refwrap}{23.14.5}
\cxxsec{meta}{23.15}
\cxxsec{meta.unary}{23.15.4}
\cxxsec{meta.unary.prop}{23.15.4.3}

\cxxsec{containers}{26}
\cxxsec{associative}{26.4}
\cxxsec{set}{26.4.6}
\cxxsec{multiset}{26.4.7}
\cxxsec{unord.set}{26.5.6}
\cxxsec{unord.multiset}{26.5.7}

\cxxsec{iterator.traits}{27.4.1}
\cxxsec{algorithm}{28}

\cxxsec{tab:iterator.forward.requirements}{89}
\cxxsec{tab:iterator.bidirectional.requirements}{90}
\cxxsec{tab:iterator.random.access.requirements}{91}

\cxxsec{numerics}{29}
\cxxsec{rand}{29.6}
\cxxsec{rand.req}{29.6.1}
\cxxsec{rand.req.urng}{29.6.1.3}

\cxxsec{input.output}{30}
\cxxsec{stream.buffers}{30.6}
\cxxsec{iostream.format}{30.7}

\cxxsec{ranges.comparisons}{23.14.8}
\cxxsec{ranges.primitives}{29.6}
\cxxsec{ranges.primitives.size}{29.6.1}
