%!TEX root = std.tex
\setcounter{chapter}{27}
\rSec0[iterators]{Iterators library}

\rSec1[iterators.general]{General}

\pnum
This Clause describes components that \Cpp{} programs may use to perform
iterations over containers\iref{containers},
streams\iref{iostream.format},
and stream buffers\iref{stream.buffers}.

\pnum
The following subclauses describe
iterator requirements, and
components for
iterator primitives,
predefined iterators,
and stream iterators,
as summarized in \tref{iterators.lib.summary}.

\begin{libsumtab}{Iterators library summary}{tab:iterators.lib.summary}
\ref{iterator.requirements} & \changed{R}{Iterator r}equirements        &   \added{\tcode{<iterator>}}    \\
\added{\ref{indirectcallable}} & \added{Indirect callable requirements} &                                 \\
\added{\ref{commonalgoreq}} & \added{Common algorithm requirements}     &                                 \\
\ref{iterator.primitives} & Iterator primitives   &   \removed{\tcode{<iterator>}}                        \\
\ref{predef.iterators} & Predefined iterators     &                                                       \\
\ref{stream.iterators} & Stream iterators         &                                                       \\
\end{libsumtab}


\ednote{Move the section ``Header \tcode{iterator} synopsis'' to immediately follow
[iterators.general] and preceed [iterator.requirements], and change it as follows:}

\rSec1[iterator.synopsis]{Header \tcode{<iterator>} synopsis}

\indexlibrary{\idxhdr{iterator}}%
\begin{codeblock}
@\added{\#include <concepts>}@

namespace std {
  @\ednote{Relocated from the header <range> synopsis, and \placeholder{dereferenceable} is promoted to namespace std::.}@
  template <class T> concept @\placeholder{dereferenceable}@ // \expos
    = requires(T& t) { {*t} -> auto&&; };

  namespace ranges {
    // \ref{iterator.concepts}, iterator \changed{requirements}{concepts}:
    // \ref{iterator.custpoints}, customization points:
    inline namespace @\unspec@ {
      // \ref{iterator.custpoints.iter_move}, iter_move:
      inline constexpr @\unspec@ iter_move = @\unspec@;

      // \ref{iterator.custpoints.iter_swap}, iter_swap:
      inline constexpr @\unspec@ iter_swap = @\unspec@;
    }
  }

  @\ednote{The following through the definition of indirect_result_t is also relocated from <range> but promoted to namespace std::.}@
  // \ref{iterator.assoc.types}, associated types:
  // \ref{iterator.assoc.types.incrementable_traits}, \changed{difference_type}{incrementable_traits}:
  template <class> struct @\changed{difference_type}{incrementable_traits}@;
  template <class T> using @\changed{difference_type_t}{iter_difference_t = \seebelow;}@
    @\removed{= typename difference_type<T>::type;}@

  // \ref{iterator.assoc.types.readable_traits}, \changed{value_type}{readable_traits}:
  template <class> struct @\changed{value_type}{readable_traits}@;
  template <class T> using @\changed{value_type_t}{iter_value_t = \seebelow;}@
    @\removed{= typename value_type<T>::type;}@

  @\removed{// \ref{iterator.assoc.types.iterator_category}, iterator_category:}@
  @\removed{template <class> struct iterator_category;}@
  @\removed{template <class T> using iterator_category_t}@
    @\removed{= typename iterator_category<T>::type;}@

  template <@\placeholder{dereferenceable}@ T> using @\added{iter_}@reference_t
    = decltype(*declval<T&>());

  template <@\placeholder{dereferenceable}@ T>
      requires @\changed{\seebelow}{requires (T\& t) \{}@
        @\added{\{ ranges::iter_move(t) \} -> auto \&\&;}@
      @\added{\}}@
  using @\added{iter_}@rvalue_reference_t
    = decltype(ranges::iter_move(declval<T&>()));

  // \ref{iterators.readable}, Readable:
  template <class In>
  concept Readable = @\seebelow@;

  // \ref{iterators.writable}, Writable:
  template <class Out, class T>
  concept Writable = @\seebelow@;

  // \ref{iterators.weaklyincrementable}, WeaklyIncrementable:
  template <class I>
  concept WeaklyIncrementable = @\seebelow@;

  // \ref{iterators.incrementable}, Incrementable:
  template <class I>
  concept Incrementable = @\seebelow@;

  // \ref{iterators.iterator}, Iterator:
  template <class I>
  concept Iterator = @\seebelow@;

  // \ref{iterators.sentinel}, Sentinel:
  template <class S, class I>
  concept Sentinel = @\seebelow@;

  // \ref{iterators.sizedsentinel}, SizedSentinel:
  template <class S, class I>
  constexpr bool disable_sized_sentinel = false;

  template <class S, class I>
  concept SizedSentinel = @\seebelow@;

  // \ref{iterators.input}, InputIterator:
  template <class I>
  concept InputIterator = @\seebelow@;

  // \ref{iterators.output}, OutputIterator:
  template <class I>
  concept OutputIterator = @\seebelow@;

  // \ref{iterators.forward}, ForwardIterator:
  template <class I>
  concept ForwardIterator = @\seebelow@;

  // \ref{iterators.bidirectional}, BidirectionalIterator:
  template <class I>
  concept BidirectionalIterator = @\seebelow@;

  // \ref{iterators.random.access}, RandomAccessIterator:
  template <class I>
  concept RandomAccessIterator = @\seebelow@;

  // \ref{indirectcallable}, indirect callable requirements:
  // \ref{indirectcallable.indirectinvocable}, indirect callables:
  template <class F, class I>
  concept IndirectUnaryInvocable = @\seebelow@;

  template <class F, class I>
  concept IndirectRegularUnaryInvocable = @\seebelow@;

  template <class F, class I>
  concept IndirectUnaryPredicate = @\seebelow@;

  template <class F, class I1, class I2 = I1>
  concept IndirectRelation = @\seebelow@;

  template <class F, class I1, class I2 = I1>
  concept IndirectStrictWeakOrder = @\seebelow@;

  template <class, class...> struct indirect_result { };

  template <class F, class... Is>
    requires (Readable<Is> &&...) && Invocable<F, @\added{iter_}@reference_t<Is>...>
  struct indirect_result<F, Is...>;

  template <class F, class... Is>
  using indirect_result_t = typename indirect_result<F, Is...>::type;

  // \ref{projected}, projected:
  template <Readable I, IndirectRegularUnaryInvocable<I> Proj>
  struct projected;

  template <WeaklyIncrementable I, class Proj>
  struct @\changed{difference_type}{incrementable_traits}@<projected<I, Proj>>;

  // \ref{commonalgoreq}, common algorithm requirements:
  // \ref{commonalgoreq.indirectlymovable} IndirectlyMovable:
  template <class In, class Out>
  concept IndirectlyMovable = @\seebelow@;

  template <class In, class Out>
  concept IndirectlyMovableStorable = @\seebelow@;

  // \ref{commonalgoreq.indirectlycopyable} IndirectlyCopyable:
  template <class In, class Out>
  concept IndirectlyCopyable = @\seebelow@;

  template <class In, class Out>
  concept IndirectlyCopyableStorable = @\seebelow@;

  // \ref{commonalgoreq.indirectlyswappable} IndirectlySwappable:
  template <class I1, class I2 = I1>
  concept IndirectlySwappable = @\seebelow@;

  // \ref{commonalgoreq.indirectlycomparable} IndirectlyComparable:
  template <class I1, class I2, class R = @\added{ranges::}@equal_to<>, class P1 = identity,
      class P2 = identity>
  concept IndirectlyComparable = @\seebelow@;

  // \ref{commonalgoreq.permutable} Permutable:
  template <class I>
  concept Permutable = @\seebelow@;

  // \ref{commonalgoreq.mergeable} Mergeable:
  template <class I1, class I2, class Out,
      class R = @\added{ranges::}@less<>, class P1 = identity, class P2 = identity>
  concept Mergeable = @\seebelow@;

  template <class I, class R = @\added{ranges::}@less<>, class P = identity>
  concept Sortable = @\seebelow@;

  @\ednote{ranges::iterator_traits from P0896 is intentionally omitted.}@

  template <Readable T> using iter_common_reference_t
    = common_reference_t<@\added{iter_}@reference_t<T>, @\changed{value_type_t}{iter_value_t}@<T>&>;

  // \ref{iterator.primitives}, primitives
  template<class Iterator> struct iterator_traits;
  template<class T> struct iterator_traits<T*>;

  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
  @\added{struct contiguous_iterator_tag: public random_access_iterator_tag \{ \};}@

  @\ednote{The clones of the iterator tags in the ranges:: namespace from P0896R1 are intentionally omitted here.}@

  // \ref{iterator.operations}, iterator operations
  template<class InputIterator, class Distance>
    constexpr void
      advance(InputIterator& i, Distance n);
  template<class InputIterator>
    constexpr typename iterator_traits<InputIterator>::difference_type
      distance(InputIterator first, InputIterator last);
  template<class InputIterator>
    constexpr InputIterator
      next(InputIterator x,
           typename iterator_traits<InputIterator>::difference_type n = 1);
  template<class BidirectionalIterator>
    constexpr BidirectionalIterator
      prev(BidirectionalIterator x,
           typename iterator_traits<BidirectionalIterator>::difference_type n = 1);

  @\added{namespace ranges \{}@
    // \ref{range.iterator.operations}, \added{Range} iterator operations:
    @\added{// \ref{range.iterator.operations.advance}, \tcode{ranges::advance}:}@
    template <Iterator I>
      constexpr void advance(I& i, @\added{iter_}@difference@\removed{_type}@_t<I> n);
    template <Iterator I, Sentinel<I> S>
      constexpr void advance(I& i, S bound);
    template <Iterator I, Sentinel<I> S>
      constexpr @\added{iter_}@difference@\removed{_type}@_t<I> advance(I& i, @\added{iter_}@difference@\removed{_type}@_t<I> n, S bound);

    @\added{// \ref{range.iterator.operations.distance}, \tcode{ranges::distance}:}@
    template <Iterator I, Sentinel<I> S>
      constexpr @\added{iter_}@difference@\removed{_type}@_t<I> distance(I first, S last);
    template <Range R>
      constexpr @\added{iter_}@difference@\removed{_type}@_t<iterator_t<R>> distance(R&& r);

    @\added{// \ref{range.iterator.operations.next}, \tcode{ranges::next}:}@
    template <Iterator I>
      constexpr I next(I x);
    template <Iterator I>
      constexpr I next(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n);
    template <Iterator I, Sentinel<I> S>
      constexpr I next(I x, S bound);
    template <Iterator I, Sentinel<I> S>
      constexpr I next(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n, S bound);

    @\added{// \ref{range.iterator.operations.prev}, \tcode{ranges::prev}:}@
    template <BidirectionalIterator I>
      constexpr I prev(I x);
    template <BidirectionalIterator I>
      constexpr I prev(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n);
    template <BidirectionalIterator I>
      constexpr I prev(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n, I bound);
  @\added{\}}@

  // \ref{iterators.predef}, predefined iterators and sentinels:
  // \ref{predef.iterators}, predefined iterators
  template<class Iterator> class reverse_iterator;

  template<class Iterator1, class Iterator2>
    constexpr bool operator==(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator!=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);

  template<class Iterator1, class Iterator2>
    constexpr auto operator-(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
  template<class Iterator>
    constexpr reverse_iterator<Iterator>
      operator+(
    typename reverse_iterator<Iterator>::difference_type n,
    const reverse_iterator<Iterator>& x);

  template<class Iterator>
    constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i);

  template<class Container> class back_insert_iterator;
  template<class Container>
    back_insert_iterator<Container> back_inserter(Container& x);

  template<class Container> class front_insert_iterator;
  template<class Container>
    front_insert_iterator<Container> front_inserter(Container& x);

  template<class Container> class insert_iterator;
  template<class Container>
    insert_iterator<Container> inserter(Container& x, typename Container::iterator i);
  @\ednote{The insert iterators from P0896R1 are intentionally omitted.}@

  template<class Iterator> class move_iterator;
  template<class Iterator1, class Iterator2>
    constexpr bool operator==(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator!=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

  template<class Iterator1, class Iterator2>
    constexpr auto operator-(
    const move_iterator<Iterator1>& x,
    const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
  template<class Iterator>
    constexpr move_iterator<Iterator> operator+(
      typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);
  template<class Iterator>
    constexpr move_iterator<Iterator> make_move_iterator(Iterator i);

  @\ednote{move_sentinel is taken from the <range> synopsis of P0896R1.}@
  template <Semiregular S> class move_sentinel;

  @\ednote{common_iterator and associated types specializations are taken from the <range> synopsis of P0896R1.}@
  // \ref{iterators.common}, common iterators:
  template <Iterator I, Sentinel<I> S>
    requires !Same<I, S>
  class common_iterator;

  template <Readable I, class S>
  struct @\changed{value_type}{readable_traits}@<common_iterator<I, S>>;

  template <InputIterator I, class S>
  struct iterator_@\changed{category}{traits}@<common_iterator<I, S>>;

  template <ForwardIterator I, class S>
  struct iterator_@\changed{category}{traits}@<common_iterator<I, S>>;

  template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
  bool operator==(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
  template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
    requires EqualityComparableWith<I1, I2>
  bool operator==(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
  template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
  bool operator!=(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

  template <class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>
  @\added{iter_}@difference@\removed{_type}@_t<I2> operator-(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

  // \ref{default.sentinels}, default sentinels:
  class default_sentinel;

  // \ref{iterators.counted}, counted iterators:
  template <Iterator I> class counted_iterator;

  @\added{template <Readable I>}@
    @\added{struct readable_traits<counted_iterator<I>{>};}@

  @\added{template <InputIterator I>}@
    @\added{struct iterator_traits<counted_iterator<I>{>};}@

  template <class I1, class I2>
      requires Common<I1, I2>
    constexpr bool operator==(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  // ... as in P0896R1, but relocated into namespace std

  @\ednote{P0896R1's versions of reverse_iterator and move_iterator are intentionally omitted.}@

  @\ednote{unreachable is from P0896R1 and promoted to namespace std.}@
  class unreachable;

  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator==(const I&, unreachable) noexcept;
  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator==(unreachable, const I&) noexcept;
  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator!=(const I&, unreachable) noexcept;
  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator!=(unreachable, const I&) noexcept;

  // \ref{stream.iterators}, stream iterators
  template<class T, class charT = char, class traits = char_traits<charT>,
           class Distance = ptrdiff_t>
  class istream_iterator;
  template<class T, class charT, class traits, class Distance>
    bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);
  template<class T, class charT, class traits, class Distance>
    bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);

  template<class T, class charT = char, class traits = char_traits<charT>>
      class ostream_iterator;

  template<class charT, class traits = char_traits<charT>>
    class istreambuf_iterator;
  template<class charT, class traits>
    bool operator==(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);
  template<class charT, class traits>
    bool operator!=(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);

  template<class charT, class traits = char_traits<charT>>
    class ostreambuf_iterator;
  @\ednote{The stream iterators from P0896R1 are intentionally omitted.}@

  // \ref{iterator.range}, range access
  template<class C> constexpr auto begin(C& c) -> decltype(c.begin());
  template<class C> constexpr auto begin(const C& c) -> decltype(c.begin());
  template<class C> constexpr auto end(C& c) -> decltype(c.end());
  template<class C> constexpr auto end(const C& c) -> decltype(c.end());
  template<class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept;
  template<class T, size_t N> constexpr T* end(T (&array)[N]) noexcept;
  template<class C> constexpr auto cbegin(const C& c) noexcept(noexcept(std::begin(c)))
    -> decltype(std::begin(c));
  template<class C> constexpr auto cend(const C& c) noexcept(noexcept(std::end(c)))
    -> decltype(std::end(c));
  template<class C> constexpr auto rbegin(C& c) -> decltype(c.rbegin());
  template<class C> constexpr auto rbegin(const C& c) -> decltype(c.rbegin());
  template<class C> constexpr auto rend(C& c) -> decltype(c.rend());
  template<class C> constexpr auto rend(const C& c) -> decltype(c.rend());
  template<class T, size_t N> constexpr reverse_iterator<T*> rbegin(T (&array)[N]);
  template<class T, size_t N> constexpr reverse_iterator<T*> rend(T (&array)[N]);
  template<class E> constexpr reverse_iterator<const E*> rbegin(initializer_list<E> il);
  template<class E> constexpr reverse_iterator<const E*> rend(initializer_list<E> il);
  template<class C> constexpr auto crbegin(const C& c) -> decltype(std::rbegin(c));
  template<class C> constexpr auto crend(const C& c) -> decltype(std::rend(c));

  // \ref{iterator.container}, container access
  template<class C> constexpr auto size(const C& c) -> decltype(c.size());
  template<class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept;
  template<class C> [[nodiscard]] constexpr auto empty(const C& c) -> decltype(c.empty());
  template<class T, size_t N> [[nodiscard]] constexpr bool empty(const T (&array)[N]) noexcept;
  template<class E> [[nodiscard]] constexpr bool empty(initializer_list<E> il) noexcept;
  template<class C> constexpr auto data(C& c) -> decltype(c.data());
  template<class C> constexpr auto data(const C& c) -> decltype(c.data());
  template<class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;
  template<class E> constexpr const E* data(initializer_list<E> il) noexcept;
}
\end{codeblock}

\ednote{For the remainder of Clauses [iterator] and [ranges], textually replace
\tcode{value_type<>}, \tcode{difference_type<>}, \tcode{value_type_t<>},
\tcode{difference_type_t<>}, \tcode{reference_t<>}, and \tcode{rvalue_reference_t<>}
with \tcode{readable_traits<>}, \tcode{incrementable_traits<>}, \tcode{iter_value_t<>},
\tcode{iter_difference_t<>}, \tcode{iter_reference_t<>}, and
\tcode{iter_rvalue_reference_t<>}, respectively.}

\rSec1[iterator.requirements]{Iterator requirements}

\rSec2[iterator.requirements.general]{In general}

\pnum
\indextext{requirements!iterator}%
Iterators are a generalization of pointers that allow a \Cpp{} program to work with different data structures
(containers) in a uniform manner.
To be able to construct template algorithms that work correctly and
efficiently on different types of data structures, the library formalizes not just the interfaces but also the
semantics and complexity assumptions of iterators.
An input iterator
\tcode{i}
supports the expression
\tcode{*i},
resulting in a value of some object type
\tcode{T},
called the
\term{value type}
of the iterator.
An output iterator \tcode{i} has a non-empty set of types that are
\defn{writable} to the iterator;
for each such type \tcode{T}, the expression \tcode{*i = o}
is valid where \tcode{o} is a value of type \tcode{T}.
An iterator
\tcode{i}
for which the expression
\tcode{(*i).m}
is well-defined supports the expression
\tcode{i->m}
with the same semantics as
\tcode{(*i).m}.
For every iterator type
\tcode{X}
for which
equality is defined, there is a corresponding signed integer type called the
\term{difference type}
of the iterator.

\pnum
Since iterators are an abstraction of pointers, their semantics is
a generalization of most of the semantics of pointers in \Cpp{}.
This ensures that every
function template
that takes iterators
works as well with regular pointers.
This document defines
five categories of iterators, according to the operations
defined on them:
\techterm{input iterators},
\techterm{output iterators},
\techterm{forward iterators},
\techterm{bidirectional iterators}
and
\techterm{random access iterators},
as shown in \tref{iterators.relations}.

\begin{floattable}{Relations among iterator categories}{tab:iterators.relations}
{llll}
\topline
\textbf{Random Access}          &   $\rightarrow$ \textbf{Bidirectional}    &
$\rightarrow$ \textbf{Forward}  &   $\rightarrow$ \textbf{Input}            \\
                        &   &   &   $\rightarrow$ \textbf{Output}           \\
\end{floattable}

\pnum
Forward iterators satisfy all the requirements of input
iterators and can be used whenever
an input iterator is specified;
Bidirectional iterators also satisfy all the requirements of
forward iterators and can be used whenever a forward iterator is specified;
Random access iterators also satisfy all the requirements of bidirectional
iterators and can be used whenever a bidirectional iterator is specified.

\pnum
Iterators that further satisfy the requirements of output iterators are
called \defnx{mutable iterators}{mutable iterator}. Nonmutable iterators are referred to
as \defnx{constant iterators}{constant iterator}.

\pnum
In addition to the requirements in this subclause,
the nested \grammarterm{typedef-name}{s} specified in \ref{iterator.traits}
shall be provided for the iterator type.
\begin{note} Either the iterator type must provide the \grammarterm{typedef-name}{s} directly
(in which case \tcode{iterator_traits} pick them up automatically), or
an \tcode{iterator_traits} specialization must provide them. \end{note}

\pnum
Iterators that further satisfy the requirement that,
for integral values \tcode{n} and
dereferenceable iterator values \tcode{a} and \tcode{(a + n)},
\tcode{*(a + n)} is equivalent to \tcode{*(addressof(*a) + n)},
are called \defn{contiguous iterators}.
\begin{note}
For example, the type ``pointer to \tcode{int}'' is a contiguous iterator,
but \tcode{reverse_iterator<int *>} is not.
For a valid iterator range $[$\tcode{a}$, $\tcode{b}$)$ with dereferenceable \tcode{a},
the corresponding range denoted by pointers is
$[$\tcode{addressof(*a)}$, $\tcode{addressof(*a) + (b - a)}$)$;
\tcode{b} might not be dereferenceable.
\end{note}

\pnum
Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence.
These values are called
\term{past-the-end}
values.
Values of an iterator
\tcode{i}
for which the expression
\tcode{*i}
is defined are called
\term{dereferenceable}.
The library never assumes that past-the-end values are dereferenceable.
Iterators can also have singular values that are not associated with any
sequence.
\begin{example}
After the declaration of an uninitialized pointer
\tcode{x}
(as with
\tcode{int* x;}),
\tcode{x}
must always be assumed to have a singular value of a pointer.
\end{example}
Results of most expressions are undefined for singular values;
the only exceptions are destroying an iterator that holds a singular value,
the assignment of a non-singular value to
an iterator that holds a singular value, and, for iterators that satisfy the
\tcode{DefaultConstructible} requirements, using a value-initialized iterator
as the source of a copy or move operation. \begin{note} This guarantee is not
offered for default-initialization, although the distinction only matters for types
with trivial default constructors such as pointers or aggregates holding pointers.
\end{note}
In these cases the singular
value is overwritten the same way as any other value.
Dereferenceable
values are always non-singular.

\pnum
An iterator
\tcode{j}
is called
\term{reachable}
from an iterator
\tcode{i}
if and only if there is a finite sequence of applications of
the expression
\tcode{++i}
that makes
\tcode{i == j}.
If
\tcode{j}
is reachable from
\tcode{i},
they refer to elements of the same sequence.

\pnum
Most of the library's algorithmic templates that operate on data structures have interfaces that use ranges.
A
\term{range}
is a pair of iterators that designate the beginning and end of the computation.
A range \range{i}{i}
is an empty range;
in general, a range \range{i}{j}
refers to the elements in the data structure starting with the element
pointed to by
\tcode{i}
and up to but not including the element pointed to by
\tcode{j}.
Range \range{i}{j}
is valid if and only if
\tcode{j}
is reachable from
\tcode{i}.
The result of the application of functions in the library to invalid ranges is
undefined.

\pnum
All the categories of iterators require only those functions that are realizable for a given category in
constant time (amortized).
Therefore, requirement tables for the iterators do not have a complexity column.

\pnum
Destruction of an iterator may invalidate pointers and references
previously obtained from that iterator.

\pnum
An
\techterm{invalid}
iterator is an iterator that may be singular.\footnote{This definition applies to pointers, since pointers are iterators.
The effect of dereferencing an iterator that has been invalidated
is undefined.
}

\pnum
\indextext{iterator!constexpr}
Iterators are called \defn{constexpr iterators}
if all operations provided to satisfy iterator category operations
are constexpr functions, except for
\begin{itemize}
\item \tcode{swap},
\item a pseudo-destructor call\iref{expr.pseudo}, and
\item the construction of an iterator with a singular value.
\end{itemize}
\begin{note}
For example, the types ``pointer to \tcode{int}'' and
\tcode{reverse_iterator<int*>} are constexpr iterators.
\end{note}

\pnum
In the following sections,
\tcode{a}
and
\tcode{b}
denote values of type
\tcode{X} or \tcode{const X},
\tcode{difference_type} and \tcode{reference} refer to the
types \tcode{iterator_traits<X>::difference_type} and
\tcode{iterator_traits<X>::reference}, respectively,
\tcode{n}
denotes a value of
\tcode{difference_type},
\tcode{u},
\tcode{tmp},
and
\tcode{m}
denote identifiers,
\tcode{r}
denotes a value of
\tcode{X\&},
\tcode{t}
denotes a value of value type
\tcode{T},
\tcode{o}
denotes a value of some type that is writable to the output iterator.
\begin{note} For an iterator type \tcode{X} there must be an instantiation
of \tcode{iterator_traits<X>}\iref{iterator.traits}. \end{note}

\ednote{[range.iterator.custpoints], [range.iterator.assoc.types], and the concept
definitions \tcode{Readable} through \tcode{RandomAccessIterator} from subsection
[range.iterator.requirements] all get moved into a new section [iterator.concepts].}

\rSec2[iterator.concepts]{Iterator concepts}
\rSec3[iterator.custpoints]{Customization points}
\ednote{Relocated from [range.iterator.custpoints] in P0896R1.}

\rSec4[iterator.custpoints.iter_move]{\tcode{iter_move}}
\ednote{Relocated from [range.iterator.custpoints.iter_move] in P0896R1 and
changed as follows:}

\pnum
The name \tcode{iter_move} denotes a \techterm{customization point
object}~(\cxxref{customization.point.object}). The expression
\tcode{ranges::iter_move(E)} for some subexpression \tcode{E} is expression-equivalent to the
following:

\begin{itemize}
\item \tcode{\removed{static_cast<decltype(iter_move(E))>(}iter_move(E)\removed{)}}, if that expression
is well-formed when evaluated in a context that does not include
\tcode{ranges::iter_move} but does include the
lookup set produced by argument-dependent lookup~(\cxxref{basic.lookup.argdep}).

\item Otherwise, if the expression \tcode{*E} is well-formed:
\begin{itemize}
\item if \tcode{*E} is an lvalue, \tcode{std::move(*E)};

\item otherwise, \tcode{\removed{static_cast<decltype(*E)>(}*E\removed{)}}.
\end{itemize}

\item Otherwise, \tcode{ranges::iter_move(E)} is ill-formed.
\end{itemize}

\pnum
If \tcode{ranges::iter_move(E)} does not equal \tcode{*E}, the program is
ill-formed with no diagnostic required.

\rSec4[iterator.custpoints.iter_swap]{\tcode{iter_swap}}

\ednote{...as in P0896R1 with updates for the new associated type alias names.}

\rSec3[iterator.assoc.types]{Iterator associated types}
\ednote{Relocated from [range.iterator.assoc.types] in P0896R1 and changed as follows:}

\pnum
To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
\tcode{WI} is the name of a type that
satisfies the \tcode{WeaklyIncrementable} concept~(\ref{iterators.weaklyincrementable})\changed{,}{ and}
\tcode{R} is the name of a type that
satisfies the \tcode{Readable} concept~(\ref{iterators.readable})\removed{, and
\tcode{II} is the name of a type that satisfies the
\tcode{InputIterator} concept~(\ref{iterators.input}) concept}, the types

\begin{codeblock}
@\changed{difference_type_t}{iter_difference_t}@<WI>
@\changed{value_type_t}{iter_value_t}@<R>
@\removed{iterator_category_t<II>}@
\end{codeblock}

be defined as the iterator's difference type\changed{,}{ and} value type
\removed{ and iterator category}, respectively.

\ednote{Change the name of [iterator.assoc.types.difference_type] from
``\tcode{difference_type}'' to ``\tcode{incrementable_traits}''.}
\rSec4[iterator.assoc.types.incrementable_traits]{\tcode{incrementable_traits}}

\pnum
\indexlibrary{\idxcode{iter_difference_t}}%
\tcode{\changed{difference_type_t}{iter_difference_t}<T>} is implemented as if:

\indexlibrary{\idxcode{incrementable_traits}}%
\begin{codeblock}
@\added{namespace std \{ namespace ranges \{}@
  @\added{struct \xname{empty} \{ \}; // \expos}@

  @\added{template <class T> struct \xname{with_difference_type} \{ // \expos}@
    @\added{using difference_type = T;}@
  @\added{\};}@

  template <class> struct @\changed{difference_type}{incrementable_traits}@ { };

  template <class T>
  struct @\changed{difference_type}{incrementable_traits}@<T*>
    : @\changed{enable_if}{conditional_t}@<is_object@\added{_v}@<T>@\removed{::value}@,
        @\added{\xname{with_difference_type}<}@ptrdiff_t@\added{>, \xname{empty}}@> { };

  template <class I>
  struct @\changed{difference_type}{incrementable_traits}@<const I>
    : @\changed{difference_type}{incrementable_traits}@<decay_t<I>> { };

  template <class T>
    requires requires { typename T::difference_type; }
  struct @\changed{difference_type}{incrementable_traits}@<T> {
    using @\added{difference_}@type = typename T::difference_type;
  };

  template <class T>
    requires !requires { typename T::difference_type; } &&
      requires(const T& a, const T& b) { { a - b } -> Integral; }
  struct @\changed{difference_type}{incrementable_traits}@<T>
    : @\added{\xname{with_difference_type< }}@make_signed@\added{_t}@< decltype(declval<T>() - declval<T>()) >@\added{>}@ {
  };

  template <class T> using @\changed{difference_type_t}{iter_difference_t = \seebelow;}@
    @\removed{= typename difference_type<T>::type;}@
@\added{\}\}}@
\end{codeblock}

\begin{addedblock}
\pnum
If \tcode{iterator_traits<T>} does not name an instantiation of the primary
template, then \tcode{iter_difference_t<T>}
is an alias for the type \tcode{iterator_traits<T>::difference_type}; otherwise,
it is an alias for the type \tcode{incrementable_traits<T>::difference_type}.
\end{addedblock}

\pnum
Users may specialize \changed{\tcode{difference_type}}{\tcode{incrementable_traits}}
on user-defined types.

\ednote{Change the name of [iterator.assoc.types.value_type] from
``\tcode{value_type}'' to ``\tcode{readable_traits}''.}
\rSec4[iterator.assoc.types.readable_traits]{\tcode{readable_traits}}

\pnum
A \tcode{Readable} type has an associated value type that can be accessed with the
\changed{\tcode{value_type_t}}{\tcode{iter_value_t}} alias template.

\indexlibrary{\idxcode{readable_traits}}%
\begin{codeblock}
  @\added{template <class T> struct \xname{with_value_type} \{ // \expos}@
    @\added{using value_type = T;}@
  @\added{\};}@

  template <class> struct @\changed{value_type}{readable_traits}@ { };

  template <class T>
  struct @\changed{value_type}{readable_traits}@<T*>
    : @\changed{enable_if}{conditional_t}@<is_object@\added{_v}@<T>@\removed{::value}@,
        @\added{\xname{with_value_type}< }@remove_cv_t<T> @\added{>, \xname{empty}}@ > { };

  template <class I>
    requires is_array@\added{_v}@<I>@\removed{::value}@
  struct @\changed{value_type}{readable_traits}@<I>
    : @\changed{value_type}{readable_traits}@<decay_t<I>> { };

  template <class I>
  struct @\changed{value_type}{readable_traits}@<const I>
    : @\changed{value_type}{readable_traits}@<decay_t<I>> { };

  template <class T>
    requires requires { typename T::value_type; }
  struct @\changed{value_type}{readable_traits}@<T>
    : @\changed{enable_if}{conditional_t}@<is_object@\added{_v}@<typename T::value_type>@\removed{::value}@,
        @\added{\xname{with_value_type}< }@typename T::value_type @\added{>, \xname{empty}}@ > { };

  template <class T>
    requires requires { typename T::element_type; }
  struct value_type<T>
    : @\changed{enable_if}{conditional_t}@<
        is_object@\added{_v}@<typename T::element_type>@\removed{::value}@,
        @\added{\xname{with_value_type}< }@remove_cv_t<typename T::element_type> @\added{>,}@
        @\added{\xname{empty}}@>
    { };

  template <class T> using @\changed{value_type_t}{iter_value_t = // \seebelow;}@
    @\removed{= typename value_type<T>::type;}@
\end{codeblock}

\begin{addedblock}
\pnum
If \tcode{iterator_traits<T>} does not name an instantiation of the primary
template, then \tcode{iter_value_t<T>} is an
alias for the type \tcode{iterator_traits<T>::value_type}; otherwise, it is an
alias for the type \tcode{readable_traits<T>::value_type}.
\end{addedblock}

\pnum
If a type \tcode{I} has an associated value type, then
\changed{\tcode{value_type<I>::type}}{\tcode{readable_traits<I>::value_type}}
shall name the value type. Otherwise, there shall be no nested type
\changed{\tcode{type}}{\tcode{value_type}}.

\pnum
The \changed{\tcode{value_type}}{\tcode{readable_traits}} class template may be
specialized on user-defined types.

\pnum
When instantiated with a type \tcode{I}
such that \tcode{I::value_type} is valid and denotes a type,
\removed{\tcode{value_type<I>::type}}\ \ \added{\tcode{read\-able_traits<I>::value_type}}
names that type, unless it is not an object type~(\cxxref{basic.types}) in which case
\changed{\tcode{value_type<I>}}{\tcode{readable_traits<I>}}
shall have no nested type \tcode{\added{value_}type}. \enternote Some legacy output
iterators define a nested type named \tcode{value_type} that is an alias for \tcode{void}. These
types are not \tcode{Readable} and have no associated value types.\exitnote

\pnum
When instantiated with a type \tcode{I}
such that \tcode{I::element_type} is valid and denotes a type,
\removed{\tcode{value_type<I>::\brk{}type}}\ \ \added{\tcode{readable_traits<I>::value_type}}
names the type \tcode{remove_cv_t<I::element_type>}, unless it is
not an object type~(\cxxref{basic.types}) in which case
\changed{\tcode{value_type<I>}}{\tcode{readable_traits<I>}} shall have no nested
type \tcode{\added{value_}type}. \enternote Smart pointers like
\tcode{shared_ptr<int>} are \tcode{Readable} and have an associated value type.
But a smart pointer like \tcode{shared_ptr<void>} is not \tcode{Readable} and
has no associated value type.\exitnote

\ednote{Remove section ``\tcode{iterator_category}'' [iterator.assoc.types.iterator_category].}


\ednote{Change section ``Concept InputIterator''~(\ref{iterators.input}) as follows:}

\setcounter{subsubsection}{10}
\rSec3[iterators.input]{Concept \tcode{InputIterator}}

\begin{addedblock}
\pnum
Let \tcode{\textit{ITER_TRAITS}(I)} be \tcode{I} if \tcode{iterator_traits<I>}
names an instantiation of the primary template; otherwise, \tcode{iterator_traits<I>}.

\pnum
Let \tcode{\textit{ITER_CONCEPT}(I)} be defined as follows:
\begin{itemize}
\item If \tcode{\textit{ITER_TRAITS}(I)::iterator_concept} is valid
  and names a type, then \tcode{\textit{ITER_TRAITS}(I)::iterator_concept}.
\item Otherwise, if \tcode{\textit{ITER_TRAITS}(I)::iterator_category} is valid
  and names a type then \tcode{\textit{ITER_TRAITS}(I)::iterator_category}.
\item Otherwise, if \tcode{iterator_traits<I>} names an instantiation of
  the primary template, then \tcode{random_access_iterator_tag}.
\item Otherwise, \tcode{\textit{ITER_CONCEPT}(I)} does not name a type.
\end{itemize}
\end{addedblock}

\pnum
The \tcode{InputIterator} concept is a refinement of
\tcode{Iterator}~(\ref{iterators.iterator}). It defines requirements for a type
whose referenced values can be read (from the requirement for
\tcode{Readable}~(\ref{iterators.readable})) and which can be both pre- and
post-incremented.
\enternote Unlike in ISO/IEC 14882, input iterators are not required to satisfy
\tcode{EqualityComparable}~(\ref{concepts.lib.compare.equalitycomparable}).\exitnote

\indexlibrary{\idxcode{InputIterator}}%
\begin{codeblock}
  template <class I>
  concept InputIterator =
    Iterator<I> &&
    Readable<I> &&
    requires { typename @\changed{iterator_category_t<I>}{\textit{ITER_CONCEPT}(I)}@; } &&
    DerivedFrom<@\changed{iterator_category_t<I>}{\textit{ITER_CONCEPT}(I)}@, input_iterator_tag>;
\end{codeblock}

\setcounter{subsubsection}{12}
\rSec3[iterators.forward]{Concept \tcode{ForwardIterator}}

\ednote{In subsection ``Concept ForwardIterator''~(\ref{iterators.forward}),
change the definition of the \tcode{ForwardIterator} concept as follows:}

\indexlibrary{\idxcode{ForwardIterator}}%
\begin{codeblock}
  template <class I>
  concept ForwardIterator =
    InputIterator<I> &&
    DerivedFrom<@\changed{iterator_category_t<I>}{\textit{ITER_CONCEPT}(I)}@, forward_iterator_tag> &&
    Incrementable<I> &&
    Sentinel<I, I>;
\end{codeblock}

\rSec3[iterators.bidirectional]{Concept \tcode{BidirectionalIterator}}

\ednote{In subsection ``Concept BidirectionalIterator''~(\ref{iterators.bidirectional}),
change the definition of the \tcode{BidirectionalIterator} concept as follows:}

\indexlibrary{\idxcode{BidirectionalIterator}}%
\begin{codeblock}
  template <class I>
  concept bool BidirectionalIterator =
    ForwardIterator<I> &&
    DerivedFrom<@\changed{iterator_category_t<I>}{\textit{ITER_CONCEPT}(I)}@, bidirectional_iterator_tag> &&
    requires(I i) {
      { --i } -> Same<I>&;
      { i-- } -> Same<I>&&;
    };
\end{codeblock}

\rSec3[iterators.random.access]{Concept \tcode{RandomAccessIterator}}

\ednote{In subsection ``Concept RandomAccessIterator''~(\ref{iterators.random.access}),
change the definition of the \tcode{RandomAccessIterator} concept as follows:}

\indexlibrary{\idxcode{RandomAccessIterator}}%
\begin{codeblock}
  template <class I>
  concept RandomAccessIterator =
    BidirectionalIterator<I> &&
    DerivedFrom<@\changed{iterator_category_t<I>}{\textit{ITER_CONCEPT}(I)}@, random_access_iterator_tag> &&
    StrictTotallyOrdered<I> &&
    SizedSentinel<I, I> &&
    requires(I i, const I j, const difference_type_t<I> n) {
      { i += n } -> Same<I>&;
      { j + n }  -> Same<I>&&;
      { n + j }  -> Same<I>&&;
      { i -= n } -> Same<I>&;
      { j - n }  -> Same<I>&&;
      j[n];
      requires Same<decltype(j[n]), @\added{iter_}@reference_t<I>>;
    };
\end{codeblock}

\rSec3[iterators.contiguous]{Concept \tcode{ContiguousIterator}}

\ednote{In subsection ``Concept ContiguousIterator''~(\ref{iterators.contiguous}),
change the definition of the \tcode{ContiguousIterator} concept as follows:}

\indexlibrary{\idxcode{ContiguousIterator}}%
\begin{codeblock}
  template <class I>
  concept ContiguousIterator =
    RandomAccessIterator<I> &&
    DerivedFrom<@\changed{iterator_category_t<I>}{\textit{ITER_CONCEPT}(I)}@, contiguous_iterator_tag> &&
    is_lvalue_reference_v<@\added{iter_}@reference_t<I>> &&
    Same<@\changed{value_type_t}{iter_value_t}@<I>, remove_cv@\added{ref}@_t<@\changed{remove_reference_t<}{iter_}@reference_t<I>@\removed{>}@>>;
\end{codeblock}

\begin{addedblock}
\rSec2[iterator.cpp98]{\Cpp{}98 iterator requirements}

\pnum
TODO describe this section

\end{addedblock}

\rSec3[iterator.iterators]{Iterator}

\pnum
The \tcode{Iterator} requirements form the basis of the iterator
taxonomy; every iterator satisfies the \tcode{Iterator} requirements. This
set of requirements specifies operations for dereferencing and incrementing
an iterator. Most algorithms will require additional operations to
read\iref{input.iterators} or write\iref{output.iterators} values, or
to provide a richer set of iterator movements~(\ref{forward.iterators},
\ref{bidirectional.iterators}, \ref{random.access.iterators}).

\pnum
A type \tcode{X} satisfies the \tcode{Iterator} requirements if:

\begin{itemize}
\item \tcode{X} satisfies the \tcode{CopyConstructible}, \tcode{CopyAssignable}, and
\tcode{Destructible} requirements\iref{utility.arg.requirements} and lvalues
of type \tcode{X} are swappable\iref{swappable.requirements}, and

\item the expressions in \tref{iterator.requirements} are valid and have
the indicated semantics.
\end{itemize}

\begin{libreqtab4b}
{Iterator requirements}
{tab:iterator.requirements}
\\ \topline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead

\tcode{*r}          &
  unspecified       &
                            &
  \requires \tcode{r} is dereferenceable.  \\ \rowsep

\tcode{++r}         &
  \tcode{X\&}       &
                            &
                    \\

\end{libreqtab4b}

\rSec3[input.iterators]{Input iterators}

\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of an input iterator for the value type
\tcode{T}
if
\tcode{X} satisfies the \tcode{Iterator}\iref{iterator.iterators} and
\tcode{EqualityComparable} (\tref{equalitycomparable}) requirements and
the expressions in \tref{iterator.input.requirements} are valid and have
the indicated semantics.

\pnum
In \tref{iterator.input.requirements}, the term
\techterm{the domain of \tcode{==}}
is used in the ordinary mathematical sense to denote
the set of values over which
\tcode{==} is (required to be) defined.
This set can change over time.
Each algorithm places additional requirements on the domain of
\tcode{==} for the iterator values it uses.
These requirements can be inferred from the uses that algorithm
makes of \tcode{==} and \tcode{!=}.
\begin{example}
The call \tcode{find(a,b,x)}
is defined only if the value of \tcode{a}
has the property \textit{p}
defined as follows:
\tcode{b} has property \textit{p}
and a value \tcode{i}
has property \textit{p}
if
(\tcode{*i==x})
or if
(\tcode{*i!=x}
and
\tcode{++i}
has property
\textit{p}).
\end{example}

\begin{libreqtab4b}
{Input iterator requirements (in addition to Iterator)}
{tab:iterator.input.requirements}
\\ \topline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
\tcode{a != b}                  &
 contextually convertible to \tcode{bool}    &
 \tcode{!(a == b)}                              &
 \requires \orange{a}{b} is in the domain of \tcode{==}. \\ \rowsep

\tcode{*a}                      &
 \tcode{reference}, convertible to \tcode{T}       &
                                &
 \requires \tcode{a} is dereferenceable.\br
 The expression\br \tcode{(void)*a, *a} is equivalent to \tcode{*a}.\br
 If \tcode{a == b} and \orange{a}{b} is in the domain of \tcode{==}
 then \tcode{*a} is equivalent to \tcode{*b}.  \\ \rowsep
\tcode{a->m}                    &
                                &
 \tcode{(*a).m}                                &
 \requires \tcode{a} is dereferenceable. \\ \rowsep
\tcode{++r}                     &
 \tcode{X\&}                    &
                                &
 \requires \tcode{r} is dereferenceable.\br
 \postconditions \tcode{r} is dereferenceable or \tcode{r} is past-the-end;\br
 any copies of the previous value of \tcode{r} are no longer
 required either to be dereferenceable or to be in the domain of \tcode{==}.    \\ \rowsep

\tcode{(void)r++}               &
                                &
                                &
 equivalent to \tcode{(void)++r}    \\ \rowsep

\tcode{*r++}                    &
 convertible to \tcode{T}       &
 \tcode{\{ T tmp = *r;}\br
 \tcode{++r;}\br
 \tcode{return tmp; \}} & \\
\end{libreqtab4b}

\pnum
\begin{note}
For input iterators,
\tcode{a == b}
does not imply
\tcode{++a == ++b}.
(Equality does not guarantee the substitution property or referential transparency.)
Algorithms on input iterators should never attempt to pass through the same iterator twice.
They should be
\term{single pass}
algorithms.
Value type \tcode{T} is not required to be a \tcode{CopyAssignable} type (\tref{copyassignable}).
These algorithms can be used with istreams as the source of the input data through the
\tcode{istream_iterator}
class template.
\end{note}

\rSec3[output.iterators]{Output iterators}

\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of an output iterator
if \tcode{X} satisfies the \tcode{Iterator} requirements\iref{iterator.iterators}
and the expressions in \tref{iterator.output.requirements}
are valid and have the indicated semantics.

\begin{libreqtab4b}
{Output iterator requirements (in addition to Iterator)}
{tab:iterator.output.requirements}
\\ \topline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
\tcode{*r = o}      &
 result is not used &
                    &
 \remarks\ After this operation \tcode{r} is not required to be dereferenceable.\br
 \postconditions \tcode{r} is incrementable. \\ \rowsep

\tcode{++r}         &
 \tcode{X\&}        &
                    &
 \tcode{\&r == \&++r}.\br
 \remarks\ After this operation \tcode{r} is not required to be dereferenceable.\br
 \postconditions \tcode{r} is incrementable. \\ \rowsep

\tcode{r++}         &
 convertible to \tcode{const X\&}   &
 \tcode{\{ X tmp = r;}\br
 \tcode{  ++r;}\br
 \tcode{  return tmp; \}}   &
 \remarks\ After this operation \tcode{r} is not required to be dereferenceable.\br
 \postconditions \tcode{r} is incrementable. \\ \rowsep

\tcode{*r++ = o}    &
 result is not used &&
 \remarks\ After this operation \tcode{r} is not required to be dereferenceable.\br
 \postconditions \tcode{r} is incrementable. \\
\end{libreqtab4b}

\pnum
\begin{note}
The only valid use of an
\tcode{operator*}
is on the left side of the assignment statement.
\textit{Assignment through the same value of the iterator happens only once.}
Algorithms on output iterators should never attempt to pass through the same iterator twice.
They should be
\term{single pass}
algorithms.
Equality and inequality might not be defined.
Algorithms that take output iterators can be used with ostreams as the destination
for placing data through the
\tcode{ostream_iterator}
class as well as with insert iterators and insert pointers.
\end{note}

\rSec3[forward.iterators]{Forward iterators}

\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of a forward iterator if

\begin{itemize}
\item \tcode{X} satisfies the requirements of an input iterator\iref{input.iterators},

\item \tcode{X} satisfies the \tcode{DefaultConstructible}
requirements\iref{utility.arg.requirements},

\item if \tcode{X} is a mutable iterator, \tcode{reference} is a reference to \tcode{T};
if \tcode{X} is a constant iterator, \tcode{reference} is a reference to \tcode{const T},

\item the expressions in \tref{iterator.forward.requirements}
are valid and have the indicated semantics, and

\item objects of type \tcode{X} offer the multi-pass guarantee, described below.
\end{itemize}

\pnum
The domain of \tcode{==} for forward iterators is that of iterators over the same
underlying sequence. However, value-initialized iterators may be compared and
shall compare equal to other value-initialized iterators of the same type.
\begin{note} Value-initialized iterators behave as if they refer past the end of
the same empty sequence. \end{note}

\pnum
Two dereferenceable iterators \tcode{a} and \tcode{b} of type \tcode{X} offer the
\defn{multi-pass guarantee} if:

\begin{itemize}
\item \tcode{a == b} implies \tcode{++a == ++b} and
\item \tcode{X} is a pointer type or the expression
\tcode{(void)++X(a), *a} is equivalent to the expression \tcode{*a}.
\end{itemize}

\pnum
\begin{note}
The requirement that
\tcode{a == b}
implies
\tcode{++a == ++b}
(which is not true for input and output iterators)
and the removal of the restrictions on the number of the assignments through
a mutable iterator
(which applies to output iterators)
allows the use of multi-pass one-directional algorithms with forward iterators.
\end{note}

\begin{libreqtab4b}
{Forward iterator requirements (in addition to input iterator)}
{tab:iterator.forward.requirements}
\\ \topline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
\tcode{r++}         &
 convertible to \tcode{const X\&}   &
 \tcode{\{ X tmp = r;}\br
 \tcode{  ++r;}\br
 \tcode{  return tmp; \}}&  \\ \rowsep

\tcode{*r++}        &
 \tcode{reference}     &&  \\
\end{libreqtab4b}

\pnum
If \tcode{a} and \tcode{b} are equal, then either \tcode{a} and \tcode{b}
are both dereferenceable
or else neither is dereferenceable.

\pnum
If \tcode{a} and \tcode{b} are both dereferenceable, then \tcode{a == b}
if and only if
\tcode{*a} and \tcode{*b} are bound to the same object.

\rSec3[bidirectional.iterators]{Bidirectional iterators}

\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of a bidirectional iterator if,
in addition to satisfying the requirements for forward iterators,
the following expressions are valid as shown in \tref{iterator.bidirectional.requirements}.

\begin{libreqtab4b}
{Bidirectional iterator requirements (in addition to forward iterator)}
{tab:iterator.bidirectional.requirements}
\\ \topline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
\tcode{\dcr r}      &
 \tcode{X\&}        &
                    &
 \requires there exists \tcode{s} such that \tcode{r == ++s}.\br
 \postconditions \tcode{r} is dereferenceable.\br
 \tcode{\dcr(++r) == r}.\br
 \tcode{\dcr r == \dcr s} implies \tcode{r == s}.\br
 \tcode{\&r == \&\dcr r}.   \\ \hline

\tcode{r\dcr}           &
 convertible to \tcode{const X\&}   &
 \tcode{\{ X tmp = r;}\br
 \tcode{  \dcr r;}\br
 \tcode{  return tmp; \}}&  \\ \rowsep

\tcode{*r\dcr}      &
 \tcode{reference}   &&  \\
\end{libreqtab4b}

\pnum
\begin{note}
Bidirectional iterators allow algorithms to move iterators backward as well as forward.
\end{note}

\rSec3[random.access.iterators]{Random access iterators}

\pnum
A class or pointer type
\tcode{X}
satisfies the requirements of a random access iterator if,
in addition to satisfying the requirements for bidirectional iterators,
the following expressions are valid as shown in \tref{iterator.random.access.requirements}.

\begin{libreqtab4b}
{Random access iterator requirements (in addition to bidirectional iterator)}
{tab:iterator.random.access.requirements}
\\ \topline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\hline
\lhdr{Expression}   &   \chdr{Return type}  &   \chdr{Operational}  &   \rhdr{Assertion/note}       \\
                    &                       &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
\tcode{r += n}      &
 \tcode{X\&}        &
 \tcode{\{ difference_type m = n;}\br
 \tcode{  if (m >= 0)}\br
 \tcode{    while (m\dcr)}\br
 \tcode{      ++r;}\br
 \tcode{  else}\br
 \tcode{    while (m++)}\br
 \tcode{      \dcr r;}\br
 \tcode{  return r; \}}&    \\ \rowsep

\tcode{a + n}\br
\tcode{n + a}       &
 \tcode{X}          &
 \tcode{\{ X tmp = a;}\br
 \tcode{  return tmp += n; \}}  &
 \tcode{a + n == n + a}.        \\ \rowsep

\tcode{r -= n}      &
 \tcode{X\&}        &
 \tcode{return r += -n;}    &
 \requires the absolute value of \tcode{n} is in the range of
 representable values of \tcode{difference_type}.   \\ \rowsep

\tcode{a - n}       &
 \tcode{X}          &
 \tcode{\{ X tmp = a;}\br
 \tcode{  return tmp -= n; \}}  &   \\ \rowsep

\tcode{b - a}       &
 \tcode{difference_type}   &
 \tcode{return n}   &
 \requires there exists a value \tcode{n} of type \tcode{difference_type} such that \tcode{a + n == b}.\br
 \tcode{b == a + (b - a)}.  \\ \rowsep

\tcode{a[n]}        &
 convertible to \tcode{reference}  &
 \tcode{*(a + n)}   &   \\ \rowsep

\tcode{a < b}       &
 contextually
 convertible to \tcode{bool}    &
 \tcode{b - a > 0}  &
 \tcode{<} is a total ordering relation \\ \rowsep

\tcode{a > b}       &
 contextually
 convertible to \tcode{bool}    &
 \tcode{b < a}      &
 \tcode{>} is a total ordering relation opposite to \tcode{<}.  \\ \rowsep

\tcode{a >= b}      &
 contextually
 convertible to \tcode{bool}    &
 \tcode{!(a < b)}   &   \\ \rowsep

\tcode{a <= b}      &
 contextually
 convertible to \tcode{bool}.    &
 \tcode{!(a > b)}   &   \\
\end{libreqtab4b}






\rSec2[indirectcallable]{Indirect callable requirements}

\rSec3[range.indirectcallable.general]{General}

\pnum
There are several concepts that group requirements of algorithms that take callable
objects~(\cxxref{func.require}) as arguments.

\rSec3[range.indirectcallable.indirectinvocable]{Indirect callables}

\pnum
The indirect callable concepts are used to constrain those algorithms that accept
callable objects~(\cxxref{func.def}) as arguments.

\indexlibrary{\idxcode{indirect_result}}%
\indexlibrary{\idxcode{IndirectUnaryInvocable}}%
\indexlibrary{\idxcode{IndirectRegularUnaryInvocable}}%
\indexlibrary{\idxcode{IndirectUnaryPredicate}}%
\indexlibrary{\idxcode{IndirectRelation}}%
\indexlibrary{\idxcode{IndirectStrictWeakOrder}}%
\begin{codeblock}
@\added{namespace std \{}@
  template <class F, class I>
  concept IndirectUnaryInvocable = // ... as in P0986R1 with new associated type names

  template <class F, class I>
  concept IndirectRegularUnaryInvocable = // ... as in P0986R1 with new associated type names

  template <class F, class I>
  concept IndirectUnaryPredicate = // ... as in P0986R1 with new associated type names

  template <class F, class I1, class I2 = I1>
  concept IndirectRelation = // ... as in P0986R1 with new associated type names

  template <class F, class I1, class I2 = I1>
  concept IndirectStrictWeakOrder = // ... as in P0986R1 with new associated type names

  template <class F, class... Is>
    requires (Readable<Is> &&...) && Invocable<F, @\added{iter_}@reference_t<Is>...>
  struct indirect_result<F, Is...> :
    invoke_result<F, @\added{iter_}@reference_t<Is>...> { };
@\added{\}}@
\end{codeblock}

\rSec3[projected]{Class template \tcode{projected}}
\ednote{Change ``Class template \tcode{projected}'' as follows:}

\pnum
The \tcode{projected} class template is intended for use when specifying the constraints of
algorithms that accept callable objects and projections~(\ref{defns.projection}). It bundles a \tcode{Readable} type
\tcode{I} and a function \tcode{Proj} into a new \tcode{Readable} type whose
\tcode{reference} type is the result of applying \tcode{Proj} to the
\tcode{\added{iter_}}\tcode{reference_t} of \tcode{I}.

\indexlibrary{\idxcode{projected}}%
\begin{codeblock}
@\added{namespace std \{}@
  template <Readable I, IndirectRegularUnaryInvocable<I> Proj>
  struct projected {
    using value_type = remove_cv@\added{ref}@_t<@\removed{remove_reference_t<}@indirect_result_t<Proj&, I>@\removed{>}@>;
    indirect_result_t<Proj&, I> operator*() const;
  };

  template <WeaklyIncrementable I, class Proj>
  struct @\changed{difference_type}{incrementable_traits}@<projected<I, Proj>> {
    @\removed{using type = difference_type_t<I>;}@
    @\added{using difference_type = iter_difference_t<I>;}@
  };
@\added{\}}@
\end{codeblock}

\pnum
\enternote \tcode{projected} is only used to ease constraints specification. Its
member function need not be defined.\exitnote




\rSec2[commonalgoreq]{Common algorithm requirements}

\rSec3[commonalgoreq.general]{General}

\pnum
There are several additional iterator concepts that are commonly applied to families of algorithms.
These group together iterator requirements of algorithm families. There are three relational
concepts that specify how element values are transferred between \tcode{Readable} and \tcode{Writable} types:
\tcode{Indirectly\-Movable}, \tcode{Indir\-ect\-ly\-Copy\-able}, and \tcode{Indirectly\-Swappable}. There are three relational concepts
for rearrangements: \tcode{Permut\-able}, \tcode{Mergeable}, and \tcode{Sortable}.
There is one relational concept for comparing values from different sequences: \tcode{IndirectlyComparable}.

\pnum
\enternote The \tcode{\added{ranges::}equal_to<>} and \tcode{\added{ranges::}less<>}~(\ref{range.comparisons}) function \added{object} types used in the
concepts below impose \removed{additional} constraints on their arguments \changed{beyond}{in addition to} those that appear explicitly in the
concepts' bodies. \tcode{\added{ranges::}equal_to<>} requires its arguments satisfy \tcode{EqualityComparableWith}~(\cxxref{concepts.lib.compare.equalitycomparable}),
and \tcode{\added{ranges::}less<>} requires its arguments satisfy \tcode{StrictTotallyOrderedWith}~(\cxxref{concepts.lib.compare.stricttotallyordered}).\exitnote

\rSec3[commonalgoreq.indirectlymovable]{Concept \tcode{IndirectlyMovable}}

\pnum
The \tcode{IndirectlyMovable} concept specifies the relationship between a \tcode{Readable}
type and a \tcode{Writable} type between which values may be moved.

\indexlibrary{\idxcode{IndirectlyMovable}}%
\begin{codeblock}
  template <class In, class Out>
  concept IndirectlyMovable =
    Readable<In> &&
    Writable<Out, rvalue_reference_t<In>>;
\end{codeblock}

\pnum
The \tcode{IndirectlyMovableStorable} concept augments \tcode{IndirectlyMovable} with additional
requirements enabling the transfer to be performed through an intermediate object of the
\tcode{Readable} type's value type.

\indexlibrary{\idxcode{IndirectlyMovableStorable}}%
\begin{codeblock}
  template <class In, class Out>
  concept IndirectlyMovableStorable =
    IndirectlyMovable<In, Out> &&
    Writable<Out, value_type_t<In>> &&
    Movable<value_type_t<In>> &&
    Constructible<value_type_t<In>, rvalue_reference_t<In>> &&
    Assignable<value_type_t<In>&, rvalue_reference_t<In>>;
\end{codeblock}

\rSec3[commonalgoreq.indirectlycopyable]{Concept \tcode{IndirectlyCopyable}}

\pnum
The \tcode{IndirectlyCopyable} concept specifies the relationship between a \tcode{Readable}
type and a \tcode{Writable} type between which values may be copied.

\indexlibrary{\idxcode{IndirectlyCopyable}}%
\begin{codeblock}
  template <class In, class Out>
  concept IndirectlyCopyable =
    Readable<In> &&
    Writable<Out, reference_t<In>>;
\end{codeblock}

\pnum
The \tcode{IndirectlyCopyableStorable} concept augments \tcode{IndirectlyCopyable} with additional
requirements enabling the transfer to be performed through an intermediate object of the
\tcode{Readable} type's value type. It also requires the capability to make copies of values.

\indexlibrary{\idxcode{IndirectlyCopyableStorable}}%
\begin{codeblock}
  template <class In, class Out>
  concept IndirectlyCopyableStorable =
    IndirectlyCopyable<In, Out> &&
    Writable<Out, const value_type_t<In>&> &&
    Copyable<value_type_t<In>> &&
    Constructible<value_type_t<In>, reference_t<In>> &&
    Assignable<value_type_t<In>&, reference_t<In>>;
\end{codeblock}

\rSec3[commonalgoreq.indirectlyswappable]{Concept \tcode{IndirectlySwappable}}

\pnum
The \tcode{IndirectlySwappable} concept specifies a swappable relationship between the
values referenced by two \tcode{Readable} types.

\indexlibrary{\idxcode{IndirectlySwappable}}%
\begin{codeblock}
  template <class I1, class I2 = I1>
  concept IndirectlySwappable =
    Readable<I1> && Readable<I2> &&
    requires(I1&& i1, I2&& i2) {
      ranges::iter_swap(std::forward<I1>(i1), std::forward<I2>(i2));
      ranges::iter_swap(std::forward<I2>(i2), std::forward<I1>(i1));
      ranges::iter_swap(std::forward<I1>(i1), std::forward<I1>(i1));
      ranges::iter_swap(std::forward<I2>(i2), std::forward<I2>(i2));
    };
\end{codeblock}

\pnum
Given an object \tcode{i1} of type \tcode{I1} and an object \tcode{i2} of
type \tcode{I2}, \tcode{IndirectlySwappable<I1, I2>} is satisfied if after
\tcode{ranges::iter_swap(i1, i2)}, the value of \tcode{*i1} is equal to the
value of \tcode{*i2} before the call, and \textit{vice versa}.

\rSec3[commonalgoreq.indirectlycomparable]{Concept \tcode{IndirectlyComparable}}

\pnum
The \tcode{IndirectlyComparable} concept specifies the common requirements of algorithms that
compare values from two different sequences.

\indexlibrary{\idxcode{IndirectlyComparable}}%
\begin{codeblock}
  template <class I1, class I2, class R = @\added{ranges::}@equal_to<>, class P1 = identity,
    class P2 = identity>
  concept IndirectlyComparable =
    IndirectRelation<R, projected<I1, P1>, projected<I2, P2>>;
\end{codeblock}

\rSec3[commonalgoreq.permutable]{Concept \tcode{Permutable}}

\pnum
The \tcode{Permutable} concept specifies the common requirements of algorithms that reorder
elements in place by moving or swapping them.

\indexlibrary{\idxcode{Permutable}}%
\begin{codeblock}
  template <class I>
  concept Permutable =
    ForwardIterator<I> &&
    IndirectlyMovableStorable<I, I> &&
    IndirectlySwappable<I, I>;
\end{codeblock}

\rSec3[commonalgoreq.mergeable]{Concept \tcode{Mergeable}}

\pnum
The \tcode{Mergeable} concept specifies the requirements of
algorithms that merge sorted sequences into an output sequence by copying elements.

\indexlibrary{\idxcode{Mergeable}}%
\begin{codeblock}
  template <class I1, class I2, class Out,
      class R = @\added{ranges::}@less<>, class P1 = identity, class P2 = identity>
  concept Mergeable =
    InputIterator<I1> &&
    InputIterator<I2> &&
    WeaklyIncrementable<Out> &&
    IndirectlyCopyable<I1, Out> &&
    IndirectlyCopyable<I2, Out> &&
    IndirectStrictWeakOrder<R, projected<I1, P1>, projected<I2, P2>>;
\end{codeblock}

\rSec3[commonalgoreq.sortable]{Concept \tcode{Sortable}}

\pnum
The \tcode{Sortable} concept specifies the common requirements of algorithms that permute
sequences into ordered sequences (e.g., \tcode{sort}).

\indexlibrary{\idxcode{Sortable}}%
\begin{codeblock}
  template <class I, class R = @\added{ranges::}@less<>, class P = identity>
  concept Sortable =
    Permutable<I> &&
    IndirectStrictWeakOrder<R, projected<I, P>>;
\end{codeblock}






\rSec1[iterator.primitives]{Iterator primitives}

\pnum
To simplify the task of defining iterators, the library provides
several classes and functions:

\rSec2[iterator.traits]{Iterator traits}

\ednote{From the Ranges TS, strike [iterator.traits], [iterator.stdtraits], and
[std.iterator.tags]. In the working draft of the IS, change section
``Iterator traits''~(\ref{iterator.traits}) as follows:}

\ednote{TODO: Merge this into iterator.assoc.types.}

\pnum
\indexlibrary{\idxcode{iterator_traits}}%
To implement algorithms only in terms of iterators, it is often necessary to
determine the value and
difference types that correspond to a particular iterator type.
Accordingly, it is required that if
\tcode{Iterator}
is the type of an iterator,
the types

\indexlibrarymember{difference_type}{iterator_traits}%
\indexlibrarymember{value_type}{iterator_traits}%
\indexlibrarymember{iterator_category}{iterator_traits}%
\begin{codeblock}
iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::iterator_category
\end{codeblock}

be defined as the iterator's difference type, value type and iterator category, respectively.
In addition, the types

\indexlibrarymember{reference}{iterator_traits}%
\indexlibrarymember{pointer}{iterator_traits}%
\begin{codeblock}
iterator_traits<Iterator>::reference
iterator_traits<Iterator>::pointer
\end{codeblock}

shall be defined as the iterator's reference and pointer types\changed{,}{;} that is, for an
iterator object \tcode{a}, the same type as the type of \tcode{*a} and \tcode{a->},
respectively. \added{The type \tcode{iterator_traits<Iterator>::pointer} shall be
\tcode{void} for a type \tcode{Iterator} which does not support \tcode{operator->}.
Additionally, i}\removed{I}n the case of an output
iterator, the types

\begin{codeblock}
iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::reference
@\removed{iterator_traits<Iterator>::pointer}@
\end{codeblock}

may be defined as \tcode{void}.

\pnum
\begin{addedblock}
The member types of the primary template are computed as defined below.
The definition below makes use of several exposition-only concepts equivalent
the the following:

\begin{codeblock}
template <class I>
concept @\textit{_Cpp98Iterator}@ =
  Copyable<I> && requires (I i) {
    { *i } -> auto &&;
    { ++i } -> Same<I>&;
    { *i++ } -> auto &&;
  };

template <class I>
concept @\textit{_Cpp98InputIterator}@ =
  @\textit{_Cpp98Iterator}@<I> && EqualityComparable<I> && requires (I i) {
    typename common_reference_t<iter_reference_t<I> &&,
                                typename readable_traits<I>::value_type &>;
    typename common_reference_t<decltype(*i++) &&,
                                typename readable_traits<I>::value_type &>;
  } && SignedIntegral<typename incrementable_traits<I>::difference_type>;

template <class I>
concept @\textit{_Cpp98ForwardIterator}@ =
  @\textit{_Cpp98InputIterator}@<I> && Constructible<I> &&
  Same<remove_cvref_t<iter_reference_t<I>>, typename readable_traits<I>::value_type> &&
  requires (I i) {
    { i++ } -> I const &;
    requires Same<iter_reference_t<I>, decltype(*i++)>;
  };

template <class I>
concept @\textit{_Cpp98BidirectionalIterator}@ =
  @\textit{_Cpp98ForwardIterator}@<I> && requires (I i) {
    { --i } -> Same<I>&;
    { i-- } -> I const &;
    requires Same<iter_reference_t<I>, decltype(*i--)>;
  };

template <class I>
concept @\textit{_Cpp98RandomAccessIterator}@ =
  @\textit{_Cpp98BidirectionalIterator}@<I> && StrictTotallyOrdered<I> &&
  requires (I i, typename incrementable_traits<I>::difference_type n) {
    { i += n } -> Same<I>&;
    { i -= n } -> Same<I>&;
    requires Same<I, decltype(i + n)>;
    requires Same<I, decltype(n + i)>;
    requires Same<I, decltype(i - n)>;
    requires Same<decltype(n), decltype(i - i)>;
    { i[n] } -> iter_reference_t<I>;
  };
\end{codeblock}
\end{addedblock}

\begin{itemize}
\item
If \tcode{Iterator} has valid~(\cxxref{temp.deduct}) member
types \tcode{difference_type}, \tcode{value_type}, \removed{\tcode{pointer},}
\tcode{reference}, and \tcode{iterator_category},
\tcode{iterator_traits<Iterator>}
shall have the following as publicly accessible members:
\begin{codeblock}
  using difference_type   = typename Iterator::difference_type;
  using value_type        = typename Iterator::value_type;
  using pointer           = @\changed{typename Iterator::pointer}{\seebelow}@;
  using reference         = typename Iterator::reference;
  using iterator_category = typename Iterator::iterator_category;
\end{codeblock}
\begin{addedblock}
If \tcode{Iterator} has a valid member type \tcode{pointer}, then
\tcode{iterator_traits<Iterator>::pointer} names that type; otherwise, it
is \tcode{void}.
\end{addedblock}

\begin{addedblock}
\item
Otherwise, if \tcode{Iterator} satisfies the exposition-only concept
\tcode{\textit{_Cpp98InputIterator}}, \tcode{iterator_traits<{}Iterator>} shall
have the following as publicly accessible members:
\begin{codeblock}
  using difference_type   = typename incrementable_traits<Iterator>::difference_type;
  using value_type        = typename readable_traits<Iterator>::value_type;
  using pointer           = @\seebelow@;
  using reference         = @\seebelow@;
  using iterator_category = @\seebelow@;
\end{codeblock}
If \tcode{Iterator::pointer} is well-formed and names a type, \tcode{pointer} is
an alias for that type. Otherwise, if \tcode{decltype(declval<Iterator\&>().operator->())}
is well-formed, then \tcode{pointer} names that type. Otherwise, if
\tcode{iter_reference_t<Iterator>} is an lvalue reference type, \tcode{pointer}
is \tcode{add_pointer_t<iter_reference_t<Iterator{>}>}. Otherwise, \tcode{pointer}
is \tcode{void}.

If \tcode{Iterator::reference} is well-formed and names a type, \tcode{reference}
names that type. Otherwise, \tcode{reference} is \tcode{iter_reference_t<Iterator>}.

If \tcode{Iterator::iterator_category} is well-formed and names a type,
\tcode{iterator_category} names that type. Otherwise, if \tcode{Iterator}
satisfies \tcode{\textit{_Cpp98RandomAccessIterator}}, \tcode{iterator_category}
is \tcode{random_access_iterator_tag}. Otherwise, if \tcode{Iterator}
satisfies \tcode{\textit{_Cpp98BidirectionalIterator}}, \tcode{iterator_category}
is \tcode{bidirectional_iterator_tag}. Otherwise, if \tcode{Iterator}
satisfies \tcode{\textit{_Cpp98ForwardIterator}}, \tcode{iterator_category}
is \tcode{forward_iterator_tag}. Otherwise, \tcode{iterator_category}
is \tcode{input_iterator_tag}.

\item
Otherwise, if \tcode{Iterator} satisfies the exposition-only concept
\tcode{\textit{_Cpp98Iterator}}, \tcode{iterator_traits<{}Iterator>} shall
have the following as publicly accessible members:
\begin{codeblock}
  using difference_type   = @\seebelow@;
  using value_type        = void;
  using pointer           = void;
  using reference         = void;
  using iterator_category = output_iterator_tag;
\end{codeblock}
If \tcode{incrementable_traits<Iterator>::difference_type} is well-formed
and names a type, then \tcode{difference_type} names that type; otherwise, it is
\tcode{void}.
\end{addedblock}

\item
Otherwise, \tcode{iterator_traits<Iterator>}
shall have no members by any of the above names.
\end{itemize}

\begin{addedblock}
\pnum
Additionally, user specializations of \tcode{iterator_traits} may have a member
type \tcode{iterator_concept} that is used to opt in or out of conformance to the
iterator concepts defined in~\ref{iterator.concepts}. If specified, it should be
an alias for one of the standard iterator tag types~(\ref{std.iterator.tags}),
or an empty, copy- and move-constructible, trivial class type that is publicly
and unambiguously derived from one of the standard iterator tag types.
\end{addedblock}

\pnum
\changed{It}{\tcode{iterator_traits}} is specialized for pointers as

\begin{codeblock}
namespace std {
  template<class T> struct iterator_traits<T*> {
    using difference_type   = ptrdiff_t;
    using value_type        = remove_cv_t<T>;
    using pointer           = T*;
    using reference         = T&;
    using iterator_category = random_access_iterator_tag;
    @\added{using iterator_concept  = contiguous_iterator_tag;}@
  };
}
\end{codeblock}

\pnum
\begin{example}
To implement a generic
\tcode{reverse}
function, a \Cpp{} program can do the following:

\begin{codeblock}
template<class BidirectionalIterator>
void reverse(BidirectionalIterator first, BidirectionalIterator last) {
  typename iterator_traits<BidirectionalIterator>::difference_type n =
    distance(first, last);
  --n;
  while(n > 0) {
    typename iterator_traits<BidirectionalIterator>::value_type
     tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
\end{codeblock}
\end{example}

\rSec2[std.iterator.tags]{Standard iterator tags}

\ednote{Amend the section ``Standard iterator tags'' as follows:}

\pnum
\indexlibrary{\idxcode{input_iterator_tag}}%
\indexlibrary{\idxcode{output_iterator_tag}}%
\indexlibrary{\idxcode{forward_iterator_tag}}%
\indexlibrary{\idxcode{bidirectional_iterator_tag}}%
\indexlibrary{\idxcode{random_access_iterator_tag}}%
\indexlibrary{\idxcode{contiguous_iterator_tag}}%
It is often desirable for a
function template specialization
to find out what is the most specific category of its iterator
argument, so that the function can select the most efficient algorithm at compile time.
To facilitate this, the
library introduces
\techterm{category tag}
classes which are used as compile time tags for algorithm selection.
They are:
\tcode{input_iterator_tag},
\tcode{output_iterator_tag},
\tcode{forward_iterator_tag},
\tcode{bidirectional_iterator_tag}
\changed{and}{,}
\tcode{random_access_iterator_tag}
\added{ and \tcode{contiguous_iterator_tag}}.
For every iterator of type
\tcode{Iterator},
\tcode{iterator_traits<Iterator>::it\-er\-a\-tor_ca\-te\-go\-ry}
shall be defined to be the most specific category tag that describes the
iterator's behavior. \added{Additionally and optionally,
\tcode{iterator_traits<Iterator>::it\-er\-a\-tor_ca\-te\-go\-ry} may be used
to opt in or out of conformance to the iterator concepts defined in
section REF TODO.}

\begin{codeblock}
namespace std {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
  @\added{struct contiguous_iterator_tag: public random_access_iterator_tag \{ \};}@
}
\end{codeblock}

\pnum
\indexlibrary{\idxcode{empty}}%
\indexlibrary{\idxcode{input_iterator_tag}}%
\indexlibrary{\idxcode{output_iterator_tag}}%
\indexlibrary{\idxcode{forward_iterator_tag}}%
\indexlibrary{\idxcode{bidirectional_iterator_tag}}%
\indexlibrary{\idxcode{random_access_iterator_tag}}%
\indexlibrary{\idxcode{contiguous_iterator_tag}}%
\begin{example}
For a program-defined iterator
\tcode{BinaryTreeIterator},
it could be included
into the bidirectional iterator category by specializing the
\tcode{iterator_traits}
template:

\begin{codeblock}
template<class T> struct iterator_traits<BinaryTreeIterator<T>> {
  using iterator_category = bidirectional_iterator_tag;
  using difference_type   = ptrdiff_t;
  using value_type        = T;
  using pointer           = T*;
  using reference         = T&;
};
\end{codeblock}
\end{example}

\pnum
\begin{example}
If
\tcode{evolve()}
is well-defined for bidirectional iterators, but can be implemented more
efficiently for random access iterators, then the implementation is as follows:

\begin{codeblock}
template<class BidirectionalIterator>
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {
  evolve(first, last,
    typename iterator_traits<BidirectionalIterator>::iterator_category());
}

template<class BidirectionalIterator>
void evolve(BidirectionalIterator first, BidirectionalIterator last,
  bidirectional_iterator_tag) {
  // more generic, but less efficient algorithm
}

template<class RandomAccessIterator>
void evolve(RandomAccessIterator first, RandomAccessIterator last,
  random_access_iterator_tag) {
  // more efficient, but less generic algorithm
}
\end{codeblock}
\end{example}


\rSec2[iterator.operations]{Iterator operations}

\pnum
Since only random access iterators provide
\tcode{+}
and
\tcode{-}
operators, the library provides two
function templates
\tcode{advance}
and
\tcode{distance}.
These
function templates
use
\tcode{+}
and
\tcode{-}
for random access iterators (and are, therefore, constant
time for them); for input, forward and bidirectional iterators they use
\tcode{++}
to provide linear time
implementations.

\indexlibrary{\idxcode{advance}}%
\begin{itemdecl}
template<class InputIterator, class Distance>
  constexpr void advance(InputIterator& i, Distance n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{n}
shall be negative only for bidirectional and random access iterators.

\pnum
\effects
Increments (or decrements for negative
\tcode{n})
iterator reference
\tcode{i}
by
\tcode{n}.
\end{itemdescr}

\indexlibrary{\idxcode{distance}}%
\begin{itemdecl}
template<class InputIterator>
  constexpr typename iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{InputIterator} meets the requirements of random access iterator,
returns \tcode{(last - first)}; otherwise, returns
the number of increments needed to get from
\tcode{first}
to
\tcode{last}.

\pnum
\requires
If \tcode{InputIterator} meets the requirements of random access iterator,
\tcode{last} shall be reachable from \tcode{first} or \tcode{first} shall be
reachable from \tcode{last}; otherwise,
\tcode{last}
shall be reachable from
\tcode{first}.
\end{itemdescr}

\indexlibrary{\idxcode{next}}%
\begin{itemdecl}
template<class InputIterator>
  constexpr InputIterator next(InputIterator x,
    typename iterator_traits<InputIterator>::difference_type n = 1);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, n); return x;}
\end{itemdescr}

\indexlibrary{\idxcode{prev}}%
\begin{itemdecl}
template<class BidirectionalIterator>
  constexpr BidirectionalIterator prev(BidirectionalIterator x,
    typename iterator_traits<BidirectionalIterator>::difference_type n = 1);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, -n); return x;}
\end{itemdescr}








\rSec2[range.iterator.operations]{Range iterator operations}
\ednote{Copied [range.iterator.operations] in P0896R1 and modified as follows:}

\pnum
Since only types that satisfy
\tcode{RandomAccessIterator} provide the \tcode{+} operator, and
types that satisfy \tcode{Sized\-Sent\-inel} provide the \tcode{-}
operator, the library provides function templates
\tcode{advance}, \tcode{dist\-ance}, \tcode{next}, and \tcode{prev}.
These
function templates
use
\tcode{+}
and
\tcode{-}
for random access iterators and ranges that satisfy \tcode{SizedSentinel} (and are,
therefore, constant time for them); for output, input, forward and bidirectional
iterators they use
\tcode{++}
to provide linear time
implementations.

\pnum
The function templates defined in this subclause are not found by argument-dependent
name lookup~(\cxxref{basic.lookup.argdep}). When found by
unqualified~(\cxxref{basic.lookup.unqual}) name lookup for the
\grammarterm{postfix-expression} in a function call~(\cxxref{expr.call}), they
inhibit argument-dependent name lookup.

\begin{example}
\begin{codeblock}
void foo() {
    using namespace std::ranges;
    std::vector<int> vec{1,2,3};
    distance(begin(vec), end(vec)); // \#1
}
\end{codeblock}
The function call expression at \tcode{\#1} invokes \tcode{std::ranges::distance},
not \tcode{std::distance}, despite that (a) the iterator type returned from \tcode{begin(vec)}
and \tcode{end(vec)} may be associated with namespace \tcode{std} and (b)
\tcode{std::distance} is more specialized~(\cxxref{temp.func.order}) than
\tcode{std::ranges::distance} since the former requires its first two parameters
to have the same type.
\end{example}

\rSec3[range.iterator.operations.advance]{\tcode{ranges::advance}}
\indexlibrary{\idxcode{advance}}%

\begin{itemdecl}
template <Iterator I>
  constexpr void advance(I& i, @\added{iter_}@difference@\removed{_type}@_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\tcode{n}
shall be negative only for bidirectional iterators.

\pnum
\effects
For random access iterators, equivalent to \tcode{i += n}.
Otherwise, increments (or decrements for negative
\tcode{n})
iterator
\tcode{i}
by
\tcode{n}.
\end{itemdescr}

\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  constexpr void advance(I& i, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
If
\tcode{Assignable<I\&, S>} is not satisfied, \range{i}{bound}
shall denote a range.

\pnum
\effects
\begin{itemize}
\item If \tcode{Assignable<I\&, S>} is satisfied,
      equivalent to \tcode{i = std::move(bound)}.

\item Otherwise, if
      \tcode{SizedSentinel<S, I>} is satisfied, equivalent to \tcode{advance(i, bound - i)}.

\item Otherwise, increments \tcode{i} until \tcode{i == bound}.
\end{itemize}
\end{itemdescr}

\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  constexpr @\added{iter_}@difference@\removed{_type}@_t<I> advance(I& i, @\added{iter_}@difference@\removed{_type}@_t<I> n, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
If \tcode{n > 0}, \range{i}{bound} shall denote a range. If
\tcode{n == 0}, \range{i}{bound} or \range{bound}{i} shall denote a range. If \tcode{n < 0},
\range{bound}{i} shall denote a range and \tcode{(BidirectionalIterator<I> \&\& Same<I, S>)}
shall be satisfied.

\pnum
\effects
\begin{itemize}
\item If \tcode{SizedSentinel<S, I>} is satisfied:
      \begin{itemize}
      \item If \brk{}$|\tcode{n}| >= |\tcode{bound - i}|$, equivalent to \tcode{advance(i, bound)}.

      \item Otherwise, equivalent to \tcode{advance(i, n)}.
      \end{itemize}

\item Otherwise, increments (or decrements for negative \tcode{n})
      iterator \tcode{i} either \tcode{n} times or until \tcode{i == bound},
      whichever comes first.
\end{itemize}

\pnum
\returns
\tcode{n - $M$}, where $M$ is the distance from the starting position of
\tcode{i} to the ending position.
\end{itemdescr}

\rSec3[range.iterator.operations.distance]{\tcode{ranges::distance}}
\indexlibrary{\idxcode{distance}}%

\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  constexpr @\added{iter_}@difference@\removed{_type}@_t<I> distance(I first, S last);
\end{itemdecl}

\begin{itemdescr}
\pnum
\requires
\range{first}{last} shall denote a range, or \tcode{(Same<S, I> \&\& SizedSentinel<S, I>)} shall be
satisfied and \range{last}{first} shall denote a range.

\pnum
\effects
If \tcode{SizedSentinel<S, I>} is satisfied, returns \tcode{(last - first)}; otherwise,
returns the number of increments needed to get from
\tcode{first}
to
\tcode{last}.
\end{itemdescr}

\begin{itemdecl}
template <Range R>
  constexpr @\added{iter_}@difference@\removed{_type}@_t<iterator_t<R>> distance(R&& r);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{SizedRange<R>} is satisfied, equivalent to:
\begin{codeblock}
return ranges::size(r); // \ref{range.primitives.size}
\end{codeblock}
Otherwise, equivalent to:
\begin{codeblock}
return distance(ranges::begin(r), ranges::end(r)); // \ref{range.access}
\end{codeblock}
\end{itemdescr}

\rSec3[range.iterator.operations.next]{\tcode{ranges::next}}
\indexlibrary{\idxcode{next}}%

\begin{itemdecl}
template <Iterator I>
  constexpr I next(I x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{++x; return x;}
\end{itemdescr}

\begin{itemdecl}
template <Iterator I>
  constexpr I next(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, n); return x;}
\end{itemdescr}

\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  constexpr I next(I x, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, bound); return x;}
\end{itemdescr}

\begin{itemdecl}
template <Iterator I, Sentinel<I> S>
  constexpr I next(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n, S bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, n, bound); return x;}
\end{itemdescr}

\rSec3[range.iterator.operations.prev]{\tcode{ranges::prev}}
\indexlibrary{\idxcode{prev}}%

\begin{itemdecl}
template <BidirectionalIterator I>
  constexpr I prev(I x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{-{-}x; return x;}
\end{itemdescr}

\begin{itemdecl}
template <BidirectionalIterator I>
  constexpr I prev(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, -n); return x;}
\end{itemdescr}

\begin{itemdecl}
template <BidirectionalIterator I>
  constexpr I prev(I x, @\added{iter_}@difference@\removed{_type}@_t<I> n, I bound);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{advance(x, -n, bound); return x;}
\end{itemdescr}










\rSec1[predef.iterators]{Iterator adaptors}

\rSec2[reverse.iterators]{Reverse iterators}

\pnum
Class template \tcode{reverse_iterator} is an iterator adaptor that iterates
from the end of the sequence defined by its underlying iterator to the beginning
of that sequence. \removed{The fundamental relation between a reverse iterator
and its corresponding iterator \tcode{i} is established by the identity:
\tcode{\&*(reverse_iterator(i)) == \&*(i - 1)}.}

\rSec3[reverse.iterator]{Class template \tcode{reverse_iterator}}

\ednote{Change the synopsis of \tcode{reverse_iterator} as follows:}

\indexlibrary{\idxcode{reverse_iterator}}%
\begin{codeblock}
namespace std {
  template<class Iterator>
  class reverse_iterator {
  public:
    using iterator_type     = Iterator;
    @\removed{using iterator_category = typename iterator_traits<Iterator>::iterator_category;}@
    @\removed{using value_type        = typename iterator_traits<Iterator>::value_type;}@
    @\removed{using difference_type   = typename iterator_traits<Iterator>::difference_type;}@
    @\removed{using pointer           = typename iterator_traits<Iterator>::pointer;}@
    @\removed{using reference         = typename iterator_traits<Iterator>::reference;}@
    @\added{using iterator_category = \seebelow;}@
    @\added{using iterator_concept  = \seebelow;}@
    @\added{using value_type        = iter_value_t<Iterator>;}@
    @\added{using difference_type   = iter_difference_t<Iterator>;}@
    @\added{using pointer           = Iterator;}@
    @\added{using reference         = iter_reference_t<Iterator>;}@

    constexpr reverse_iterator();
    constexpr explicit reverse_iterator(Iterator x);
    template<class U> constexpr reverse_iterator(const reverse_iterator<U>& u);
    template<class U> constexpr reverse_iterator& operator=(const reverse_iterator<U>& u);

    constexpr Iterator base() const;      // explicit
    constexpr reference operator*() const;
    constexpr pointer   operator->() const;

    constexpr reverse_iterator& operator++();
    constexpr reverse_iterator  operator++(int);
    constexpr reverse_iterator& operator--();
    constexpr reverse_iterator  operator--(int);

    constexpr reverse_iterator  operator+ (difference_type n) const;
    constexpr reverse_iterator& operator+=(difference_type n);
    constexpr reverse_iterator  operator- (difference_type n) const;
    constexpr reverse_iterator& operator-=(difference_type n);
    constexpr @\unspec@ operator[](difference_type n) const;

    @\added{friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const reverse_iterator\& i)}@
      @\added{noexcept(\seebelow);}@
    @\added{template <IndirectlySwappable<Iterator> Iterator2>}@
      @\added{friend constexpr void iter_swap(const reverse_iterator\& x, const reverse_iterator<Iterator2>\& y)}@
        @\added{noexcept(\seebelow);}@

  protected:
    Iterator current;
  };

  template<class Iterator1, class Iterator2>
    constexpr bool operator==(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator!=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr auto operator-(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
  template<class Iterator>
    constexpr reverse_iterator<Iterator> operator+(
      typename reverse_iterator<Iterator>::difference_type n,
      const reverse_iterator<Iterator>& x);

  template<class Iterator>
    constexpr reverse_iterator<Iterator> make_reverse_iterator(Iterator i);

  @\added{template <class Iterator1, class Iterator2>}@
    @\added{requires !SizedSentinel<Iterator1, Iterator2>}@
  @\added{constexpr bool disable_sized_sentinel<reverse_iterator<Iterator1>,}@
                                        @\added{reverse_iterator<Iterator2>{>} = true;}@
}
\end{codeblock}

\begin{addedblock}
\pnum
The member type \tcode{iterator_category} is defined as follows:
\begin{itemize}
\item If \tcode{iterator_traits<Iterator>::iterator_category} is
\tcode{contiguous_iterator_tag}, then \tcode{random_access_iterator_tag}.
\item Otherwise, \tcode{iterator_traits<Iterator>::iterator_category}.
\end{itemize}

\pnum
The member type \tcode{iterator_concept} is defined as follows:
\begin{itemize}
\item If \tcode{Iterator} satisfies \tcode{RandomAccessIterator}, then
\tcode{random_access_iterator_tag}.
\item Otherwise, \tcode{bidirectional_iterator_tag}.
\end{itemize}
\end{addedblock}


\setcounter{subsubsection}{4}
\rSec3[reverse.iterator.elem]{\tcode{reverse_iterator} element access}
\ednote{Change section ``\tcode{reverse_iterator} element access'' /p2 as follows:}

\indexlibrarymember{operator->}{reverse_iterator}%
\begin{itemdecl}
constexpr pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\setcounter{Paras}{1}
\pnum
\returns \changed{\tcode{addressof(operator*())}}{\tcode{prev(current)}}.
\end{itemdescr}

\setcounter{subsubsection}{6}
\ednote{After [reverse.iter.nav], add a new subsection for \tcode{reverse_iterator} friend functions.}

\begin{addedblock}

\rSec3[reverse.iter.friends]{\tcode{reverse_iterator} friend functions}
\indexlibrarymember{iter_move}{reverse_iterator}%
\begin{itemdecl}
friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const reverse_iterator& i)
   noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(prev(i.current));}

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
   noexcept(ranges::iter_move(declval<Iterator&>())) && noexcept(--declval<Iterator&>()) &&
     is_nothrow_copy_constructible<Iterator>::value
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{iter_swap}{reverse_iterator}%
\begin{itemdecl}
template <IndirectlySwappable<Iterator> Iterator2>
  friend constexpr void iter_swap(const reverse_iterator& x, const reverse_iterator<Iterator2>& y)
    noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to \tcode{ranges::iter_swap(prev(x.current), prev(y.current))}.

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
  noexcept(ranges::iter_swap(declval<Iterator>(), declval<Iterator>())) &&
    noexcept(--declval<Iterator&>())
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[reverse.iter.cmp]{\tcode{reverse_iterator} comparisons}

\begin{addedblock}
\pnum
The functions in this subsection only participate in overload resolution if the
expression in their \textit{Returns:} clause is well-formed.
\end{addedblock}

\indexlibrarymember{operator==}{reverse_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr bool operator==(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.current == y.current}.
\end{itemdescr}

\indexlibrarymember{operator<}{reverse_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr bool operator<(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.current > y.current}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{reverse_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr bool operator!=(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.current != y.current}.
\end{itemdescr}

\indexlibrarymember{operator>}{reverse_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr bool operator>(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.current < y.current}.
\end{itemdescr}

\indexlibrarymember{operator>=}{reverse_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr bool operator>=(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.current <= y.current}.
\end{itemdescr}

\indexlibrarymember{operator<=}{reverse_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr bool operator<=(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.current >= y.current}.
\end{itemdescr}







\rSec2[insert.iterators]{Insert iterators}
\rSec3[back.insert.iterator]{Class template \tcode{back_insert_iterator}}

\ednote{Change the class synopsis of \tcode{back_insert_iterator} as follows.
The addition of the default constructor is so that \tcode{back_insert_iterator}
satisfies the \tcode{Iterator} concept.}

\indexlibrary{\idxcode{back_insert_iterator}}%
\begin{codeblock}
namespace std {
  template<class Container>
  class back_insert_iterator {
  protected:
    Container* container @\added{= nullptr}@; @\added{// \expos}@

  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\changed{void}{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;

    @\added{constexpr back_insert_iterator() noexcept = default;}@
    explicit back_insert_iterator(Container& x);
    back_insert_iterator& operator=(const typename Container::value_type& value);
    back_insert_iterator& operator=(typename Container::value_type&& value);

    back_insert_iterator& operator*();
    back_insert_iterator& operator++();
    back_insert_iterator  operator++(int);
  };

  template<class Container>
    back_insert_iterator<Container> back_inserter(Container& x);
}
\end{codeblock}


\rSec3[front.insert.iterator]{Class template \tcode{front_insert_iterator}}


\ednote{Change the class synopsis of \tcode{front_insert_iterator} as follows.
The addition of the default constructor is so that \tcode{front_insert_iterator}
satisfies the \tcode{Iterator} concept.}

\indexlibrary{\idxcode{front_insert_iterator}}%
\begin{codeblock}
namespace std {
  template<class Container>
  class front_insert_iterator {
  protected:
    Container* container @\added{= nullptr}@; @\added{// \expos}@

  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\changed{void}{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;

    @\added{constexpr front_insert_iterator() noexcept = default;}@
    explicit front_insert_iterator(Container& x);
    front_insert_iterator& operator=(const typename Container::value_type& value);
    front_insert_iterator& operator=(typename Container::value_type&& value);

    front_insert_iterator& operator*();
    front_insert_iterator& operator++();
    front_insert_iterator  operator++(int);
  };

  template<class Container>
    front_insert_iterator<Container> front_inserter(Container& x);
}
\end{codeblock}


\rSec3[insert.iterator]{Class template \tcode{insert_iterator}}

\ednote{Change the class synopsis of \tcode{insert_iterator} as follows:}

\indexlibrary{\idxcode{insert_iterator}}%
\begin{codeblock}
namespace std {
  template<class Container>
  class insert_iterator {
  protected:
    Container* container @\added{= nullptr}@; @\added{// \expos}@
    @\changed{typename Container::iterator}{iterator_t<Container>}@ iter @\added{\{\}}@; @\added{// \expos}@

  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\changed{void}{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using container_type    = Container;

    @\added{insert_iterator() = default;}@
    insert_iterator(Container& x, @\changed{typename Container::iterator}{iterator_t<Container>}@ i);
    insert_iterator& operator=(const typename Container::value_type& value);
    insert_iterator& operator=(typename Container::value_type&& value);

    insert_iterator& operator*();
    insert_iterator& operator++();
    insert_iterator& operator++(int);
  };

  template<class Container>
    insert_iterator<Container> inserter(Container& x, @\changed{typename Container::iterator}{iterator_t<Container>}@ i);
}
\end{codeblock}

\rSec4[insert.iter.ops]{\tcode{insert_iterator} operations}

\indexlibrary{\idxcode{insert_iterator}!constructor}%
\begin{itemdecl}
insert_iterator(Container& x, @\changed{typename Container::iterator}{iterator_t<Container>}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes
\tcode{container}
with \tcode{addressof(x)} and
\tcode{iter}
with \tcode{i}.
\end{itemdescr}

\indexlibrarymember{operator=}{insert_iterator}%
\begin{itemdecl}
insert_iterator& operator=(const typename Container::value_type& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
iter = container->insert(iter, value);
++iter;
\end{codeblock}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{insert_iterator}%
\begin{itemdecl}
insert_iterator& operator=(typename Container::value_type&& value);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
iter = container->insert(iter, std::move(value));
++iter;
\end{codeblock}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator*}{insert_iterator}%
\begin{itemdecl}
insert_iterator& operator*();
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{insert_iterator}%
\begin{itemdecl}
insert_iterator& operator++();
insert_iterator& operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec4[inserter]{\tcode{inserter}}

\indexlibrary{\idxcode{inserter}}%
\begin{itemdecl}
template<class Container>
  insert_iterator<Container> inserter(Container& x, @\changed{typename Container::iterator}{iterator_t<Container>}@ i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{insert_iterator<Container>(x, i)}.
\end{itemdescr}








\rSec2[move.iterators]{Move iterators and sentinels}

\ednote{Note that this section in the working draft has changed name from
``Move iterators'' to ``Move iterators and sentinels''.}

\pnum
Class template \tcode{move_iterator} is an iterator adaptor
with the same behavior as the underlying iterator except that its
indirection operator implicitly converts the value returned by the
underlying iterator's indirection operator to an rvalue.
Some generic algorithms can be called with move iterators to replace
copying with moving.

\pnum
\begin{example}

\begin{codeblock}
list<string> s;
// populate the list \tcode{s}
vector<string> v1(s.begin(), s.end());          // copies strings into \tcode{v1}
vector<string> v2(make_move_iterator(s.begin()),
                  make_move_iterator(s.end())); // moves strings into \tcode{v2}
\end{codeblock}

\end{example}

\rSec3[move.iterator]{Class template \tcode{move_iterator}}

\indexlibrary{\idxcode{move_iterator}}%
\begin{codeblock}
namespace std {
  template<class Iterator>
  class move_iterator {
  public:
    using iterator_type     = Iterator;
    using iterator_category = typename iterator_traits<Iterator>::iterator_category;
    using value_type        = @\changed{typename iterator_traits<Iterator>::value_type}{iter_value_t<Iterator>}@;
    using difference_type   = @\changed{typename iterator_traits<Iterator>::difference_type}{iter_difference_t<Iterator>}@;
    using pointer           = Iterator;
    using reference         = @\changed{\seebelow}{iter_rvalue_reference_t<Iterator>}@;
    @\added{using iterator_concept  = input_iterator_tag;}@

    constexpr move_iterator();
    constexpr explicit move_iterator(Iterator i);
    template<class U> constexpr move_iterator(const move_iterator<U>& u);
    template<class U> constexpr move_iterator& operator=(const move_iterator<U>& u);

    constexpr iterator_type base() const;
    constexpr reference operator*() const;
    constexpr pointer operator->() const;

    constexpr move_iterator& operator++();
    constexpr move_iterator operator++(int);
    constexpr move_iterator& operator--();
    constexpr move_iterator operator--(int);

    constexpr move_iterator operator+(difference_type n) const;
    constexpr move_iterator& operator+=(difference_type n);
    constexpr move_iterator operator-(difference_type n) const;
    constexpr move_iterator& operator-=(difference_type n);
    constexpr @\changed{\unspec}{reference}@ operator[](difference_type n) const;

    @\ednote{These are relocated from the \tcode{ranges::} namespace.}@
    @\added{template <Sentinel<Iterator> S>}@
      @\added{friend constexpr bool operator==(}@
        @\added{const move_iterator\& x, const move_sentinel<S>\& y);}@
    @\added{template <Sentinel<Iterator> S>}@
      @\added{friend constexpr bool operator==(}@
        @\added{const move_sentinel<S>\& x, const move_iterator\& y);}@
    @\added{template <Sentinel<Iterator> S>}@
      @\added{friend constexpr bool operator!=(}@
        @\added{const move_iterator\& x, const move_sentinel<S>\& y);}@
    @\added{template <Sentinel<Iterator> S>}@
      @\added{friend constexpr bool operator!=(}@
        @\added{const move_sentinel<S>\& x, const move_iterator\& y);}@

    @\added{template <SizedSentinel<Iterator> S>}@
      @\added{friend constexpr iter_difference_t<Iterator> operator-(}@
        @\added{const move_sentinel<S>\& x, const move_iterator\& y);}@
    @\added{template <SizedSentinel<Iterator> S>}@
      @\added{friend constexpr iter_difference_t<Iterator> operator-(}@
        @\added{const move_iterator\& x, const move_sentinel<S>\& y);}@

    @\added{friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const move_iterator\& i)}@
      @\added{noexcept(\seebelow);}@
    @\added{template <IndirectlySwappable<Iterator> Iterator2>}@
      @\added{friend constexpr void iter_swap(const move_iterator\& x, const move_iterator<Iterator2>\& y)}@
        @\added{noexcept(\seebelow);}@
  private:
    Iterator current;   // \expos
  };

  template<class Iterator1, class Iterator2>
    constexpr bool operator==(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator!=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator<=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template<class Iterator1, class Iterator2>
    constexpr bool operator>=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

  template<class Iterator1, class Iterator2>
    constexpr auto operator-(
      const move_iterator<Iterator1>& x,
      const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
  template<class Iterator>
    constexpr move_iterator<Iterator> operator+(
      @\changed{typename move_iterator<Iterator>::difference_type}{iter_difference_t<move_iterator<Iterator>{>}}@ n,
      const move_iterator<Iterator>& x);
  template<class Iterator>
    constexpr move_iterator<Iterator> make_move_iterator(Iterator i);
}
\end{codeblock}

\begin{removedblock}
\pnum
Let \tcode{\placeholder{R}} denote \tcode{iterator_traits<Iterator>::reference}.
If \tcode{is_reference_v<\placeholder{R}>} is \tcode{true},
the template specialization \tcode{move_iterator<Iterator>} shall define
the nested type named \tcode{reference} as a synonym for
\tcode{remove_reference_t<\placeholder{R}>\&\&},
otherwise as a synonym for \tcode{\placeholder{R}}.
\end{removedblock}

\rSec3[move.iter.requirements]{\tcode{move_iterator} requirements}

\pnum
The template parameter \tcode{Iterator} shall satisfy
the requirements of an input iterator\ref{input.iterators}.
Additionally, if any of the bidirectional or random access traversal
functions are instantiated, the template parameter shall satisfy the
requirements for a Bidirectional Iterator\ref{bidirectional.iterators}
or a Random Access Iterator\ref{random.access.iterators}, respectively.

\rSec3[move.iter.ops]{\tcode{move_iterator} operations}

\rSec4[move.iter.op.const]{\tcode{move_iterator} constructors}

\indexlibrary{\idxcode{move_iterator}!constructor}%
\begin{itemdecl}
constexpr move_iterator();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, value-initializing
\tcode{current}. Iterator operations applied to the resulting
iterator have defined behavior if and only if the corresponding operations are defined
on a value-initialized iterator of type \tcode{Iterator}.
\end{itemdescr}


\indexlibrary{\idxcode{move_iterator}!constructor}%
\begin{itemdecl}
constexpr explicit move_iterator(Iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, initializing
\tcode{current} with \tcode{i}.
\end{itemdescr}


\indexlibrary{\idxcode{move_iterator}!constructor}%
\begin{itemdecl}
template<class U> constexpr move_iterator(const move_iterator<U>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_iterator}, initializing
\tcode{current} with \tcode{u.base()}.

\pnum
\requires \tcode{U} shall be convertible to
\tcode{Iterator}.
\end{itemdescr}

\rSec4[move.iter.op=]{\tcode{move_iterator::operator=}}

\indexlibrarymember{operator=}{move_iterator}%
\begin{itemdecl}
template<class U> constexpr move_iterator& operator=(const move_iterator<U>& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{u.base()} to
\tcode{current}.

\pnum
\requires \tcode{U} shall be convertible to
\tcode{Iterator}.
\end{itemdescr}

\rSec4[move.iter.op.conv]{\tcode{move_iterator} conversion}

\indexlibrarymember{base}{move_iterator}%
\begin{itemdecl}
constexpr Iterator base() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[move.iter.op.star]{\tcode{move_iterator::operator*}}

\indexlibrarymember{operator*}{move_iterator}%
\begin{itemdecl}
constexpr reference operator*() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \changed{\tcode{static_cast<reference>(*current)}}{\tcode{ranges::iter_move(current)}}.
\end{itemdescr}

\rSec4[move.iter.op.ref]{\tcode{move_iterator::operator->}}

\ednote{My preference is to remove this operator since for \tcode{move_iterator}, the
expressions \tcode{(*i).m} and \tcode{i->m} are not, and cannot be, equivalent. I am
leaving the operator as-is in an excess of caution.}

\indexlibrarymember{operator->}{move_iterator}%
\begin{itemdecl}
constexpr pointer operator->() const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{current}.
\end{itemdescr}

\rSec4[move.iter.op.incr]{\tcode{move_iterator::operator++}}

\indexlibrarymember{operator++}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{++current}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator++}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator operator++(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
move_iterator tmp = *this;
++current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[move.iter.op.decr]{\tcode{move_iterator::operator-{-}}}

\indexlibrarymember{operator\dcr}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator& operator--();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by \tcode{\dcr current}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator\dcr}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator operator--(int);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
As if by:
\begin{codeblock}
move_iterator tmp = *this;
--current;
return tmp;
\end{codeblock}
\end{itemdescr}

\rSec4[move.iter.op.+]{\tcode{move_iterator::operator+}}

\indexlibrarymember{operator+}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator operator+(difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_iterator(current + n)}.
\end{itemdescr}

\rSec4[move.iter.op.+=]{\tcode{move_iterator::operator+=}}

\indexlibrarymember{operator+=}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator& operator+=(difference_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{current += n;}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[move.iter.op.-]{\tcode{move_iterator::operator-}}

\indexlibrarymember{operator-}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator operator-(difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_iterator(current - n)}.
\end{itemdescr}

\rSec4[move.iter.op.-=]{\tcode{move_iterator::operator-=}}

\indexlibrarymember{operator-=}{move_iterator}%
\begin{itemdecl}
constexpr move_iterator& operator-=(difference_type n);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects As if by: \tcode{current -= n;}

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\rSec4[move.iter.op.index]{\tcode{move_iterator::operator[]}}

\indexlibrarymember{operator[]}{move_iterator}%
\begin{itemdecl}
constexpr @\changed{\unspec}{reference}@ operator[](difference_type n) const;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \changed{\tcode{std::move(current[n])}}{\tcode{ranges::iter_move(current + n)}}.
\end{itemdescr}

\ednote{Add a new subsection for \tcode{move_iterator}'s friend functions:}

\begin{addedblock}
\rSec4[move.iter.op.friend]{\tcode{move_iterator} friend functions}

\indexlibrarymember{iter_move}{move_iterator}%
\begin{itemdecl}
friend constexpr iter_rvalue_reference_t<Iterator> iter_move(const move_iterator& i)
  noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{return ranges::iter_move(i.current);}

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
noexcept(ranges::iter_move(i.current))
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{iter_swap}{move_iterator}%
\begin{itemdecl}
template <IndirectlySwappable<Iterator> Iterator2>
  friend constexpr void iter_swap(const move_iterator& x, const move_iterator<Iterator2>& y)
    noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Equivalent to: \tcode{ranges::iter_swap(x.current, y.current)}.

\pnum
\remarks The expression in \tcode{noexcept} is equivalent to:
\begin{codeblock}
noexcept(ranges::iter_swap(x.current, y.current))
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec4[move.iter.op.comp]{\tcode{move_iterator} comparisons}

\begin{addedblock}
\pnum
The functions in this subsection only participate in overload resolution if the
expression in their \textit{Returns:} clause is well-formed.
\end{addedblock}

\indexlibrarymember{operator==}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
@\added{template <Sentinel<Iterator> S>}@
@\added{friend constexpr bool operator==(const move_iterator\& x, const move_sentinel<S>\& y);}@
@\added{template <Sentinel<Iterator> S>}@
@\added{friend constexpr bool operator==(const move_sentinel<S>\& x, const move_iterator\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() == y.base()}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
@\added{template <Sentinel<Iterator> S>}@
@\added{friend constexpr bool operator!=(const move_iterator\& x, const move_sentinel<S>\& y);}@
@\added{template <Sentinel<Iterator> S>}@
@\added{friend constexpr bool operator!=(const move_sentinel<S>\& x, const move_iterator\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x == y)}.
\end{itemdescr}

\indexlibrarymember{operator<}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() < y.base()}.
\end{itemdescr}

\indexlibrarymember{operator<=}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(y < x)}.
\end{itemdescr}

\indexlibrarymember{operator>}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{y < x}.
\end{itemdescr}

\indexlibrarymember{operator>=}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
constexpr bool operator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{!(x < y)}.
\end{itemdescr}

\rSec4[move.iter.nonmember]{\tcode{move_iterator} non-member functions}

\begin{addedblock}
\pnum
The functions in this subsection only participate in overload resolution if the
expression in their \textit{Returns:} clause is well-formed.
\end{addedblock}

\indexlibrarymember{operator-}{move_iterator}%
\begin{itemdecl}
template<class Iterator1, class Iterator2>
  constexpr auto operator-(
    const move_iterator<Iterator1>& x,
    const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
@\added{template <SizedSentinel<Iterator> S>}@
@\added{friend constexpr iter_difference_t<Iterator> operator-(}@
    @\added{const move_sentinel<S>\& x, const move_iterator\& y);}@
@\added{template <SizedSentinel<Iterator> S>}@
@\added{friend constexpr iter_difference_t<Iterator> operator-(}@
    @\added{const move_iterator\& x, const move_sentinel<S>\& y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x.base() - y.base()}.
\end{itemdescr}

\indexlibrarymember{operator+}{move_iterator}%
\begin{itemdecl}
template<class Iterator>
  constexpr move_iterator<Iterator> operator+(
    @\changed{typename move_iterator<Iterator>::difference_type}{iter_difference_t<move_iterator<Iterator>{>}}@ n,
    const move_iterator<Iterator>& x);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{x + n}.
\end{itemdescr}

\indexlibrary{\idxcode{make_move_iterator}}%
\begin{itemdecl}
template<class Iterator>
constexpr move_iterator<Iterator> make_move_iterator(Iterator i);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{move_iterator<Iterator>(i)}.
\end{itemdescr}







\rSec3[move.sentinel]{Class template \tcode{move_sentinel}}

\ednote{This section is relocated from REF TODO.}

\pnum
Class template \tcode{move_sentinel} is a sentinel adaptor useful for denoting
ranges together with \tcode{move_iterator}. When an input iterator type
\tcode{I} and sentinel type \tcode{S} satisfy \tcode{Sentinel<S, I>},
\tcode{Sentinel<move_sentinel<S>, move_iterator<I>{>}} is satisfied as well.

\pnum
\enterexample A \tcode{move_if} algorithm is easily implemented with
\tcode{copy_if} using \tcode{move_iterator} and \tcode{move_sentinel}:

\begin{codeblock}
template <InputIterator I, Sentinel<I> S, WeaklyIncrementable O,
          IndirectUnaryPredicate<I> Pred>
  requires IndirectlyMovable<I, O>
void move_if(I first, S last, O out, Pred pred)
{
  copy_if(move_iterator<I>{first}, move_sentinel<S>{last}, out, pred);
}
\end{codeblock}

\exitexample

\indexlibrary{\idxcode{move_sentinel}}%
\begin{codeblock}
namespace std { @\removed{namespace ranges \{}@
  template <Semiregular S>
  class move_sentinel {
  public:
    constexpr move_sentinel();
    explicit @\added{constexpr}@ move_sentinel(S s);
    template <ConvertibleTo<S> S2>
      move_sentinel(const move_sentinel<S2>& s);
    template <ConvertibleTo<S> S2>
      move_sentinel& operator=(const move_sentinel<S2>& s);

    S base() const;

  private:
    S last; // \expos
  };

  @\removed{template <class I, Sentinel<I> S>}@
    @\removed{constexpr bool operator==(}@
      @\removed{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\removed{template <class I, Sentinel<I> S>}@
    @\removed{constexpr bool operator==(}@
      @\removed{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\removed{template <class I, Sentinel<I> S>}@
    @\removed{constexpr bool operator!=(}@
      @\removed{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@
  @\removed{template <class I, Sentinel<I> S>}@
    @\removed{constexpr bool operator!=(}@
      @\removed{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@

  @\removed{template <class I, SizedSentinel<I> S>}@
    @\removed{constexpr difference_type_t<I> operator-(}@
      @\removed{const move_sentinel<S>\& s, const move_iterator<I>\& i);}@
  @\removed{template <class I, SizedSentinel<I> S>}@
    @\removed{constexpr difference_type_t<I> operator-(}@
      @\removed{const move_iterator<I>\& i, const move_sentinel<S>\& s);}@

  @\removed{template <Semiregular S>}@
    @\removed{constexpr move_sentinel<S> make_move_sentinel(S s);}@
}@\removed{\}}@
\end{codeblock}

\rSec3[move.sent.ops]{\tcode{move_sentinel} operations}

\rSec4[move.sent.op.const]{\tcode{move_sentinel} constructors}

\indexlibrary{\idxcode{move_sentinel}!\idxcode{move_sentinel}}%
\begin{itemdecl}
constexpr move_sentinel();
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, value-initializing
\tcode{last}. If \tcode{is_\-trivially_\-default_\-constr\-uct\-ible<\brk{}S>::value} is \tcode{true}, then this constructor
is a \tcode{constexpr} constructor.
\end{itemdescr}

\indexlibrary{\idxcode{move_sentinel}!constructor}%
\begin{itemdecl}
explicit @\added{constexpr}@ move_sentinel(S s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, initializing
\tcode{last} with \tcode{s}.
\end{itemdescr}

\indexlibrary{\idxcode{move_sentinel}!constructor}%
\begin{itemdecl}
template <ConvertibleTo<S> S2>
  move_sentinel(const move_sentinel<S2>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Constructs a \tcode{move_sentinel}, initializing
\tcode{last} with \tcode{s.last}.
\end{itemdescr}

\rSec4[move.sent.op=]{\tcode{move_sentinel::operator=}}

\indexlibrary{\idxcode{operator=}!\idxcode{move_sentinel}}%
\indexlibrary{\idxcode{move_sentinel}!\idxcode{operator=}}%
\begin{itemdecl}
template <ConvertibleTo<S> S2>
  move_sentinel& operator=(const move_sentinel<S2>& s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects Assigns \tcode{s.last} to \tcode{last}.

\pnum
\returns \tcode{*this}.
\end{itemdescr}

\ednote{Remove subsections REF TODO [move.sent.op.comp] and [move.sent.nonmember].}


\rSec2[iterators.common]{Common iterators}

\ednote{Change sub-subsection [iterators.common]/p1 from the Ranges TS as
follows:}

\pnum
Class template \tcode{common_iterator} is an iterator/sentinel adaptor that is
capable of representing a non-common range of elements (where the types of the
iterator and sentinel differ) as a common range (where they are the same). It
does this by holding either an iterator or a sentinel, and implementing the
equality comparison operators appropriately.

\ednote{Change sub-subsection ``[common.iterator]'' from the Ranges TS as
follows:}

\rSec3[common.iterator]{Class template \tcode{common_iterator}}

\indexlibrary{\idxcode{common_iterator}}%
\begin{codeblock}
namespace std { @\removed{namespace ranges \{}@
  template <Iterator I, Sentinel<I> S>
    requires !Same<I, S>
  class common_iterator {
  public:
    using difference_type = difference_type_t<I>;

    constexpr common_iterator();
    constexpr common_iterator(I i);
    constexpr common_iterator(S s);
    template <ConvertibleTo<I> I2, ConvertibleTo<S> S2>
      constexpr common_iterator(const common_iterator<I2, S2>& u);
    template <ConvertibleTo<I> I2, ConvertibleTo<S> S2>
      common_iterator& operator=(const common_iterator<I2, S2>& u);

    decltype(auto) operator*();
    decltype(auto) operator*() const
      requires @\placeholder{dereferenceable}@<const I>;
    decltype(auto) operator->() const
      requires @\seebelow@;

    common_iterator& operator++();
    decltype(auto) operator++(int);
    common_iterator operator++(int)
      requires ForwardIterator<I>;

    friend rvalue_reference_t<I> iter_move(const common_iterator& i)
      noexcept(@\seebelow@)
        requires InputIterator<I>;
    template <IndirectlySwappable<I> I2, class S2>
      friend void iter_swap(const common_iterator& x, const common_iterator<I2, S2>& y)
        noexcept(@\seebelow@);

  private:
    bool is_sentinel; // \expos
    I iter;           // \expos
    S sentinel;       // \expos
  };

  template <Readable I, class S>
  struct @\changed{value_type}{readable_traits}@<common_iterator<I, S>> {
    @\removed{using type = value_type_t<I>;}@
    @\added{using value_type = iter_value_t<I>;}@
  };

  template <InputIterator I, class S>
  struct iterator_@\changed{category}{traits}@<common_iterator<I, S>> {
    @\added{using difference_type = iter_difference_t<I>;}@
    @\added{using value_type = iter_value_t<I>;}@
    @\added{using reference = iter_reference_t<I>;}@
    @\added{using pointer = \seebelow;}@
    using @\changed{type}{iterator_category}@ = input_iterator_tag;
    @\added{using iterator_concept = input_iterator_tag;}@
  };

  template <ForwardIterator I, class S>
  struct iterator_@\changed{category}{traits}@<common_iterator<I, S>> {
    @\added{using difference_type = iter_difference_t<I>;}@
    @\added{using value_type = iter_value_t<I>;}@
    @\added{using reference = iter_reference_t<I>;}@
    @\added{using pointer = \seebelow;}@
    using @\changed{type}{iterator_category}@ = forward_iterator_tag;
    @\added{using iterator_concept = forward_iterator_tag;}@
  };

  template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
  bool operator==(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
  template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
    requires EqualityComparableWith<I1, I2>
  bool operator==(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
  template <class I1, class I2, Sentinel<I2> S1, Sentinel<I1> S2>
  bool operator!=(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);

  template <class I2, SizedSentinel<I2> I1, SizedSentinel<I2> S1, SizedSentinel<I1> S2>
  difference_type_t<I2> operator-(
    const common_iterator<I1, S1>& x, const common_iterator<I2, S2>& y);
}@\removed{\}}@
\end{codeblock}

\begin{addedblock}
\pnum
For both specializations of \tcode{iterator_traits} for
\tcode{common_iterator<I, S>}, the nested \tcode{pointer} type alias is defined
as follows:
\begin{itemize}
\item If the expression \tcode{a.operator->()} is well-formed, where \tcode{a}
is an lvalue of type \tcode{const common_iterator<I, S>}, then
\tcode{pointer} is an alias for the type of that expression.
\item Otherwise, \tcode{pointer} is an alias for \tcode{void}.
\end{itemize}
\end{addedblock}

\rSec2[default.sentinels]{Default sentinels}
\rSec3[default.sent]{Class \tcode{default_sentinel}}

\indexlibrary{\idxcode{default_sentinel}}%
\begin{itemdecl}
namespace std { @\removed{namespace ranges \{}@
  class default_sentinel { };
}@\removed{\}}@
\end{itemdecl}

\pnum
Class \tcode{default_sentinel} is an empty type used to denote the end of a
range. It is intended to be used together with iterator types that know the bound
of their range (e.g., \tcode{counted_iterator}~(\ref{counted.iterator})).

\rSec2[iterators.counted]{Counted iterators}
\rSec3[counted.iterator]{Class template \tcode{counted_iterator}}

\ednote{Change the class synopsis of \tcode{counted_iterator} as follows:}

\indexlibrary{\idxcode{counted_iterator}}%
\begin{codeblock}
namespace std { @\removed{namespace ranges \{}@
  template <Iterator I>
  class counted_iterator {
  public:
    using iterator_type = I;
    using difference_type = difference_type_t<I>;

    constexpr counted_iterator();
    constexpr counted_iterator(I x, difference_type_t<I> n);
    template <ConvertibleTo<I> I2>
      constexpr counted_iterator(const counted_iterator<I2>& i);
    template <ConvertibleTo<S> S2>
      constexpr counted_iterator& operator=(const counted_iterator<S2>& i);

    constexpr I base() const;
    constexpr difference_type_t<I> count() const;
    constexpr decltype(auto) operator*();
    constexpr decltype(auto) operator*() const
      requires @\placeholder{dereferenceable}@<const I>;

    constexpr counted_iterator& operator++();
    decltype(auto) operator++(int);
    constexpr counted_iterator operator++(int)
      requires ForwardIterator<I>;
    constexpr counted_iterator& operator--()
      requires BidirectionalIterator<I>;
    constexpr counted_iterator operator--(int)
      requires BidirectionalIterator<I>;

    constexpr counted_iterator  operator+ (difference_type n) const
      requires RandomAccessIterator<I>;
    constexpr counted_iterator& operator+=(difference_type n)
      requires RandomAccessIterator<I>;
    constexpr counted_iterator  operator- (difference_type n) const
      requires RandomAccessIterator<I>;
    constexpr counted_iterator& operator-=(difference_type n)
      requires RandomAccessIterator<I>;
    constexpr decltype(auto) operator[](difference_type n) const
      requires RandomAccessIterator<I>;

    friend constexpr rvalue_reference_t<I> iter_move(const counted_iterator& i)
      noexcept(@\seebelow@)
        requires InputIterator<I>;
    template <IndirectlySwappable<I> I2>
      friend constexpr void iter_swap(const counted_iterator& x, const counted_iterator<I2>& y)
        noexcept(@\seebelow@);

  private:
    I current; // \expos
    difference_type_t<I> cnt; // \expos
  };

  template <Readable I>
  struct @\changed{value_type}{readable_traits}@<counted_iterator<I>> {
    @\removed{using type = value_type_t<I>;}@
    @\added{using value_type = iter_value_t<I>;}@
  };

  template <InputIterator I>
  struct iterator_@\changed{category}{traits}@<counted_iterator<I>>
    @\added{: iterator_traits<I>}@ {
    @\removed{using type = iterator_category_t<I>;}@
    @\added{using pointer = void;}@
  };

  template <class I1, class I2>
      requires Common<I1, I2>
    constexpr bool operator==(
      const counted_iterator<I1>& x, const counted_iterator<I2>& y);
  // ... as before
}@\removed{\}}@
\end{codeblock}

\rSec2[unreachable.sentinels]{Unreachable sentinel}
\rSec3[unreachable.sentinel]{Class \tcode{unreachable}}

\ednote{This section integrates the fix for
\href{https://github.com/ericniebler/stl2/issues/507}{stl2\#507}.}

\pnum
\indexlibrary{\idxcode{unreachable}}%
Class \tcode{unreachable} is a \changed{sentinel}{placeholder} type that can be
used with any \changed{\tcode{Iterator}}{\tcode{WeaklyIncrementable} type} to
denote \changed{an infinite range}{the ``upper bound'' of an open interval}.
Comparing \changed{an iterator}{anything} for equality with an object of type
\tcode{unreachable} always returns \tcode{false}.

\enterexample
\begin{codeblock}
char* p;
// set p to point to a character buffer containing newlines
char* nl = find(p, unreachable(), '@\textbackslash@n');
\end{codeblock}

Provided a newline character really exists in the buffer, the use of
\tcode{unreachable} above potentially makes the call to \tcode{find} more
efficient since the loop test against the sentinel does not require a
conditional branch.
\exitexample

\begin{codeblock}
namespace std { @\removed{namespace ranges \{}@
  class unreachable { };

  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator==(const I&, unreachable) noexcept;
  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator==(unreachable, const I&) noexcept;
  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator!=(const I&, unreachable) noexcept;
  template <@\changed{Iterator}{WeaklyIncrementable}@ I>
    constexpr bool operator!=(unreachable, const I&) noexcept;
}@\removed{\}}@
\end{codeblock}

\rSec3[unreachable.sentinel.ops]{\tcode{unreachable} operations}

\rSec4[unreachable.sentinel.op==]{\tcode{operator==}}

\indexlibrary{\idxcode{operator==}!\idxcode{unreachable}}%
\indexlibrary{\idxcode{unreachable}!\idxcode{operator==}}%
\begin{itemdecl}
template <@\changed{Iterator}{WeaklyIncrementable}@ I>
  constexpr bool operator==(const I&, unreachable) noexcept;
template <@\changed{Iterator}{WeaklyIncrementable}@ I>
  constexpr bool operator==(unreachable, const I&) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns \tcode{false}.
\end{itemdescr}

\rSec4[unreachable.sentinel.op!=]{\tcode{operator!=}}

\indexlibrary{\idxcode{operator"!=}!\idxcode{unreachable}}%
\indexlibrary{\idxcode{unreachable}!\idxcode{operator"!=}}%
\begin{itemdecl}
template <@\changed{Iterator}{WeaklyIncrementable}@ I>
  constexpr bool operator!=(const I& x, unreachable y) noexcept;
template <@\changed{Iterator}{WeaklyIncrementable}@ I>
  constexpr bool operator!=(unreachable x, const I& y) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{true}.
\end{itemdescr}

\rSec1[stream.iterators]{Stream iterators}
\rSec2[istream.iterator]{Class template \tcode{istream_iterator}}

\ednote{Change the class synopsis of \tcode{istream_iterator} from the working
draft of the IS as follows:}

\begin{codeblock}
namespace std {
  template<class T, class charT = char, class traits = char_traits<charT>,
           class Distance = ptrdiff_t>
  class istream_iterator {
  public:
    using iterator_category = input_iterator_tag;
    using value_type        = T;
    using difference_type   = Distance;
    using pointer           = const T*;
    using reference         = const T&;
    using char_type         = charT;
    using traits_type       = traits;
    using istream_type      = basic_istream<charT,traits>;

    constexpr istream_iterator();
    @\added{constexpr istream_iterator(default_sentinel);}@
    istream_iterator(istream_type& s);
    istream_iterator(const istream_iterator& x) = default;
    ~istream_iterator() = default;

    const T& operator*() const;
    const T* operator->() const;
    istream_iterator& operator++();
    istream_iterator  operator++(int);

    @\ednote{Relocated from namespace \tcode{ranges}:}@
    @\added{friend bool operator==(default_sentinel, const istream_iterator\& i);}@
    @\added{friend bool operator==(const istream_iterator\& i, default_sentinel);}@
    @\added{friend bool operator!=(default_sentinel x, const istream_iterator\& y);}@
    @\added{friend bool operator!=(const istream_iterator\& x, default_sentinel y);}@

  private:
    basic_istream<charT,traits>* in_stream; // \expos
    T value;                                // \expos
  };

  template<class T, class charT, class traits, class Distance>
    bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);
  template<class T, class charT, class traits, class Distance>
    bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);
}
\end{codeblock}

\rSec3[istream.iterator.cons]{\tcode{istream_iterator} constructors and destructor}

\ednote{Change [istream.iterator.cons] as follows:}

\indexlibrary{\idxcode{istream_iterator}!constructor}%
\begin{itemdecl}
constexpr istream_iterator();
@\added{constexpr istream_iterator(default_sentinel);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Constructs the end-of-stream iterator.
If \tcode{is_trivially_default_constructible_v<T>} is \tcode{true},
then \changed{this constructor is a}{these constructors are} constexpr
constructor\added{s}.

\pnum
\postconditions \tcode{in_stream == 0}.
\end{itemdescr}



\rSec3[istream.iterator.ops]{\tcode{istream_iterator} operations}

\ednote{Change [istream.iterator.ops] as follows:}
\setcounter{Paras}{7}
\indexlibrarymember{operator==}{istream_iterator}%
\begin{itemdecl}
template<class T, class charT, class traits, class Distance>
  bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
                  const istream_iterator<T,charT,traits,Distance>& y);
@\added{friend bool operator==(default_sentinel, const istream_iterator\& i);}@
@\added{friend bool operator==(const istream_iterator\& i, default_sentinel);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{x.in_stream == y.in_stream} \added{for the first overload, and
\tcode{!i.in_stream} for the other two}.
\end{itemdescr}

\indexlibrarymember{operator"!=}{istream_iterator}%
\begin{itemdecl}
template<class T, class charT, class traits, class Distance>
  bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
                  const istream_iterator<T,charT,traits,Distance>& y);
@\added{friend bool operator!=(default_sentinel x, const istream_iterator\& y);}@
@\added{friend bool operator!=(const istream_iterator\& x, default_sentinel y);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{!(x == y)}
\end{itemdescr}

\rSec2[ostream.iterator]{Class template \tcode{ostream_iterator}}

\ednote{Change the class synopsis of \tcode{ostream_iterator} as follows:}

\begin{codeblock}
namespace std {
  template<class T, class charT = char, class traits = char_traits<charT>>
  class ostream_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\changed{void}{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using char_type         = charT;
    using traits_type       = traits;
    using ostream_type      = basic_ostream<charT,traits>;

    @\added{constexpr ostream_iterator() noexcept = default;}@
    ostream_iterator(ostream_type& s);
    ostream_iterator(ostream_type& s, const charT* delimiter);
    ostream_iterator(const ostream_iterator& x);
    ~ostream_iterator();
    ostream_iterator& operator=(const T& value);

    ostream_iterator& operator*();
    ostream_iterator& operator++();
    ostream_iterator& operator++(int);

  private:
    basic_ostream<charT,traits>* out_stream @\added{= nullptr}@;  // \expos
    const charT* delim @\added{= nullptr}@;                       // \expos
  };
}
\end{codeblock}

\rSec2[istreambuf.iterator]{Class template \tcode{istreambuf_iterator}}

\ednote{Change the class synopsis of \tcode{istreambuf_iterator} as follows:}

\indexlibrary{\idxcode{istreambuf_iterator}}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>>
  class istreambuf_iterator {
  public:
    using iterator_category = input_iterator_tag;
    using value_type        = charT;
    using difference_type   = typename traits::off_type;
    using pointer           = @\unspec@;
    using reference         = charT;
    using char_type         = charT;
    using traits_type       = traits;
    using int_type          = typename traits::int_type;
    using streambuf_type    = basic_streambuf<charT,traits>;
    using istream_type      = basic_istream<charT,traits>;

    class proxy;                          // \expos

    constexpr istreambuf_iterator() noexcept;
    @\added{constexpr istreambuf_iterator(default_sentinel) noexcept;}@
    istreambuf_iterator(const istreambuf_iterator&) noexcept = default;
    ~istreambuf_iterator() = default;
    istreambuf_iterator(istream_type& s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const proxy& p) noexcept;
    charT operator*() const;
    istreambuf_iterator& operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator& b) const;

    @\added{friend bool operator==(default_sentinel s, const istreambuf_iterator\& i);}@
    @\added{friend bool operator==(const istreambuf_iterator\& i, default_sentinel s);}@
    @\added{friend bool operator!=(default_sentinel a, const istreambuf_iterator\& b);}@
    @\added{friend bool operator!=(const istreambuf_iterator\& a, default_sentinel b);}@

  private:
    streambuf_type* sbuf_;                // \expos
  };

  template<class charT, class traits>
    bool operator==(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);
  template<class charT, class traits>
    bool operator!=(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);
}
\end{codeblock}


\setcounter{subsubsection}{1}
\rSec3[istreambuf.iterator.cons]{\tcode{istreambuf_iterator} constructors}
\ednote{Change \tcode{istreambuf_iterator}'s constructors as follows:}

\setcounter{Paras}{1}
\indexlibrary{\idxcode{istreambuf_iterator}!constructor}%
\begin{itemdecl}
constexpr istreambuf_iterator() noexcept;
@\added{constexpr istreambuf_iterator(default_sentinel) noexcept;}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Initializes \tcode{sbuf_} with \tcode{nullptr}.
\end{itemdescr}


\rSec3[istreambuf.iterator.ops]{\tcode{istreambuf_iterator} operations}

\ednote{Change \tcode{istreambuf_iterator}'s comparison operators as follows:}

\setcounter{Paras}{5}
\indexlibrarymember{operator==}{istreambuf_iterator}%
\begin{itemdecl}
template<class charT, class traits>
  bool operator==(const istreambuf_iterator<charT,traits>& a,
                  const istreambuf_iterator<charT,traits>& b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{a.equal(b)}.
\end{itemdescr}

\begin{addedblock}
\indexlibrarymember{operator==}{istreambuf_iterator}%
\begin{itemdecl}
friend bool operator==(default_sentinel s, const istreambuf_iterator& i);
friend bool operator==(const istreambuf_iterator& i, default_sentinel s);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{i.equal(s)}.
\end{itemdescr}
\end{addedblock}

\indexlibrarymember{operator"!=}{istreambuf_iterator}%
\begin{itemdecl}
template<class charT, class traits>
  bool operator!=(const istreambuf_iterator<charT,traits>& a,
                  const istreambuf_iterator<charT,traits>& b);
@\added{friend bool operator!=(default_sentinel a, const istreambuf_iterator\& b);}@
@\added{friend bool operator!=(const istreambuf_iterator\& a, default_sentinel b);}@
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\changed{\tcode{!a.equal(b)}}{\tcode{!(a == b)}}.
\end{itemdescr}



\rSec2[ostreambuf.iterator]{Class template \tcode{ostreambuf_iterator}}

\ednote{Change the \tcode{ostreambuf_iterator} class synopsis as follows:}

\indexlibrary{\idxcode{ostreambuf_iterator}}%
\begin{codeblock}
namespace std {
  template<class charT, class traits = char_traits<charT>>
  class ostreambuf_iterator {
  public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using difference_type   = @\changed{void}{ptrdiff_t}@;
    using pointer           = void;
    using reference         = void;
    using char_type         = charT;
    using traits_type       = traits;
    using streambuf_type    = basic_streambuf<charT,traits>;
    using ostream_type      = basic_ostream<charT,traits>;

    @\added{constexpr ostreambuf_iterator() noexcept = default;}@
    ostreambuf_iterator(ostream_type& s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator& operator=(charT c);

    ostreambuf_iterator& operator*();
    ostreambuf_iterator& operator++();
    ostreambuf_iterator& operator++(int);
    bool failed() const noexcept;

  private:
    streambuf_type* sbuf_ @\added{= nullptr}@;                // \expos
  };
}
\end{codeblock}

