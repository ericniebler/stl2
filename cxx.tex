% Define section from the C++ standard that can be indexed
% using its dotted identifer. That is:
%
%  \cxxsec{basic.def.odr}{3.2}
%
% This is used to make references to sections of the C++ Standard
% that are not labeled within this document.
\newcommand{\cxxsec}[2]{%
  \expandafter\def\csname #1 \endcsname{#2}%
}

% Generate a reference to the section with the given id. This
% expands to the full chapter/section/subsection number declared
% by \cxxsec. For example:
%
%  \cxxref{basic.def.odr}
%
% Expands to the string 3.2.
\newcommand{\stdcxxref}[1]{%
  \csname #1 \endcsname%
}

\newcommand{\cxxref}[1]{%
  ISO/\brk{}IEC\brk{} 14882:\brk{}2014\brk{} \brk{}\S\brk{}\stdcxxref{#1}%
}

\cxxsec{intro.compliance}{1.4}
\cxxsec{intro.execution}{1.9}
\cxxsec{intro.multithread}{1.10}

\cxxsec{lex.phases}{2.2}
\cxxsec{lex.key}{2.12}

\cxxsec{basic.def.odr}{3.2}
\cxxsec{basic.scope.namespace}{3.3.6}
\cxxsec{basic.lookup}{3.4}
\cxxsec{basic.lookup.unqual}{3.4.1}
\cxxsec{basic.lookup.argdep}{3.4.2}
\cxxsec{basic.lookup.classref}{3.4.5}
\cxxsec{basic.link}{3.5}
\cxxsec{basic.types}{3.9}
\cxxsec{basic.fundamental}{3.9.1}
\cxxsec{basic.compound}{3.9.2}
\cxxsec{basic.type.qualifier}{3.9.3}
\cxxsec{basic.lval}{3.10}

\cxxsec{conv}{4}
\cxxsec{conv.integral}{4.7}
\cxxsec{conv.array}{4.2}

\cxxsec{expr}{5}
\cxxsec{expr.prim}{5.1}
\cxxsec{expr.prim.general}{5.1.1}
\cxxsec{expr.prim.lambda}{5.1.2}
\cxxsec{expr.prim.req}{5.1.3}
\cxxsec{expr.prim.fold}{5.1.4}
\cxxsec{expr.typeid}{5.2.8}
\cxxsec{expr.unary}{5.3}
\cxxsec{expr.unaryOp}{5.3.1}
\cxxsec{expr.pre.incr}{5.3.2}
\cxxsec{expr.sizeof}{5.3.3}
\cxxsec{expr.new}{5.3.4}
\cxxsec{expr.delete}{5.3.5}
\cxxsec{expr.alignof}{5.3.6}
\cxxsec{expr.unary.noexcept}{5.3.7}
\cxxsec{expr.cast}{5.4}
\cxxsec{expr.mptr.oper}{5.5}
\cxxsec{expr.mul}{5.6}
\cxxsec{expr.add}{5.7}
\cxxsec{expr.shift}{5.8}
\cxxsec{expr.rel}{5.9}
\cxxsec{expr.eq}{5.10}
\cxxsec{expr.bit.and}{5.11}
\cxxsec{expr.bit.xor}{5.12}
\cxxsec{expr.bit.or}{5.13}
\cxxsec{expr.log.and}{5.14}
\cxxsec{expr.log.or}{5.15}
\cxxsec{expr.cond}{5.16}
\cxxsec{expr.ass}{5.17}
\cxxsec{expr.comma}{5.18}
\cxxsec{expr.const}{5.19}

\cxxsec{stmt.block}{6.3}
\cxxsec{stmt.select}{6.4}
\cxxsec{stmt.iter}{6.5}
\cxxsec{stmt.for}{6.5.3}
\cxxsec{stmt.ranged}{6.5.4}

\cxxsec{dcl.dcl}{7}
\cxxsec{dcl.spec}{7.1}
\cxxsec{dcl.fct.spec}{7.1.2}
\cxxsec{dcl.constexpr}{7.1.5}
\cxxsec{dcl.type}{7.1.6}
\cxxsec{dcl.type.cv}{7.1.6.1}
\cxxsec{dcl.type.simple}{7.1.6.2}
\cxxsec{dcl.type.elab}{7.1.6.3}
\cxxsec{dcl.spec.auto}{7.1.6.4}
\cxxsec{namespace.alias}{7.3.2}
\cxxsec{namespace.udecl}{7.3.3}
\cxxsec{dcl.link}{7.5}
\cxxsec{dcl.attr.deprecated}{7.6.5}

\cxxsec{dcl.decl}{8}
\cxxsec{dcl.name}{8.1}
\cxxsec{dcl.ambig.res}{8.2}
\cxxsec{dcl.meaning}{8.3}
\cxxsec{dcl.fct}{8.3.5}
\cxxsec{dcl.fct.default}{8.3.6}
\cxxsec{dcl.fct.def}{8.4}
\cxxsec{dcl.fct.def.general}{8.4.1}
\cxxsec{dcl.init}{8.5}
\cxxsec{dcl.init.list}{8.5.4}

\cxxsec{class}{9}
\cxxsec{class.name}{9.1}
\cxxsec{class.mem}{9.2}
\cxxsec{class.static.data}{9.4.2}

\cxxsec{class.derived}{10}
\cxxsec{class.mi}{10.1}
\cxxsec{class.member.lookup}{10.2}
\cxxsec{class.virtual}{10.3}
\cxxsec{class.abstract}{10.4}

\cxxsec{special}{12}
\cxxsec{class.ctor}{12.1}
\cxxsec{class.ctor}{12.1}
\cxxsec{class.conv}{12.3}
\cxxsec{class.dtor}{12.4}

\cxxsec{over}{13}
\cxxsec{over.load}{13.1}
\cxxsec{over.dcl}{13.2}
\cxxsec{over.match}{13.3}
\cxxsec{over.match.funcs}{13.3.1}
\cxxsec{over.match.viable}{13.3.2}
\cxxsec{over.match.best}{13.3.3}
\cxxsec{over.over}{13.4}
\cxxsec{over.oper}{13.5}
\cxxsec{over.call}{13.5.4}
\cxxsec{over.built}{13.6}

\cxxsec{temp}{14}
\cxxsec{temp.param}{14.1}
\cxxsec{temp.names}{14.2}
\cxxsec{temp.arg}{14.3}
\cxxsec{temp.arg.type}{14.3.1}
\cxxsec{temp.arg.nontype}{14.3.2}
\cxxsec{temp.arg.template}{14.3.3}
\cxxsec{temp.type}{14.4}
\cxxsec{temp.dcls}{14.5}
\cxxsec{temp.class}{14.5.1}
\cxxsec{temp.mem.func}{14.5.1.1}
\cxxsec{temp.mem.class}{14.5.1.2}
\cxxsec{temp.static}{14.5.1.3}
\cxxsec{temp.mem.enum}{14.5.1.4}
\cxxsec{temp.mem}{14.5.2}
\cxxsec{temp.variadic}{14.5.3}
\cxxsec{temp.friend}{14.5.4}
\cxxsec{temp.class.spec.match}{14.5.5.1}
\cxxsec{temp.class.order}{14.5.5.2}
\cxxsec{temp.class.spec.mfunc}{14.5.5.3}
\cxxsec{temp.fct}{14.5.6}
\cxxsec{temp.over.link}{14.5.6.1}
\cxxsec{temp.func.order}{14.5.6.2}
\cxxsec{temp.res}{14.6}
\cxxsec{temp.local}{14.6.1}
\cxxsec{temp.dep}{14.6.2}
\cxxsec{temp.dep.type}{14.6.2.1}
\cxxsec{temp.dep.expr}{14.6.2.2}
\cxxsec{temp.dep.constexpr}{14.6.2.3}
\cxxsec{temp.dep.temp}{14.6.2.4}
\cxxsec{temp.nondep}{14.6.3}
\cxxsec{temp.dep.res}{14.6.4}
\cxxsec{temp.point}{14.6.4.1}
\cxxsec{temp.inject}{14.6.5}
\cxxsec{temp.spec}{14.7}
\cxxsec{temp.inst}{14.7.1}
\cxxsec{temp.explicit}{14.7.2}
\cxxsec{temp.expl.spec}{14.7.3}

\cxxsec{temp.deduct}{14.8.2}
\cxxsec{temp.deduct.call}{14.8.2.1}
\cxxsec{temp.deduct.funcaddr}{14.8.2.2}
\cxxsec{temp.deduct.conv}{14.8.2.3}
\cxxsec{temp.deduct.partial}{14.8.2.4}
\cxxsec{temp.deduct.type}{14.8.2.5}
\cxxsec{temp.deduct.decl}{14.8.2.6}

\cxxsec{except}{15}
\cxxsec{except.throw}{15.1}
\cxxsec{except.ctor}{15.2}
\cxxsec{except.handle}{15.3}
\cxxsec{except.spec}{15.4}
\cxxsec{except.special}{15.5}
\cxxsec{except.terminate}{15.5.1}
\cxxsec{except.unexcpected}{15.5.2}
\cxxsec{except.uncaught}{15.5.3}

\cxxsec{library}{17}
\cxxsec{definitions}{17.3}
\cxxsec{structure.specifications}{17.5.1.4}
\cxxsec{type.descriptions}{17.5.2.1}
\cxxsec{functions.within.classes}{17.5.2.2}
\cxxsec{objects.within.classes}{17.5.2.3}
\cxxsec{requirements}{17.6}
\cxxsec{using.headers}{17.6.2.2}
\cxxsec{utility.requirements}{17.6.3}
\cxxsec{utility.arg.requirements}{17.6.3.1}
\cxxsec{namespace.std}{17.6.4.2.1}
\cxxsec{res.on.arguments}{17.6.4.9}
\cxxsec{res.on.objects}{17.6.4.10}
\cxxsec{conforming}{17.6.5}
\cxxsec{algorithm.stable}{17.6.5.7}
\cxxsec{res.on.exception.handling}{17.6.5.12}
\cxxsec{lib.types.movedfrom}{17.6.5.15}

\cxxsec{support}{18}
\cxxsec{support.initlist}{18.9}

\cxxsec{equalitycomparable}{17}
\cxxsec{lessthancomparable}{18}
\cxxsec{moveconstructible}{20}
\cxxsec{copyconstructible}{21}
\cxxsec{moveassignable}{22}

\cxxsec{operators}{20.2.1}
\cxxsec{utility.swap}{20.2.2}
\cxxsec{declval}{20.2.5}
\cxxsec{pairs}{20.3}
\cxxsec{tuple}{20.4}
\cxxsec{tuple.helper}{20.4.2.5}
\cxxsec{tuple.elem}{20.4.2.6}
\cxxsec{func.def}{20.9.1}
\cxxsec{func.require}{20.9.2}
\cxxsec{refwrap}{20.9.3}
\cxxsec{meta}{20.10}
\cxxsec{meta.type.synop}{20.10.2}
\cxxsec{meta.unary}{20.10.4}
\cxxsec{meta.unary.prop}{20.10.4.3}
\cxxsec{meta.trans.other}{20.10.7.6}

\cxxsec{containers}{23}
\cxxsec{associative}{23.4}
\cxxsec{set}{23.4.6}
\cxxsec{multiset}{23.4.7}
\cxxsec{unord.set}{23.5.6}
\cxxsec{unord.multiset}{23.5.7}

\cxxsec{iterator.traits}{24.4.1}

\cxxsec{alg.foreach}{25.2.4}

\cxxsec{tab:iterator.forward.requirements}{109}
\cxxsec{tab:iterator.bidirectional.requirements}{110}
\cxxsec{tab:iterator.random.access.requirements}{111}


\cxxsec{numerics}{26}
\cxxsec{rand}{26.5}
\cxxsec{rand.req}{26.5.1}
\cxxsec{rand.req.urng}{26.5.1.3}

\cxxsec{input.output}{27}
\cxxsec{stream.buffers}{27.6}
\cxxsec{iostream.format}{27.7}
